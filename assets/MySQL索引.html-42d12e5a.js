import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o,c as s,b as e,d as a,e as n,f as h}from"./app-109e850b.js";const d={},c=e("p",null,"索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。",-1),p=e("p",null,[a("索引底层数据结构存在很多种类型，常见的索引结构有: B 树， B+树 和 Hash、红黑树。"),e("br"),a(" 在 MySQL 中，无论是 Innodb 还是 MyIsam，都使用了 "),e("strong",null,"B+树"),a(" 作为索引结构。")],-1),B={class:"hint-container info"},b=e("p",{class:"hint-container-title"},"相关信息",-1),u=e("p",null,[a("存储引擎是数据库的核心，在MySQL中，存储引擎是以插件的形式运行的。支持的引擎有十几种之多，实战常用到的，大概只有 "),e("code",null,"InnoDB"),a("、"),e("code",null,"MyISAM"),a(" 和 "),e("code",null,"Memory")],-1),_={href:"https://cloud.tencent.com/developer/article/1662516",target:"_blank",rel:"noopener noreferrer"},f=h('<h2 id="索引的优缺点" tabindex="-1"><a class="header-anchor" href="#索引的优缺点" aria-hidden="true">#</a> 索引的优缺点：</h2><p>优点：</p><ul><li>使用索引可以大大加快数据的检索速度</li><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性</li></ul><p>缺点：</p><ul><li>创建索引和维护索引需要耗费许多时间。<br> 当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率</li><li>索引需要使用物理文件存储，也会耗费一定空间</li></ul><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>使用索引一定能提高查询性能吗?</p><p>大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升</p></div><h2 id="不同的数据结构" tabindex="-1"><a class="header-anchor" href="#不同的数据结构" aria-hidden="true">#</a> 不同的数据结构</h2><h3 id="hash-表" tabindex="-1"><a class="header-anchor" href="#hash-表" aria-hidden="true">#</a> Hash 表</h3><p>哈希表可以快速检索数据（接近 O(1)）</p><p>但哈希算法有个 Hash 冲突问题，不同的 key 得到的 index 相同。</p><p>通常情况下，我们常用的解决办法是 <code>链地址法</code>。就是将哈希冲突数据存放在链表中。<br> 就比如 JDK1.8 之前 HashMap 就是通过链地址法来解决哈希冲突的。<br> 不过，JDK1.8 以后 HashMap 为了减少链表过长的时候搜索时间过长引入了红黑树。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>哈希表这么快，为什么 MySQL 没有使用其作为索引的数据结构呢？<br> 主要是因为 Hash 索引不支持顺序和范围查询。<br> 假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。并且，每次 IO 只能取一个。</p></div><h3 id="二叉查找树-bst" tabindex="-1"><a class="header-anchor" href="#二叉查找树-bst" aria-hidden="true">#</a> 二叉查找树(BST)</h3><p>二叉查找树（Binary Search Tree）是一种基于二叉树的数据结构</p><ul><li>左子树所有节点的值均小于根节点的值。</li><li>右子树所有节点的值均大于根节点的值。</li><li>左右子树也分别为二叉查找树。</li></ul><p>当二叉查找树是平衡的时候，查询的时间复杂度为 O(log2(n))<br> 当二叉查找树不平衡时，在最坏情况下，树会退化成线性链表，时间复杂退化为 O(n)<br> 二叉查找树的性能非常依赖于它的平衡程度，这就导致其不适合作为 MySQL 底层索引的数据结构。</p><p>为了解决这个问题，发明了多种在二叉查找树基础上的改进型数据结构，如平衡二叉树、B-Tree、B+Tree 等。</p><h3 id="avl-树" tabindex="-1"><a class="header-anchor" href="#avl-树" aria-hidden="true">#</a> AVL 树</h3><p>AVL 树是计算机科学中最早被发明的自平衡二叉查找树，它的名称来自于发明者 G.M. Adelson-Velsky 和 E.M. Landis 的名字缩写。</p><p>AVL 树的特点是保证任何节点的左右子树高度之差不超过 1，因此也被称为高度平衡二叉树，它的查找、插入和删除在平均和最坏情况下的时间复杂度都是 O(logn)。</p><p>AVL 树采用了旋转操作来保持平衡。主要有四种旋转操作：LL 旋转、RR 旋转、LR 旋转和 RL 旋转。</p><p>AVL 树需要频繁地进行旋转操作来保持平衡，因此会有较大的计算开销进而降低了查询性能。<br> 并且， 在使用 AVL 树时，每个树节点仅存储一个数据，而每次进行磁盘 IO 时只能读取一个节点的数据，如果需要查询的数据分布在多个节点上，那么就需要进行多次磁盘 IO。</p><p>AVL 树使用的并不多</p><h3 id="红黑树" tabindex="-1"><a class="header-anchor" href="#红黑树" aria-hidden="true">#</a> 红黑树</h3><p>红黑树是一种自平衡二叉查找树，通过在插入和删除节点时进行颜色变换和旋转操作，使得树始终保持平衡状态，它具有以下特点：</p><ul><li>每个节点非红即黑</li><li>根节点总是黑色的</li><li>每个叶子节点都是黑色的空节点（NIL 节点）</li><li>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）</li><li>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）</li></ul><p>红黑树并不追求严格的平衡，而是大致的平衡。</p><p>因此，红黑树的查询效率稍有下降，因为红黑树的平衡性相对较弱，可能会导致树的高度较高，这可能会导致一些数据需要进行多次磁盘 IO 操作才能查询到，这也是 MySQL 没有选择红黑树的主要原因。</p><p>但红黑树的插入和删除操作效率大大提高了，红黑树在插入和删除节点时只需进行 O(1) 次数的旋转和变色操作，即可保持基本平衡状态，而不需要像 AVL 树一样进行 O(logn) 次数的旋转操作。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>红黑树的应用还是比较广泛的，TreeMap、TreeSet 以及 JDK1.8 的 HashMap 底层都用到了红黑树。对于数据在内存中的这种情况来说，红黑树的表现是非常优异的。</p></div><h3 id="b-树-b-树" tabindex="-1"><a class="header-anchor" href="#b-树-b-树" aria-hidden="true">#</a> B 树&amp; B+树</h3><p>B 树也称 B-树，全称为 多路平衡查找树 ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 Balanced （平衡）的意思。<br> 目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。</p><h4 id="b树-与-b-树-的异同" tabindex="-1"><a class="header-anchor" href="#b树-与-b-树-的异同" aria-hidden="true">#</a> B树 与 B+树 的异同</h4><ul><li>B树 的所有节点既存放键(key) 也存放数据(data)<br> B+树 只有<strong>叶子节点</strong>存放 key 和 data，其他内节点只存放 key。</li><li>B树 的叶子节点都是独立的<br> B+树 的叶子节点有一条<strong>引用链</strong>指向与它相邻的叶子节点。</li><li>B树 的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。<br> B+树 的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li><li>B树 中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限<br> B+树 的范围查询，只需要对链表进行遍历即可。</li></ul><p>综上，B+树 与 B树 相比，具备更少的 IO 次数、更稳定的查询效率和更适于范围查询这些优势</p><h3 id="索引类型总结" tabindex="-1"><a class="header-anchor" href="#索引类型总结" aria-hidden="true">#</a> 索引类型总结</h3>',36);function L(m,y){const r=i("ExternalLinkIcon"),l=i("BiliBili");return o(),s("div",null,[c,p,e("div",B,[b,u,e("p",null,[e("a",_,[a("https://cloud.tencent.com/developer/article/1662516"),n(r)])])]),n(l,{bvid:"BV1Wm4y147mS"}),f])}const v=t(d,[["render",L],["__file","MySQL索引.html.vue"]]);export{v as default};
