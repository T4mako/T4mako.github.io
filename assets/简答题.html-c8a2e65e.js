import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as d,c as e,f as t}from"./app-bcabb1c6.js";const r={},h=t('<h2 id="_1-结构化程序定义以及优缺点-真题" tabindex="-1" data-v-6ab87549><a class="header-anchor" href="#_1-结构化程序定义以及优缺点-真题" aria-hidden="true" data-v-6ab87549>#</a> 1. 结构化程序定义以及优缺点（真题）</h2><p data-v-6ab87549>优点：可读性强、可维护性高、容易调试、可靠性高</p><p data-v-6ab87549>缺点：缺乏灵活性、可读性受限</p><h2 id="_2-面向对程序定义以及优缺点" tabindex="-1" data-v-6ab87549><a class="header-anchor" href="#_2-面向对程序定义以及优缺点" aria-hidden="true" data-v-6ab87549>#</a> 2. 面向对程序定义以及优缺点</h2><h2 id="_3-数组及链表处理数据的优缺点-真题" tabindex="-1" data-v-6ab87549><a class="header-anchor" href="#_3-数组及链表处理数据的优缺点-真题" aria-hidden="true" data-v-6ab87549>#</a> 3. 数组及链表处理数据的优缺点（真题）</h2><h2 id="_4-arraylist-和-linkedlist-的优缺点" tabindex="-1" data-v-6ab87549><a class="header-anchor" href="#_4-arraylist-和-linkedlist-的优缺点" aria-hidden="true" data-v-6ab87549>#</a> 4. ArrayList 和 LinkedList 的优缺点</h2><p data-v-6ab87549>ArrayList 是数组的数据结构，LinkedList 是链表的数据结构。</p><p data-v-6ab87549>随机访问的时候，ArrayList 的效率比较高，因为LinkedList 要移动指针，而ArrayList 是基于索引(index)的数据结构，可以直接映射到。</p><p data-v-6ab87549>插入、删除数据时，LinkedList 的效率比较高，因为ArrayList 要移动数据。LinkedList 比ArrayList 开销更大，因为LinkedList 的节点除了存储数据，还需要存储引用。</p><h2 id="_5-treeset-实现排序的方式" tabindex="-1" data-v-6ab87549><a class="header-anchor" href="#_5-treeset-实现排序的方式" aria-hidden="true" data-v-6ab87549>#</a> 5. TreeSet 实现排序的方式</h2><h2 id="_6-基本数据类型有哪些" tabindex="-1" data-v-6ab87549><a class="header-anchor" href="#_6-基本数据类型有哪些" aria-hidden="true" data-v-6ab87549>#</a> 6. 基本数据类型有哪些</h2><h2 id="_7-public-private-公私有成员变量的区别-真题" tabindex="-1" data-v-6ab87549><a class="header-anchor" href="#_7-public-private-公私有成员变量的区别-真题" aria-hidden="true" data-v-6ab87549>#</a> 7. public / Private 公私有成员变量的区别（真题）</h2><h2 id="_8-面向对象程序设计三个特点-并解释其含义-真题" tabindex="-1" data-v-6ab87549><a class="header-anchor" href="#_8-面向对象程序设计三个特点-并解释其含义-真题" aria-hidden="true" data-v-6ab87549>#</a> 8. 面向对象程序设计三个特点，并解释其含义（真题）</h2><h2 id="_9-抽象类和接口的定义以及区别-真题" tabindex="-1" data-v-6ab87549><a class="header-anchor" href="#_9-抽象类和接口的定义以及区别-真题" aria-hidden="true" data-v-6ab87549>#</a> 9. 抽象类和接口的定义以及区别（真题）</h2><h2 id="_10-重载与重写的区别" tabindex="-1" data-v-6ab87549><a class="header-anchor" href="#_10-重载与重写的区别" aria-hidden="true" data-v-6ab87549>#</a> 10. 重载与重写的区别</h2><h2 id="_11-根据-uml-图解释类的关系-根据类的关系画-uml-类图-真题" tabindex="-1" data-v-6ab87549><a class="header-anchor" href="#_11-根据-uml-图解释类的关系-根据类的关系画-uml-类图-真题" aria-hidden="true" data-v-6ab87549>#</a> 11. 根据 uml 图解释类的关系，根据类的关系画 uml 类图（真题）</h2><h2 id="_12-类与类之间的关系有哪些-分别描述" tabindex="-1" data-v-6ab87549><a class="header-anchor" href="#_12-类与类之间的关系有哪些-分别描述" aria-hidden="true" data-v-6ab87549>#</a> 12. 类与类之间的关系有哪些，分别描述</h2><h2 id="_13-什么是开闭原则-高内聚、低耦合原则-多用组合少用继承原则" tabindex="-1" data-v-6ab87549><a class="header-anchor" href="#_13-什么是开闭原则-高内聚、低耦合原则-多用组合少用继承原则" aria-hidden="true" data-v-6ab87549>#</a> 13. 什么是开闭原则，高内聚、低耦合原则，多用组合少用继承原则</h2><h2 id="_14-线程有多少种状态-请详细列举出来" tabindex="-1" data-v-6ab87549><a class="header-anchor" href="#_14-线程有多少种状态-请详细列举出来" aria-hidden="true" data-v-6ab87549>#</a> 14. 线程有多少种状态，请详细列举出来</h2><p data-v-6ab87549>4 种状态：新建、运行、中断和死亡</p><h2 id="_15-线程和进程的区别是什么" tabindex="-1" data-v-6ab87549><a class="header-anchor" href="#_15-线程和进程的区别是什么" aria-hidden="true" data-v-6ab87549>#</a> 15. 线程和进程的区别是什么</h2><p data-v-6ab87549>进程：是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。</p><p data-v-6ab87549>线程：是进程的一个执行单元，是进程内科调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。一个程序至少一个进程，一个进程至少一个线程。</p><h2 id="_16-简述对象的序列化与反序列化过程" tabindex="-1" data-v-6ab87549><a class="header-anchor" href="#_16-简述对象的序列化与反序列化过程" aria-hidden="true" data-v-6ab87549>#</a> 16. 简述对象的序列化与反序列化过程</h2><p data-v-6ab87549>序列化：把对象转化为可传输的字节序列过程称为序列化。</p><p data-v-6ab87549>反序列化：把字节序列还原为对象的过程称为反序列化。</p><h2 id="_17-什么是设计模式-什么是工厂模式之简单工厂-简述其优缺点-真题" tabindex="-1" data-v-6ab87549><a class="header-anchor" href="#_17-什么是设计模式-什么是工厂模式之简单工厂-简述其优缺点-真题" aria-hidden="true" data-v-6ab87549>#</a> 17. 什么是设计模式，什么是工厂模式之简单工厂，简述其优缺点（真题）</h2><h2 id="_18-什么是单例模式-简述其优缺点" tabindex="-1" data-v-6ab87549><a class="header-anchor" href="#_18-什么是单例模式-简述其优缺点" aria-hidden="true" data-v-6ab87549>#</a> 18. 什么是单例模式，简述其优缺点</h2><h2 id="_19-什么是抽象工厂模式" tabindex="-1" data-v-6ab87549><a class="header-anchor" href="#_19-什么是抽象工厂模式" aria-hidden="true" data-v-6ab87549>#</a> 19. 什么是抽象工厂模式</h2><h2 id="_20-什么是原型模式" tabindex="-1" data-v-6ab87549><a class="header-anchor" href="#_20-什么是原型模式" aria-hidden="true" data-v-6ab87549>#</a> 20. 什么是原型模式</h2><p data-v-6ab87549>原型模式(Prototype 模式)是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象。</p><p data-v-6ab87549>原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象， 无需知道如何创建的细节。</p><p data-v-6ab87549>工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即对象.clone()</p><h2 id="_21-什么是-java-虚拟机-有哪三个类加载器-都有什么用-真题" tabindex="-1" data-v-6ab87549><a class="header-anchor" href="#_21-什么是-java-虚拟机-有哪三个类加载器-都有什么用-真题" aria-hidden="true" data-v-6ab87549>#</a> 21. 什么是 Java 虚拟机，有哪三个类加载器，都有什么用（真题）</h2><h2 id="_22-什么是反射-及其作用" tabindex="-1" data-v-6ab87549><a class="header-anchor" href="#_22-什么是反射-及其作用" aria-hidden="true" data-v-6ab87549>#</a> 22. 什么是反射，及其作用</h2><h2 id="_23-简述-java-类加载机制" tabindex="-1" data-v-6ab87549><a class="header-anchor" href="#_23-简述-java-类加载机制" aria-hidden="true" data-v-6ab87549>#</a> 23. 简述 Java 类加载机制</h2><h2 id="_24-简述-jvm-的主要组成部分-都有什么用" tabindex="-1" data-v-6ab87549><a class="header-anchor" href="#_24-简述-jvm-的主要组成部分-都有什么用" aria-hidden="true" data-v-6ab87549>#</a> 24. 简述 Jvm 的主要组成部分，都有什么用</h2><h2 id="_25-什么是垃圾回收-有哪些垃圾回收算法" tabindex="-1" data-v-6ab87549><a class="header-anchor" href="#_25-什么是垃圾回收-有哪些垃圾回收算法" aria-hidden="true" data-v-6ab87549>#</a> 25. 什么是垃圾回收，有哪些垃圾回收算法</h2><h2 id="_26-什么是双亲委派机制" tabindex="-1" data-v-6ab87549><a class="header-anchor" href="#_26-什么是双亲委派机制" aria-hidden="true" data-v-6ab87549>#</a> 26. 什么是双亲委派机制</h2>',39),i=[h];function n(b,s){return d(),e("div",null,i)}const c=a(r,[["render",n],["__scopeId","data-v-6ab87549"],["__file","简答题.html.vue"]]);export{c as default};
