import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r,o as d,c as h,b as e,d as a,e as i,f as o}from"./app-493a8eb8.js";const s={},c=e("br",null,null,-1),p={href:"https://javaguide.cn/database/mysql/mysql-index.html",target:"_blank",rel:"noopener noreferrer"},u=e("br",null,null,-1),b={href:"https://www.bilibili.com/video/BV1Wm4y147mS",target:"_blank",rel:"noopener noreferrer"},B=e("p",null,"索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。",-1),_=e("p",null,[a("索引底层数据结构存在很多种类型，常见的索引结构有: B 树， B+树 和 Hash、红黑树。"),e("br"),a(" 在 MySQL 中，无论是 Innodb 还是 MyIsam，都使用了 "),e("strong",null,"B+树"),a(" 作为索引结构。")],-1),y={class:"hint-container info"},L=e("p",{class:"hint-container-title"},"相关信息",-1),f=e("p",null,[a("存储引擎是数据库的核心，在MySQL中，存储引擎是以插件的形式运行的。支持的引擎有十几种之多，实战常用到的，大概只有 "),e("code",null,"InnoDB"),a("、"),e("code",null,"MyISAM"),a(" 和 "),e("code",null,"Memory")],-1),x={href:"https://cloud.tencent.com/developer/article/1662516",target:"_blank",rel:"noopener noreferrer"},m=o('<h2 id="索引的优缺点" tabindex="-1"><a class="header-anchor" href="#索引的优缺点" aria-hidden="true">#</a> 索引的优缺点：</h2><p>优点：</p><ul><li>使用索引可以大大加快数据的检索速度</li><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性</li></ul><p>缺点：</p><ul><li>创建索引和维护索引需要耗费许多时间。<br> 当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率</li><li>索引需要使用物理文件存储，也会耗费一定空间</li></ul><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>使用索引一定能提高查询性能吗?</p><p>大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升</p></div><h2 id="不同的数据结构" tabindex="-1"><a class="header-anchor" href="#不同的数据结构" aria-hidden="true">#</a> 不同的数据结构</h2><h3 id="hash-表" tabindex="-1"><a class="header-anchor" href="#hash-表" aria-hidden="true">#</a> Hash 表</h3><p>哈希表可以快速检索数据（接近 O(1)）</p><p>但哈希算法有个 Hash 冲突问题，不同的 key 得到的 index 相同。</p><p>通常情况下，我们常用的解决办法是 <code>链地址法</code>。就是将哈希冲突数据存放在链表中。<br> 就比如 JDK1.8 之前 HashMap 就是通过链地址法来解决哈希冲突的。<br> 不过，JDK1.8 以后 HashMap 为了减少链表过长的时候搜索时间过长引入了红黑树。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>哈希表这么快，为什么 MySQL 没有使用其作为索引的数据结构呢？<br> 主要是因为 Hash 索引不支持顺序和范围查询。<br> 假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。并且，每次 IO 只能取一个。</p></div><h3 id="二叉查找树-bst" tabindex="-1"><a class="header-anchor" href="#二叉查找树-bst" aria-hidden="true">#</a> 二叉查找树(BST)</h3><p>二叉查找树（Binary Search Tree）是一种基于二叉树的数据结构</p><ul><li>左子树所有节点的值均小于根节点的值。</li><li>右子树所有节点的值均大于根节点的值。</li><li>左右子树也分别为二叉查找树。</li></ul><p>当二叉查找树是平衡的时候，查询的时间复杂度为 O(log2(n))<br> 当二叉查找树不平衡时，在最坏情况下，树会退化成线性链表，时间复杂退化为 O(n)<br> 二叉查找树的性能非常依赖于它的平衡程度，这就导致其不适合作为 MySQL 底层索引的数据结构。</p><p>为了解决这个问题，发明了多种在二叉查找树基础上的改进型数据结构，如平衡二叉树、B-Tree、B+Tree 等。</p><h3 id="avl-树" tabindex="-1"><a class="header-anchor" href="#avl-树" aria-hidden="true">#</a> AVL 树</h3><p>AVL 树是计算机科学中最早被发明的自平衡二叉查找树，它的名称来自于发明者 G.M. Adelson-Velsky 和 E.M. Landis 的名字缩写。</p><p>AVL 树的特点是保证任何节点的左右子树高度之差不超过 1，因此也被称为高度平衡二叉树，它的查找、插入和删除在平均和最坏情况下的时间复杂度都是 O(logn)。</p><p>AVL 树采用了旋转操作来保持平衡。主要有四种旋转操作：LL 旋转、RR 旋转、LR 旋转和 RL 旋转。</p><p>AVL 树需要频繁地进行旋转操作来保持平衡，因此会有较大的计算开销进而降低了查询性能。<br> 并且， 在使用 AVL 树时，每个树节点仅存储一个数据，而每次进行磁盘 IO 时只能读取一个节点的数据，如果需要查询的数据分布在多个节点上，那么就需要进行多次磁盘 IO。</p><p>AVL 树使用的并不多</p><h3 id="红黑树" tabindex="-1"><a class="header-anchor" href="#红黑树" aria-hidden="true">#</a> 红黑树</h3><p>红黑树是一种自平衡二叉查找树，通过在插入和删除节点时进行颜色变换和旋转操作，使得树始终保持平衡状态，它具有以下特点：</p><ul><li>每个节点非红即黑</li><li>根节点总是黑色的</li><li>每个叶子节点都是黑色的空节点（NIL 节点）</li><li>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）</li><li>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）</li></ul><p>红黑树并不追求严格的平衡，而是大致的平衡。</p><p>因此，红黑树的查询效率稍有下降，因为红黑树的平衡性相对较弱，可能会导致树的高度较高，这可能会导致一些数据需要进行多次磁盘 IO 操作才能查询到，这也是 MySQL 没有选择红黑树的主要原因。</p><p>但红黑树的插入和删除操作效率大大提高了，红黑树在插入和删除节点时只需进行 O(1) 次数的旋转和变色操作，即可保持基本平衡状态，而不需要像 AVL 树一样进行 O(logn) 次数的旋转操作。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>红黑树的应用还是比较广泛的，TreeMap、TreeSet 以及 JDK1.8 的 HashMap 底层都用到了红黑树。对于数据在内存中的这种情况来说，红黑树的表现是非常优异的。</p></div><h3 id="b-树-b-树" tabindex="-1"><a class="header-anchor" href="#b-树-b-树" aria-hidden="true">#</a> B 树&amp; B+树</h3><p>B 树也称 B-树，全称为 多路平衡查找树 ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 Balanced （平衡）的意思。<br> 目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。</p><h4 id="b树-与-b-树-的异同" tabindex="-1"><a class="header-anchor" href="#b树-与-b-树-的异同" aria-hidden="true">#</a> B树 与 B+树 的异同</h4><ul><li>B树 的所有节点既存放键(key) 也存放数据(data)<br> B+树 只有 <strong>叶子节点</strong> 存放 key 和 data，其他内节点只存放 key。</li><li>B树 的叶子节点都是独立的<br> B+树 的叶子节点有一条 <strong>引用链</strong> 指向与它相邻的叶子节点。</li><li>B树 的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。<br> B+树 的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li><li>B树 中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限<br> B+树 的范围查询，只需要对链表进行遍历即可。</li></ul><p>综上，B+树 与 B树 相比，具备更少的 IO 次数、更稳定的查询效率和更适于范围查询这些优势</p><h2 id="索引类型分类" tabindex="-1"><a class="header-anchor" href="#索引类型分类" aria-hidden="true">#</a> 索引类型分类</h2><h4 id="按照数据结构划分" tabindex="-1"><a class="header-anchor" href="#按照数据结构划分" aria-hidden="true">#</a> 按照数据结构划分</h4><ul><li>BTree 索引：<br> MySQL 里默认和最常用的索引类型。只有叶子节点存储 value，非叶子节点只有指针和 key。<br> 存储引擎 MyISAM 和 InnoDB 实现 BTree 索引都是使用 B+Tree，但二者实现方式不一样。</li><li>哈希索引：类似键值对的形式，一次即可定位。</li><li>RTree 索引：一般不会使用，仅支持 geometry 数据类型，优势在于范围查找，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li><li>全文索引：对文本的内容进行分词，进行搜索。目前只有 <code>char</code>、<code>varchar</code>、<code>text</code> 上可创建全文索引，一般不使用，效率较低，通常使用 ES 代替</li></ul><h4 id="按照底层存储方式划分" tabindex="-1"><a class="header-anchor" href="#按照底层存储方式划分" aria-hidden="true">#</a> 按照底层存储方式划分</h4><ul><li>聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。</li><li>非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引（辅助索引）就属于非聚簇索引。<br> MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。</li></ul><h4 id="按照应用维度划分" tabindex="-1"><a class="header-anchor" href="#按照应用维度划分" aria-hidden="true">#</a> 按照应用维度划分</h4><ul><li>主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个。</li><li>普通索引：仅加速查询。</li><li>唯一索引：加速查询 + 列值唯一（可以有 NULL）。</li><li>覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。</li><li>联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。</li><li>全文索引：对文本的内容进行分词，进行搜索。目前只有 <code>char</code>、<code>varchar</code>、<code>text</code> 上可创建全文索引，一般不使用，效率较低，通常使用 ES 代替</li></ul><h4 id="mysql-8-x-中实现的索引新特性" tabindex="-1"><a class="header-anchor" href="#mysql-8-x-中实现的索引新特性" aria-hidden="true">#</a> MySQL 8.x 中实现的索引新特性：</h4><ul><li>隐藏索引（不可见索引）：不会被优化器使用，但是仍然需要维护，通常会软删除和灰度发布的场景中使用。主键不能设置为隐藏（包括显式设置或隐式设置）。</li><li>降序索引：之前的版本就支持通过 desc 来指定索引为降序，但实际上创建的仍然是常规的升序索引。直到 MySQL 8.x 版本才开始真正支持降序索引。另外，在 MySQL 8.x 版本中，不再对 GROUP BY 语句进行隐式排序。</li><li>函数索引：从 MySQL 8.0.13 版本开始支持在索引中使用函数或者表达式的值，也就是在索引中可以包含函数或者表达式。</li></ul><h2 id="主键索引" tabindex="-1"><a class="header-anchor" href="#主键索引" aria-hidden="true">#</a> 主键索引</h2><p>一张数据表有只能有一个主键，并且主键不能为 null，不能重复。</p><p>MySQL 的 InnoDB 的表中，若没有显示的指定表的主键时<br> InnoDB 会自动先检查表中是否有唯一索引且不允许存在 null 值的字段<br> 如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。</p><h2 id="二级索引" tabindex="-1"><a class="header-anchor" href="#二级索引" aria-hidden="true">#</a> 二级索引</h2><p>二级索引（Secondary Index）又称为辅助索引<br> 二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。</p><p>唯一索引，普通索引，前缀索引等索引属于二级索引。</p><ul><li>唯一索引（Unique Key）：不能出现重复的数据，但允许数据为 NULL，一张表允许创建多个唯一索引。</li><li>普通索引（Index）：普通索引的唯一作用是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。</li><li>前缀索引（Prefix）：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。</li><li>全文索引（Full Text）：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。</li></ul><h2 id="聚簇索引与非聚簇索引" tabindex="-1"><a class="header-anchor" href="#聚簇索引与非聚簇索引" aria-hidden="true">#</a> 聚簇索引与非聚簇索引</h2>',52);function M(S,I){const l=r("ExternalLinkIcon"),n=r("BiliBili");return d(),h("div",null,[e("blockquote",null,[e("p",null,[a("参考："),c,e("a",p,[a("https://javaguide.cn/database/mysql/mysql-index.html"),i(l)]),u,e("a",b,[a("https://www.bilibili.com/video/BV1Wm4y147mS"),i(l)])])]),B,_,e("div",y,[L,f,e("p",null,[e("a",x,[a("https://cloud.tencent.com/developer/article/1662516"),i(l)])])]),i(n,{bvid:"BV1Wm4y147mS"}),m])}const Q=t(s,[["render",M],["__file","MySQL索引.html.vue"]]);export{Q as default};
