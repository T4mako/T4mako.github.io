import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{o as n,c as e,a as t,d as a}from"./app-a589a01e.js";const l={},o=a('<h2 id="注解-annotation" tabindex="-1"><a class="header-anchor" href="#注解-annotation" aria-hidden="true">#</a> 注解(Annotation)</h2><p>一定程度上：框架=注解+反射+设计模式</p><h3 id="_1、理解annotation" tabindex="-1"><a class="header-anchor" href="#_1、理解annotation" aria-hidden="true">#</a> 1、理解Annotation：</h3><ul><li>JDK5.0新增</li><li>Annotation 就是代码里的特殊标记, 它可以在编译, 类加载, 运行时被读取, 并执行相应的处理。</li><li>使用 Annotation, 在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。</li><li>代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署 。</li><li>Annotation 可以修饰包,类,构造器,方法,成员变量,参数,局部变量的声明,这些信息被保存在 Annotation的 “name=value” 对中</li><li>在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等</li></ul>',4),r=a('<h3 id="_2、annotation的使用实例" tabindex="-1"><a class="header-anchor" href="#_2、annotation的使用实例" aria-hidden="true">#</a> 2、Annotation的使用实例</h3><p>示例一：生成文档相关的注解</p><p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220720154849463.png" alt="image-20220720154849463" loading="lazy"></p><p>示例二： 在编译时进行格式检查(JDK内置的三个基本注解)</p><ul><li>@Override: 限定重写父类方法, 该注解只能用于方法</li><li>@Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择</li><li>@SuppressWarnings: 抑制编译器警告 (所定义的结构尚未使用)</li></ul><p>示例三： 跟踪代码依赖性，实现替代配置文件功能</p><h3 id="_3、自定义注解" tabindex="-1"><a class="header-anchor" href="#_3、自定义注解" aria-hidden="true">#</a> 3、自定义注解</h3><p>参照@SuppressWarnings定义</p><ol><li>注解声明为@interface</li><li>内部定义成员，通常使用value表示</li><li>可以指定成员默认值，使用default定义</li><li>如果自定义注解没有成员，表明是一个标识作用</li></ol><p>如果注解有成员，在使用注解时，需要指明成员的值<br> 自定义注解必须配上注解的信息处理流程(使用反射)才有意义<br> 自定义注解通常会指明两个元注解：Retention、Target</p><h3 id="_4、jdk提供的四种元注解" tabindex="-1"><a class="header-anchor" href="#_4、jdk提供的四种元注解" aria-hidden="true">#</a> 4、jdk提供的四种元注解</h3><p>元注解：对现有的注解进行解释说明的注解</p><ul><li>Retention：指定所修饰的Annotation的声明周期：SOURCE、CLASS（默认行为）、RUNTIME（只有声明为RUNTIME声明周期的注解，才能通过反射获取）</li></ul><p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220720163114450.png" alt="image-20220720163114450" loading="lazy"></p><ul><li>Target：指定被修饰的Annotation能用于修饰哪些程序元素</li></ul><p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220720163052587.png" alt="image-20220720163052587" loading="lazy"></p><ul><li>Documented：表示所修饰的注解在被javadoc解析时，保留下来</li><li>Inherited：被他修饰的Annotation将具有继承性</li></ul><h3 id="_5、通过反射获取注解信息" tabindex="-1"><a class="header-anchor" href="#_5、通过反射获取注解信息" aria-hidden="true">#</a> 5、通过反射获取注解信息</h3><h3 id="_6、jdk8中注解的新特性-可重复注解、类型注解" tabindex="-1"><a class="header-anchor" href="#_6、jdk8中注解的新特性-可重复注解、类型注解" aria-hidden="true">#</a> 6、jdk8中注解的新特性：可重复注解、类型注解</h3><ol><li>可重复注解：</li></ol><ul><li>在MyAnnotation上声明@Repeatable，成员值为MyAnnotations.class</li><li>在MyAnnotation的Target和Retention和MyAnnotations相同</li></ul><ol start="2"><li>类型注解</li></ol><ul><li>ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（如： 泛型声明） 。</li><li>ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。</li></ul>',23);function d(h,s){return n(),e("div",null,[o,t(" more "),r])}const u=i(l,[["render",d],["__file","12、注解.html.vue"]]);export{u as default};
