---
date: 2023-08-31
category: MySQL
title: MySQL 索引
---

> 参考：
> https://javaguide.cn/database/mysql/mysql-index.html  
> https://www.bilibili.com/video/BV1Wm4y147mS

索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。

索引底层数据结构存在很多种类型，常见的索引结构有: B 树， B+树 和 Hash、红黑树。  
在 MySQL 中，无论是 Innodb 还是 MyIsam，都使用了 **B+树** 作为索引结构。
:::info
存储引擎是数据库的核心，在MySQL中，存储引擎是以插件的形式运行的。支持的引擎有十几种之多，实战常用到的，大概只有 `InnoDB`、`MyISAM` 和 `Memory`

https://cloud.tencent.com/developer/article/1662516
:::

<BiliBili bvid="BV1Wm4y147mS" />

## 索引的优缺点
优点：
- 使用索引可以大大加快数据的检索速度
- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性

缺点：
- 创建索引和维护索引需要耗费许多时间。  
  当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率
- 索引需要使用物理文件存储，也会耗费一定空间

:::info
使用索引一定能提高查询性能吗?

大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升
:::

## 不同的数据结构

### Hash 表
哈希表可以快速检索数据（接近 O(1)）

但哈希算法有个 Hash 冲突问题，不同的 key 得到的 index 相同。  

通常情况下，我们常用的解决办法是 `链地址法`。就是将哈希冲突数据存放在链表中。  
就比如 JDK1.8 之前 HashMap 就是通过链地址法来解决哈希冲突的。  
不过，JDK1.8 以后 HashMap 为了减少链表过长的时候搜索时间过长引入了红黑树。

:::info
哈希表这么快，为什么 MySQL 没有使用其作为索引的数据结构呢？   
主要是因为 Hash 索引不支持顺序和范围查询。  
假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。并且，每次 IO 只能取一个。
:::

### 二叉查找树(BST)

二叉查找树（Binary Search Tree）是一种基于二叉树的数据结构
- 左子树所有节点的值均小于根节点的值。
- 右子树所有节点的值均大于根节点的值。
- 左右子树也分别为二叉查找树。

当二叉查找树是平衡的时候，查询的时间复杂度为 O(log2(n))    
当二叉查找树不平衡时，在最坏情况下，树会退化成线性链表，时间复杂退化为 O(n)  
二叉查找树的性能非常依赖于它的平衡程度，这就导致其不适合作为 MySQL 底层索引的数据结构。

为了解决这个问题，发明了多种在二叉查找树基础上的改进型数据结构，如平衡二叉树、B-Tree、B+Tree 等。


### AVL 树
AVL 树是计算机科学中最早被发明的自平衡二叉查找树，它的名称来自于发明者 G.M. Adelson-Velsky 和 E.M. Landis 的名字缩写。  

AVL 树的特点是保证任何节点的左右子树高度之差不超过 1，因此也被称为高度平衡二叉树，它的查找、插入和删除在平均和最坏情况下的时间复杂度都是 O(logn)。

AVL 树采用了旋转操作来保持平衡。主要有四种旋转操作：LL 旋转、RR 旋转、LR 旋转和 RL 旋转。

AVL 树需要频繁地进行旋转操作来保持平衡，因此会有较大的计算开销进而降低了查询性能。  
并且， 在使用 AVL 树时，每个树节点仅存储一个数据，而每次进行磁盘 IO 时只能读取一个节点的数据，如果需要查询的数据分布在多个节点上，那么就需要进行多次磁盘 IO。

AVL 树使用的并不多

### 红黑树
红黑树是一种自平衡二叉查找树，通过在插入和删除节点时进行颜色变换和旋转操作，使得树始终保持平衡状态，它具有以下特点：
- 每个节点非红即黑
- 根节点总是黑色的
- 每个叶子节点都是黑色的空节点（NIL 节点）
- 如果节点是红色的，则它的子节点必须是黑色的（反之不一定）
- 从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）

红黑树并不追求严格的平衡，而是大致的平衡。  

因此，红黑树的查询效率稍有下降，因为红黑树的平衡性相对较弱，可能会导致树的高度较高，这可能会导致一些数据需要进行多次磁盘 IO 操作才能查询到，这也是 MySQL 没有选择红黑树的主要原因。

但红黑树的插入和删除操作效率大大提高了，红黑树在插入和删除节点时只需进行 O(1) 次数的旋转和变色操作，即可保持基本平衡状态，而不需要像 AVL 树一样进行 O(logn) 次数的旋转操作。

:::info
红黑树的应用还是比较广泛的，TreeMap、TreeSet 以及 JDK1.8 的 HashMap 底层都用到了红黑树。对于数据在内存中的这种情况来说，红黑树的表现是非常优异的。
:::

### B 树& B+树
B 树也称 B-树，全称为 多路平衡查找树 ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 Balanced （平衡）的意思。  
目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。  

#### B树 与 B+树 的异同
- B树 的所有节点既存放键(key) 也存放数据(data)    
  B+树 只有 **叶子节点** 存放 key 和 data，其他内节点只存放 key。  
- B树 的叶子节点都是独立的  
  B+树 的叶子节点有一条 **引用链** 指向与它相邻的叶子节点。
- B树 的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。
  B+树 的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。
- B树 中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限  
  B+树 的范围查询，只需要对链表进行遍历即可。

综上，B+树 与 B树 相比，具备更少的 IO 次数、更稳定的查询效率和更适于范围查询这些优势

## 索引类型分类

#### 按照数据结构划分
- BTree 索引：
  MySQL 里默认和最常用的索引类型。只有叶子节点存储 value，非叶子节点只有指针和 key。  
  存储引擎 MyISAM 和 InnoDB 实现 BTree 索引都是使用 B+Tree，但二者实现方式不一样。
- 哈希索引：类似键值对的形式，一次即可定位。
- RTree 索引：一般不会使用，仅支持 geometry 数据类型，优势在于范围查找，效率较低，通常使用搜索引擎如 ElasticSearch 代替。
- 全文索引：对文本的内容进行分词，进行搜索。目前只有 `char`、`varchar`、`text` 上可创建全文索引，一般不使用，效率较低，通常使用 ES 代替


#### 按照底层存储方式划分
- 聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。
- 非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引（辅助索引）就属于非聚簇索引。
  MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。

#### 按照应用维度划分
- 主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个。
- 普通索引：仅加速查询。
- 唯一索引：加速查询 + 列值唯一（可以有 NULL）。
- 覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。
- 联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。
- 全文索引：对文本的内容进行分词，进行搜索。目前只有 `char`、`varchar`、`text` 上可创建全文索引，一般不使用，效率较低，通常使用 ES 代替

#### MySQL 8.x 中实现的索引新特性：
- 隐藏索引（不可见索引）：不会被优化器使用，但是仍然需要维护，通常会软删除和灰度发布的场景中使用。主键不能设置为隐藏（包括显式设置或隐式设置）。
- 降序索引：之前的版本就支持通过 desc 来指定索引为降序，但实际上创建的仍然是常规的升序索引。直到 MySQL 8.x 版本才开始真正支持降序索引。另外，在 MySQL 8.x 版本中，不再对 GROUP BY 语句进行隐式排序。
- 函数索引：从 MySQL 8.0.13 版本开始支持在索引中使用函数或者表达式的值，也就是在索引中可以包含函数或者表达式。

### 主键索引

一张数据表有只能有一个主键，并且主键不能为 null，不能重复。

MySQL 的 InnoDB 的表中，若没有显示的指定表的主键时  
InnoDB 会自动先检查表中是否有唯一索引且不允许存在 null 值的字段  
如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。

### 二级索引

二级索引（Secondary Index）又称为辅助索引  
二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。

唯一索引，普通索引，前缀索引等索引属于二级索引。
- 唯一索引（Unique Key）：不能出现重复的数据，但允许数据为 NULL，一张表允许创建多个唯一索引。
- 普通索引（Index）：普通索引的唯一作用是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。
- 前缀索引（Prefix）：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。
- 全文索引（Full Text）：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。

###  聚簇索引与非聚簇索引

#### 聚簇索引
聚簇索引（Clustered Index）即 「索引结构和数据一起存放」的索引，并不是一种单独的索引类型。InnoDB 中的主键索引就属于聚簇索引。  
MySQL 中，InnoDB 引擎的表的 `.ibd` 文件就包含了该表的索引和数据  
对于 InnoDB 引擎表来说，该表的索引（B+树）的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。

##### 聚簇索引的优缺点：

优点：
- 查询速度快：  
  整个 B+树 本身就是一颗多叉平衡树，叶子节点也都是有序的   
  定位到索引的节点，就相当于定位到了数据。相比于非聚簇索引， 聚簇索引少了一次读取数据的 IO 操作
- 对排序查找和范围查找优化：  
  聚簇索引对于主键的排序查找和范围查找速度非常快。

缺点：
- 依赖于有序的数据：
  B+树 是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。
- 更新代价大：  
  如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚簇索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。

#### 非聚簇索引
非聚簇索引（Non-Clustered Index）即「索引结构和数据分开存放」的索引，并不是一种单独的索引类型。  
二级索引（唯一索引，普通索引，前缀索引等）就属于非聚簇索引。  
MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。

非聚簇索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。

##### 聚簇索引的优缺点
优点：
- 更新代价比聚簇索引要小：  
  非聚簇索引的叶子节点是不存放数据的

缺点：
- 依赖于有序的数据：
  跟聚簇索引一样，非聚簇索引也依赖于有序的数据  
  可能会二次查询（回表）：这应该是非聚簇索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。


:::info
**非聚簇索引不一定回表查询**
```sql
-- 用户名字段正好建立了索引
-- 索引的 key 本身就是 name，查到对应的 name 直接返回就行了，无需回表查询。
SELECT name FROM table WHERE name='guang19';

-- 如果 SQL 查的就是主键
-- 主键索引本身的 key 就是主键，查到返回就行了。这种情况就称之为覆盖索引了。
SELECT id FROM table WHERE id=1;
```
:::


### 覆盖索引和联合索引

#### 覆盖索引

如果一个索引包含（覆盖）所有需要查询的字段的值，我们就称之为 覆盖索引（Covering Index） 。  
在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是 主键+列值。  
最终还是要「回表」，也就是要通过主键再查找一次，这样就会比较慢。  
而覆盖索引就是把要查询出的列和索引是对应的，**不做回表操作！**

> 如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引， 那么直接根据这个索引就可以查到数据，也无需回表。

#### 联合索引
使用表中的多个字段创建索引，就是 **联合索引**（组合索引/复合索引）

### 最左前缀匹配原则
:::info

最左前缀匹配原则指的是，在使用联合索引时，MySQL 会根据 **联合索引中的字段顺序** 。  
从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询（如 >、<）才会停止匹配。对于 >=、<=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配。  
所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。

:::

### 索引下推
索引下推（Index Condition Pushdown） 是 MySQL 5.6 版本中提供的一项索引优化功能，可以在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数


## 如何正确使用索引

### 适合创建索引的字段
- **不为 NULL 的字段**
  索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。
- **频繁查询的字段**
  创建索引的字段应该是查询操作非常频繁的字段
- **作为条件查询的字段**
  被作为 WHERE 条件查询的字段，应该被考虑建立索引
- **频繁需要排序的字段**
  索引已经排序，这样查询可以利用索引的排序，加快排序查询时间
- **经常频繁用于连接的字段**
  经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。

### 被频繁更新的字段应该慎重建立索引

如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。

### 限制每张表上的索引数量
索引并不是越多越好，建议单张表索引不超过 5 个！  
索引可以提高效率同样可以降低效率。索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。  
因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能

### 尽可能的考虑建立联合索引而不是单列索引
索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。  
如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。  
如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升

### 注意避免冗余索引
冗余索引指的是索引的功能相同，能够命中索引（a, b）就肯定能命中索引（a），那么索引（a）就是冗余索引。  
在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引

### 字符串类型的字段使用前缀索引代替普通索引
前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引

### 避免索引失效
索引失效也是慢查询的主要原因之一，常见的导致索引失效的情况：
- `SELECT *` 不会直接导致索引失效（如果不走索引大概率是因为 where 查询范围过大导致的），但它可能会带来一些其他的性能问题比如造成网络传输和数据处理的浪费、无法使用索引覆盖;
- 创建了组合索引（联合索引/复合索引），但查询条件未遵守最左匹配原则
- 在索引列上进行计算、函数、类型转换等操作;
- 以 % 开头的 LIKE 查询比如 like '%abc'
- 查询条件中使用 or，且 or 的前后条件中有一个列没有索引，涉及的索引都不会被使用到
- 发生 [隐式转换](https://javaguide.cn/database/mysql/index-invalidation-caused-by-implicit-conversion.html)

### 删除长期未使用的索引
删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗。

MySQL 5.7 可以通过查询 sys 库的 `schema_unused_indexes` 视图来查询哪些索引从未被使用。

### 分析语句是否走索引查询
我们可以使用 `EXPLAIN` 命令来分析 SQL 的 **执行计划** ，这样就知道语句是否命中索引了。执行计划是指一条 SQL 语句在经过 MySQL 查询优化器的优化会后，具体的执行方式。

`EXPLAIN` 并不会真的去执行相关的语句，而是通过 **查询优化器** 对语句进行分析，找出最优的查询方案，并显示对应的信息。

`EXPLAIN` 的输出格式如下：
```sql
mysql> EXPLAIN SELECT `score`,`name` FROM `cus_order` ORDER BY `score` DESC;
+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+
| id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra          |
+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+
|  1 | SIMPLE      | cus_order | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 997572 |   100.00 | Using filesort |
+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+
1 row in set, 1 warning (0.00 sec)
```

各个字段的含义如下：

| **列名**      | **含义**                                     |
| ------------- | -------------------------------------------- |
| id            | SELECT 查询的序列标识符                      |
| select_type   | SELECT 关键字对应的查询类型                  |
| table         | 用到的表名                                   |
| partitions    | 匹配的分区，对于未分区的表，值为 NULL        |
| type          | 表的访问方法                                 |
| possible_keys | 可能用到的索引                               |
| key           | 实际用到的索引                               |
| key_len       | 所选索引的长度                               |
| ref           | 当使用索引等值查询时，与索引作比较的列或常量 |
| rows          | 预计要读取的行数                             |
| filtered      | 按表条件过滤后，留存的记录数的百分比         |
| Extra         | 附加信息                                     |