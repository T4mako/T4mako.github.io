# 算法

## 算法性能度量方法

时间复杂度的判别、动态规划状态转移方程

## 常见问题

阶乘、素数、完数、回文数、最小公约数、最小公倍数  

KMP算法、马拉车算法、Prim算法、Krusk算法、Dijkstra算法、Bellman-Ford 算法

## 线性表
线性表有「顺序存储结构 ArrayList」和「链式存储结构 LinkedList」  

顺序表和链表的区别及其优缺点：
顺序表：
- 原理：顺序表存储是将数据元素放到一块连续的内存存储空间，相邻数据元素的存放地址也相邻（逻辑与物理统一）。
- 优点：
  - 空间利用率高（局部性原理，连续存放，命中率高） 
  - 存取速度高效，可以随机存取，通过下标来直接存储
- 缺点：
  - 插入和删除比较慢，比如：插入或者删除一个元素时，整个表需要遍历移动元素来重新排一次顺序
  - 不可以增长长度，有空间限制，当需要存取的元素个数可能多于顺序表的元素个数时，会出现「溢出」问题，当元素个数远少于预先分配的空间时，空间浪费巨大
  - 顺序表的存储密度为 1（存储密度 = 节点中数据占用的存储量 / 整个节点占用存储量）
- 时间性能 :查找 O(1)，插入和删除 O(n)

链表：
- 原理：链表存储是在程序运行过程中动态的分配空间，只要存储器还有空间，就不会发生存储溢出问题，相邻数据元素可随意存放，但所占存储空间分两部分，一部分存放结点值，另一部分存放表示结点关系间的指针
- 优点：
  - 存取某个元素速度慢
  - 插入和删除速度快，保留原有的物理顺序，比如：插入或者删除一个元素时，只需要改变指针指向即可
  - 没有空间限制，存储元素的个数无上限，基本只与内存空间大小有关
- 缺点：
  - 占用额外的空间以存储指针
  - 链表的存储密度小于 1 
  - 查找速度慢，因为查找时，需要从开始节点一个一个节点去查找元素访问
- 时间性能 :查找 O(n)，插入和删除 O(1) 

### 链表节点定义

- 单链表
```java
public class ListNode {
    int val;
    ListNode next;

    ListNode() {
    }

    ListNode(int val) {
        this.val = val;
    }

    ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }
}
```

- 双链表
```java
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode() {
    }

    TreeNode(int val) {
        this.val = val;
    }

    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

线性表常见算法题：
### 链表题
[链表合集](https://t4mako.github.io/tag/%E9%93%BE%E8%A1%A8/)
### 数组题
[数组合集](https://t4mako.github.io/tag/%E6%95%B0%E7%BB%84/)


## 查找

### 顺序查找

### 二分查找

```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0,right = nums.length - 1;
        while(left <= right){
            int mid = left + (right - left) / 2;
            if(target == nums[mid]) return mid;
            else if(target < nums[mid]) right = mid - 1;
            else left = mid + 1;
        }
        return -1;
    }
}
```

## 排序

|算法|最好|最坏|平均|空间|稳定|思想|
|-|-|-|-|-|-|-|
| 冒泡 | O(n) | O(n^2^) |O(n^2^)|O(1)|Y|比较|
| 选择 |O(n^2^)|O(n^2^)|O(n^2^)|O(1)|N|比较|
| 堆 |O(nlogn)|O(nlogn)|O(nlogn)|O(1)|N|选择|
| 插入 |O(n)|O(n^2^)|O(n^2^)|O(1)|Y|比较|
| 希尔 |O(nlogn)|O(n^2^)|O(nlogn)|O(1)|N|插入|
| 归并 |O(nlogn)|O(nlogn)|O(nlogn)|O(n)|Y|归并|
| 快速 |O(nlogn)|O(n^2^)|O(nlogn)|O(nlogn)|N|分治|

### 冒泡排序

```java
public static void sort(int[] array) {
    if (array == null || array.length == 0) {
        return;
    }
    int length = array.length;
    // 外层：需要 length - 1 次循环比较
    for (int i = 0; i < length - 1; i++) {
        // 内层：每次循环需要两两比较的次数，每次比较后，都会将当前最大的数放到最后位置，所以每次比较次数递减一次
        for (int j = 0; j < length - 1 - i; j++) {
            if (array[j] > array[j + 1]) {
                // 交换数组 array 的 j 和 j + 1 位置的数据
                int temp = array[i];
                array[i] = array[j];
                array[j] = temp;
            }
        }
    }
}
```

### 选择排序

```java
public static void sort(int[] arr) {
    for (int i = 0; i < arr.length - 1; i++) {
        int min = i;
        for (int j = i + 1; j < arr.length; j++) { //选出之后待排序中值最小的位置
            if (arr[j] < arr[min]) {
                min = j;
            }
        }
        if (min != i) {
            arr[min] = arr[i] + arr[min];
            arr[i] = arr[min] - arr[i];
            arr[min] = arr[min] - arr[i];
        }
    }
}
```

### 直接插入排序

```java
public static void sort(int[] a) {
    if (a == null || a.length == 0) {
        return;
    }

    for (int i = 1; i < a.length; i++) {
        int j = i - 1;
        int temp = a[i]; // 先取出待插入数据保存，因为向后移位过程中会把覆盖掉待插入数
        while (j >= 0 && a[j] > temp) { // 如果待是比待插入数据大，就后移
            a[j + 1] = a[j];
            j--;
        }
        a[j+1] = temp; // 找到比待插入数据小的位置，将待插入数据插入
    }
}
```

### 快速排序

```java
public static void sort(int arr[], int low, int high) {
    if (arr == null || arr.length <= 0) {
        return;
    }
    if (low >= high) {
        return;
    }

    int left = low;
    int right = high;
    int temp = arr[left]; // 基准

    while (left < right) {
        while (left < right && arr[right] >= temp) {
            right--;
        }
        arr[left] = arr[right]; // 从后向前找到比基准小的元素，放入空位
        while (left < right && arr[left] <= temp) {
            left ++;
        }
        arr[right] = arr[left]; // 从前往后找到比基准大的元素，放入空位
    }
    arr[left] = temp; // 基准放入空位
    sort(arr, low, left-1);
    sort(arr, left + 1, high);
}
```

### 希尔排序

将待排序数组按照步长 gap 进行分组，然后将每组的元素利用直接插入排序的方法进行排序；每次再将 gap 折半减小，循环上述操作；当 gap = 1 时，利用直接插入，完成排序。

gap 初始时一般为数组长度的一半，即每两个数为一组

```java
private static void shellSort(int[] a){
    for (int gap = a.length >> 1; gap >= 1; gap = gap >> 1) {
        for (int low = gap; low < a.length; low++) {
            int t = a[low];
            int i = low - gap;
            // 自右向左找插入位置，如果比待插入元素大，则不断右移
            while (i >= 0 && t < a[i]){
                a[i + gap] = a[i];
                i -= gap;
            }
            // 找到插入位置
            if(i != low - gap){
                a[i + gap] = t;
            }
        }
    }
}
```

### 归并排序

```java
public class MergeSort {

    public static int[] sort(int [] a) {
        if (a.length <= 1) {
            return a;
        }
        int num = a.length >> 1;
        int[] left = Arrays.copyOfRange(a, 0, num);
        int[] right = Arrays.copyOfRange(a, num, a.length);
        return mergeTwoArray(sort(left), sort(right));
    }

    public static int[] mergeTwoArray(int[] a, int[] b) {
        int i = 0, j = 0, k = 0;
        int[] result = new int[a.length + b.length]; // 申请额外空间保存归并之后数据

        while (i < a.length && j < b.length) { //选取两个序列中的较小值放入新数组
            if (a[i] <= b[j]) {
                result[k++] = a[i++];
            } else {
                result[k++] = b[j++];
            }
        }

        while (i < a.length) { //序列a中多余的元素移入新数组
            result[k++] = a[i++];
        }
        while (j < b.length) {//序列b中多余的元素移入新数组
            result[k++] = b[j++];
        }
        return result;
    }

    public static void main(String[] args) {
        int[] b = {3, 1, 5, 4};
        System.out.println(Arrays.toString(sort(b)));
    }
}
```

### 基数排序

```java
public class RadixSort {

    public static void main(String[] args) {
        int[] array = {10, 20, 5, 4, 100};
        sort(array);
    }

    public static void sort(int[] a) {

        if (a == null || a.length < 0) {
            return;
        }

        int max = a[0];
        for (int i = 0; i <a.length; i++) {
            if (a[i] > max) {
                max = a[i];
            }
        }
        System.out.println("max, " + max);

        int maxDigit = 0;
        while (max != 0) {
            max = max / 10;
            maxDigit++;
        }
        System.out.println("maxDigit, " + maxDigit);

        int[][] buckets = new int[10][a.length];
        int base = 10;

        //从低位到高位，对每一位遍历，将所有元素分配到桶中
        for (int i = 0; i < maxDigit; i++) {
            int[] bucketLen = new int[10];  //存储各个桶中存储元素的数量

            //收集：将不同桶里数据挨个捞出来,为下一轮高位排序做准备,由于靠近桶底的元素排名靠前,因此从桶底先捞
            for (int j = 0; j < a.length; j++) {
                int whichBucket = (a[j] % base) / (base / 10);
                buckets[whichBucket][bucketLen[whichBucket]] = a[j];
                bucketLen[whichBucket]++;
            }

            int k = 0;
            //收集：将不同桶里数据挨个捞出来,为下一轮高位排序做准备,由于靠近桶底的元素排名靠前,因此从桶底先捞
            for (int l = 0; l < buckets.length; l++) {
                for (int m =0; m < bucketLen[l]; m++) {
                    a[k++] = buckets[l][m];
                }
            }
            System.out.println("Sorting: " + Arrays.toString(a));
            base *= 10;
        }
    }
}
```

### 堆排序

- 建立大顶堆
- 每次将堆顶元素（最大值）交换到末尾，重新调整大顶堆，使其重新符合大顶堆特性

```java
public class HeapSort {

    public static void sort(int[] a){
        heapify(a,a.length);
        for(int right = a.length - 1;right > 0;right--){
            swap(a,0,right);
            down(a,0,right);
        }
    }


    // 建堆 O(n)
    private static void heapify(int[] array,int size){
        for (int i = size / 2 - 1; i >= 0 ; i--) {
            down(array,i,size);
        }
    }

    // 下潜
    private static void down(int[] array,int parent,int size){
        while (true){
            int left = parent * 2 + 1; // 左孩子
            int right = left + 1; // 右孩子
            int max = parent;
            if(left < size && array[left] > array[max]){
                max = left;
            }
            if(right < size && array[right] > array[max]){
                max = right;
            }
            if(max == parent){ // 没有更大的孩子
                break;
            }
            swap(array,max,parent);
            parent = max;
        }

    }

    // 交换
    private static void swap(int[] a,int i,int j){
        int temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }

}
```



## 递归与分支

## 动态规划

## 贪心算法

## 回溯法

## 分支限界法