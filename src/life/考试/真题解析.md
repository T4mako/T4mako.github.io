## 2022 程序设计题
### 计算 n*n 数组元素和
```java
public int sum(int[][] arr){
    int res = 0;
    for (int i = 0; i < arr.length; i++) {
        for (int j = 0; j < arr[0].length; j++) {
            res += arr[i][j];
        }
    }
    return res;
}
```
### 利用递归的方法将 10 进制转换为 16 进制
```java
public static String decimalToHex(int num) {
    if (num == 0) {
        return "";
    }

    // 十六进制中的数字
    char[] hexChars = "0123456789ABCDEF".toCharArray();

    // 递归的基本情况
    if (num > 0) {
        int remainder = num % 16;
        return decimalToHex(num / 16) + hexChars[remainder];
    }

    return "";
}
```

### 给出链表，将链表奇节点排在前，偶节点排在后
```java
class Solution {
    public ListNode oddEvenList(ListNode head) {
        if (head == null) {
            return head;
        }
        ListNode evenHead = head.next;
        ListNode odd = head, even = evenHead;
        while (even != null && even.next != null) {
            odd.next = even.next;
            odd = odd.next;
            even.next = odd.next;
            even = even.next;
        }
        odd.next = evenHead;
        return head;
    }
}
```

### 对 Test.csv 求表第一行数据平均值，加入某数据某个值缺失如何处理
```java
public static double averageCsv() throws IOException{
    File file = new File("C:\\Users\\Tamako\\Desktop\\value.csv");
    FileReader reader = new FileReader(file);
    BufferedReader bf = new BufferedReader(reader);
    String str = bf.readLine();
    reader.close();
    bf.close();
    String[] strings = str.split(",");
    double res = 0;
    for(String s : strings){
        res += Double.parseDouble(s);
    }
    return res / strings.length;
}
```

缺失值处理方法：
1. 跳过缺失值
忽略包含缺失值的行或列，跳过这些行或列，而不进行任何处理。
2. 填充缺失值
可以填充一个默认值，例如 0、空字符串、平均值、中位数或者是其他指定的值。
3. 插值填充
如果数据在某些维度上是有序的，可以使用插值技术来填充缺失值。例如使用线性插值、多项式插值或时间序列插值等方法来估计缺失值。
4. 使用统计方法填充
另一种常见的方法是使用统计量（如平均值、中位数或众数）来填充缺失值。这种方法可以帮助保持数据的整体统计特性。

### 猜拳游戏
   https://www.cnblogs.com/0717GG/p/7084473.html

## 2023

### 数组最大连续子序列和
```java
class Solution {
    public int maxSubArray(int[] nums) {
        int res = nums[0];
        int[] dp = new int[nums.length];
        dp[0] = res;
        for(int i = 1;i < dp.length;i++){
            dp[i] = Math.max(nums[i],dp[i - 1] + nums[i]);
            res = Math.max(dp[i],res);
        }
        return res;
    }
}
```

### 最大公约数
```java
public static int gcd(int m,int n){
    int a = Math.max(m,n);
    int b = Math.min(m,n);
    while (a % b != 0){
        int temp = a % b;
        a = b;
        b = temp;
    }
    return b;
}
```

### 单链表第 k 个节点数据

```java
public int find(ListNode head,int k){
    ListNode node = head;
    if(k <= 0) throw new RuntimeException("k 值异常");
    for(int i = 1;i <= k;i++){
        if (node == null) {
            throw new RuntimeException("第 k 个结点不存在");
        }else if(i == k) {
            return node.val;
        }else {
            node = node.next;
        }
    }
    return node.val;
}
```
### 读取 file.txt
第一问：  
```java
public int readCsv() throws IOException{
    File file = new File("C:\\Users\\Tamako\\Desktop\\file.txt");
    FileReader reader = new FileReader(file);
    BufferedReader bf = new BufferedReader(reader);
    String str = bf.readLine();
    Pattern pattern = Pattern.compile("123");
    Matcher matcher = pattern.matcher(str);
    int count = 0;
    while (matcher.find()){
        count++;
    }
    reader.close();
    bf.close();
    return count;
}
```
第二问：  
```java
public void maxAndMin() throws IOException {
    File file = new File("C:\\Users\\Tamako\\Desktop\\file.txt");
    FileReader reader = new FileReader(file);
    BufferedReader bf = new BufferedReader(reader);
    String str = bf.readLine();
    int min = Integer.MAX_VALUE;
    int max = Integer.MIN_VALUE;
    Pattern pattern = Pattern.compile("[0-9]+"); // 正则为一个或多个
    Matcher matcher = pattern.matcher(str);
    while (matcher.find()){
        int temp = Integer.parseInt(matcher.group()); // String 转为 Integer 再比较
        min = Math.min(min,temp);
        max = Math.max(max,temp);
    }
    System.out.println("最大值：" + max +"\n" + "最小值：" + min);
}
```

### 多线程存取款

```java
class BankAccount {
    private double balance;

    public BankAccount(double initialBalance) {
        this.balance = initialBalance;
    }

    public synchronized void deposit(double amount) {
        balance += amount;
        System.out.println("Deposited: " + amount + " | Current Balance: " + balance);
    }

    public synchronized void withdraw(double amount) {
        if (balance >= amount) {
            balance -= amount;
            System.out.println("Withdrawn: " + amount + " | Current Balance: " + balance);
        } else {
            System.out.println("Insufficient funds!");
        }
    }

    public double getBalance() {
        return balance;
    }
}

class DepositThread extends Thread {
    private BankAccount account;
    private double depositAmount;

    public DepositThread(BankAccount account, double depositAmount) {
        this.account = account;
        this.depositAmount = depositAmount;
    }

    public void run() {
        for (int i = 0; i < 5; i++) {
            account.deposit(depositAmount);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

class WithdrawThread extends Thread {
    private BankAccount account;
    private double withdrawAmount;

    public WithdrawThread(BankAccount account, double withdrawAmount) {
        this.account = account;
        this.withdrawAmount = withdrawAmount;
    }

    public void run() {
        for (int i = 0; i < 3; i++) {
            account.withdraw(withdrawAmount);
            try {
                Thread.sleep(1500);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

public class BankTransactionDemo {
    public static void main(String[] args) {
        BankAccount account = new BankAccount(1000);

        DepositThread depositThread = new DepositThread(account, 200);
        WithdrawThread withdrawThread = new WithdrawThread(account, 300);

        depositThread.start();
        withdrawThread.start();
    }
}

```