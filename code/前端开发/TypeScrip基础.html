<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.66" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://T4mako.github.io/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html"><meta property="og:site_name" content="T4mako"><meta property="og:title" content="TypeScript基础"><meta property="og:description" content="(参考文章)[https://wangdoc.com/typescript/] 最简单的 TypeScript 使用方法，就是使用官网的在线编译页面， TypeScript Playground。 一、TypeScript 语言简介"><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="T4mako"><meta property="article:published_time" content="2023-08-12T00:00:00.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"TypeScript基础","image":[""],"datePublished":"2023-08-12T00:00:00.000Z","dateModified":null,"author":[{"@type":"Person","name":"T4mako","url":"https://github.com/T4mako/T4mako.github.io"}]}</script><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin=""><link href="https://fonts.googleapis.com/css2?family=Zen+Maru+Gothic:wght@500&display=swap" rel="stylesheet"><link rel="alternate" type="application/rss+xml" href="https://T4mako.github.io/rss.xml" title="T4mako RSS Feed"><title>TypeScript基础 | T4mako</title><meta name="description" content="(参考文章)[https://wangdoc.com/typescript/] 最简单的 TypeScript 使用方法，就是使用官网的在线编译页面， TypeScript Playground。 一、TypeScript 语言简介">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d1e1f;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/assets/style-fa26a189.css" as="style"><link rel="stylesheet" href="/assets/style-fa26a189.css">
    <link rel="modulepreload" href="/assets/app-80b25126.js"><link rel="modulepreload" href="/assets/TypeScrip基础.html-a311a698.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper-c27b6911.js"><link rel="modulepreload" href="/assets/TypeScrip基础.html-31e54fbf.js"><link rel="prefetch" href="/assets/index.html-28de6f14.js" as="script"><link rel="prefetch" href="/assets/intro.html-153db12e.js" as="script"><link rel="prefetch" href="/assets/index.html-f5f264d6.js" as="script"><link rel="prefetch" href="/assets/index.html-30a1b7c2.js" as="script"><link rel="prefetch" href="/assets/IDEA、Eclipse快捷键.html-15e3dc66.js" as="script"><link rel="prefetch" href="/assets/JDBC.html-8ec2fd12.js" as="script"><link rel="prefetch" href="/assets/JWT.html-7c0fd9d7.js" as="script"><link rel="prefetch" href="/assets/JavaWeb基础.html-af51d1ad.js" as="script"><link rel="prefetch" href="/assets/Maven基础.html-ad80dbfe.js" as="script"><link rel="prefetch" href="/assets/MyBatis.html-1642006c.js" as="script"><link rel="prefetch" href="/assets/MybatisPlus.html-07f9ea4d.js" as="script"><link rel="prefetch" href="/assets/RabbitMQ.html-5aae586f.js" as="script"><link rel="prefetch" href="/assets/SpringBoot.html-50d035ac.js" as="script"><link rel="prefetch" href="/assets/SpringBoot自动装配原理.html-4ffd3d17.js" as="script"><link rel="prefetch" href="/assets/SpringCloud基础.html-081659a3.js" as="script"><link rel="prefetch" href="/assets/SpringMVC.html-20c731bf.js" as="script"><link rel="prefetch" href="/assets/Spring基础.html-7fdff257.js" as="script"><link rel="prefetch" href="/assets/index.html-3c1bb24e.js" as="script"><link rel="prefetch" href="/assets/python基础语法.html-2b3089cf.js" as="script"><link rel="prefetch" href="/assets/个人博客快速搭建.html-3a92fbe9.js" as="script"><link rel="prefetch" href="/assets/Ajax.html-73e0d2ee.js" as="script"><link rel="prefetch" href="/assets/Axios.html-6a0f7031.js" as="script"><link rel="prefetch" href="/assets/CSS3.html-fbf9bd49.js" as="script"><link rel="prefetch" href="/assets/HTML.html-dba9796c.js" as="script"><link rel="prefetch" href="/assets/Node.js笔记.html-edd6db0d.js" as="script"><link rel="prefetch" href="/assets/Promise.html-aa788430.js" as="script"><link rel="prefetch" href="/assets/Git.html-ef4b5f14.js" as="script"><link rel="prefetch" href="/assets/Markdown语法基础.html-2825f872.js" as="script"><link rel="prefetch" href="/assets/操作系统.html-8bed0f34.js" as="script"><link rel="prefetch" href="/assets/数据结构.html-c75d55d3.js" as="script"><link rel="prefetch" href="/assets/正则表达式.html-8edf6ade.js" as="script"><link rel="prefetch" href="/assets/计算机组成原理.html-2668b30e.js" as="script"><link rel="prefetch" href="/assets/计算机网络.html-52903b9b.js" as="script"><link rel="prefetch" href="/assets/Elasticsearch.html-c9ea7333.js" as="script"><link rel="prefetch" href="/assets/MongoDB.html-d98ba2d3.js" as="script"><link rel="prefetch" href="/assets/MySQL基础.html-9e90fbb2.js" as="script"><link rel="prefetch" href="/assets/Redis.html-07a92502.js" as="script"><link rel="prefetch" href="/assets/Docker.html-6dd1d99a.js" as="script"><link rel="prefetch" href="/assets/GitHub Actions.html-bc1f64fb.js" as="script"><link rel="prefetch" href="/assets/基于centos部署java项目.html-b44ac3d3.js" as="script"><link rel="prefetch" href="/assets/一些插件.html-7333e5f0.js" as="script"><link rel="prefetch" href="/assets/快捷键.html-c14413e6.js" as="script"><link rel="prefetch" href="/assets/CSGO饰品图.html-41566c4f.js" as="script"><link rel="prefetch" href="/assets/基础.html-376a9d53.js" as="script"><link rel="prefetch" href="/assets/快捷键.html-ff145bec.js" as="script"><link rel="prefetch" href="/assets/hlae.html-5be4d809.js" as="script"><link rel="prefetch" href="/assets/settings.html-ed8baefd.js" as="script"><link rel="prefetch" href="/assets/index.html-71b38232.js" as="script"><link rel="prefetch" href="/assets/index.html-648f386b.js" as="script"><link rel="prefetch" href="/assets/职场交流.html-819bdd72.js" as="script"><link rel="prefetch" href="/assets/高频 SQL 50 题（基础版）.html-80e6fa9f.js" as="script"><link rel="prefetch" href="/assets/leetcode_001_两数之和.html-69ef2bd9.js" as="script"><link rel="prefetch" href="/assets/leetcode_002_两数相加.html-11eed37a.js" as="script"><link rel="prefetch" href="/assets/leetcode_003_无重复字符的最长子串.html-69f9efee.js" as="script"><link rel="prefetch" href="/assets/leetcode_004_寻找两个正序数组的中位数.html-55a3161c.js" as="script"><link rel="prefetch" href="/assets/leetcode_005_最长回文子串.html-6ddc857e.js" as="script"><link rel="prefetch" href="/assets/leetcode_006_N 字形变换.html-71857166.js" as="script"><link rel="prefetch" href="/assets/leetcode_007_整数反转.html-ba26512a.js" as="script"><link rel="prefetch" href="/assets/leetcode_008_字符串转换整数 (atoi).html-0aaaed68.js" as="script"><link rel="prefetch" href="/assets/leetcode_009_回文数.html-b6756019.js" as="script"><link rel="prefetch" href="/assets/leetcode_010_正则表达式匹配.html-fcd22626.js" as="script"><link rel="prefetch" href="/assets/leetcode_011_盛最多水的容器.html-a8c48603.js" as="script"><link rel="prefetch" href="/assets/leetcode_012_整数转罗马数字.html-6b38adef.js" as="script"><link rel="prefetch" href="/assets/leetcode_013_罗马数字转整数.html-22c1adfb.js" as="script"><link rel="prefetch" href="/assets/leetcode_014_最长公共前缀.html-c172cec6.js" as="script"><link rel="prefetch" href="/assets/leetcode_015_三数之和.html-875a5ed0.js" as="script"><link rel="prefetch" href="/assets/leetcode_016_最接近的三数之和.html-b931e3c9.js" as="script"><link rel="prefetch" href="/assets/leetcode_017_电话号码的字母组合.html-6d899101.js" as="script"><link rel="prefetch" href="/assets/leetcode_018_四数之和.html-087b71dc.js" as="script"><link rel="prefetch" href="/assets/leetcode_019_删除链表的倒数第 N 个结点.html-8241fe9c.js" as="script"><link rel="prefetch" href="/assets/leetcode_020_有效的括号.html-e07e2181.js" as="script"><link rel="prefetch" href="/assets/leetcode_021_合并两个有序链表.html-3e5fdc85.js" as="script"><link rel="prefetch" href="/assets/leetcode_022_括号生成.html-34027bae.js" as="script"><link rel="prefetch" href="/assets/leetcode_023_合并 K 个升序链表.html-2830aabf.js" as="script"><link rel="prefetch" href="/assets/leetcode_024_两两交换链表中的节点.html-aa44f045.js" as="script"><link rel="prefetch" href="/assets/leetcode_025_K 个一组翻转链表.html-1cb0de2d.js" as="script"><link rel="prefetch" href="/assets/leetcode_026_删除有序数组中的重复项.html-bf359f60.js" as="script"><link rel="prefetch" href="/assets/leetcode_027_移除元素.html-529831e9.js" as="script"><link rel="prefetch" href="/assets/leetcode_028_找出字符串中第一个匹配项的下标.html-dc2e4f17.js" as="script"><link rel="prefetch" href="/assets/leetcode_029_两数相除.html-03436b7a.js" as="script"><link rel="prefetch" href="/assets/leetcode_030_串联所有单词的子串.html-faa41612.js" as="script"><link rel="prefetch" href="/assets/leetcode_031_下一个排列.html-bb066df3.js" as="script"><link rel="prefetch" href="/assets/leetcode_032_最长有效括号.html-dbd4329f.js" as="script"><link rel="prefetch" href="/assets/leetcode_033_搜索旋转排序数组.html-b3f9f227.js" as="script"><link rel="prefetch" href="/assets/leetcode_034_在排序数组中查找元素的第一个和最后一个位置.html-df6d34be.js" as="script"><link rel="prefetch" href="/assets/leetcode_035_搜索插入位置.html-f3871315.js" as="script"><link rel="prefetch" href="/assets/leetcode_036_有效的数独.html-5f2bc80d.js" as="script"><link rel="prefetch" href="/assets/leetcode_038_外观数列.html-6e3a5b1a.js" as="script"><link rel="prefetch" href="/assets/leetcode_039_ 组合总和.html-b0a7cd1a.js" as="script"><link rel="prefetch" href="/assets/leetcode_040_ 组合总和II.html-87cd31b2.js" as="script"><link rel="prefetch" href="/assets/leetcode_041_ 缺失的第一个正数.html-c08437a5.js" as="script"><link rel="prefetch" href="/assets/leetcode_042_接雨水.html-4f929eb5.js" as="script"><link rel="prefetch" href="/assets/leetcode_043_字符串相乘.html-81486896.js" as="script"><link rel="prefetch" href="/assets/leetcode_045_跳跃游戏II.html-a0a07e13.js" as="script"><link rel="prefetch" href="/assets/leetcode_046_全排列.html-e52ef4d0.js" as="script"><link rel="prefetch" href="/assets/leetcode_047_全排列II.html-bc7cb387.js" as="script"><link rel="prefetch" href="/assets/leetcode_048_旋转图像.html-ec0a782c.js" as="script"><link rel="prefetch" href="/assets/leetcode_049_字母异位词分组.html-dc410cab.js" as="script"><link rel="prefetch" href="/assets/leetcode_050_Pow(x_n).html-7e5605de.js" as="script"><link rel="prefetch" href="/assets/leetcode_056_合并区间.html-ebf3a404.js" as="script"><link rel="prefetch" href="/assets/leetcode_058_最后一个单词的长度.html-c74c97db.js" as="script"><link rel="prefetch" href="/assets/leetcode_066_加一.html-12eefde8.js" as="script"><link rel="prefetch" href="/assets/leetcode_067_二进制求和.html-555cfc00.js" as="script"><link rel="prefetch" href="/assets/leetcode_069_x的平方根.html-b20ef54c.js" as="script"><link rel="prefetch" href="/assets/leetcode_070_爬楼梯.html-d52a7e95.js" as="script"><link rel="prefetch" href="/assets/leetcode_094_二叉树的中序遍历.html-8288cdbe.js" as="script"><link rel="prefetch" href="/assets/leetcode_095_不同的二叉搜索树 II.html-47652036.js" as="script"><link rel="prefetch" href="/assets/leetcode_096_不同的二叉搜索树.html-ae75ff17.js" as="script"><link rel="prefetch" href="/assets/leetcode_098_验证二叉搜索树.html-03e5a7b1.js" as="script"><link rel="prefetch" href="/assets/leetcode_1004_最大连续1的个数 III.html-768d05f4.js" as="script"><link rel="prefetch" href="/assets/leetcode_102_二叉树的层序遍历.html-cd49dd33.js" as="script"><link rel="prefetch" href="/assets/leetcode_103_二叉树的锯齿形层序遍历.html-c877409c.js" as="script"><link rel="prefetch" href="/assets/leetcode_104_二叉树的最大深度.html-1b32579f.js" as="script"><link rel="prefetch" href="/assets/leetcode_105_从前序与中序遍历序列构造二叉树.html-d13a65a1.js" as="script"><link rel="prefetch" href="/assets/leetcode_1071_字符串的最大公因子.html-b1393e3f.js" as="script"><link rel="prefetch" href="/assets/leetcode_107_二叉树的层序遍历 II.html-8d1b9daf.js" as="script"><link rel="prefetch" href="/assets/leetcode_113_路径总和II.html-8f74fe65.js" as="script"><link rel="prefetch" href="/assets/leetcode_1207_独一无二的出现次数.html-d74630f4.js" as="script"><link rel="prefetch" href="/assets/leetcode_1431_拥有最多糖果的孩子.html-fce23bd4.js" as="script"><link rel="prefetch" href="/assets/leetcode_144_二叉树的前序遍历.html-2389341a.js" as="script"><link rel="prefetch" href="/assets/leetcode_1456_定长子串中元音的最大数目.html-e8fe792e.js" as="script"><link rel="prefetch" href="/assets/leetcode_145_二叉树的后序遍历.html-70666e63.js" as="script"><link rel="prefetch" href="/assets/leetcode_1493_删掉一个元素以后全为 1 的最长子数组.html-636e2d28.js" as="script"><link rel="prefetch" href="/assets/leetcode_151_反转字符串中的单词.html-aa515e5b.js" as="script"><link rel="prefetch" href="/assets/leetcode_1657_确定两个字符串是否接近.html-621bacc4.js" as="script"><link rel="prefetch" href="/assets/leetcode_1679_K 和数对的最大数目.html-9bf57141.js" as="script"><link rel="prefetch" href="/assets/leetcode_1732_找到最高海拔.html-9484cfaf.js" as="script"><link rel="prefetch" href="/assets/leetcode_1768_交替合并字符串.html-f3554f9a.js" as="script"><link rel="prefetch" href="/assets/leetcode_206_反转链表.html-4f3d4b19.js" as="script"><link rel="prefetch" href="/assets/leetcode_2095_删除链表的中间节点.html-c4197727.js" as="script"><link rel="prefetch" href="/assets/leetcode_2215_找出两数组的不同.html-0195648d.js" as="script"><link rel="prefetch" href="/assets/leetcode_2352_相等行列对.html-17d680a1.js" as="script"><link rel="prefetch" href="/assets/leetcode_2390_从字符串中移除星号.html-b5cd3346.js" as="script"><link rel="prefetch" href="/assets/leetcode_283_移动0.html-38f15644.js" as="script"><link rel="prefetch" href="/assets/leetcode_328_奇偶链表.html-964b1c35.js" as="script"><link rel="prefetch" href="/assets/leetcode_334_递增的三元子序列.html-f8f866fe.js" as="script"><link rel="prefetch" href="/assets/leetcode_345_反转字符串中的元音字母.html-604bba09.js" as="script"><link rel="prefetch" href="/assets/leetcode_374_猜数字大小.html-f095ebea.js" as="script"><link rel="prefetch" href="/assets/leetcode_392_判断子序列.html-b4b71767.js" as="script"><link rel="prefetch" href="/assets/leetcode_394_字符串解码.html-5e161841.js" as="script"><link rel="prefetch" href="/assets/leetcode_443_压缩字符串.html-7157d8d4.js" as="script"><link rel="prefetch" href="/assets/leetcode_605_种花问题.html-96e6493e.js" as="script"><link rel="prefetch" href="/assets/leetcode_643_子数组最大平均数 I.html-c9fd4f7c.js" as="script"><link rel="prefetch" href="/assets/leetcode_649_Dota2 参议院.html-3c7e8517.js" as="script"><link rel="prefetch" href="/assets/leetcode_724_寻找数组的中心下标.html-fe56fd6b.js" as="script"><link rel="prefetch" href="/assets/leetcode_735_行星碰撞.html-79f1a906.js" as="script"><link rel="prefetch" href="/assets/leetcode_933_最近的请求次数.html-3498090e.js" as="script"><link rel="prefetch" href="/assets/leetcode_LCP68_美丽的花束.html-3d61b946.js" as="script"><link rel="prefetch" href="/assets/noob-Rg-better.html-cc14aa26.js" as="script"><link rel="prefetch" href="/assets/noob-Rg.html-987f6735.js" as="script"><link rel="prefetch" href="/assets/1、JavaScript基础语法笔记.html-69b3cd61.js" as="script"><link rel="prefetch" href="/assets/2、WebAPIs笔记.html-a8c50328.js" as="script"><link rel="prefetch" href="/assets/3、JavaScript进阶.html-180a19d8.js" as="script"><link rel="prefetch" href="/assets/index.html-6b5045be.js" as="script"><link rel="prefetch" href="/assets/Arrays类.html-c90d7f5f.js" as="script"><link rel="prefetch" href="/assets/BigInteger和BigDecimal.html-d28a4d76.js" as="script"><link rel="prefetch" href="/assets/Collections类.html-5ecd00ee.js" as="script"><link rel="prefetch" href="/assets/Java比较器.html-85d1ddda.js" as="script"><link rel="prefetch" href="/assets/Math类.html-62ed0ba3.js" as="script"><link rel="prefetch" href="/assets/Object类.html-f6c711b2.js" as="script"><link rel="prefetch" href="/assets/Scanner类.html-147673dd.js" as="script"><link rel="prefetch" href="/assets/Stream API.html-6db257fd.js" as="script"><link rel="prefetch" href="/assets/String相关类.html-7893a48b.js" as="script"><link rel="prefetch" href="/assets/System类.html-c722a5ce.js" as="script"><link rel="prefetch" href="/assets/日期时间API.html-c1e27820.js" as="script"><link rel="prefetch" href="/assets/10、多线程.html-f73d7677.js" as="script"><link rel="prefetch" href="/assets/11、枚举类.html-7fd14df0.js" as="script"><link rel="prefetch" href="/assets/12、注解.html-50944a71.js" as="script"><link rel="prefetch" href="/assets/13、集合.html-1ec3b7cd.js" as="script"><link rel="prefetch" href="/assets/14、泛型.html-0b846833.js" as="script"><link rel="prefetch" href="/assets/15、IO流.html-84be1fe9.js" as="script"><link rel="prefetch" href="/assets/16、网络编程.html-d4102567.js" as="script"><link rel="prefetch" href="/assets/17、反射.html-93d319e4.js" as="script"><link rel="prefetch" href="/assets/18、新特性.html-ef7a4719.js" as="script"><link rel="prefetch" href="/assets/1、注释与命名规范.html-4e58ea13.js" as="script"><link rel="prefetch" href="/assets/2、数据类型.html-c9187c54.js" as="script"><link rel="prefetch" href="/assets/3、运算符.html-92ca5dbf.js" as="script"><link rel="prefetch" href="/assets/4、程序流程控制.html-71240d39.js" as="script"><link rel="prefetch" href="/assets/5、数组.html-7fcc1d9e.js" as="script"><link rel="prefetch" href="/assets/6、面向对象.html-02ef158c.js" as="script"><link rel="prefetch" href="/assets/7、单元测试Junit.html-6c06e896.js" as="script"><link rel="prefetch" href="/assets/8、包装类.html-04f580e4.js" as="script"><link rel="prefetch" href="/assets/9、异常处理.html-37fdebdf.js" as="script"><link rel="prefetch" href="/assets/Vue笔记1-核心.html-e989c925.js" as="script"><link rel="prefetch" href="/assets/Vue笔记2-组件.html-8621d7cf.js" as="script"><link rel="prefetch" href="/assets/Vue笔记3-脚手架.html-de68fd83.js" as="script"><link rel="prefetch" href="/assets/Vue笔记4-Vue中的ajax.html-df24fe68.js" as="script"><link rel="prefetch" href="/assets/Vue笔记5-插槽.html-3155ce14.js" as="script"><link rel="prefetch" href="/assets/Vue笔记6-vuex.html-90ee75fa.js" as="script"><link rel="prefetch" href="/assets/Vue笔记7-路由.html-9023e075.js" as="script"><link rel="prefetch" href="/assets/Vue笔记8-element-ui.html-a3b54a99.js" as="script"><link rel="prefetch" href="/assets/Vue3笔记.html-54dfd747.js" as="script"><link rel="prefetch" href="/assets/markdown扩展.html-1b4673b3.js" as="script"><link rel="prefetch" href="/assets/404.html-cc91ab3d.js" as="script"><link rel="prefetch" href="/assets/index.html-a6b9d739.js" as="script"><link rel="prefetch" href="/assets/index.html-673bc96c.js" as="script"><link rel="prefetch" href="/assets/index.html-34f56070.js" as="script"><link rel="prefetch" href="/assets/index.html-a7a29c4c.js" as="script"><link rel="prefetch" href="/assets/index.html-194b0620.js" as="script"><link rel="prefetch" href="/assets/index.html-b698eee0.js" as="script"><link rel="prefetch" href="/assets/index.html-a899c6cf.js" as="script"><link rel="prefetch" href="/assets/index.html-e2494c9f.js" as="script"><link rel="prefetch" href="/assets/index.html-61c0a09c.js" as="script"><link rel="prefetch" href="/assets/index.html-be2636ab.js" as="script"><link rel="prefetch" href="/assets/index.html-2f703168.js" as="script"><link rel="prefetch" href="/assets/index.html-49eef8d8.js" as="script"><link rel="prefetch" href="/assets/index.html-300a7381.js" as="script"><link rel="prefetch" href="/assets/index.html-2fa96ec7.js" as="script"><link rel="prefetch" href="/assets/index.html-1ba1d180.js" as="script"><link rel="prefetch" href="/assets/index.html-6d51d871.js" as="script"><link rel="prefetch" href="/assets/index.html-d782a376.js" as="script"><link rel="prefetch" href="/assets/index.html-9e55ee4d.js" as="script"><link rel="prefetch" href="/assets/index.html-106d954c.js" as="script"><link rel="prefetch" href="/assets/index.html-5fbc2a0d.js" as="script"><link rel="prefetch" href="/assets/index.html-ee02ddf0.js" as="script"><link rel="prefetch" href="/assets/index.html-20b834a5.js" as="script"><link rel="prefetch" href="/assets/index.html-3a4d6e36.js" as="script"><link rel="prefetch" href="/assets/index.html-139f2f06.js" as="script"><link rel="prefetch" href="/assets/index.html-a935f094.js" as="script"><link rel="prefetch" href="/assets/index.html-e92ce08c.js" as="script"><link rel="prefetch" href="/assets/index.html-63bc6b2b.js" as="script"><link rel="prefetch" href="/assets/index.html-94957f61.js" as="script"><link rel="prefetch" href="/assets/index.html-91bcd141.js" as="script"><link rel="prefetch" href="/assets/index.html-e5933818.js" as="script"><link rel="prefetch" href="/assets/index.html-e438d120.js" as="script"><link rel="prefetch" href="/assets/index.html-9c7c91b2.js" as="script"><link rel="prefetch" href="/assets/index.html-abd11527.js" as="script"><link rel="prefetch" href="/assets/index.html-e9a4a4e1.js" as="script"><link rel="prefetch" href="/assets/index.html-ec18a7df.js" as="script"><link rel="prefetch" href="/assets/index.html-d6c5a433.js" as="script"><link rel="prefetch" href="/assets/index.html-13f98761.js" as="script"><link rel="prefetch" href="/assets/index.html-d3624e38.js" as="script"><link rel="prefetch" href="/assets/index.html-41fd6d63.js" as="script"><link rel="prefetch" href="/assets/index.html-0cce8e2d.js" as="script"><link rel="prefetch" href="/assets/index.html-bfb66f86.js" as="script"><link rel="prefetch" href="/assets/index.html-0e85c606.js" as="script"><link rel="prefetch" href="/assets/index.html-5c2c76d5.js" as="script"><link rel="prefetch" href="/assets/index.html-faa3c911.js" as="script"><link rel="prefetch" href="/assets/index.html-b7b8c4b6.js" as="script"><link rel="prefetch" href="/assets/index.html-f5020150.js" as="script"><link rel="prefetch" href="/assets/index.html-a3550230.js" as="script"><link rel="prefetch" href="/assets/index.html-ff6eb04f.js" as="script"><link rel="prefetch" href="/assets/index.html-c5715831.js" as="script"><link rel="prefetch" href="/assets/index.html-8af2a3d1.js" as="script"><link rel="prefetch" href="/assets/index.html-9d2fd3be.js" as="script"><link rel="prefetch" href="/assets/index.html-cc614db6.js" as="script"><link rel="prefetch" href="/assets/index.html-c424e42c.js" as="script"><link rel="prefetch" href="/assets/index.html-b1a752fe.js" as="script"><link rel="prefetch" href="/assets/index.html-cd47dbea.js" as="script"><link rel="prefetch" href="/assets/index.html-ee726727.js" as="script"><link rel="prefetch" href="/assets/index.html-4ff744ba.js" as="script"><link rel="prefetch" href="/assets/index.html-7f168d0f.js" as="script"><link rel="prefetch" href="/assets/index.html-56de2f95.js" as="script"><link rel="prefetch" href="/assets/index.html-f7cb97d3.js" as="script"><link rel="prefetch" href="/assets/index.html-c546e8a1.js" as="script"><link rel="prefetch" href="/assets/index.html-0009964a.js" as="script"><link rel="prefetch" href="/assets/index.html-00b637a2.js" as="script"><link rel="prefetch" href="/assets/index.html-fb5f6e90.js" as="script"><link rel="prefetch" href="/assets/index.html-d462cdeb.js" as="script"><link rel="prefetch" href="/assets/index.html-6b698fb1.js" as="script"><link rel="prefetch" href="/assets/index.html-acbfbf53.js" as="script"><link rel="prefetch" href="/assets/index.html-905f1804.js" as="script"><link rel="prefetch" href="/assets/index.html-16d7d340.js" as="script"><link rel="prefetch" href="/assets/index.html-7e1863fb.js" as="script"><link rel="prefetch" href="/assets/index.html-ccaf9ee9.js" as="script"><link rel="prefetch" href="/assets/index.html-1c66cf59.js" as="script"><link rel="prefetch" href="/assets/index.html-8968a188.js" as="script"><link rel="prefetch" href="/assets/index.html-46271911.js" as="script"><link rel="prefetch" href="/assets/index.html-c8b179d7.js" as="script"><link rel="prefetch" href="/assets/index.html-64ee687b.js" as="script"><link rel="prefetch" href="/assets/index.html-80fe2383.js" as="script"><link rel="prefetch" href="/assets/index.html-f310c092.js" as="script"><link rel="prefetch" href="/assets/index.html-fea946c3.js" as="script"><link rel="prefetch" href="/assets/index.html-14c05c19.js" as="script"><link rel="prefetch" href="/assets/index.html-9c6eba41.js" as="script"><link rel="prefetch" href="/assets/index.html-f17f8ab5.js" as="script"><link rel="prefetch" href="/assets/index.html-1a5be529.js" as="script"><link rel="prefetch" href="/assets/index.html-0e767346.js" as="script"><link rel="prefetch" href="/assets/index.html-3ca31bd8.js" as="script"><link rel="prefetch" href="/assets/index.html-b133f8c8.js" as="script"><link rel="prefetch" href="/assets/index.html-e22bc441.js" as="script"><link rel="prefetch" href="/assets/index.html-7195b3a2.js" as="script"><link rel="prefetch" href="/assets/index.html-1beacc22.js" as="script"><link rel="prefetch" href="/assets/index.html-88e5e4ce.js" as="script"><link rel="prefetch" href="/assets/index.html-210be80e.js" as="script"><link rel="prefetch" href="/assets/index.html-38a7a2af.js" as="script"><link rel="prefetch" href="/assets/index.html-4941c0fe.js" as="script"><link rel="prefetch" href="/assets/index.html-03c9f91d.js" as="script"><link rel="prefetch" href="/assets/index.html-0b4b9ae3.js" as="script"><link rel="prefetch" href="/assets/index.html-229119d0.js" as="script"><link rel="prefetch" href="/assets/index.html-bc2fb4cf.js" as="script"><link rel="prefetch" href="/assets/index.html-842d27e2.js" as="script"><link rel="prefetch" href="/assets/index.html-8208559f.js" as="script"><link rel="prefetch" href="/assets/index.html-a3c429a2.js" as="script"><link rel="prefetch" href="/assets/index.html-e28d3b12.js" as="script"><link rel="prefetch" href="/assets/index.html-e18dcbc2.js" as="script"><link rel="prefetch" href="/assets/index.html-c02de52a.js" as="script"><link rel="prefetch" href="/assets/index.html-375eef32.js" as="script"><link rel="prefetch" href="/assets/index.html-3b8fb7db.js" as="script"><link rel="prefetch" href="/assets/index.html-2b8d0809.js" as="script"><link rel="prefetch" href="/assets/index.html-186dd8fe.js" as="script"><link rel="prefetch" href="/assets/index.html-62cabbed.js" as="script"><link rel="prefetch" href="/assets/index.html-821b7914.js" as="script"><link rel="prefetch" href="/assets/intro.html-2502ea4b.js" as="script"><link rel="prefetch" href="/assets/index.html-49deb968.js" as="script"><link rel="prefetch" href="/assets/index.html-03670160.js" as="script"><link rel="prefetch" href="/assets/IDEA、Eclipse快捷键.html-7c132c86.js" as="script"><link rel="prefetch" href="/assets/JDBC.html-9a005861.js" as="script"><link rel="prefetch" href="/assets/JWT.html-b0cb9d8e.js" as="script"><link rel="prefetch" href="/assets/JavaWeb基础.html-b8de5a4c.js" as="script"><link rel="prefetch" href="/assets/Maven基础.html-9466547e.js" as="script"><link rel="prefetch" href="/assets/MyBatis.html-1f4df57a.js" as="script"><link rel="prefetch" href="/assets/MybatisPlus.html-3a5174ed.js" as="script"><link rel="prefetch" href="/assets/RabbitMQ.html-2f07d392.js" as="script"><link rel="prefetch" href="/assets/SpringBoot.html-8c98ef27.js" as="script"><link rel="prefetch" href="/assets/SpringBoot自动装配原理.html-8d524506.js" as="script"><link rel="prefetch" href="/assets/SpringCloud基础.html-5b8d6d4e.js" as="script"><link rel="prefetch" href="/assets/SpringMVC.html-f83c8e24.js" as="script"><link rel="prefetch" href="/assets/Spring基础.html-a97e819b.js" as="script"><link rel="prefetch" href="/assets/index.html-50d18dcf.js" as="script"><link rel="prefetch" href="/assets/python基础语法.html-acb96b0b.js" as="script"><link rel="prefetch" href="/assets/个人博客快速搭建.html-b31c6452.js" as="script"><link rel="prefetch" href="/assets/Ajax.html-8cb4d08d.js" as="script"><link rel="prefetch" href="/assets/Axios.html-da0bac15.js" as="script"><link rel="prefetch" href="/assets/CSS3.html-6499f8cc.js" as="script"><link rel="prefetch" href="/assets/HTML.html-cda6e787.js" as="script"><link rel="prefetch" href="/assets/Node.js笔记.html-748f9314.js" as="script"><link rel="prefetch" href="/assets/Promise.html-a1eea88d.js" as="script"><link rel="prefetch" href="/assets/Git.html-a9f8c45b.js" as="script"><link rel="prefetch" href="/assets/Markdown语法基础.html-bc03af6f.js" as="script"><link rel="prefetch" href="/assets/操作系统.html-621bdc68.js" as="script"><link rel="prefetch" href="/assets/数据结构.html-53b40d4b.js" as="script"><link rel="prefetch" href="/assets/正则表达式.html-7eb673a9.js" as="script"><link rel="prefetch" href="/assets/计算机组成原理.html-18d69916.js" as="script"><link rel="prefetch" href="/assets/计算机网络.html-a0b45169.js" as="script"><link rel="prefetch" href="/assets/Elasticsearch.html-cde8ce93.js" as="script"><link rel="prefetch" href="/assets/MongoDB.html-fe8991c8.js" as="script"><link rel="prefetch" href="/assets/MySQL基础.html-5746715c.js" as="script"><link rel="prefetch" href="/assets/Redis.html-fe09f1de.js" as="script"><link rel="prefetch" href="/assets/Docker.html-2eca3309.js" as="script"><link rel="prefetch" href="/assets/GitHub Actions.html-8d5908d5.js" as="script"><link rel="prefetch" href="/assets/基于centos部署java项目.html-41e47d3a.js" as="script"><link rel="prefetch" href="/assets/一些插件.html-2152a886.js" as="script"><link rel="prefetch" href="/assets/快捷键.html-149fdb66.js" as="script"><link rel="prefetch" href="/assets/CSGO饰品图.html-016e28a9.js" as="script"><link rel="prefetch" href="/assets/基础.html-92fde3f0.js" as="script"><link rel="prefetch" href="/assets/快捷键.html-f27de485.js" as="script"><link rel="prefetch" href="/assets/hlae.html-fef4530a.js" as="script"><link rel="prefetch" href="/assets/settings.html-53c6e716.js" as="script"><link rel="prefetch" href="/assets/index.html-0cf3a5cb.js" as="script"><link rel="prefetch" href="/assets/index.html-a64c2b71.js" as="script"><link rel="prefetch" href="/assets/职场交流.html-312cf45c.js" as="script"><link rel="prefetch" href="/assets/高频 SQL 50 题（基础版）.html-373e67c3.js" as="script"><link rel="prefetch" href="/assets/leetcode_001_两数之和.html-8059ce0d.js" as="script"><link rel="prefetch" href="/assets/leetcode_002_两数相加.html-40ab5f3a.js" as="script"><link rel="prefetch" href="/assets/leetcode_003_无重复字符的最长子串.html-3f977430.js" as="script"><link rel="prefetch" href="/assets/leetcode_004_寻找两个正序数组的中位数.html-99d86c54.js" as="script"><link rel="prefetch" href="/assets/leetcode_005_最长回文子串.html-1886d283.js" as="script"><link rel="prefetch" href="/assets/leetcode_006_N 字形变换.html-f1686bbd.js" as="script"><link rel="prefetch" href="/assets/leetcode_007_整数反转.html-3154d623.js" as="script"><link rel="prefetch" href="/assets/leetcode_008_字符串转换整数 (atoi).html-66afbed1.js" as="script"><link rel="prefetch" href="/assets/leetcode_009_回文数.html-04cd9447.js" as="script"><link rel="prefetch" href="/assets/leetcode_010_正则表达式匹配.html-d57e3770.js" as="script"><link rel="prefetch" href="/assets/leetcode_011_盛最多水的容器.html-df02b669.js" as="script"><link rel="prefetch" href="/assets/leetcode_012_整数转罗马数字.html-91c4e8d2.js" as="script"><link rel="prefetch" href="/assets/leetcode_013_罗马数字转整数.html-a8b61f6a.js" as="script"><link rel="prefetch" href="/assets/leetcode_014_最长公共前缀.html-8ed5d89e.js" as="script"><link rel="prefetch" href="/assets/leetcode_015_三数之和.html-a813c62c.js" as="script"><link rel="prefetch" href="/assets/leetcode_016_最接近的三数之和.html-18c264cc.js" as="script"><link rel="prefetch" href="/assets/leetcode_017_电话号码的字母组合.html-aa27608c.js" as="script"><link rel="prefetch" href="/assets/leetcode_018_四数之和.html-a4c6c1c4.js" as="script"><link rel="prefetch" href="/assets/leetcode_019_删除链表的倒数第 N 个结点.html-0c49359f.js" as="script"><link rel="prefetch" href="/assets/leetcode_020_有效的括号.html-ba4bae5a.js" as="script"><link rel="prefetch" href="/assets/leetcode_021_合并两个有序链表.html-26f02983.js" as="script"><link rel="prefetch" href="/assets/leetcode_022_括号生成.html-1d30618c.js" as="script"><link rel="prefetch" href="/assets/leetcode_023_合并 K 个升序链表.html-f845087e.js" as="script"><link rel="prefetch" href="/assets/leetcode_024_两两交换链表中的节点.html-618ceef7.js" as="script"><link rel="prefetch" href="/assets/leetcode_025_K 个一组翻转链表.html-64437b45.js" as="script"><link rel="prefetch" href="/assets/leetcode_026_删除有序数组中的重复项.html-9110d658.js" as="script"><link rel="prefetch" href="/assets/leetcode_027_移除元素.html-2e4faabf.js" as="script"><link rel="prefetch" href="/assets/leetcode_028_找出字符串中第一个匹配项的下标.html-23cf9652.js" as="script"><link rel="prefetch" href="/assets/leetcode_029_两数相除.html-12da8f64.js" as="script"><link rel="prefetch" href="/assets/leetcode_030_串联所有单词的子串.html-1d179347.js" as="script"><link rel="prefetch" href="/assets/leetcode_031_下一个排列.html-fb8811e9.js" as="script"><link rel="prefetch" href="/assets/leetcode_032_最长有效括号.html-631a95a3.js" as="script"><link rel="prefetch" href="/assets/leetcode_033_搜索旋转排序数组.html-0948bc72.js" as="script"><link rel="prefetch" href="/assets/leetcode_034_在排序数组中查找元素的第一个和最后一个位置.html-59b1369b.js" as="script"><link rel="prefetch" href="/assets/leetcode_035_搜索插入位置.html-c9711255.js" as="script"><link rel="prefetch" href="/assets/leetcode_036_有效的数独.html-1dea8d9c.js" as="script"><link rel="prefetch" href="/assets/leetcode_038_外观数列.html-482cfcf8.js" as="script"><link rel="prefetch" href="/assets/leetcode_039_ 组合总和.html-cf4a0890.js" as="script"><link rel="prefetch" href="/assets/leetcode_040_ 组合总和II.html-e5230f2d.js" as="script"><link rel="prefetch" href="/assets/leetcode_041_ 缺失的第一个正数.html-8d6f2e62.js" as="script"><link rel="prefetch" href="/assets/leetcode_042_接雨水.html-c78c75ed.js" as="script"><link rel="prefetch" href="/assets/leetcode_043_字符串相乘.html-b17069aa.js" as="script"><link rel="prefetch" href="/assets/leetcode_045_跳跃游戏II.html-31127672.js" as="script"><link rel="prefetch" href="/assets/leetcode_046_全排列.html-7c381f01.js" as="script"><link rel="prefetch" href="/assets/leetcode_047_全排列II.html-f0144db3.js" as="script"><link rel="prefetch" href="/assets/leetcode_048_旋转图像.html-1032887c.js" as="script"><link rel="prefetch" href="/assets/leetcode_049_字母异位词分组.html-154f97f9.js" as="script"><link rel="prefetch" href="/assets/leetcode_050_Pow(x_n).html-25e6f45c.js" as="script"><link rel="prefetch" href="/assets/leetcode_056_合并区间.html-62aee730.js" as="script"><link rel="prefetch" href="/assets/leetcode_058_最后一个单词的长度.html-8146d046.js" as="script"><link rel="prefetch" href="/assets/leetcode_066_加一.html-cf05a41f.js" as="script"><link rel="prefetch" href="/assets/leetcode_067_二进制求和.html-21fc8c97.js" as="script"><link rel="prefetch" href="/assets/leetcode_069_x的平方根.html-9be54650.js" as="script"><link rel="prefetch" href="/assets/leetcode_070_爬楼梯.html-ee46eda0.js" as="script"><link rel="prefetch" href="/assets/leetcode_094_二叉树的中序遍历.html-176c42b6.js" as="script"><link rel="prefetch" href="/assets/leetcode_095_不同的二叉搜索树 II.html-ffaae1dd.js" as="script"><link rel="prefetch" href="/assets/leetcode_096_不同的二叉搜索树.html-7aa33d66.js" as="script"><link rel="prefetch" href="/assets/leetcode_098_验证二叉搜索树.html-ccd7ce3d.js" as="script"><link rel="prefetch" href="/assets/leetcode_1004_最大连续1的个数 III.html-785f0431.js" as="script"><link rel="prefetch" href="/assets/leetcode_102_二叉树的层序遍历.html-12c94ed5.js" as="script"><link rel="prefetch" href="/assets/leetcode_103_二叉树的锯齿形层序遍历.html-f80a3c35.js" as="script"><link rel="prefetch" href="/assets/leetcode_104_二叉树的最大深度.html-3f170224.js" as="script"><link rel="prefetch" href="/assets/leetcode_105_从前序与中序遍历序列构造二叉树.html-e8c1e78b.js" as="script"><link rel="prefetch" href="/assets/leetcode_1071_字符串的最大公因子.html-4c7a4bf1.js" as="script"><link rel="prefetch" href="/assets/leetcode_107_二叉树的层序遍历 II.html-7c629bba.js" as="script"><link rel="prefetch" href="/assets/leetcode_113_路径总和II.html-3e489b9c.js" as="script"><link rel="prefetch" href="/assets/leetcode_1207_独一无二的出现次数.html-a80a1384.js" as="script"><link rel="prefetch" href="/assets/leetcode_1431_拥有最多糖果的孩子.html-cda852fb.js" as="script"><link rel="prefetch" href="/assets/leetcode_144_二叉树的前序遍历.html-e56574d8.js" as="script"><link rel="prefetch" href="/assets/leetcode_1456_定长子串中元音的最大数目.html-3f9a3bac.js" as="script"><link rel="prefetch" href="/assets/leetcode_145_二叉树的后序遍历.html-d7fafc72.js" as="script"><link rel="prefetch" href="/assets/leetcode_1493_删掉一个元素以后全为 1 的最长子数组.html-e7c39009.js" as="script"><link rel="prefetch" href="/assets/leetcode_151_反转字符串中的单词.html-4ff57bd7.js" as="script"><link rel="prefetch" href="/assets/leetcode_1657_确定两个字符串是否接近.html-cfca7322.js" as="script"><link rel="prefetch" href="/assets/leetcode_1679_K 和数对的最大数目.html-0949ee84.js" as="script"><link rel="prefetch" href="/assets/leetcode_1732_找到最高海拔.html-77cf14c4.js" as="script"><link rel="prefetch" href="/assets/leetcode_1768_交替合并字符串.html-0a69befe.js" as="script"><link rel="prefetch" href="/assets/leetcode_206_反转链表.html-73231869.js" as="script"><link rel="prefetch" href="/assets/leetcode_2095_删除链表的中间节点.html-07d2fdf1.js" as="script"><link rel="prefetch" href="/assets/leetcode_2215_找出两数组的不同.html-929c2410.js" as="script"><link rel="prefetch" href="/assets/leetcode_2352_相等行列对.html-4e3414fb.js" as="script"><link rel="prefetch" href="/assets/leetcode_2390_从字符串中移除星号.html-d38118ba.js" as="script"><link rel="prefetch" href="/assets/leetcode_283_移动0.html-35bf602d.js" as="script"><link rel="prefetch" href="/assets/leetcode_328_奇偶链表.html-c421bbfb.js" as="script"><link rel="prefetch" href="/assets/leetcode_334_递增的三元子序列.html-735374ba.js" as="script"><link rel="prefetch" href="/assets/leetcode_345_反转字符串中的元音字母.html-e4281f82.js" as="script"><link rel="prefetch" href="/assets/leetcode_374_猜数字大小.html-92c03200.js" as="script"><link rel="prefetch" href="/assets/leetcode_392_判断子序列.html-fa9ebbfa.js" as="script"><link rel="prefetch" href="/assets/leetcode_394_字符串解码.html-d542a7af.js" as="script"><link rel="prefetch" href="/assets/leetcode_443_压缩字符串.html-dc16ba2f.js" as="script"><link rel="prefetch" href="/assets/leetcode_605_种花问题.html-2b014c94.js" as="script"><link rel="prefetch" href="/assets/leetcode_643_子数组最大平均数 I.html-36ba5b67.js" as="script"><link rel="prefetch" href="/assets/leetcode_649_Dota2 参议院.html-77e05c67.js" as="script"><link rel="prefetch" href="/assets/leetcode_724_寻找数组的中心下标.html-6e4eba84.js" as="script"><link rel="prefetch" href="/assets/leetcode_735_行星碰撞.html-d9a9047a.js" as="script"><link rel="prefetch" href="/assets/leetcode_933_最近的请求次数.html-1792d85e.js" as="script"><link rel="prefetch" href="/assets/leetcode_LCP68_美丽的花束.html-990b4642.js" as="script"><link rel="prefetch" href="/assets/noob-Rg-better.html-0d03e1ba.js" as="script"><link rel="prefetch" href="/assets/noob-Rg.html-4de32124.js" as="script"><link rel="prefetch" href="/assets/1、JavaScript基础语法笔记.html-bc62db29.js" as="script"><link rel="prefetch" href="/assets/2、WebAPIs笔记.html-e73a57bf.js" as="script"><link rel="prefetch" href="/assets/3、JavaScript进阶.html-8fc8bcc7.js" as="script"><link rel="prefetch" href="/assets/index.html-9505df8f.js" as="script"><link rel="prefetch" href="/assets/Arrays类.html-098a3e17.js" as="script"><link rel="prefetch" href="/assets/BigInteger和BigDecimal.html-4047e8ed.js" as="script"><link rel="prefetch" href="/assets/Collections类.html-3dd1c5f1.js" as="script"><link rel="prefetch" href="/assets/Java比较器.html-03d0a754.js" as="script"><link rel="prefetch" href="/assets/Math类.html-3ca8843b.js" as="script"><link rel="prefetch" href="/assets/Object类.html-2fe5b69d.js" as="script"><link rel="prefetch" href="/assets/Scanner类.html-18ae97ec.js" as="script"><link rel="prefetch" href="/assets/Stream API.html-b3e33b4b.js" as="script"><link rel="prefetch" href="/assets/String相关类.html-5fd211fe.js" as="script"><link rel="prefetch" href="/assets/System类.html-b058cc4d.js" as="script"><link rel="prefetch" href="/assets/日期时间API.html-04c42bad.js" as="script"><link rel="prefetch" href="/assets/10、多线程.html-c2941b58.js" as="script"><link rel="prefetch" href="/assets/11、枚举类.html-86397353.js" as="script"><link rel="prefetch" href="/assets/12、注解.html-f4d112a2.js" as="script"><link rel="prefetch" href="/assets/13、集合.html-4e63876c.js" as="script"><link rel="prefetch" href="/assets/14、泛型.html-7c1f7ea6.js" as="script"><link rel="prefetch" href="/assets/15、IO流.html-2b24b9ef.js" as="script"><link rel="prefetch" href="/assets/16、网络编程.html-9304eed2.js" as="script"><link rel="prefetch" href="/assets/17、反射.html-1c06f39e.js" as="script"><link rel="prefetch" href="/assets/18、新特性.html-ca02b56f.js" as="script"><link rel="prefetch" href="/assets/1、注释与命名规范.html-82b26902.js" as="script"><link rel="prefetch" href="/assets/2、数据类型.html-624e34fe.js" as="script"><link rel="prefetch" href="/assets/3、运算符.html-6c0e19bd.js" as="script"><link rel="prefetch" href="/assets/4、程序流程控制.html-356aa2bd.js" as="script"><link rel="prefetch" href="/assets/5、数组.html-cef8ea30.js" as="script"><link rel="prefetch" href="/assets/6、面向对象.html-55a1ea4d.js" as="script"><link rel="prefetch" href="/assets/7、单元测试Junit.html-7a9ce017.js" as="script"><link rel="prefetch" href="/assets/8、包装类.html-cb26dee5.js" as="script"><link rel="prefetch" href="/assets/9、异常处理.html-8238923a.js" as="script"><link rel="prefetch" href="/assets/Vue笔记1-核心.html-9b9fbd37.js" as="script"><link rel="prefetch" href="/assets/Vue笔记2-组件.html-05a919de.js" as="script"><link rel="prefetch" href="/assets/Vue笔记3-脚手架.html-cc4f107c.js" as="script"><link rel="prefetch" href="/assets/Vue笔记4-Vue中的ajax.html-be039659.js" as="script"><link rel="prefetch" href="/assets/Vue笔记5-插槽.html-5287c74e.js" as="script"><link rel="prefetch" href="/assets/Vue笔记6-vuex.html-b4c6aed8.js" as="script"><link rel="prefetch" href="/assets/Vue笔记7-路由.html-4f892b43.js" as="script"><link rel="prefetch" href="/assets/Vue笔记8-element-ui.html-c3a4c636.js" as="script"><link rel="prefetch" href="/assets/Vue3笔记.html-c4cad984.js" as="script"><link rel="prefetch" href="/assets/markdown扩展.html-c51c0c8e.js" as="script"><link rel="prefetch" href="/assets/404.html-777ca5e6.js" as="script"><link rel="prefetch" href="/assets/index.html-8e1e7ea9.js" as="script"><link rel="prefetch" href="/assets/index.html-ab9d159d.js" as="script"><link rel="prefetch" href="/assets/index.html-486b4988.js" as="script"><link rel="prefetch" href="/assets/index.html-771a338f.js" as="script"><link rel="prefetch" href="/assets/index.html-825d5149.js" as="script"><link rel="prefetch" href="/assets/index.html-f6c1a2c0.js" as="script"><link rel="prefetch" href="/assets/index.html-f38fb6bc.js" as="script"><link rel="prefetch" href="/assets/index.html-e2701baf.js" as="script"><link rel="prefetch" href="/assets/index.html-7f8d8130.js" as="script"><link rel="prefetch" href="/assets/index.html-ef68ae00.js" as="script"><link rel="prefetch" href="/assets/index.html-2cdc7860.js" as="script"><link rel="prefetch" href="/assets/index.html-f66360e1.js" as="script"><link rel="prefetch" href="/assets/index.html-2d4a7840.js" as="script"><link rel="prefetch" href="/assets/index.html-93f197a8.js" as="script"><link rel="prefetch" href="/assets/index.html-8b030fbc.js" as="script"><link rel="prefetch" href="/assets/index.html-ec7739f6.js" as="script"><link rel="prefetch" href="/assets/index.html-5453fb29.js" as="script"><link rel="prefetch" href="/assets/index.html-55589962.js" as="script"><link rel="prefetch" href="/assets/index.html-cea89b82.js" as="script"><link rel="prefetch" href="/assets/index.html-2951a07c.js" as="script"><link rel="prefetch" href="/assets/index.html-b98f2f61.js" as="script"><link rel="prefetch" href="/assets/index.html-ae96119a.js" as="script"><link rel="prefetch" href="/assets/index.html-d31cacb1.js" as="script"><link rel="prefetch" href="/assets/index.html-6db60edc.js" as="script"><link rel="prefetch" href="/assets/index.html-28217fda.js" as="script"><link rel="prefetch" href="/assets/index.html-0d20779b.js" as="script"><link rel="prefetch" href="/assets/index.html-f624f3a6.js" as="script"><link rel="prefetch" href="/assets/index.html-02aba61f.js" as="script"><link rel="prefetch" href="/assets/index.html-534751bf.js" as="script"><link rel="prefetch" href="/assets/index.html-0eda6eda.js" as="script"><link rel="prefetch" href="/assets/index.html-3110a049.js" as="script"><link rel="prefetch" href="/assets/index.html-3fde793f.js" as="script"><link rel="prefetch" href="/assets/index.html-fd39f7af.js" as="script"><link rel="prefetch" href="/assets/index.html-8bfe4f41.js" as="script"><link rel="prefetch" href="/assets/index.html-18cd691d.js" as="script"><link rel="prefetch" href="/assets/index.html-b19c78a0.js" as="script"><link rel="prefetch" href="/assets/index.html-6a3726b8.js" as="script"><link rel="prefetch" href="/assets/index.html-9cf6b30f.js" as="script"><link rel="prefetch" href="/assets/index.html-fd978a3a.js" as="script"><link rel="prefetch" href="/assets/index.html-7489220d.js" as="script"><link rel="prefetch" href="/assets/index.html-3eaf365a.js" as="script"><link rel="prefetch" href="/assets/index.html-dae91973.js" as="script"><link rel="prefetch" href="/assets/index.html-29adec90.js" as="script"><link rel="prefetch" href="/assets/index.html-09017d89.js" as="script"><link rel="prefetch" href="/assets/index.html-d3ac6bc6.js" as="script"><link rel="prefetch" href="/assets/index.html-ebb014cb.js" as="script"><link rel="prefetch" href="/assets/index.html-4189ab58.js" as="script"><link rel="prefetch" href="/assets/index.html-8026452b.js" as="script"><link rel="prefetch" href="/assets/index.html-8bd8569f.js" as="script"><link rel="prefetch" href="/assets/index.html-48510bed.js" as="script"><link rel="prefetch" href="/assets/index.html-e4b05ff4.js" as="script"><link rel="prefetch" href="/assets/index.html-d3be3294.js" as="script"><link rel="prefetch" href="/assets/index.html-d6ee82f0.js" as="script"><link rel="prefetch" href="/assets/index.html-e30126e0.js" as="script"><link rel="prefetch" href="/assets/index.html-d9494fe5.js" as="script"><link rel="prefetch" href="/assets/index.html-555729eb.js" as="script"><link rel="prefetch" href="/assets/index.html-c7eb9b83.js" as="script"><link rel="prefetch" href="/assets/index.html-73ee8829.js" as="script"><link rel="prefetch" href="/assets/index.html-72610226.js" as="script"><link rel="prefetch" href="/assets/index.html-5eec6fa3.js" as="script"><link rel="prefetch" href="/assets/index.html-43da773a.js" as="script"><link rel="prefetch" href="/assets/index.html-9470ac51.js" as="script"><link rel="prefetch" href="/assets/index.html-a955dc6d.js" as="script"><link rel="prefetch" href="/assets/index.html-d93d9df3.js" as="script"><link rel="prefetch" href="/assets/index.html-73ca3c44.js" as="script"><link rel="prefetch" href="/assets/index.html-69d209f1.js" as="script"><link rel="prefetch" href="/assets/index.html-c209865e.js" as="script"><link rel="prefetch" href="/assets/index.html-320da8e5.js" as="script"><link rel="prefetch" href="/assets/index.html-3972e98f.js" as="script"><link rel="prefetch" href="/assets/index.html-22da35ee.js" as="script"><link rel="prefetch" href="/assets/index.html-ee21b81c.js" as="script"><link rel="prefetch" href="/assets/index.html-e6e0a4f4.js" as="script"><link rel="prefetch" href="/assets/index.html-7a425773.js" as="script"><link rel="prefetch" href="/assets/index.html-8665b90a.js" as="script"><link rel="prefetch" href="/assets/index.html-d37a0712.js" as="script"><link rel="prefetch" href="/assets/index.html-ac03c7ca.js" as="script"><link rel="prefetch" href="/assets/index.html-e0869b1f.js" as="script"><link rel="prefetch" href="/assets/index.html-031c234a.js" as="script"><link rel="prefetch" href="/assets/index.html-e8628deb.js" as="script"><link rel="prefetch" href="/assets/index.html-c1b04a34.js" as="script"><link rel="prefetch" href="/assets/index.html-72afc3c2.js" as="script"><link rel="prefetch" href="/assets/index.html-7eac6d80.js" as="script"><link rel="prefetch" href="/assets/index.html-4f8a4f23.js" as="script"><link rel="prefetch" href="/assets/index.html-bed79512.js" as="script"><link rel="prefetch" href="/assets/index.html-67f9c238.js" as="script"><link rel="prefetch" href="/assets/index.html-f7b4e365.js" as="script"><link rel="prefetch" href="/assets/index.html-c74ed5e4.js" as="script"><link rel="prefetch" href="/assets/index.html-6847312f.js" as="script"><link rel="prefetch" href="/assets/index.html-66aa3467.js" as="script"><link rel="prefetch" href="/assets/index.html-5a1fa800.js" as="script"><link rel="prefetch" href="/assets/index.html-270f2bdb.js" as="script"><link rel="prefetch" href="/assets/index.html-ed2b4b9f.js" as="script"><link rel="prefetch" href="/assets/index.html-ad2687ed.js" as="script"><link rel="prefetch" href="/assets/index.html-eba95ea1.js" as="script"><link rel="prefetch" href="/assets/index.html-79d6d44d.js" as="script"><link rel="prefetch" href="/assets/index.html-7757c6f4.js" as="script"><link rel="prefetch" href="/assets/index.html-ef2dbed2.js" as="script"><link rel="prefetch" href="/assets/index.html-06a5c493.js" as="script"><link rel="prefetch" href="/assets/index.html-8c9227eb.js" as="script"><link rel="prefetch" href="/assets/index.html-eab42e6d.js" as="script"><link rel="prefetch" href="/assets/index.html-d01d4cc8.js" as="script"><link rel="prefetch" href="/assets/index.html-32500b4a.js" as="script"><link rel="prefetch" href="/assets/index.html-766541e0.js" as="script"><link rel="prefetch" href="/assets/index.html-c19c200a.js" as="script"><link rel="prefetch" href="/assets/index.html-941feae5.js" as="script"><link rel="prefetch" href="/assets/index.html-c04682a0.js" as="script"><link rel="prefetch" href="/assets/index.html-c4e46bea.js" as="script"><link rel="prefetch" href="/assets/index.html-3cae11ef.js" as="script"><link rel="prefetch" href="/assets/waline-meta-56fbc549.js" as="script"><link rel="prefetch" href="/assets/component-22848d8e.js" as="script"><link rel="prefetch" href="/assets/auto-fa8841cf.js" as="script"><link rel="prefetch" href="/assets/index-a7d1ee58.js" as="script"><link rel="prefetch" href="/assets/flowchart-c441f34d.js" as="script"><link rel="prefetch" href="/assets/mermaid.core-fee71718.js" as="script"><link rel="prefetch" href="/assets/highlight.esm-75b11b9d.js" as="script"><link rel="prefetch" href="/assets/markdown.esm-abe06b83.js" as="script"><link rel="prefetch" href="/assets/math.esm-70a288c8.js" as="script"><link rel="prefetch" href="/assets/notes.esm-a106bb2c.js" as="script"><link rel="prefetch" href="/assets/reveal.esm-ec5549c1.js" as="script"><link rel="prefetch" href="/assets/search.esm-7e6792e2.js" as="script"><link rel="prefetch" href="/assets/zoom.esm-b83b91d0.js" as="script"><link rel="prefetch" href="/assets/VuePlayground-3b0800ec.js" as="script"><link rel="prefetch" href="/assets/photoswipe.esm-5794cde2.js" as="script"><link rel="prefetch" href="/assets/pageview-a374beb1.js" as="script"><link rel="prefetch" href="/assets/style-e9220a04.js" as="script"><link rel="prefetch" href="/assets/docsearch-1d421ddb.js" as="script"><link rel="prefetch" href="/assets/index-5161ad19.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a class="vp-link vp-brand" href="/"><img class="vp-nav-logo" src="/favicon.ico" alt="T4mako"><!----><span class="vp-site-name hide-in-pad">T4mako</span></a><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-center"><!--[--><!----><!--]--><!--[--><nav class="vp-nav-links"><div class="nav-item hide-in-mobile"><a class="vp-link nav-link" href="/"><span class="font-icon icon iconfont icon-home" style=""></span>主页<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="代码笔记"><span class="title"><span class="font-icon icon iconfont icon-code" style=""></span>代码笔记</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a class="vp-link nav-link" href="/code/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html"><!---->基础知识<!----></a></li><li class="dropdown-item"><a class="vp-link nav-link" href="/code/java.html"><!---->Java<!----></a></li><li class="dropdown-item"><a class="vp-link nav-link active" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91.html"><!---->前端开发<!----></a></li><li class="dropdown-item"><a class="vp-link nav-link" href="/code/%E6%95%B0%E6%8D%AE%E5%BA%93.html"><!---->数据库<!----></a></li><li class="dropdown-item"><a class="vp-link nav-link" href="/code/%E8%BF%90%E7%BB%B4%E4%B8%8E%E9%83%A8%E7%BD%B2.html"><!---->运维与部署<!----></a></li><li class="dropdown-item"><a class="vp-link nav-link" href="/code/python.html"><!---->Python<!----></a></li><li class="dropdown-item"><a class="vp-link nav-link" href="/code/leetcode.html"><!---->Leetcode<!----></a></li><li class="dropdown-item"><a class="vp-link nav-link" href="/code/project.html"><!---->项目笔记<!----></a></li><li class="dropdown-item"><a class="vp-link nav-link" href="/code/%E5%85%B6%E4%BB%96.html"><!---->其他<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="兴趣使然"><span class="title"><span class="font-icon icon iconfont icon-view" style=""></span>兴趣使然</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a class="vp-link nav-link" href="/interests/AE.html"><!---->AE<!----></a></li><li class="dropdown-item"><a class="vp-link nav-link" href="/interests/Blender.html"><!---->Blender<!----></a></li><li class="dropdown-item"><a class="vp-link nav-link" href="/interests/HLAE.html"><!---->HLAE<!----></a></li><li class="dropdown-item"><a class="vp-link nav-link" href="/interests/cook.html"><!---->吃饭糊弄学<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="生活碎片"><span class="title"><span class="font-icon icon iconfont icon-note" style=""></span>生活碎片</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a class="vp-link nav-link" href="/life/%E9%9A%8F%E7%AC%94.html"><!---->随笔<!----></a></li><li class="dropdown-item"><a class="vp-link nav-link" href="/life/%E8%A7%82%E5%BD%B1%E5%8C%BA.html"><!---->观影区<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><a class="vp-link nav-link" href="/friends.html"><span class="font-icon icon iconfont icon-group" style=""></span>友链<!----></a></div></nav><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!--]--><!--[--><!----><div class="nav-item vp-repo"><a class="vp-repo-link" href="https://github.com/T4mako/T4mako.github.io" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button type="button" id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!--[--><div id="docsearch-container" style="display:none;"></div><div><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索文档"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">搜索文档</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"><svg width="15" height="15" class="DocSearch-Control-Key-Icon"><path d="M4.505 4.496h2M5.505 5.496v5M8.216 4.496l.055 5.993M10 7.5c.333.333.5.667.5 1v2M12.326 4.5v5.996M8.384 4.496c1.674 0 2.116 0 2.116 1.5s-.442 1.5-2.116 1.5M3.205 9.303c-.09.448-.277 1.21-1.241 1.203C1 10.5.5 9.513.5 8V7c0-1.57.5-2.5 1.464-2.494.964.006 1.134.598 1.24 1.342M12.553 10.5h1.953" stroke-width="1.2" stroke="currentColor" fill="none" stroke-linecap="square"></path></svg></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--><!--]--><!--[--><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!--[--><!----><!--]--><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><p class="vp-sidebar-heading active"><span class="font-icon icon iconfont icon-code" style=""></span><span class="vp-sidebar-title">代码笔记</span><!----></p><ul class="vp-sidebar-links"><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/code/"><span class="font-icon icon iconfont icon-code" style=""></span>代码笔记<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">Java</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">LeetCode刷题</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">Project</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">Python</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">其他</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable active" type="button"><!----><span class="vp-sidebar-title">前端开发</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Ajax.html"><span class="font-icon icon iconfont icon-ajax" style=""></span>Ajax 教程<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Axios.html"><span class="font-icon icon iconfont icon-study" style=""></span>Axios 教程<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/CSS3.html"><span class="font-icon icon iconfont icon-css" style=""></span>CSS 基础<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/HTML.html"><span class="font-icon icon iconfont icon-html" style=""></span>HTML 基础<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-javascript" style=""></span><span class="vp-sidebar-title">JavaScript 教程</span><span class="vp-arrow end"></span></button><!----></section></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Node.js%E7%AC%94%E8%AE%B0.html"><span class="font-icon icon iconfont icon-nodeJS" style=""></span>Node.js 教程<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Promise.html"><span class="font-icon icon iconfont icon-object" style=""></span>Promise 基础<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link active vp-sidebar-link vp-sidebar-page active" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html"><!---->TypeScript基础<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#一、typescript-语言简介"><!---->一、TypeScript 语言简介<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#_1、概述"><!---->1、概述<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#_2、类型的概念"><!---->2、类型的概念<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#_3、动态类型与静态类型"><!---->3、动态类型与静态类型<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#_4、静态类型的优缺点"><!---->4、静态类型的优缺点<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#二、基本用法"><!---->二、基本用法<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#_1、类型声明"><!---->1、类型声明<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#_2、类型推断"><!---->2、类型推断<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#_3、typescript-的编译"><!---->3、TypeScript 的编译<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#_4、值与类型"><!---->4、值与类型<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#_5、typescript-playground"><!---->5、TypeScript Playground<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#_6、tsc-编辑器"><!---->6、tsc 编辑器<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#_7、ts-node-模块"><!---->7、ts-node 模块<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#三、any-unknown-never-类型"><!---->三、any，unknown ，never 类型<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#_1、any-类型"><!---->1、any 类型<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#_2、unknown-类型"><!---->2、unknown 类型<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#_3、never-类型"><!---->3、never 类型<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#四、系统类型"><!---->四、系统类型<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#_1、基本类型"><!---->1、基本类型<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#_2、包装对象类型"><!---->2、包装对象类型<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#_3、object-类型与-object-类型"><!---->3、Object 类型与 object 类型<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#_4、undefined-和-null-的特殊性"><!---->4、undefined 和 null 的特殊性<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#_5、值类型"><!---->5、值类型<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#_6、联合类型"><!---->6、联合类型 |<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#_7、交叉类型"><!---->7、交叉类型 &amp;<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#_8、type-命令"><!---->8、type 命令<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#_9、typeof-运算符"><!---->9、typeof 运算符<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#_10、块级类型声明"><!---->10、块级类型声明<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#_11、类型的兼容"><!---->11、类型的兼容<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#五、数组"><!---->五、数组<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#_1、简介"><!---->1、简介<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#_2、数组的类型推断"><!---->2、数组的类型推断<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#_3、只读数组-const-断言"><!---->3、只读数组，const 断言<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#_4、多维数组"><!---->4、多维数组<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#六、元祖"><!---->六、元祖<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#_1、简介-1"><!---->1、简介<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#_2、只读元组"><!---->2、只读元组<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#_3、成员数量的推断"><!---->3、成员数量的推断<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#_4、扩展运算符与成员数量"><!---->4、扩展运算符与成员数量<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#七、symbol-类型"><!---->七、symbol 类型<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#_1、简介-2"><!---->1、简介<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#_2、unique-symbol"><!---->2、unique symbol<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#_3、类型推断"><!---->3、类型推断<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#八、函数"><!---->八、函数<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#九、对象"><!---->九、对象<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#十、interface"><!---->十、interface<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#十一、类"><!---->十一、类<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#十二、泛型"><!---->十二、泛型<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#十三、enum"><!---->十三、Enum<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#十四、类型推断"><!---->十四、类型推断<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#十五、模块"><!---->十五、模块<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#十六、namespace"><!---->十六、namespace<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#十七、装饰器"><!---->十七、装饰器<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#十八、装饰器-旧语法"><!---->十八、装饰器（旧语法）<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#十九、declare-关键字"><!---->十九、declare 关键字<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#二十、d-ts-类型声明文件"><!---->二十、d.ts 类型声明文件<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#二十一、运算符"><!---->二十一、运算符<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#二十二、类型映射"><!---->二十二、类型映射<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#二十三、类型工具"><!---->二十三、类型工具<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#二十四、注释指令"><!---->二十四、注释指令<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#二十五、tsconfig-ts"><!---->二十五、tsconfig.ts<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html#二十六、tsc命令"><!---->二十六、tsc命令<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul><!--]--></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">Vue</span><span class="vp-arrow end"></span></button><!----></section></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">基础知识</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">数据库</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">运维与部署</span><span class="vp-arrow end"></span></button><!----></section></li></ul></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->TypeScript基础</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://github.com/T4mako/T4mako.github.io" target="_blank" rel="noopener noreferrer">T4mako</a></span><span property="author" content="T4mako"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2023-08-12T00:00:00.000Z"></span><span class="page-pageview-info" aria-label="访问量🔢" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon eye-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="eye icon"><path d="M992 512.096c0-5.76-.992-10.592-1.28-11.136-.192-2.88-1.152-8.064-2.08-10.816-.256-.672-.544-1.376-.832-2.08-.48-1.568-1.024-3.104-1.6-4.32C897.664 290.112 707.104 160 512 160c-195.072 0-385.632 130.016-473.76 322.592-1.056 2.112-1.792 4.096-2.272 5.856a55.512 55.512 0 00-.64 1.6c-1.76 5.088-1.792 8.64-1.632 7.744-.832 3.744-1.568 11.168-1.568 11.168-.224 2.272-.224 4.032.032 6.304 0 0 .736 6.464 1.088 7.808.128 1.824.576 4.512 1.12 6.976h-.032c.448 2.08 1.12 4.096 1.984 6.08.48 1.536.992 2.976 1.472 4.032C126.432 733.856 316.992 864 512 864c195.136 0 385.696-130.048 473.216-321.696 1.376-2.496 2.24-4.832 2.848-6.912.256-.608.48-1.184.672-1.728 1.536-4.48 1.856-8.32 1.728-8.32l-.032.032c.608-3.104 1.568-7.744 1.568-13.28zM512 672c-88.224 0-160-71.776-160-160s71.776-160 160-160 160 71.776 160 160-71.776 160-160 160z"></path></svg><span id="ArtalkPV" class="waline-pageview-count" data-path="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScrip%E5%9F%BA%E7%A1%80.html">...</span></span><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 49 分钟</span><meta property="timeRequired" content="PT49M"></span><span class="page-category-info" aria-label="分类🌈" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><!--[--><span class="page-category-item category8 clickable" role="navigation">TypeScript</span><!--]--><meta property="articleSection" content="TypeScript"></span><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#一、typescript-语言简介">一、TypeScript 语言简介</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_1、概述">1、概述</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_2、类型的概念">2、类型的概念</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_3、动态类型与静态类型">3、动态类型与静态类型</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_4、静态类型的优缺点">4、静态类型的优缺点</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#二、基本用法">二、基本用法</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_1、类型声明">1、类型声明</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_2、类型推断">2、类型推断</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_3、typescript-的编译">3、TypeScript 的编译</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_4、值与类型">4、值与类型</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_5、typescript-playground">5、TypeScript Playground</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_6、tsc-编辑器">6、tsc 编辑器</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_7、ts-node-模块">7、ts-node 模块</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#三、any-unknown-never-类型">三、any，unknown ，never 类型</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_1、any-类型">1、any 类型</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_2、unknown-类型">2、unknown 类型</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_3、never-类型">3、never 类型</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#四、系统类型">四、系统类型</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_1、基本类型">1、基本类型</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_2、包装对象类型">2、包装对象类型</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_3、object-类型与-object-类型">3、Object 类型与 object 类型</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_4、undefined-和-null-的特殊性">4、undefined 和 null 的特殊性</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_5、值类型">5、值类型</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_6、联合类型">6、联合类型 |</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_7、交叉类型">7、交叉类型 &amp;</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_8、type-命令">8、type 命令</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_9、typeof-运算符">9、typeof 运算符</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_10、块级类型声明">10、块级类型声明</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_11、类型的兼容">11、类型的兼容</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#五、数组">五、数组</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_1、简介">1、简介</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_2、数组的类型推断">2、数组的类型推断</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_3、只读数组-const-断言">3、只读数组，const 断言</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_4、多维数组">4、多维数组</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#六、元祖">六、元祖</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_1、简介-1">1、简介</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_2、只读元组">2、只读元组</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_3、成员数量的推断">3、成员数量的推断</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_4、扩展运算符与成员数量">4、扩展运算符与成员数量</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#七、symbol-类型">七、symbol 类型</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_1、简介-2">1、简介</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_2、unique-symbol">2、unique symbol</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#_3、类型推断">3、类型推断</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#八、函数">八、函数</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#九、对象">九、对象</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#十、interface">十、interface</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#十一、类">十一、类</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#十二、泛型">十二、泛型</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#十三、enum">十三、Enum</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#十四、类型推断">十四、类型推断</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#十五、模块">十五、模块</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#十六、namespace">十六、namespace</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#十七、装饰器">十七、装饰器</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#十八、装饰器-旧语法">十八、装饰器（旧语法）</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#十九、declare-关键字">十九、declare 关键字</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#二十、d-ts-类型声明文件">二十、d.ts 类型声明文件</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#二十一、运算符">二十一、运算符</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#二十二、类型映射">二十二、类型映射</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#二十三、类型工具">二十三、类型工具</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#二十四、注释指令">二十四、注释指令</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#二十五、tsconfig-ts">二十五、tsconfig.ts</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#二十六、tsc命令">二十六、tsc命令</a></li><!----><!--]--></ul><div class="toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!----><div class="theme-hope-content"><p>(参考文章)[<a href="https://wangdoc.com/typescript/" target="_blank" rel="noopener noreferrer">https://wangdoc.com/typescript/<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>]</p><p>最简单的 TypeScript 使用方法，就是使用官网的在线编译页面， <a href="http://www.typescriptlang.org/play/" target="_blank" rel="noopener noreferrer">TypeScript Playground<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>。</p><h2 id="一、typescript-语言简介" tabindex="-1"><a class="header-anchor" href="#一、typescript-语言简介" aria-hidden="true">#</a> 一、TypeScript 语言简介</h2><h3 id="_1、概述" tabindex="-1"><a class="header-anchor" href="#_1、概述" aria-hidden="true">#</a> 1、概述</h3><p>TypeScript（简称 TS）是微软公司开发的一种 <strong>基于 JavaScript</strong> （简称 JS）语言的编程语言。</p><p>它的目的并不是创造一种全新语言，而是 <strong>增强 JavaScript</strong> 的功能，使其更适合多人合作的企业级项目。</p><p>TypeScript 可以看成是 JavaScript 的 <strong>超集</strong>（superset），即它继承了后者的全部语法，所有 JavaScript 脚本都可以当作 TypeScript 脚本（但是可能会报错），此外它再增加了一些自己的语法。</p><h3 id="_2、类型的概念" tabindex="-1"><a class="header-anchor" href="#_2、类型的概念" aria-hidden="true">#</a> 2、类型的概念</h3><p><strong>类型是人为添加的一种编程约束和用法提示</strong>，目的是在软件开发过程中，为编译器和开发工具提供更多的验证和帮助，帮助提高代码质量，减少错误。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">addOne</span><span class="token punctuation">(</span>n<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">addOne</span><span class="token punctuation">(</span><span class="token string">&#39;hello&#39;</span><span class="token punctuation">)</span> <span class="token comment">// 报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>TypeScript 是在开发阶段报错，这样有利于提早发现错误，避免使用时报错。<br> 另一方面，函数定义里面加入类型，具有提示作用，可以告诉开发者这个函数怎么用。</p><h3 id="_3、动态类型与静态类型" tabindex="-1"><a class="header-anchor" href="#_3、动态类型与静态类型" aria-hidden="true">#</a> 3、动态类型与静态类型</h3><p><strong>JavaScript</strong> 的类型系统非常弱，而且没有使用限制，运算符可以接受各种类型的值。在语法上，JavaScript 属于 <strong>动态类型语言</strong><br><strong>TypeScript</strong> 引入了一个更强大、更严格的类型系统，属于 <strong>静态类型语言</strong></p><h3 id="_4、静态类型的优缺点" tabindex="-1"><a class="header-anchor" href="#_4、静态类型的优缺点" aria-hidden="true">#</a> 4、静态类型的优缺点</h3><p>优点：</p><ul><li>有利于代码的静态分析。</li><li>有利于发现错误。</li><li>更好的 IDE 支持，做到语法提示和自动补全。</li><li>提供了代码文档。</li><li>有助于代码重构。</li></ul><p>缺点：</p><ul><li>丧失了动态类型的代码灵活性。</li><li>增加了编程工作量。</li><li>更高的学习成本。</li><li>引入了独立的编译步骤。</li><li>兼容性问题。</li></ul><h2 id="二、基本用法" tabindex="-1"><a class="header-anchor" href="#二、基本用法" aria-hidden="true">#</a> 二、基本用法</h2><h3 id="_1、类型声明" tabindex="-1"><a class="header-anchor" href="#_1、类型声明" aria-hidden="true">#</a> 1、类型声明</h3><p>TypeScript 代码最明显的特征，就是为 JavaScript 变量加上了类型声明。</p><p>类型声明的写法，一律为在标识符后面添加“<strong>冒号 + 类型</strong>”。函数参数和返回值，也是这样来声明类型。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> foo<span class="token operator">:</span><span class="token builtin">string</span><span class="token punctuation">;</span> <span class="token comment">//声明了它的类型为string</span>
<span class="token keyword">function</span> <span class="token function">toString</span><span class="token punctuation">(</span>num<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token builtin">string</span> <span class="token punctuation">{</span> <span class="token comment">//num的类型是number。参数列表的圆括号后面，声明了返回值的类型是string</span>
  <span class="token keyword">return</span> <span class="token function">String</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>变量的值应该与声明的类型一致，如果不一致，TypeScript 就会报错。</p><p>另外，TypeScript 规定，变量只有<strong>赋值后才能使用</strong>，否则就会报错。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> x<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token comment">// 报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2、类型推断" tabindex="-1"><a class="header-anchor" href="#_2、类型推断" aria-hidden="true">#</a> 2、类型推断</h3><p>类型声明并不是必需的，如果没有，TypeScript 会自己 <strong>推断类型</strong>。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> foo <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment">// TypeScript 推断它的类型为 number。</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>TypeScript 推断它的类型为<code>number</code>。</p><p>后面，如果变量<code>foo</code>更改为其他类型的值，跟推断的类型不一致，TypeScript 就会报错。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> foo <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
foo <span class="token operator">=</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">;</span> <span class="token comment">// 报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>TypeScript 也可以<strong>推断</strong>函数的<strong>返回值</strong>。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">toString</span><span class="token punctuation">(</span>num<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">String</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// TypeScript 推断返回的是字符串。</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>正是因为 TypeScript 的类型推断，所以函数返回值的类型通常是省略不写的。</p><p>这样设计还有一个好处，将以前的 JavaScript 项目改为 TypeScript 项目时，你可以逐步地为老代码添加类型，即使有些代码没有添加，也不会无法运行。</p></div><h3 id="_3、typescript-的编译" tabindex="-1"><a class="header-anchor" href="#_3、typescript-的编译" aria-hidden="true">#</a> 3、TypeScript 的编译</h3><p><strong>JavaScript</strong> 的运行环境（<strong>浏览器</strong> 和 <strong>Node.js</strong>）不认识 <strong>TypeScript</strong> 代码。所以，TypeScript 项目要想运行，必须先转为 JavaScript 代码，这个代码转换的过程就叫做“<strong>编译</strong>”（compile）。</p><p>TypeScript 官方没有做运行环境，只提供编译器。编译时，会将类型声明和类型相关的代码全部删除，只留下能运行的 JavaScript 代码，并且不会改变 JavaScript 的运行结果。</p><p>因此，TypeScript 的类型检查只是编译时的类型检查，而不是运行时的类型检查。一旦代码编译为 JavaScript，运行时就不再检查类型了。</p><h3 id="_4、值与类型" tabindex="-1"><a class="header-anchor" href="#_4、值与类型" aria-hidden="true">#</a> 4、值与类型</h3><p>TypeScript 代码只涉及类型，不涉及值。所有跟“值”相关的处理，都由 JavaScript 完成。</p><p>它们是可以分离的，TypeScript 的编译过程，实际上就是把“类型代码”全部拿掉，只保留“值代码”。</p><h3 id="_5、typescript-playground" tabindex="-1"><a class="header-anchor" href="#_5、typescript-playground" aria-hidden="true">#</a> 5、TypeScript Playground</h3><p>最简单的 TypeScript 使用方法，就是使用官网的在线编译页面，叫做 <a href="http://www.typescriptlang.org/play/" target="_blank" rel="noopener noreferrer">TypeScript Playground<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>。</p><p>把 TypeScript 代码贴进文本框，它就会在当前页面自动编译出 JavaScript 代码，还可以在浏览器执行编译产物。如果编译报错，它也会给出详细的报错信息。</p><p>这个页面还具有支持完整的 IDE 支持，可以自动语法提示。此外，它支持把代码片段和编译器设置保存成 URL，分享给他人。</p><h3 id="_6、tsc-编辑器" tabindex="-1"><a class="header-anchor" href="#_6、tsc-编辑器" aria-hidden="true">#</a> 6、tsc 编辑器</h3><p>TypeScript 官方提供的编译器叫做 tsc，可以将 TypeScript 脚本编译成 JavaScript 脚本。本机想要编译 TypeScript 代码，必须安装 tsc。</p><p>根据约定，TypeScript 脚本文件使用<code>.ts</code>后缀名，JavaScript 脚本文件使用<code>.js</code>后缀名。tsc 的作用就是把<code>.ts</code>脚本转变成<code>.js</code>脚本。</p><h4 id="_6-1、安装" tabindex="-1"><a class="header-anchor" href="#_6-1、安装" aria-hidden="true">#</a> 6.1、安装</h4><p>tsc 是一个 npm 模块，使用下面的命令安装（必须先安装 npm）。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">npm</span> <span class="token function">install</span> <span class="token parameter variable">-g</span> typescript
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面命令是全局安装 tsc，也可以在项目中将 tsc 安装为一个依赖模块。</p><p>安装完成后，检查一下是否安装成功。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 或者 tsc --version</span>
$ tsc <span class="token parameter variable">-v</span>
Version <span class="token number">5.1</span>.6
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面命令中，<code>-v</code>或<code>--version</code>参数可以输出当前安装的 tsc 版本。</p><h4 id="_6-2、帮助信息" tabindex="-1"><a class="header-anchor" href="#_6-2、帮助信息" aria-hidden="true">#</a> 6.2、帮助信息</h4><p><code>-h</code>或<code>--help</code>参数输出帮助信息。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ tsc <span class="token parameter variable">-h</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>默认情况下，“--help”参数仅显示基本的可用选项。我们可以使用“--all”参数，查看完整的帮助信息。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ tsc <span class="token parameter variable">--all</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="_6-3、编译脚本" tabindex="-1"><a class="header-anchor" href="#_6-3、编译脚本" aria-hidden="true">#</a> 6.3、编译脚本</h4><p>安装 tsc 之后，就可以编译 TypeScript 脚本了。</p><p><code>tsc</code>命令后面，加上 TypeScript 脚本文件，就可以将其编译成 JavaScript 脚本。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ tsc app.ts
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面命令会在当前目录下，生成一个<code>app.js</code>脚本文件，这个脚本就完全是编译后生成的 JavaScript 代码。</p><p><code>tsc</code>命令也可以一次编译多个 TypeScript 脚本。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ tsc file1.ts file2.ts file3.ts
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面命令会在当前目录生成三个 JavaScript 脚本文件<code>file1.js</code>、<code>file2.js</code>、<code>file3.js</code>。</p><p>tsc 有很多参数，可以调整编译行为。</p><p><strong>（1）--outFile</strong></p><p>如果想将多个 TypeScript 脚本编译成一个 JavaScript 文件，使用<code>--outFile</code>参数。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ tsc file1.ts file2.ts <span class="token parameter variable">--outFile</span> app.js
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面命令将<code>file1.ts</code>和<code>file2.ts</code>两个脚本编译成一个 JavaScript 文件<code>app.js</code>。</p><p><strong>（2）--outDir</strong></p><p>编译结果默认都保存在当前目录，<code>--outDir</code>参数可以指定保存到其他目录。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ tsc app.ts <span class="token parameter variable">--outDir</span> dist
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面命令会在<code>dist</code>子目录下生成<code>app.js</code>。</p><p><strong>（3）--target</strong></p><p>为了保证编译结果能在各种 JavaScript 引擎运行，tsc 默认会将 TypeScript 代码编译成很<strong>低版本</strong>的 JavaScript，即3.0版本（以<code>es3</code>表示）。这通常不是我们想要的结果。</p><p>这时可以使用<code>--target</code>参数，指定编译后的 JavaScript 版本。建议使用<code>es2015</code>，或者<strong>更新版本</strong>。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ tsc <span class="token parameter variable">--target</span> es2015 app.ts
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="_6-4、编译错误的处理" tabindex="-1"><a class="header-anchor" href="#_6-4、编译错误的处理" aria-hidden="true">#</a> 6.4、编译错误的处理</h4><p>编译过程中，如果没有报错，<code>tsc</code>命令不会有任何显示。所以，如果你没有看到任何提示，就表示编译成功了。</p><p>如果<strong>编译报错</strong>，<code>tsc</code>命令就会显示报错信息，但是这种情况下，<strong>依然会编译生成 JavaScript 脚本</strong>。</p><p>举例来说，下面是一个错误的 TypeScript 脚本<code>app.ts</code>。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token comment">// app.ts</span>
<span class="token keyword">let</span> foo<span class="token operator">:</span><span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
foo <span class="token operator">=</span> <span class="token string">&#39;abc&#39;</span><span class="token punctuation">;</span> <span class="token comment">// 报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>foo</code>是数值类型，赋值为字符串，<code>tsc</code>命令编译这个脚本就会报错。</p><div class="language-txt line-numbers-mode" data-ext="txt"><pre class="language-txt"><code>$ tsc app.ts

app.ts:2:1 - error TS2322: Type &#39;string&#39; is not assignable to type &#39;number&#39;.

2 foo = &#39;abc&#39;;
  ~~~

Found 1 error in app.ts:2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>tsc</code>命令输出报错信息，表示变量<code>foo</code>被错误地赋值为字符串。</p><p>这种情况下，编译产物<code>app.js</code>还是会照样生成，下面就是编译后的结果。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// app.js</span>
<span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
foo <span class="token operator">=</span> <span class="token string">&#39;abc&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，<strong>尽管有错，tsc 依然原样将 TypeScript 编译成 JavaScript 脚本</strong>。</p><p>如果希望一旦报错就停止编译，不生成编译产物，可以使用<code>--noEmitOnError</code>参数。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ tsc <span class="token parameter variable">--noEmitOnError</span> app.ts
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面命令在报错后，就不会生成<code>app.js</code>。</p><p>tsc 还有一个<code>--noEmit</code>参数，只检查类型是否正确，不生成 JavaScript 文件。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ tsc <span class="token parameter variable">--noEmit</span> app.ts
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面命令只检查是否有编译错误，不会生成<code>app.js</code>。</p><p>tsc 命令的更多参数，详见《tsc 编译器》一章。</p><h4 id="_6-5、tsconfig-json" tabindex="-1"><a class="header-anchor" href="#_6-5、tsconfig-json" aria-hidden="true">#</a> 6.5、tsconfig.json</h4><p>TypeScript 允许将<code>tsc</code>的编译参数，写在配置文件<code>tsconfig.json</code>。只要当前目录有这个文件，<code>tsc</code>就会自动读取，所以运行时可以不写参数。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ tsc file1.ts file2.ts <span class="token parameter variable">--outFile</span> dist/app.js
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面这个命令写成<code>tsconfig.json</code>，就是下面这样。</p><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;files&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;file1.ts&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;file2.ts&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token property">&quot;compilerOptions&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">&quot;outFile&quot;</span><span class="token operator">:</span> <span class="token string">&quot;dist/app.js&quot;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有了这个配置文件，编译时直接调用<code>tsc</code>命令就可以了。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ tsc
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>tsconfig.json</code>的详细介绍，参见《tsconfig.json 配置文件》一章。</p><h3 id="_7、ts-node-模块" tabindex="-1"><a class="header-anchor" href="#_7、ts-node-模块" aria-hidden="true">#</a> 7、ts-node 模块</h3><p><a href="https://github.com/TypeStrong/ts-node" target="_blank" rel="noopener noreferrer">ts-node<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 是一个非官方的 npm 模块，可以直接运行 TypeScript 代码。</p><p>使用时，可以先全局安装它。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">npm</span> <span class="token function">install</span> <span class="token parameter variable">-g</span> ts-node
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>安装后，就可以直接运行 TypeScript 脚本。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ ts-node script.ts
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面命令运行了 TypeScript 脚本<code>script.ts</code>，给出运行结果。</p><p>如果不安装 ts-node，也可以通过 npx 调用它来运行 TypeScript 脚本。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ npx ts-node script.ts
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面命令中，<code>npx</code>会在线调用 ts-node，从而在不安装的情况下，运行<code>script.ts</code>。</p><p>如果执行 ts-node 命令不带有任何参数，它会提供一个 TypeScript 的命令行 REPL 运行环境，你可以在这个环境中输入 TypeScript 代码，逐行执行。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ ts-node
<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，单独运行<code>ts-node</code>命令，会给出一个大于号，这就是 TypeScript 的 REPL 运行环境，可以逐行输入代码运行。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ ts-node
<span class="token operator">&gt;</span> const twice <span class="token operator">=</span> <span class="token punctuation">(</span>x:string<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> x + x<span class="token punctuation">;</span>
<span class="token operator">&gt;</span> twice<span class="token punctuation">(</span><span class="token string">&#39;abc&#39;</span><span class="token punctuation">)</span>
<span class="token string">&#39;abcabc&#39;</span>
<span class="token operator">&gt;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，在 TypeScript 命令行 REPL 环境中，先输入一个函数<code>twice</code>，然后调用该函数，就会得到结果。</p><p>要退出这个 REPL 环境，可以按下 Ctrl + d，或者输入<code>.exit</code>。</p><p>如果只是想简单运行 TypeScript 代码看看结果，ts-node 不失为一个便捷的方法。</p><h2 id="三、any-unknown-never-类型" tabindex="-1"><a class="header-anchor" href="#三、any-unknown-never-类型" aria-hidden="true">#</a> 三、any，unknown ，never 类型</h2><h3 id="_1、any-类型" tabindex="-1"><a class="header-anchor" href="#_1、any-类型" aria-hidden="true">#</a> 1、any 类型</h3><h4 id="_1-1、基本含义" tabindex="-1"><a class="header-anchor" href="#_1-1、基本含义" aria-hidden="true">#</a> 1.1、基本含义</h4><p>any 类型表示没有任何限制，该类型的变量可以赋予任意类型的值。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> x<span class="token operator">:</span><span class="token builtin">any</span><span class="token punctuation">;</span>
x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 正确</span>
x <span class="token operator">=</span> <span class="token string">&#39;foo&#39;</span><span class="token punctuation">;</span> <span class="token comment">// 正确</span>
x <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 正确</span>

<span class="token keyword">let</span> x<span class="token operator">:</span><span class="token builtin">any</span> <span class="token operator">=</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">;</span>
<span class="token function">x</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 不报错</span>
x<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// 不报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>变量类型一旦设为<code>any</code>，TypeScript 实际上会关闭这个变量的类型检查。只要句法正确，都不会报错。</p><p>由于这个原因，应该尽量避免使用<code>any</code>类型，否则就失去了使用 TypeScript 的意义。</p><p><code>any</code>类型主要适用以下两个场合：</p><ol><li>需要关闭某些变量的类型检查</li><li>为了适配以前老的 JavaScript 项目，让代码快速迁移到 TypeScript，可以把变量类型设为<code>any</code></li></ol><h4 id="_1-2、类型推断问题" tabindex="-1"><a class="header-anchor" href="#_1-2、类型推断问题" aria-hidden="true">#</a> 1.2、类型推断问题</h4><p>对于开发者没有指定类型、TypeScript 必须自己推断类型的那些变量，如果无法推断出类型，TypeScript 就会认为该变量的类型是<code>any</code></p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 不报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，函数<code>add()</code>的参数变量<code>x</code>和<code>y</code>，都没有足够的信息，TypeScript 无法推断出它们的类型，就会认为这两个变量和函数返回值的类型都是<code>any</code>。以至于后面就不再对函数<code>add()</code>进行类型检查了，怎么用都可以。</p><p>TypeScript 提供了一个编译选项<code>noImplicitAny</code>，打开该选项，只要推断出<code>any</code>类型就会报错。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ tsc <span class="token parameter variable">--noImplicitAny</span> app.ts <span class="token comment"># 会报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这里有一个特殊情况，即使打开了<code>noImplicitAny</code>，使用<code>let</code>和<code>var</code>命令声明变量，但不赋值也不指定类型，是不会报错的。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">var</span> x<span class="token punctuation">;</span> <span class="token comment">// 不报错 TypeScript 会推断它们的类型为any。这时即使打开了noImplicitAny，也不会报错。</span>
<span class="token keyword">let</span> y<span class="token punctuation">;</span> <span class="token comment">// 不报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>建议使用<code>let</code>和<code>var</code>声明变量时，如果不赋值，就一定要显式声明类型，否则可能存在安全隐患。</p><p><code>const</code>命令没有这个问题，因为 JavaScript 语言规定<code>const</code>声明变量时，必须同时进行初始化（赋值）</p><p><code>const</code>命令声明的<code>x</code>是不能改变值的，声明时必须同时赋值，否则报错，所以它不存在类型推断为<code>any</code>的问题。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> x<span class="token punctuation">;</span> <span class="token comment">// 报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></div><h4 id="_1-3、污染问题" tabindex="-1"><a class="header-anchor" href="#_1-3、污染问题" aria-hidden="true">#</a> 1.3、污染问题</h4><p><code>any</code>类型除了关闭类型检查，还有一个很大的问题，就是它会“污染”其他变量。它可以赋值给其他任何类型的变量（因为没有类型检查），导致其他变量出错。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> x<span class="token operator">:</span><span class="token builtin">any</span> <span class="token operator">=</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> y<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">;</span>

y <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">// 不报错</span>

y <span class="token operator">*</span> <span class="token number">123</span> <span class="token comment">// 不报错</span>
y<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 不报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>污染其他具有正确类型的变量，把错误留到运行时，这就是不宜使用<code>any</code>类型的另一个主要原因。</p></div><h3 id="_2、unknown-类型" tabindex="-1"><a class="header-anchor" href="#_2、unknown-类型" aria-hidden="true">#</a> 2、unknown 类型</h3><p>为了解决<code>any</code>类型“污染”其他变量的问题，TypeScript 3.0 引入了<a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type" target="_blank" rel="noopener noreferrer"><code>unknown</code>类型<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>。它与<code>any</code>含义相同，表示类型不确定，可能是任意类型，但是它的使用有一些限制，不像<code>any</code>那样自由，可以视为 <strong>严格版的<code>any</code></strong>。</p><p><code>unknown</code>跟<code>any</code>的<strong>相似</strong>之处，在于所有类型的值都可以分配给<code>unknown</code>类型。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> x<span class="token operator">:</span><span class="token builtin">unknown</span><span class="token punctuation">;</span>

x <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 正确</span>
x <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment">// 正确</span>
x <span class="token operator">=</span> <span class="token string">&#39;Hello World&#39;</span><span class="token punctuation">;</span> <span class="token comment">// 正确</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>unknown</code>类型跟<code>any</code>类型的不同之处在于，它不能直接使用。主要有以下几个限制。</p><ol><li><p><code>unknown</code>类型的变量，不能直接赋值给其他类型的变量（除了<code>any</code>类型和<code>unknown</code>类型）。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> v<span class="token operator">:</span><span class="token builtin">unknown</span> <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> v1<span class="token operator">:</span><span class="token builtin">boolean</span> <span class="token operator">=</span> v<span class="token punctuation">;</span> <span class="token comment">// 报错</span>
<span class="token keyword">let</span> v2<span class="token operator">:</span><span class="token builtin">number</span> <span class="token operator">=</span> v<span class="token punctuation">;</span> <span class="token comment">// 报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>变量<code>v</code>是<code>unknown</code>类型，<strong>赋值给<code>any</code>和<code>unknown</code>以外类型的变量都会报错</strong>，这就避免了污染问题，从而克服了<code>any</code>类型的一大缺点。</p></li><li><p>不能直接调用<code>unknown</code>类型变量的方法和属性。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> v1<span class="token operator">:</span><span class="token builtin">unknown</span> <span class="token operator">=</span> <span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token number">123</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
v1<span class="token punctuation">.</span>foo  <span class="token comment">// 报错</span>

<span class="token keyword">let</span> v2<span class="token operator">:</span><span class="token builtin">unknown</span> <span class="token operator">=</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">;</span>
v2<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 报错</span>

<span class="token keyword">let</span> v3<span class="token operator">:</span><span class="token function-variable function">unknown</span> <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token function">v3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接调用<code>unknown</code>类型变量的属性和方法，或者直接当作函数执行，都会报错。</p></li><li><p>再次，<code>unknown</code>类型变量能够进行的运算是有限的</p><p>只能进行比较运算（运算符<code>==</code>、<code>===</code>、<code>!=</code>、<code>!==</code>、<code>||</code>、<code>&amp;&amp;</code>、<code>?</code>）、取反运算（运算符<code>!</code>）、<code>typeof</code>运算符和<code>instanceof</code>运算符这几种，其他运算都会报错。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> a<span class="token operator">:</span><span class="token builtin">unknown</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

a <span class="token operator">+</span> <span class="token number">1</span> <span class="token comment">// 报错</span>
a <span class="token operator">===</span> <span class="token number">1</span> <span class="token comment">// 正确</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>使用<code>unknown</code>类型变量</p><p>只有经过“<strong>类型缩小</strong>”，<code>unknown</code>类型变量才可以使用。所谓“类型缩小”，就是缩小<code>unknown</code>变量的类型范围，确保不会出错。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> a<span class="token operator">:</span><span class="token builtin">unknown</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> a <span class="token operator">===</span> <span class="token string">&#39;number&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> r <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 正确</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> s<span class="token operator">:</span><span class="token builtin">unknown</span> <span class="token operator">=</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> s <span class="token operator">===</span> <span class="token string">&#39;string&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  s<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment">// 正确</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>unknown</code>类型的变量<code>a</code>经过**<code>typeof</code>**运算以后，能够确定实际类型是<code>number</code>，就能用于加法运算了。这就是“类型缩小”，即将一个不确定的类型缩小为更明确的类型。</p><p><code>unknown</code>可以看作是更安全的<code>any</code>。一般来说，凡是需要设为<code>any</code>类型的地方，通常都应该优先考虑设为<code>unknown</code>类型。</p><p>在集合论上，<code>unknown</code>也可以视为所有其他类型（除了<code>any</code>）的全集，所以它和<code>any</code>一样，也属于 TypeScript 的顶层类型。</p></li></ol><h3 id="_3、never-类型" tabindex="-1"><a class="header-anchor" href="#_3、never-类型" aria-hidden="true">#</a> 3、never 类型</h3><p>为了保持与集合论的对应关系，以及类型运算的完整性，TypeScript 还引入了“<strong>空类型</strong>”的概念，即该类型为空，不包含任何值。</p><p>由于不存在任何属于“空类型”的值，所以该类型被称为<code>never</code>，即不可能有这样的值。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> x<span class="token operator">:</span><span class="token builtin">never</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面示例中，变量<code>x</code>的类型是<code>never</code>，就不可能赋给它任何值，否则都会报错。</p><p><code>never</code>类型的使用场景，主要是在一些类型运算之中，保证类型运算的完整性，详见后面章节。<br> 另外，不可能返回值的函数，返回值的类型就可以写成<code>never</code>，详见《函数》一章。</p><p>如果一个变量可能有多种类型（即联合类型），通常需要使用分支处理每一种类型。这时，处理所有可能的类型之后，剩余的情况就属于<code>never</code>类型。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>x<span class="token operator">:</span><span class="token builtin">string</span><span class="token operator">|</span><span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">&#39;string&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">&#39;number&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    x<span class="token punctuation">;</span> <span class="token comment">// never 类型</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，参数变量<code>x</code>可能是字符串，也可能是数值，判断了这两种情况后，剩下的最后那个<code>else</code>分支里面，<code>x</code>就是<code>never</code>类型了。</p><p><strong><code>never</code>类型的一个重要特点是，可以赋值给任意其他类型。</strong></p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token builtin">never</span> <span class="token punctuation">{</span>
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&#39;Error&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> v1<span class="token operator">:</span><span class="token builtin">number</span> <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 不报错</span>
<span class="token keyword">let</span> v2<span class="token operator">:</span><span class="token builtin">string</span> <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 不报错</span>
<span class="token keyword">let</span> v3<span class="token operator">:</span><span class="token builtin">boolean</span> <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 不报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，函数<code>f()</code>会抛错，所以返回值类型可以写成<code>never</code>，即不可能返回任何值。各种其他类型的变量都可以赋值为<code>f()</code>的运行结果（<code>never</code>类型）。</p><p>为什么<code>never</code>类型可以赋值给任意其他类型呢？这也跟集合论有关，空集是任何集合的子集。TypeScript 就相应规定，任何类型都包含了<code>never</code>类型。因此，<code>never</code>类型是任何其他类型所共有的，TypeScript 把这种情况称为“底层类型”（bottom type）。</p><p>总之，TypeScript 有两个“<strong>顶层类型</strong>”（<code>any</code>和<code>unknown</code>），但是“<strong>底层类型</strong>”只有<code>never</code>唯一一个。</p><h2 id="四、系统类型" tabindex="-1"><a class="header-anchor" href="#四、系统类型" aria-hidden="true">#</a> 四、系统类型</h2><h3 id="_1、基本类型" tabindex="-1"><a class="header-anchor" href="#_1、基本类型" aria-hidden="true">#</a> 1、基本类型</h3><p><strong>JavaScript</strong> 语言 将值分成8种类型。</p><ul><li>boolean</li><li>string</li><li>number</li><li>bigint</li><li>symbol</li><li>object</li><li>undefined</li><li>null</li></ul><p>TypeScript 继承了 JavaScript 的类型设计，以上8种类型可以看作 TypeScript 的基本类型。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>注意，上面所有类型的名称都是小写字母，首字母大写的<code>Number</code>、<code>String</code>、<code>Boolean</code>等在 JavaScript 语言中都是内置对象，而不是类型名称。</p><p>另外，undefined 和 null 既可以作为值，也可以作为类型，取决于在哪里使用它们。</p></div><p>这8种基本类型是 TypeScript 类型系统的基础，复杂类型由它们组合而成。</p><h4 id="_1-1、boolean类型" tabindex="-1"><a class="header-anchor" href="#_1-1、boolean类型" aria-hidden="true">#</a> 1.1、boolean类型</h4><p><code>boolean</code>类型只包含<code>true</code>和<code>false</code>两个布尔值。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> x<span class="token operator">:</span><span class="token builtin">boolean</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> y<span class="token operator">:</span><span class="token builtin">boolean</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1-2、string-类型" tabindex="-1"><a class="header-anchor" href="#_1-2、string-类型" aria-hidden="true">#</a> 1.2、string 类型</h4><p>string类型包含所有字符串。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> x<span class="token operator">:</span><span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> y<span class="token operator">:</span><span class="token builtin">string</span> <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>x<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> world</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1-3、number-类型" tabindex="-1"><a class="header-anchor" href="#_1-3、number-类型" aria-hidden="true">#</a> 1.3、number 类型</h4><p><code>number</code>类型包含所有<strong>整数</strong>和<strong>浮点数</strong>。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> x<span class="token operator">:</span><span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> y<span class="token operator">:</span><span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> z<span class="token operator">:</span><span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">0xffff</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1-4、bigint-类型" tabindex="-1"><a class="header-anchor" href="#_1-4、bigint-类型" aria-hidden="true">#</a> 1.4、bigint 类型</h4><p>bigint 类型包含所有的大整数。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> x<span class="token operator">:</span>bigint <span class="token operator">=</span> <span class="token number">123n</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> y<span class="token operator">:</span>bigint <span class="token operator">=</span> <span class="token number">0xffffn</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1-5、symbol-类型" tabindex="-1"><a class="header-anchor" href="#_1-5、symbol-类型" aria-hidden="true">#</a> 1.5、symbol 类型</h4><p>symbol 类型包含所有的 Symbol 值。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> x<span class="token operator">:</span><span class="token builtin">symbol</span> <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>symbol 类型的详细介绍，参见《Symbol》一章。</p><h4 id="_1-6、object-类型" tabindex="-1"><a class="header-anchor" href="#_1-6、object-类型" aria-hidden="true">#</a> 1.6、object 类型</h4><p>根据 JavaScript 的设计，object 类型包含了所有对象、数组和函数。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> x<span class="token operator">:</span>object <span class="token operator">=</span> <span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token number">123</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> y<span class="token operator">:</span>object <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> z<span class="token operator">:</span><span class="token function-variable function">object</span> <span class="token operator">=</span> <span class="token punctuation">(</span>n<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1-7、undefined-类型-null-类型" tabindex="-1"><a class="header-anchor" href="#_1-7、undefined-类型-null-类型" aria-hidden="true">#</a> 1.7、undefined 类型，null 类型</h4><p>undefined 和 null 是两种独立类型，它们各自都只有一个值。</p><p>undefined 类型只包含一个值<code>undefined</code>，表示未定义（即还未给出定义，以后可能会有定义）。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> x<span class="token operator">:</span><span class="token keyword">undefined</span> <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> y<span class="token operator">:</span><span class="token keyword">null</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>x</code>就属于 undefined 类型。两个<code>undefined</code>里面，第一个是类型，第二个是值。</p><p>null 类型也只包含一个值<code>null</code>，表示为空（即此处没有值）。</p><div class="hint-container warning"><p class="hint-container-title">注意</p><p>注意，如果没有声明类型的变量，被赋值为<code>undefined</code>或<code>null</code>，它们的类型会被推断为<code>any</code>。</p></div><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>   <span class="token comment">// any</span>
<span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span> <span class="token comment">// any</span>

<span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">// any</span>
<span class="token keyword">const</span> d <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>      <span class="token comment">// any</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果希望避免这种情况，则需要打开编译选项<code>strictNullChecks</code>。（vscode默认打开）</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token comment">// 打开编译设置 strictNullChecks</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>   <span class="token comment">// undefined</span>
<span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>

<span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">// null</span>
<span class="token keyword">const</span> d <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>      <span class="token comment">// null</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，打开编译设置<code>strictNullChecks</code>以后，赋值为<code>undefined</code>的变量会被推断为<code>undefined</code>类型，赋值为<code>null</code>的变量会被推断为<code>null</code>类型。</p><h3 id="_2、包装对象类型" tabindex="-1"><a class="header-anchor" href="#_2、包装对象类型" aria-hidden="true">#</a> 2、包装对象类型</h3><h4 id="_2-1、包装对象的概念" tabindex="-1"><a class="header-anchor" href="#_2-1、包装对象的概念" aria-hidden="true">#</a> 2.1、包装对象的概念</h4><p>JavaScript 的8种类型之中（boolean，number，bigint，stristring，symbol，undefined，null，object），<code>undefined</code>和<code>null</code>其实是两个特殊值，<code>object</code>属于复合类型，剩下的五种属于原始类型（primitive value），代表最基本的、不可再分的值。</p><ul><li>boolean、string、number、bigint、symbol</li></ul><p>上面这五种原始类型的值，都有对应的包装对象（wrapper object）。所谓“包装对象”，指的是这些值在需要时，会自动产生的对象。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token string">&#39;hello&#39;</span><span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// &#39;e&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面示例中，字符串<code>hello</code>执行了<code>charAt()</code>方法。但是，在 JavaScript 语言中，只有对象才有方法，原始类型的值本身没有方法。这行代码之所以可以运行，就是因为在调用方法时，字符串会<strong>自动转为包装对象</strong>，<code>charAt()</code>方法其实是定义在包装对象上。</p><p>五种包装对象之中，symbol 类型和 bigint 类型无法直接获取它们的包装对象（即<code>Symbol()</code>和<code>BigInt()</code>不能作为构造函数使用），但是剩下三种可以。</p><ul><li><code>Boolean()</code>、<code>String()</code>、<code>Number()</code></li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&#39;hello&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">typeof</span> s <span class="token comment">// &#39;object&#39;</span>
s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// &#39;e&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>::warning</p><p>注意，<code>String()</code>只有当作构造函数使用时（即带有<code>new</code>命令调用），才会返回包装对象。如果当作普通函数使用（不带有<code>new</code>命令），返回就是一个普通字符串。其他两个构造函数<code>Number()</code>和<code>Boolean()</code>也是如此。</p><p>:::</p><h4 id="_2-2、包装对象类型与字面量类型" tabindex="-1"><a class="header-anchor" href="#_2-2、包装对象类型与字面量类型" aria-hidden="true">#</a> 2.2、包装对象类型与字面量类型</h4><p>由于包装对象的存在，导致每一个原始类型的值都有包装<strong>对象</strong>和<strong>字面量</strong>两种情况。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token string">&#39;hello&#39;</span> <span class="token comment">// 字面量</span>
<span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&#39;hello&#39;</span><span class="token punctuation">)</span> <span class="token comment">// 包装对象</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>为了区分这两种情况，TypeScript 对五种原始类型分别提供了大写和小写两种类型。</p><ul><li>Boolean 和 boolean</li><li>String 和 string</li><li>Number 和 number</li><li>BigInt 和 bigint</li><li>Symbol 和 symbol</li></ul><p>其中，大写类型同时包含包装对象和字面量两种情况，小写类型只包含字面量，不包含包装对象。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> s1<span class="token operator">:</span>String <span class="token operator">=</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">;</span> <span class="token comment">// 正确</span>
<span class="token keyword">const</span> s2<span class="token operator">:</span>String <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&#39;hello&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 正确</span>
<span class="token keyword">const</span> s3<span class="token operator">:</span><span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">;</span> <span class="token comment">// 正确</span>
<span class="token keyword">const</span> s4<span class="token operator">:</span><span class="token builtin">string</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&#39;hello&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 报错 基本类型不能接受包装类型</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>建议只使用小写类型，不使用大写类型。因为绝大部分使用原始类型的场合，都是使用字面量，不使用包装对象。<br> 而且，TypeScript 把很多内置方法的参数，定义成小写类型，使用大写类型会报错。</p></div><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> n1<span class="token operator">:</span><span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> n2<span class="token operator">:</span>Number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>n1<span class="token punctuation">)</span> <span class="token comment">// 1</span>
Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>n2<span class="token punctuation">)</span> <span class="token comment">// 报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>Math.abs()</code>方法的参数类型被定义成小写的<code>number</code>，传入大写的<code>Number</code>类型就会报错。</p><p>上一小节说过，<code>Symbol()</code>和<code>BigInt()</code>这两个函数不能当作构造函数使用，所以没有办法直接获得 symbol 类型和 bigint 类型的包装对象，除非使用下面的写法。但是，它们没有使用场景，因此<code>Symbol</code>和<code>BigInt</code>这两个类型虽然存在，但是完全没有使用的理由。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> a<span class="token operator">:</span>Symbol <span class="token operator">=</span> <span class="token function">Object</span><span class="token punctuation">(</span><span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> b<span class="token operator">:</span>BigInt <span class="token operator">=</span> <span class="token function">Object</span><span class="token punctuation">(</span><span class="token function">BigInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，得到的就是 Symbol 和 BigInt 的包装对象，但是没有使用的意义。</p><h3 id="_3、object-类型与-object-类型" tabindex="-1"><a class="header-anchor" href="#_3、object-类型与-object-类型" aria-hidden="true">#</a> 3、Object 类型与 object 类型</h3><p>TypeScript 的<strong>对象类型</strong>也有大写<code>Object</code>和小写<code>object</code>两种。</p><h4 id="_3-1、object-类型" tabindex="-1"><a class="header-anchor" href="#_3-1、object-类型" aria-hidden="true">#</a> 3.1、Object 类型</h4><p>大写的<code>Object</code>类型代表 JavaScript 语言里面的广义对象。所有可以转成对象的值，都是<code>Object</code>类型，这囊括了几乎所有的值。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> obj<span class="token operator">:</span>Object<span class="token punctuation">;</span>
 
obj <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
obj <span class="token operator">=</span> <span class="token string">&#39;hi&#39;</span><span class="token punctuation">;</span>
obj <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
obj <span class="token operator">=</span> <span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token number">123</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
obj <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function-variable function">obj</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>

obj <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span> <span class="token comment">// 报错</span>
obj <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，原始类型值、对象、数组、函数都是合法的<code>Object</code>类型。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>事实上，除了<code>undefined</code>和<code>null</code>这两个值不能转为对象，其他任何值都可以赋值给<code>Object</code>类型。</p><p>上面示例中，<code>undefined</code>和<code>null</code>赋值给<code>Object</code>类型，就会报错。</p></div><p>另外，空对象<code>{}</code>是<code>Object</code>类型的简写形式，所以使用<code>Object</code>时常常用空对象代替。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> obj<span class="token operator">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// {} 是 Object 的简写形式</span>
 
obj <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
obj <span class="token operator">=</span> <span class="token string">&#39;hi&#39;</span><span class="token punctuation">;</span>
obj <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
obj <span class="token operator">=</span> <span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token number">123</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
obj <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function-variable function">obj</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>obj</code>的类型是空对象<code>{}</code>，就代表<code>Object</code>类型。</p><p>显然，无所不包的<code>Object</code>类型既不符合直觉，也不方便使用。</p><h4 id="_3-2、object-类型" tabindex="-1"><a class="header-anchor" href="#_3-2、object-类型" aria-hidden="true">#</a> 3.2、object 类型</h4><p>小写的<code>object</code>类型代表 JavaScript 里面的狭义对象，即可以用字面量表示的对象，只包含对象、数组和函数，<strong>不包括原始类型</strong>的值。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> obj<span class="token operator">:</span>object<span class="token punctuation">;</span>
 
obj <span class="token operator">=</span> <span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token number">123</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
obj <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function-variable function">obj</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
obj <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 报错</span>
obj <span class="token operator">=</span> <span class="token string">&#39;hi&#39;</span><span class="token punctuation">;</span> <span class="token comment">// 报错</span>
obj <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>object</code>类型不包含原始类型值，只包含<strong>对象、数组和函数</strong>。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>所以，建议总是使用小写类型<code>object</code>，不使用大写类型<code>Object</code>。</p><p>注意，无论是大写的<code>Object</code>类型，还是小写的<code>object</code>类型，都只包含 JavaScript 内置对象原生的属性和方法，用户自定义的属性和方法都不存在于这两个类型之中。</p></div><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> o1<span class="token operator">:</span>Object <span class="token operator">=</span> <span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> o2<span class="token operator">:</span>object <span class="token operator">=</span> <span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

o1<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 正确</span>
o1<span class="token punctuation">.</span>foo <span class="token comment">// 报错</span>

o2<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 正确</span>
o2<span class="token punctuation">.</span>foo <span class="token comment">// 报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>toString()</code>是对象的原生方法，可以正确访问。<code>foo</code>是自定义属性，访问就会报错。<br> 如何描述对象的自定义属性，详见《对象类型》一章。</p><h3 id="_4、undefined-和-null-的特殊性" tabindex="-1"><a class="header-anchor" href="#_4、undefined-和-null-的特殊性" aria-hidden="true">#</a> 4、undefined 和 null 的特殊性</h3><div class="hint-container info"><p class="hint-container-title">相关信息</p><p><code>undefined</code>和<code>null</code>既是 <strong>值</strong>，又是 <strong>类型</strong>。</p><p>作为值，它们有一个特殊的地方：任何<strong>其他类型</strong>的变量都可以赋值为<code>undefined</code>或<code>null</code>。</p></div><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> age<span class="token operator">:</span><span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">24</span><span class="token punctuation">;</span>

age <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>      <span class="token comment">// 正确</span>
age <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span> <span class="token comment">// 正确</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中，变量<code>age</code>的类型是<code>number</code>，但是赋值为<code>null</code>或<code>undefined</code>并不报错。</p><p>这并不是因为<code>undefined</code>和<code>null</code>包含在<code>number</code>类型里面，而是故意这样设计<br> 任何类型的变量都可以赋值为<code>undefined</code>和<code>null</code>，以便跟 JavaScript 的行为保持一致。</p><p>JavaScript 的行为是，变量如果等于<code>undefined</code>就表示还没有赋值，如果等于<code>null</code>就表示值为空。所以，TypeScript 就允许了任何类型的变量都可以赋值为这两个值。</p><p>但是有时候，这并不是开发者想要的行为，也不利于发挥类型系统的优势。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> obj<span class="token operator">:</span>object <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
obj<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 编译不报错，运行就报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>obj</code>等于<code>undefined</code>，编译不会报错。但是，实际执行时，调用<code>obj.toString()</code>就报错了，因为<code>undefined</code>不是对象，没有这个方法。</p><p>为了避免这种情况，及早发现错误，TypeScript 提供了一个编译选项<code>strictNullChecks</code>。<br> 只要打开这个选项，<code>undefined</code>和<code>null</code>就不能赋值给其他类型的变量（除了<code>any</code>类型和<code>unknown</code>类型）。</p><p>下面是 tsc 命令打开这个编译选项的例子。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token comment">// tsc --strictNullChecks app.ts</span>

<span class="token keyword">let</span> age<span class="token operator">:</span><span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">24</span><span class="token punctuation">;</span>

age <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>      <span class="token comment">// 报错</span>
age <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span> <span class="token comment">// 报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，打开<code>--strictNullChecks</code>以后，<code>number</code>类型的变量<code>age</code>就不能赋值为<code>undefined</code>和<code>null</code>。</p><p>这个选项在配置文件**<code>tsconfig.json</code>**的写法如下。</p><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;compilerOptions&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">&quot;strictNullChecks&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>打开<code>strictNullChecks</code>以后，<code>undefined</code>和<code>null</code>这两种值也不能互相赋值了。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token comment">// 打开 strictNullChecks</span>

<span class="token keyword">let</span> x<span class="token operator">:</span><span class="token keyword">undefined</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 报错</span>
<span class="token keyword">let</span> y<span class="token operator">:</span><span class="token keyword">null</span> <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span> <span class="token comment">// 报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>undefined</code>类型的变量赋值为<code>null</code>，或者<code>null</code>类型的变量赋值为<code>undefind</code>，都会报错。</p><p>总之，打开<code>strictNullChecks</code>以后，<code>undefined</code>和<code>null</code>只能赋值给自身，或者<code>any</code>类型和<code>unknown</code>类型的变量。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> x<span class="token operator">:</span><span class="token builtin">any</span>     <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> y<span class="token operator">:</span><span class="token builtin">unknown</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_5、值类型" tabindex="-1"><a class="header-anchor" href="#_5、值类型" aria-hidden="true">#</a> 5、值类型</h3><p>TypeScript 规定，单个值也是一种类型，称为“值类型”。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> x<span class="token operator">:</span><span class="token string">&#39;hello&#39;</span><span class="token punctuation">;</span>

x <span class="token operator">=</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">;</span> <span class="token comment">// 正确</span>
x <span class="token operator">=</span> <span class="token string">&#39;world&#39;</span><span class="token punctuation">;</span> <span class="token comment">// 报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>x</code>的类型是字符串<code>hello</code>，导致它只能赋值为这个字符串，赋值为其他字符串就会报错。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>TypeScript 推断类型时，遇到<code>const</code>命令声明的变量，如果代码里面没有注明类型，就会推断该变量是值类型。</p></div><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token comment">// x 的类型是 &quot;https&quot;</span>
<span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token string">&#39;https&#39;</span><span class="token punctuation">;</span>

<span class="token comment">// y 的类型是 string</span>
<span class="token keyword">const</span> y<span class="token operator">:</span><span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">&#39;https&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>x</code>是<code>const</code>命令声明的，TypeScript 就会推断它的类型是值<code>https</code>，而不是<code>string</code>类型。</p><p>这样推断是合理的，因为<code>const</code>命令声明的变量，一旦声明就不能改变，相当于常量。值类型就意味着不能赋为其他值。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>注意，<code>const</code>命令声明的变量，如果赋值为对象，并不会推断为值类型。</p></div><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token comment">// x 的类型是 { foo: number }</span>
<span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>x</code>没有被推断为值类型，而是推断属性<code>foo</code>的类型是<code>number</code>。<br> 这是因为 JavaScript 里面，<strong><code>const</code>变量赋值为对象时，属性值是可以改变的</strong>。</p><p>值类型可能会出现一些很奇怪的报错。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> x<span class="token operator">:</span><span class="token number">5</span> <span class="token operator">=</span> <span class="token number">4</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面示例中，等号左侧的类型是数值<code>5</code>，等号右侧<code>4 + 1</code>的类型，TypeScript 推测为<code>number</code>。由于<code>5</code>是<code>number</code>的子类型，<code>number</code>是<code>5</code>的父类型，父类型不能赋值给子类型，所以报错了（详见本章后文）。</p><p>但是，反过来是可以的，子类型可以赋值给父类型。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> x<span class="token operator">:</span><span class="token number">5</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> y<span class="token operator">:</span><span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">4</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>

x <span class="token operator">=</span> y<span class="token punctuation">;</span> <span class="token comment">// 报错</span>
y <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">// 正确</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>x</code>属于子类型，变量<code>y</code>属于父类型。<code>y</code>不能赋值为子类型<code>x</code>，但是反过来是可以的。</p><p>如果一定要让子类型可以赋值为父类型的值，就要用到类型断言（详见《类型断言》一章）。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> x<span class="token operator">:</span><span class="token number">5</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// 正确</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面示例中，在<code>4 + 1</code>后面加上<code>as 5</code>，就是告诉编译器，可以把<code>4 + 1</code>的类型视为值类型<code>5</code>，这样就不会报错了。</p><p>只包含单个值的值类型，用处不大。实际开发中，往往将多个值结合，作为联合类型使用。</p><h3 id="_6、联合类型" tabindex="-1"><a class="header-anchor" href="#_6、联合类型" aria-hidden="true">#</a> 6、联合类型 |</h3><p>联合类型（union types）指的是多个类型组成的一个新类型，使用符号<code>|</code>表示。</p><p>联合类型<code>A|B</code>表示，任何一个类型只要属于<code>A</code>或<code>B</code>，就属于联合类型<code>A|B</code>。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> x<span class="token operator">:</span><span class="token builtin">string</span><span class="token operator">|</span><span class="token builtin">number</span><span class="token punctuation">;</span>

x <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment">// 正确</span>
x <span class="token operator">=</span> <span class="token string">&#39;abc&#39;</span><span class="token punctuation">;</span> <span class="token comment">// 正确</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>x</code>就是联合类型<code>string|number</code>，表示它的值既可以是字符串，也可以是数值。</p><p>联合类型可以与值类型相结合，表示一个变量的值有若干种可能。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> setting<span class="token operator">:</span><span class="token boolean">true</span><span class="token operator">|</span><span class="token boolean">false</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> gender<span class="token operator">:</span><span class="token string">&#39;male&#39;</span><span class="token operator">|</span><span class="token string">&#39;female&#39;</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> rainbowColor<span class="token operator">:</span><span class="token string">&#39;赤&#39;</span><span class="token operator">|</span><span class="token string">&#39;橙&#39;</span><span class="token operator">|</span><span class="token string">&#39;黄&#39;</span><span class="token operator">|</span><span class="token string">&#39;绿&#39;</span><span class="token operator">|</span><span class="token string">&#39;青&#39;</span><span class="token operator">|</span><span class="token string">&#39;蓝&#39;</span><span class="token operator">|</span><span class="token string">&#39;紫&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的示例都是由值类型组成的联合类型，非常清晰地表达了变量的取值范围。其中，<code>true|false</code>其实就是布尔类型<code>boolean</code>。</p><p>前面提到，打开编译选项<code>strictNullChecks</code>后，其他类型的变量不能赋值为<code>undefined</code>或<code>null</code>。这时，如果某个变量确实可能包含空值，就可以采用联合类型的写法。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> name<span class="token operator">:</span><span class="token builtin">string</span><span class="token operator">|</span><span class="token keyword">null</span><span class="token punctuation">;</span>

name <span class="token operator">=</span> <span class="token string">&#39;John&#39;</span><span class="token punctuation">;</span>
name <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>name</code>的值可以是字符串，也可以是<code>null</code>。</p><p>联合类型的第一个成员前面，也可以加上竖杠<code>|</code>，这样便于多行书写。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> x<span class="token operator">:</span>
  <span class="token operator">|</span> <span class="token string">&#39;one&#39;</span>
  <span class="token operator">|</span> <span class="token string">&#39;two&#39;</span>
  <span class="token operator">|</span> <span class="token string">&#39;three&#39;</span>
  <span class="token operator">|</span> <span class="token string">&#39;four&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果一个变量有多种类型，读取该变量时，往往需要进行“类型缩小”（type narrowing），区分该值到底属于哪一种类型，然后再进一步处理。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token comment">// 未进行类型缩小</span>
<span class="token keyword">function</span> <span class="token function">printId</span><span class="token punctuation">(</span>
  id<span class="token operator">:</span><span class="token builtin">number</span><span class="token operator">|</span><span class="token builtin">string</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>id<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 报错</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解决方法就是对参数<code>id</code>做一下类型缩小，确定它的类型以后再进行处理。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">printId</span><span class="token punctuation">(</span>
  id<span class="token operator">:</span><span class="token builtin">number</span><span class="token operator">|</span><span class="token builtin">string</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> id <span class="token operator">===</span> <span class="token string">&#39;string&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>id<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，函数体内部会判断一下变量<code>id</code>的类型，如果是字符串，就对其执行<code>toUpperCase()</code>方法。</p><p>“类型缩小”是 TypeScript 处理联合类型的标准方法，凡是遇到可能为多种类型的场合，都需要先缩小类型，再进行处理。<br> 实际上，联合类型本身可以看成是一种“<strong>类型放大</strong>”（type widening），处理时就需要“<strong>类型缩小</strong>”（type narrowing）。</p><p>下面是“类型缩小”的另一个例子。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">getPort</span><span class="token punctuation">(</span>
  scheme<span class="token operator">:</span> <span class="token string">&#39;http&#39;</span><span class="token operator">|</span><span class="token string">&#39;https&#39;</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>scheme<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token string">&#39;http&#39;</span><span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token number">80</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token string">&#39;https&#39;</span><span class="token operator">:</span>
      <span class="token keyword">return</span> <span class="token number">443</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，函数体内部对参数变量<code>scheme</code>进行类型缩小，根据不同的值类型，返回不同的结果。</p><h3 id="_7、交叉类型" tabindex="-1"><a class="header-anchor" href="#_7、交叉类型" aria-hidden="true">#</a> 7、交叉类型 &amp;</h3><p>交叉类型（intersection types）指的多个类型组成的一个新类型，使用符号<code>&amp;</code>表示。</p><p>交叉类型<code>A&amp;B</code>表示，任何一个类型必须<strong>同时属于<code>A</code>和<code>B</code></strong>，才属于交叉类型<code>A&amp;B</code>，即交叉类型同时满足<code>A</code>和<code>B</code>的特征。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> x<span class="token operator">:</span><span class="token builtin">number</span><span class="token operator">&amp;</span><span class="token builtin">string</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面示例中，变量<code>x</code>同时是数值和字符串，这当然是不可能的，所以 TypeScript 会认为<code>x</code>的类型实际是**<code>never</code>**。</p><p>交叉类型的主要用途是表示<strong>对象的合成</strong>。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> obj<span class="token operator">:</span>
  <span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span> <span class="token operator">&amp;</span>
  <span class="token punctuation">{</span> bar<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  foo<span class="token operator">:</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">,</span>
  bar<span class="token operator">:</span> <span class="token string">&#39;world&#39;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>obj</code>同时具有属性<code>foo</code>和属性<code>bar</code>。</p><p>交叉类型常常用来为对象类型添加新属性。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token operator">=</span> <span class="token constant">A</span> <span class="token operator">&amp;</span> <span class="token punctuation">{</span> bar<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，类型<code>B</code>是一个交叉类型，用来在<code>A</code>的基础上增加了属性<code>bar</code>。</p><h3 id="_8、type-命令" tabindex="-1"><a class="header-anchor" href="#_8、type-命令" aria-hidden="true">#</a> 8、type 命令</h3><p><code>type</code>命令用来定义一个类型的别名。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Age</span> <span class="token operator">=</span> <span class="token builtin">number</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> age<span class="token operator">:</span>Age <span class="token operator">=</span> <span class="token number">55</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>type</code>命令为<code>number</code>类型定义了一个别名<code>Age</code>。这样就能像使用<code>number</code>一样，使用<code>Age</code>作为类型。</p><p>别名可以让类型的名字变得更有意义，也能增加代码的可读性，还可以使复杂类型用起来更方便，便于以后修改变量的类型。</p><p><strong>别名不允许重名</strong>。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Color</span> <span class="token operator">=</span> <span class="token string">&#39;red&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">Color</span> <span class="token operator">=</span> <span class="token string">&#39;blue&#39;</span><span class="token punctuation">;</span> <span class="token comment">// 报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，同一个别名<code>Color</code>声明了两次，就报错了。</p><p>别名的作用域是<strong>块级作用域</strong>。这意味着，代码块内部定义的别名，影响不到外部。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Color</span> <span class="token operator">=</span> <span class="token string">&#39;red&#39;</span><span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0.5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">type</span> <span class="token class-name">Color</span> <span class="token operator">=</span> <span class="token string">&#39;blue&#39;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>if</code>代码块内部的类型别名<code>Color</code>，跟外部的<code>Color</code>是不一样的。</p><p>别名支持使用表达式，也可以在定义一个别名时，使用另一个别名，即<strong>别名允许嵌套</strong>。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">World</span> <span class="token operator">=</span> <span class="token string">&quot;world&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">Greeting</span> <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">hello </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>World<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，别名<code>Greeting</code>使用了模板字符串，读取另一个别名<code>World</code>。</p><p><code>type</code>命令属于类型相关的代码，编译成 JavaScript 的时候，会被全部删除。</p><h3 id="_9、typeof-运算符" tabindex="-1"><a class="header-anchor" href="#_9、typeof-运算符" aria-hidden="true">#</a> 9、typeof 运算符</h3><p>JavaScript 语言中，typeof 运算符是一个一元运算符，返回一个字符串，代表操作数的类型。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">typeof</span> <span class="token string">&#39;foo&#39;</span><span class="token punctuation">;</span> <span class="token comment">// &#39;string&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面示例中，<code>typeof</code>运算符返回字符串<code>foo</code>的类型是<code>string</code>。</p><div class="hint-container warning"><p class="hint-container-title">注意</p><p>注意，这时 typeof 的操作数是一个<strong>值</strong>。</p></div><p>JavaScript 里面，<code>typeof</code>运算符只可能返回八种结果，而且都是字符串。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">typeof</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span> <span class="token comment">// &quot;undefined&quot;</span>
<span class="token keyword">typeof</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// &quot;boolean&quot;</span>
<span class="token keyword">typeof</span> <span class="token number">1337</span><span class="token punctuation">;</span> <span class="token comment">// &quot;number&quot;</span>
<span class="token keyword">typeof</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">;</span> <span class="token comment">// &quot;string&quot;</span>
<span class="token keyword">typeof</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// &quot;object&quot;</span>
<span class="token keyword">typeof</span> parseInt<span class="token punctuation">;</span> <span class="token comment">// &quot;function&quot;</span>
<span class="token keyword">typeof</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;symbol&quot;</span>
<span class="token keyword">typeof</span> <span class="token number">127n</span> <span class="token comment">// &quot;bigint&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>TypeScript 将<code>typeof</code>运算符移植到了<strong>类型</strong>运算，它的操作数依然是一个值，但是返回的不是字符串，而是该值的 TypeScript 类型。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T0</span></span> <span class="token operator">=</span> <span class="token keyword">typeof</span> a<span class="token punctuation">;</span>   <span class="token comment">// { x: number }</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T1</span></span> <span class="token operator">=</span> <span class="token keyword">typeof</span> a<span class="token punctuation">.</span>x<span class="token punctuation">;</span> <span class="token comment">// number</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>typeof a</code>表示返回变量<code>a</code>的 TypeScript 类型（<code>{ x: number }</code>）。同理，<code>typeof a.x</code>返回的是属性<code>x</code>的类型（<code>number</code>）。</p><p>这种用法的<code>typeof</code>返回的是 TypeScript 类型，所以只能用在<strong>类型运算</strong>之中（即跟类型相关的代码之中），不能用在<strong>值运算</strong>。</p><p>也就是说，同一段代码可能存在两种<code>typeof</code>运算符，一种用在值相关的 JavaScript 代码部分，另一种用在类型相关的 TypeScript 代码部分。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> b<span class="token operator">:</span><span class="token keyword">typeof</span> a<span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> a <span class="token operator">===</span> <span class="token string">&#39;number&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  b <span class="token operator">=</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，用到了两个<code>typeof</code>，第一个是类型运算，第二个是值运算。它们是不一样的，不要混淆。</p><p>JavaScript 的 typeof 遵守 JavaScript 规则，TypeScript 的 typeof 遵守 TypeScript 规则。<br> 它们的一个重要区别在于，编译后，前者会保留，后者会被全部删除。</p><p>上例的代码编译结果如下。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> b<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> a <span class="token operator">===</span> <span class="token string">&#39;number&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    b <span class="token operator">=</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，只保留了原始代码的第二个 typeof，删除了第一个 typeof。</p><p>由于编译时不会进行 JavaScript 的值运算，所以TypeScript 规定，typeof 的参数只能是<strong>标识符</strong>，不能是需要运算的表达式。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T</span></span> <span class="token operator">=</span> <span class="token keyword">typeof</span> <span class="token function">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面示例会报错，原因是 typeof 的参数不能是一个值的运算式，而<code>Date()</code>需要运算才知道结果。</p><p>另外，<code>typeof</code>命令的参数不能是类型。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Age</span> <span class="token operator">=</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">MyAge</span> <span class="token operator">=</span> <span class="token keyword">typeof</span> Age<span class="token punctuation">;</span> <span class="token comment">// 报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>Age</code>是一个类型别名，用作<code>typeof</code>命令的参数就会报错。</p><p>typeof 是一个很重要的 TypeScript 运算符，有些场合不知道某个变量<code>foo</code>的类型，这时使用<code>typeof foo</code>就可以获得它的类型。</p><h3 id="_10、块级类型声明" tabindex="-1"><a class="header-anchor" href="#_10、块级类型声明" aria-hidden="true">#</a> 10、块级类型声明</h3><p>TypeScript 支持块级类型声明，即类型可以声明在代码块（用大括号表示）里面，并且只在当前代码块有效。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T</span></span> <span class="token operator">=</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> v<span class="token operator">:</span><span class="token constant">T</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T</span></span> <span class="token operator">=</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> v<span class="token operator">:</span><span class="token constant">T</span> <span class="token operator">=</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，存在两个代码块，其中分别有一个类型<code>T</code>的声明。这两个声明都只在自己的代码块内部有效，在代码块外部无效。</p><h3 id="_11、类型的兼容" tabindex="-1"><a class="header-anchor" href="#_11、类型的兼容" aria-hidden="true">#</a> 11、类型的兼容</h3><p>TypeScript 的类型存在兼容关系，某些类型可以兼容其他类型。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">T</span></span> <span class="token operator">=</span> <span class="token builtin">number</span><span class="token operator">|</span><span class="token builtin">string</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> a<span class="token operator">:</span><span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> b<span class="token operator">:</span><span class="token constant">T</span> <span class="token operator">=</span> a<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>a</code>和<code>b</code>的类型是不一样的，但是变量<code>a</code>赋值给变量<code>b</code>并不会报错。这时，我们就认为，<code>b</code>的类型兼容<code>a</code>的类型。</p><p>TypeScript 为这种情况定义了一个专门术语。如果类型<code>A</code>的值可以赋值给类型<code>B</code>，那么类型<code>A</code>就称为类型<code>B</code>的<strong>子类型</strong>（subtype）。<br> 在上例中，类型<code>number</code>就是类型<code>number|string</code>的子类型。</p><p>TypeScript 的一个规则是，凡是可以使用父类型的地方，都可以使用子类型，但是反过来不行。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> a<span class="token operator">:</span><span class="token string">&#39;hi&#39;</span> <span class="token operator">=</span> <span class="token string">&#39;hi&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> b<span class="token operator">:</span><span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">;</span>

b <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">// 正确</span>
a <span class="token operator">=</span> b<span class="token punctuation">;</span> <span class="token comment">// 报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>hi</code>是<code>string</code>的子类型，<code>string</code>是<code>hi</code>的父类型。所以，变量<code>a</code>可以赋值给变量<code>b</code>，但是反过来就会报错。</p><p>之所以有这样的规则，是因为子类型继承了父类型的所有特征，所以可以用在父类型的场合。但是，子类型还可能有一些父类型没有的特征，所以父类型不能用在子类型的场合。</p><h2 id="五、数组" tabindex="-1"><a class="header-anchor" href="#五、数组" aria-hidden="true">#</a> 五、数组</h2><p>JavaScript 数组在 TypeScript 里面分成两种类型，分别是<strong>数组（array）<strong>和</strong>元组（tuple）</strong>。</p><h3 id="_1、简介" tabindex="-1"><a class="header-anchor" href="#_1、简介" aria-hidden="true">#</a> 1、简介</h3><p>TypeScript 数组有一个根本特征：所有成员的<strong>类型必须相同</strong>，但是成员数量是不确定的，可以是无限数量的成员，也可以是零成员。</p><p>数组的类型有两种写法。第一种写法是在数组成员的类型后面，加上一对方括号。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> arr<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面示例中，数组<code>arr</code>的类型是<code>number[]</code>，其中<code>number</code>表示数组成员类型是<code>number</code>。</p><p>如果数组成员的类型比较复杂，可以写在圆括号里面。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> arr<span class="token operator">:</span><span class="token punctuation">(</span><span class="token builtin">number</span><span class="token operator">|</span><span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面示例中，数组<code>arr</code>的成员类型是<code>number|string</code>。</p><p>这个例子里面的圆括号是必须的，否则因为竖杠<code>|</code>的优先级低于<code>[]</code>，TypeScript 会把<code>number|string[]</code>理解成<code>number</code>和<code>string[]</code>的联合类型。</p><p>如果数组成员可以是任意类型，写成<code>any[]</code>。当然，这种写法是应该避免的。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> arr<span class="token operator">:</span><span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>数组类型的第二种写法是使用 TypeScript 内置的 <code>Array </code>接口。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> arr<span class="token operator">:</span><span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面示例中，数组<code>arr</code>的类型是<code>Array&lt;number&gt;</code>，其中<code>number</code>表示成员类型是<code>number</code>。</p><p>这种写法对于成员类型比较复杂的数组，代码<strong>可读性</strong>会稍微好一些。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> arr<span class="token operator">:</span><span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">|</span><span class="token builtin">string</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这种写法本质上属于泛型，详细解释参见《泛型》一章。<br> 另外，数组类型还有第三种写法，因为很少用到，本章就省略了，详见《interface 接口》一章。</p><p>数组类型声明了以后，成员数量是不限制的，任意数量的成员都可以，也可以是空数组。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> arr<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，数组<code>arr</code>无论有多少个成员，都是正确的。</p><p>这种规定的隐藏含义就是，数组的成员是可以动态变化的。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> arr<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

arr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
arr<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

arr <span class="token comment">// [1, 2]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，数组增加成员或减少成员，都是可以的。</p><p>正是由于成员数量可以动态变化，所以 TypeScript 不会对数组边界进行检查，越界访问数组并不会报错。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> arr<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> foo <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 正确</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>foo</code>的值是一个不存在的数组成员，TypeScript 并不会报错。</p><p>TypeScript 允许使用方括号读取数组成员的类型。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Names</span> <span class="token operator">=</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">Name</span> <span class="token operator">=</span> Names<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// string</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，类型<code>Names</code>是字符串数组，那么<code>Names[0]</code>返回的类型就是<code>string</code>。</p><p>由于数组成员的索引类型都是<code>number</code>，所以读取成员类型也可以写成下面这样。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Names</span> <span class="token operator">=</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">Name</span> <span class="token operator">=</span> Names<span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// string</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>Names[number]</code>表示数组<code>Names</code>所有数值索引的成员类型，所以返回<code>string</code>。</p><h3 id="_2、数组的类型推断" tabindex="-1"><a class="header-anchor" href="#_2、数组的类型推断" aria-hidden="true">#</a> 2、数组的类型推断</h3><p>如果数组变量没有声明类型，TypeScript 就会推断数组成员的类型。这时，推断行为会因为值的不同，而有所不同。</p><p>如果变量的初始值是空数组，那么 TypeScript 会推断数组类型是<code>any[]</code>。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token comment">// 推断为 any[]</span>
<span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>后面，为这个数组赋值时，TypeScript 会自动更新类型推断。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
arr <span class="token comment">// 推断为 any[]</span>

arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
arr <span class="token comment">// 推断类型为 number[]</span>

arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&#39;abc&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
arr <span class="token comment">// 推断类型为 (string|number)[]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>上面示例中，数组变量<code>arr</code>的初始值是空数组，然后随着新成员的加入，TypeScript 会自动修改推断的数组类型。</p><p>但是，类型推断的自动更新只发生初始值为空数组的情况。如果初始值不是空数组，类型推断就不会更新。</p></div><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token comment">// 推断类型为 number[]</span>
<span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">123</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&#39;abc&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，数组变量<code>arr</code>的初始值是<code>[123]</code>，TypeScript 就推断成员类型为<code>number</code>。新成员如果不是这个类型，TypeScript 就会报错，而不会更新类型推断。</p><h3 id="_3、只读数组-const-断言" tabindex="-1"><a class="header-anchor" href="#_3、只读数组-const-断言" aria-hidden="true">#</a> 3、只读数组，const 断言</h3><p>JavaScript 规定，<code>const</code>命令声明的数组变量是可以改变成员的。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，修改<code>const</code>命令声明的数组的成员是允许的。</p><p>但是，很多时候确实有声明为只读数组的需求，即不允许变动数组成员。</p><p>TypeScript 允许声明只读数组，方法是在数组类型前面加上<code>readonly</code>关键字。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> arr<span class="token operator">:</span><span class="token keyword">readonly</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 报错</span>
arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 报错</span>
<span class="token keyword">delete</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>TypeScript 将<code>readonly number[]</code>与<code>number[]</code>视为两种不一样的类型，后者是前者的子类型。</p><p>这是因为只读数组没有<code>pop()</code>、<code>push()</code>之类会改变原数组的方法，所以<code>number[]</code>的方法数量要多于<code>readonly number[]</code>，这意味着<code>number[]</code>其实是<code>readonly number[]</code>的子类型。</p><p>我们知道，子类型继承了父类型的所有特征，并加上了自己的特征，所以子类型<code>number[]</code>可以用于所有使用父类型的场合，反过来就不行。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> a1<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> a2<span class="token operator">:</span><span class="token keyword">readonly</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> a1<span class="token punctuation">;</span> <span class="token comment">// 正确</span>

a1 <span class="token operator">=</span> a2<span class="token punctuation">;</span> <span class="token comment">// 报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，子类型<code>number[]</code>可以赋值给父类型<code>readonly number[]</code>，但是反过来就会报错。</p><p>由于只读数组是数组的父类型，所以它不能代替数组。这一点很容易产生令人困惑的报错。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">getSum</span><span class="token punctuation">(</span>s<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> arr<span class="token operator">:</span><span class="token keyword">readonly</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token function">getSum</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token comment">// 报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，函数<code>getSum()</code>的参数<code>s</code>是一个数组，传入只读数组就会报错。原因就是只读数组是数组的父类型，父类型不能替代子类型。这个问题的解决方法是使用类型断言<code>getSum(arr as number[])</code>，详见《类型断言》一章。</p><div class="hint-container warning"><p class="hint-container-title">注意</p><p>注意，<code>readonly</code>关键字不能与数组的泛型写法一起使用。</p></div><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token comment">// 报错</span>
<span class="token keyword">const</span> arr<span class="token operator">:</span><span class="token keyword">readonly</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>readonly</code>与数组的泛型写法一起使用，就会报错。</p><p>实际上，TypeScript 提供了两个专门的泛型，用来生成只读数组的类型。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> a1<span class="token operator">:</span>ReadonlyArray<span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> a2<span class="token operator">:</span>Readonly<span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，泛型<code>ReadonlyArray&lt;T&gt;</code>和<code>Readonly&lt;T[]&gt;</code>都可以用来生成只读数组类型。两者尖括号里面的写法不一样，<code>Readonly&lt;T[]&gt;</code>的尖括号里面是整个数组（<code>number[]</code>），而<code>ReadonlyArray&lt;T&gt;</code>的尖括号里面是数组成员（<code>number</code>）。</p><p>只读数组还有一种声明方法，就是使用“const 断言”。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">as</span> <span class="token keyword">const</span><span class="token punctuation">;</span>

arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 报错 </span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>as const</code>告诉 TypeScript，推断类型时要把变量<code>arr</code>推断为只读数组，从而使得数组成员无法改变。</p><h3 id="_4、多维数组" tabindex="-1"><a class="header-anchor" href="#_4、多维数组" aria-hidden="true">#</a> 4、多维数组</h3><p>TypeScript 使用<code>T[][]</code>的形式，表示二维数组，<code>T</code>是最底层数组成员的类型。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">var</span> multi<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span>
  <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">24</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>multi</code>的类型是<code>number[][]</code>，表示它是一个二维数组，最底层的数组成员类型是<code>number</code>。</p><h2 id="六、元祖" tabindex="-1"><a class="header-anchor" href="#六、元祖" aria-hidden="true">#</a> 六、元祖</h2><h3 id="_1、简介-1" tabindex="-1"><a class="header-anchor" href="#_1、简介-1" aria-hidden="true">#</a> 1、简介</h3><p>元组（tuple）是 TypeScript 特有的数据类型，JavaScript 没有单独区分这种类型。</p><p>元组必须明确声明每个成员的类型。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> s<span class="token operator">:</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">boolean</span><span class="token punctuation">]</span>
  <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#39;a&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;b&#39;</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，元组<code>s</code>的前两个成员的类型是<code>string</code>，最后一个成员的类型是<code>boolean</code>。</p><p>元组类型的写法，与上一章的数组有一个重大差异。数组的成员类型写在方括号外面（<code>number[]</code>），元组的成员类型是写在方括号里面（<code>[number]</code>）。</p><p>TypeScript 的区分方法是，成员类型写在方括号里面的就是元组，写在外面的就是数组。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> a<span class="token operator">:</span><span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面示例中，变量<code>a</code>是一个元组，只有一个成员，类型是<code>number</code>。</p><p>使用元组时，必须明确给出类型声明（上例的<code>[number]</code>），不能省略，否则 TypeScript 会把一个值自动推断为数组。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token comment">// a 的类型为 (number | boolean)[]</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>a</code>的值其实是一个元组，但是 TypeScript 会将其推断为一个联合类型的数组，即<code>a</code>的类型为<code>(number | boolean)[]</code>。</p><p>元组成员的类型可以添加问号后缀（<code>?</code>），表示该成员是可选的。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> a<span class="token operator">:</span><span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token operator">?</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面示例中，元组<code>a</code>的第二个成员是可选的，可以省略。</p><div class="hint-container warning"><p class="hint-container-title">注意</p><p>注意，问号只能用于元组的尾部成员，也就是说，所有可选成员必须在必选成员之后。</p></div><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">myTuple</span> <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token builtin">number</span><span class="token punctuation">,</span>
  <span class="token builtin">number</span><span class="token punctuation">,</span>
  <span class="token builtin">number</span><span class="token operator">?</span><span class="token punctuation">,</span>
  <span class="token builtin">string</span><span class="token operator">?</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，元组<code>myTuple</code>的最后两个成员是可选的。也就是说，它的成员数量可能有两个、三个和四个。</p><p>由于需要声明每个成员的类型，所以大多数情况下，元组的成员数量是有限的，从类型声明就可以明确知道，元组包含多少个成员，越界的成员会报错。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> x<span class="token operator">:</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#39;a&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;b&#39;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

x<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&#39;c&#39;</span><span class="token punctuation">;</span> <span class="token comment">// 报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>x</code>是一个只有两个成员的元组，如果对第三个成员赋值就报错了。</p><p>但是，使用扩展运算符（<code>...</code>），可以表示不限成员数量的元组。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">NamedNums</span> <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token builtin">string</span><span class="token punctuation">,</span>
  <span class="token operator">...</span><span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> a<span class="token operator">:</span>NamedNums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#39;A&#39;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> b<span class="token operator">:</span>NamedNums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#39;B&#39;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，元组类型<code>NamedNums</code>的第一个成员是字符串，后面的成员使用扩展运算符来展开一个数组，从而实现了不定数量的成员。</p><p>扩展运算符用在元组的任意位置都可以，但是它后面只能是数组或元组。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">t1</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token operator">...</span><span class="token builtin">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">t2</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token operator">...</span><span class="token builtin">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">t3</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token builtin">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，扩展运算符分别在元组的尾部、中部和头部。</p><p>如果不确定元组成员的类型和数量，可以写成下面这样。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Tuple</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面示例中，元组<code>Tuple</code>可以放置任意数量和类型的成员。但是这样写，也就失去了使用元组和 TypeScript 的意义。</p><p>元组可以通过方括号，读取成员类型。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Tuple</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">Age</span> <span class="token operator">=</span> Tuple<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// number</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>Tuple[1]</code>返回1号位置的成员类型。</p><p>由于元组的成员都是数值索引，即索引类型都是<code>number</code>，所以可以像下面这样读取。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Tuple</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">,</span> Date<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">TupleEl</span> <span class="token operator">=</span> Tuple<span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// string|number|Date</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>Tuple[number]</code>表示元组<code>Tuple</code>的所有数值索引的成员类型，所以返回<code>string|number|Date</code>，即这个类型是三种值的联合类型。</p><h3 id="_2、只读元组" tabindex="-1"><a class="header-anchor" href="#_2、只读元组" aria-hidden="true">#</a> 2、只读元组</h3><p>元组也可以是只读的，不允许修改，有两种写法。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token comment">// 写法一</span>
<span class="token keyword">type</span> <span class="token class-name">t</span> <span class="token operator">=</span> <span class="token keyword">readonly</span> <span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">]</span>

<span class="token comment">// 写法二</span>
<span class="token keyword">type</span> <span class="token class-name">t</span> <span class="token operator">=</span> Readonly<span class="token operator">&lt;</span><span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，两种写法都可以得到只读元组，其中写法二是一个泛型，用到了工具类型<code>Readonly&lt;T&gt;</code>。</p><p>跟数组一样，只读元组是元组的父类型。所以，元组可以替代只读元组，而只读元组不能替代元组。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">t1</span> <span class="token operator">=</span> <span class="token keyword">readonly</span> <span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">t2</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> x<span class="token operator">:</span>t2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> y<span class="token operator">:</span>t1 <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">// 正确</span>

x <span class="token operator">=</span> y<span class="token punctuation">;</span> <span class="token comment">// 报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，类型<code>t1</code>是只读元组，类型<code>t2</code>是普通元组。<code>t2</code>类型可以赋值给<code>t1</code>类型，反过来就会报错。</p><p>由于只读元组不能替代元组，所以会产生一些令人困惑的报错。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">distanceFromOrigin</span><span class="token punctuation">(</span><span class="token punctuation">[</span>x<span class="token punctuation">,</span> y<span class="token punctuation">]</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span>x<span class="token operator">**</span><span class="token number">2</span> <span class="token operator">+</span> y<span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> point <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span> <span class="token keyword">as</span> <span class="token keyword">const</span><span class="token punctuation">;</span>

<span class="token function">distanceFromOrigin</span><span class="token punctuation">(</span>point<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，函数<code>distanceFromOrigin()</code>的参数是一个元组，传入只读元组就会报错，因为只读元组不能替代元组。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>读者可能注意到了，上例中<code>[3, 4] as const</code>的写法，在上一章讲到，生成的是只读数组，其实生成的同时也是只读元组。因为它生成的实际上是一个只读的“值类型”<code>readonly [3, 4]</code>，把它解读成只读数组或只读元组都可以。</p></div><p>上面示例报错的解决方法，就是使用类型断言，在最后一行将传入的参数断言为普通元组，详见《类型断言》一章。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token function">distanceFromOrigin</span><span class="token punctuation">(</span>
  point <span class="token keyword">as</span> <span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span>
<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3、成员数量的推断" tabindex="-1"><a class="header-anchor" href="#_3、成员数量的推断" aria-hidden="true">#</a> 3、成员数量的推断</h3><p>如果没有可选成员和扩展运算符，TypeScript 会推断出元组的成员数量（即元组长度）。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span>point<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>point<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 报错</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例会报错，原因是 TypeScript 发现元组<code>point</code>的长度是<code>2</code>，不可能等于<code>3</code>，这个判断无意义。</p><p>如果包含了可选成员，TypeScript 会推断出可能的成员数量。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span>
  point<span class="token operator">:</span><span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token operator">?</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token operator">?</span><span class="token punctuation">]</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>point<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 报错</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例会报错，原因是 TypeScript 发现<code>point.length</code>的类型是<code>1|2|3</code>，不可能等于<code>4</code>。</p><h3 id="_4、扩展运算符与成员数量" tabindex="-1"><a class="header-anchor" href="#_4、扩展运算符与成员数量" aria-hidden="true">#</a> 4、扩展运算符与成员数量</h3><p>扩展运算符（<code>...</code>）将数组（注意，不是元组）转换成一个逗号分隔的序列，这时 TypeScript 会认为这个序列的成员数量是不确定的，因为数组的成员数量是不确定的。</p><p>这导致如果函数调用时，使用扩展运算符传入函数参数，可能发生参数数量与数组长度不匹配的报错。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span>x<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">,</span> y<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">...</span>arr<span class="token punctuation">)</span> <span class="token comment">// 报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例会报错，原因是函数<code>add()</code>只能接受两个参数，但是传入的是<code>...arr</code>，TypeScript 认为转换后的参数个数是不确定的。</p><p>有些函数可以接受任意数量的参数，这时使用扩展运算符就不会报错。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">...</span>arr<span class="token punctuation">)</span> <span class="token comment">// 正确</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>console.log()</code>可以接受任意数量的参数，所以传入<code>...arr</code>就不会报错。</p><p>解决这个问题的一个方法，就是把成员数量不确定的数组，写成成员数量确定的元组，再使用扩展运算符。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> arr<span class="token operator">:</span><span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span>x<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">,</span> y<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">...</span>arr<span class="token punctuation">)</span> <span class="token comment">// 正确</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>arr</code>是一个拥有两个成员的元组，所以 TypeScript 能够确定<code>...arr</code>可以匹配函数<code>add()</code>的参数数量，就不会报错了。</p><p>另一种写法是使用<code>as const</code>断言。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token keyword">as</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面这种写法也可以，因为 TypeScript 会认为<code>arr</code>的类型是<code>readonly [1, 2]</code>，这是一个只读的值类型，可以当作数组，也可以当作元组。</p><h2 id="七、symbol-类型" tabindex="-1"><a class="header-anchor" href="#七、symbol-类型" aria-hidden="true">#</a> 七、symbol 类型</h2><h3 id="_1、简介-2" tabindex="-1"><a class="header-anchor" href="#_1、简介-2" aria-hidden="true">#</a> 1、简介</h3><p>Symbol 是 ES2015 新引入的一种原始类型的值。它类似于字符串，但是每一个 Symbol 值都是独一无二的，与其他任何值都不相等。</p><p>Symbol 值通过<code>Symbol()</code>函数生成。在 TypeScript 里面，Symbol 的类型使用<code>symbol</code>表示。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> x<span class="token operator">:</span><span class="token builtin">symbol</span> <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> y<span class="token operator">:</span><span class="token builtin">symbol</span> <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

x <span class="token operator">===</span> y <span class="token comment">// false</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>x</code>和<code>y</code>的类型都是<code>symbol</code>，且都用<code>Symbol()</code>生成，但是它们是不相等的。</p><h3 id="_2、unique-symbol" tabindex="-1"><a class="header-anchor" href="#_2、unique-symbol" aria-hidden="true">#</a> 2、unique symbol</h3><p><code>symbol</code>类型包含所有的 Symbol 值，但是无法表示某一个具体的 Symbol 值。</p><p>比如，<code>5</code>是一个具体的数值，就用<code>5</code>这个字面量来表示，这也是它的值类型。但是，Symbol 值不存在字面量，必须通过变量来引用，所以写不出只包含单个 Symbol 值的那种值类型。</p><p>为了解决这个问题，TypeScript 设计了<code>symbol</code>的一个子类型<code>unique symbol</code>，它表示单个的、某个具体的 Symbol 值。</p><p>因为<code>unique symbol</code>表示单个值，所以这个类型的变量是不能修改值的，只能用<code>const</code>命令声明，不能用<code>let</code>声明。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token comment">// 正确</span>
<span class="token keyword">const</span> x<span class="token operator">:</span>unique <span class="token builtin">symbol</span> <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 报错</span>
<span class="token keyword">let</span> y<span class="token operator">:</span>unique <span class="token builtin">symbol</span> <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>let</code>命令声明的变量，不能是<code>unique symbol</code>类型，会报错。</p><p><code>const</code>命令为变量赋值 Symbol 值时，变量类型默认就是<code>unique symbol</code>，所以类型可以省略不写。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> x<span class="token operator">:</span>unique <span class="token builtin">symbol</span> <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 等同于</span>
<span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>每个声明为<code>unique symbol</code>类型的变量，它们的值都是不一样的，其实属于两个值类型。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> a<span class="token operator">:</span>unique <span class="token builtin">symbol</span> <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> b<span class="token operator">:</span>unique <span class="token builtin">symbol</span> <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

a <span class="token operator">===</span> b <span class="token comment">// 报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>a</code>和变量<code>b</code>的类型虽然都是<code>unique symbol</code>，但其实是两个值类型。不同类型的值肯定是不相等的，所以最后一行就报错了。</p><p>由于 Symbol 类似于字符串，可以参考下面的例子来理解。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> a<span class="token operator">:</span><span class="token string">&#39;hello&#39;</span> <span class="token operator">=</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> b<span class="token operator">:</span><span class="token string">&#39;world&#39;</span> <span class="token operator">=</span> <span class="token string">&#39;world&#39;</span><span class="token punctuation">;</span>

a <span class="token operator">===</span> b <span class="token comment">// 报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>a</code>和<code>b</code>都是字符串，但是属于不同的值类型，不能使用严格相等运算符进行比较。</p><p>而且，由于变量<code>a</code>和<code>b</code>是两个类型，就不能把一个赋值给另一个。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> a<span class="token operator">:</span>unique <span class="token builtin">symbol</span> <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> b<span class="token operator">:</span>unique <span class="token builtin">symbol</span> <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">// 报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>a</code>和变量<code>b</code>的类型都是<code>unique symbol</code>，但是其实类型不同，所以把<code>a</code>赋值给<code>b</code>会报错。</p><p>上例变量<code>b</code>的类型，如果要写成与变量<code>a</code>同一个<code>unique symbol</code>值类型，只能写成类型为<code>typeof a</code>。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> a<span class="token operator">:</span>unique <span class="token builtin">symbol</span> <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> b<span class="token operator">:</span><span class="token keyword">typeof</span> a <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">// 正确</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>不过我们知道，相同参数的<code>Symbol.for()</code>方法会返回相同的 Symbol 值。TypeScript 目前无法识别这种情况，所以可能出现多个 unique symbol 类型的变量，等于同一个 Symbol 值的情况。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> a<span class="token operator">:</span>unique <span class="token builtin">symbol</span> <span class="token operator">=</span> Symbol<span class="token punctuation">.</span><span class="token function">for</span><span class="token punctuation">(</span><span class="token string">&#39;foo&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> b<span class="token operator">:</span>unique <span class="token builtin">symbol</span> <span class="token operator">=</span> Symbol<span class="token punctuation">.</span><span class="token function">for</span><span class="token punctuation">(</span><span class="token string">&#39;foo&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>a</code>和<code>b</code>是两个不同的值类型，但是它们的值其实是相等的。</p><p>unique symbol 类型是 symbol 类型的子类型，所以可以将前者赋值给后者，但是反过来就不行。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> a<span class="token operator">:</span>unique <span class="token builtin">symbol</span> <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> b<span class="token operator">:</span><span class="token builtin">symbol</span> <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">// 正确</span>

<span class="token keyword">const</span> c<span class="token operator">:</span>unique <span class="token builtin">symbol</span> <span class="token operator">=</span> b<span class="token punctuation">;</span> <span class="token comment">// 报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，unique symbol 类型（变量<code>a</code>）赋值给 symbol 类型（变量<code>b</code>）是可以的，但是 symbol 类型（变量<code>b</code>）赋值给 unique symbol 类型（变量<code>c</code>）会报错。</p><p>unique symbol 类型的一个作用，就是用作属性名，这可以保证不会跟其他属性名冲突。如果要把某一个特定的 Symbol 值当作属性名，那么它的类型只能是 unique symbol，不能是 symbol。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> x<span class="token operator">:</span>unique <span class="token builtin">symbol</span> <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> y<span class="token operator">:</span><span class="token builtin">symbol</span> <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> <span class="token comment">// 正确</span>
  <span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> <span class="token comment">// 报错</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>y</code>当作属性名，但是<code>y</code>的类型是 symbol，不是固定不变的值，导致报错。</p><p><code>unique symbol</code>类型也可以用作类（class）的属性值，但只能赋值给类的<code>readonly static</code>属性。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">class</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> <span class="token keyword">readonly</span> foo<span class="token operator">:</span>unique <span class="token builtin">symbol</span> <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，静态只读属性<code>foo</code>的类型就是<code>unique symbol</code>。注意，这时<code>static</code>和<code>readonly</code>两个限定符缺一不可，这是为了保证这个属性是固定不变的。</p><h3 id="_3、类型推断" tabindex="-1"><a class="header-anchor" href="#_3、类型推断" aria-hidden="true">#</a> 3、类型推断</h3><p>如果变量声明时没有给出类型，TypeScript 会推断某个 Symbol 值变量的类型。</p><p><code>let</code>命令声明的变量，推断类型为 symbol。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token comment">// 类型为 symbol</span>
<span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>const</code>命令声明的变量，推断类型为 unique symbol。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token comment">// 类型为 unique symbol</span>
<span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>但是，<code>const</code>命令声明的变量，如果赋值为另一个 symbol 类型的变量，则推断类型为 symbol。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 类型为 symbol</span>
<span class="token keyword">const</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>let</code>命令声明的变量，如果赋值为另一个 unique symbol 类型的变量，则推断类型还是 symbol。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 类型为 symbol</span>
<span class="token keyword">let</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="八、函数" tabindex="-1"><a class="header-anchor" href="#八、函数" aria-hidden="true">#</a> 八、函数</h2><h2 id="九、对象" tabindex="-1"><a class="header-anchor" href="#九、对象" aria-hidden="true">#</a> 九、对象</h2><h2 id="十、interface" tabindex="-1"><a class="header-anchor" href="#十、interface" aria-hidden="true">#</a> 十、interface</h2><h2 id="十一、类" tabindex="-1"><a class="header-anchor" href="#十一、类" aria-hidden="true">#</a> 十一、类</h2><h2 id="十二、泛型" tabindex="-1"><a class="header-anchor" href="#十二、泛型" aria-hidden="true">#</a> 十二、泛型</h2><h2 id="十三、enum" tabindex="-1"><a class="header-anchor" href="#十三、enum" aria-hidden="true">#</a> 十三、Enum</h2><h2 id="十四、类型推断" tabindex="-1"><a class="header-anchor" href="#十四、类型推断" aria-hidden="true">#</a> 十四、类型推断</h2><h2 id="十五、模块" tabindex="-1"><a class="header-anchor" href="#十五、模块" aria-hidden="true">#</a> 十五、模块</h2><h2 id="十六、namespace" tabindex="-1"><a class="header-anchor" href="#十六、namespace" aria-hidden="true">#</a> 十六、namespace</h2><h2 id="十七、装饰器" tabindex="-1"><a class="header-anchor" href="#十七、装饰器" aria-hidden="true">#</a> 十七、装饰器</h2><h2 id="十八、装饰器-旧语法" tabindex="-1"><a class="header-anchor" href="#十八、装饰器-旧语法" aria-hidden="true">#</a> 十八、装饰器（旧语法）</h2><h2 id="十九、declare-关键字" tabindex="-1"><a class="header-anchor" href="#十九、declare-关键字" aria-hidden="true">#</a> 十九、declare 关键字</h2><h2 id="二十、d-ts-类型声明文件" tabindex="-1"><a class="header-anchor" href="#二十、d-ts-类型声明文件" aria-hidden="true">#</a> 二十、d.ts 类型声明文件</h2><h2 id="二十一、运算符" tabindex="-1"><a class="header-anchor" href="#二十一、运算符" aria-hidden="true">#</a> 二十一、运算符</h2><h2 id="二十二、类型映射" tabindex="-1"><a class="header-anchor" href="#二十二、类型映射" aria-hidden="true">#</a> 二十二、类型映射</h2><h2 id="二十三、类型工具" tabindex="-1"><a class="header-anchor" href="#二十三、类型工具" aria-hidden="true">#</a> 二十三、类型工具</h2><h2 id="二十四、注释指令" tabindex="-1"><a class="header-anchor" href="#二十四、注释指令" aria-hidden="true">#</a> 二十四、注释指令</h2><h2 id="二十五、tsconfig-ts" tabindex="-1"><a class="header-anchor" href="#二十五、tsconfig-ts" aria-hidden="true">#</a> 二十五、tsconfig.ts</h2><h2 id="二十六、tsc命令" tabindex="-1"><a class="header-anchor" href="#二十六、tsc命令" aria-hidden="true">#</a> 二十六、tsc命令</h2></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/T4mako/T4mako.github.io/edit/main/src/code/前端开发/TypeScrip基础.md" rel="noopener noreferrer" target="_blank" aria-label="在 GitHub 上编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->在 GitHub 上编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><!----><!----></div></footer><nav class="vp-page-nav"><a class="vp-link nav-link prev" href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Promise.html"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><span class="font-icon icon iconfont icon-object" style=""></span>Promise 基础</div></a><!----></nav><div id="comment" class="waline-wrapper" darkmode="false" style="display:block;"><div data-waline provider="Waline"><!--v-if--><div class="wl-comment"><!--v-if--><div class="wl-panel"><div class="wl-header item3"><!--[--><div class="wl-header-item"><label for="wl-nick">昵称</label><input id="wl-nick" class="wl-input wl-nick" name="nick" type="text" value></div><div class="wl-header-item"><label for="wl-mail">邮箱</label><input id="wl-mail" class="wl-input wl-mail" name="mail" type="email" value></div><div class="wl-header-item"><label for="wl-link">网址</label><input id="wl-link" class="wl-input wl-link" name="link" type="text" value></div><!--]--></div><textarea id="wl-edit" class="wl-editor" placeholder="请留言。(填写邮箱可在被回复时收到邮件提醒)"></textarea><div class="wl-preview" style="display:none;"><hr><h4>预览:</h4><div class="wl-content"></div></div><div class="wl-footer"><div class="wl-actions"><a href="https://guides.github.com/features/mastering-markdown/" title="Markdown Guide" aria-label="Markdown is supported" class="wl-action" target="_blank" rel="noopener noreferrer"><svg width="16" height="16" ariaHidden="true"><path d="M14.85 3H1.15C.52 3 0 3.52 0 4.15v7.69C0 12.48.52 13 1.15 13h13.69c.64 0 1.15-.52 1.15-1.15v-7.7C16 3.52 15.48 3 14.85 3zM9 11H7V8L5.5 9.92 4 8v3H2V5h2l1.5 2L7 5h2v6zm2.99.5L9.5 8H11V5h2v3h1.5l-2.51 3.5z" fill="currentColor"></path></svg></a><button type="button" class="wl-action" title="表情" style="display:none;"><svg viewBox="0 0 1024 1024" width="24" height="24"><path d="M563.2 463.3 677 540c1.7 1.2 3.7 1.8 5.8 1.8.7 0 1.4-.1 2-.2 2.7-.5 5.1-2.1 6.6-4.4l25.3-37.8c1.5-2.3 2.1-5.1 1.6-7.8s-2.1-5.1-4.4-6.6l-73.6-49.1 73.6-49.1c2.3-1.5 3.9-3.9 4.4-6.6.5-2.7 0-5.5-1.6-7.8l-25.3-37.8a10.1 10.1 0 0 0-6.6-4.4c-.7-.1-1.3-.2-2-.2-2.1 0-4.1.6-5.8 1.8l-113.8 76.6c-9.2 6.2-14.7 16.4-14.7 27.5.1 11 5.5 21.3 14.7 27.4zM387 348.8h-45.5c-5.7 0-10.4 4.7-10.4 10.4v153.3c0 5.7 4.7 10.4 10.4 10.4H387c5.7 0 10.4-4.7 10.4-10.4V359.2c0-5.7-4.7-10.4-10.4-10.4zm333.8 241.3-41-20a10.3 10.3 0 0 0-8.1-.5c-2.6.9-4.8 2.9-5.9 5.4-30.1 64.9-93.1 109.1-164.4 115.2-5.7.5-9.9 5.5-9.5 11.2l3.9 45.5c.5 5.3 5 9.5 10.3 9.5h.9c94.8-8 178.5-66.5 218.6-152.7 2.4-5 .3-11.2-4.8-13.6zm186-186.1c-11.9-42-30.5-81.4-55.2-117.1-24.1-34.9-53.5-65.6-87.5-91.2-33.9-25.6-71.5-45.5-111.6-59.2-41.2-14-84.1-21.1-127.8-21.1h-1.2c-75.4 0-148.8 21.4-212.5 61.7-63.7 40.3-114.3 97.6-146.5 165.8-32.2 68.1-44.3 143.6-35.1 218.4 9.3 74.8 39.4 145 87.3 203.3.1.2.3.3.4.5l36.2 38.4c1.1 1.2 2.5 2.1 3.9 2.6 73.3 66.7 168.2 103.5 267.5 103.5 73.3 0 145.2-20.3 207.7-58.7 37.3-22.9 70.3-51.5 98.1-85 27.1-32.7 48.7-69.5 64.2-109.1 15.5-39.7 24.4-81.3 26.6-123.8 2.4-43.6-2.5-87-14.5-129zm-60.5 181.1c-8.3 37-22.8 72-43 104-19.7 31.1-44.3 58.6-73.1 81.7-28.8 23.1-61 41-95.7 53.4-35.6 12.7-72.9 19.1-110.9 19.1-82.6 0-161.7-30.6-222.8-86.2l-34.1-35.8c-23.9-29.3-42.4-62.2-55.1-97.7-12.4-34.7-18.8-71-19.2-107.9-.4-36.9 5.4-73.3 17.1-108.2 12-35.8 30-69.2 53.4-99.1 31.7-40.4 71.1-72 117.2-94.1 44.5-21.3 94-32.6 143.4-32.6 49.3 0 97 10.8 141.8 32 34.3 16.3 65.3 38.1 92 64.8 26.1 26 47.5 56 63.6 89.2 16.2 33.2 26.6 68.5 31 105.1 4.6 37.5 2.7 75.3-5.6 112.3z" fill="currentColor"></path></svg></button><button type="button" class="wl-action" title="表情包"><svg width="24" height="24" fill="currentcolor" viewBox="0 0 24 24"><path style="transform: translateY(0.5px)" d="M18.968 10.5H15.968V11.484H17.984V12.984H15.968V15H14.468V9H18.968V10.5V10.5ZM8.984 9C9.26533 9 9.49967 9.09367 9.687 9.281C9.87433 9.46833 9.968 9.70267 9.968 9.984V10.5H6.499V13.5H8.468V12H9.968V14.016C9.968 14.2973 9.87433 14.5317 9.687 14.719C9.49967 14.9063 9.26533 15 8.984 15H5.984C5.70267 15 5.46833 14.9063 5.281 14.719C5.09367 14.5317 5 14.2973 5 14.016V9.985C5 9.70367 5.09367 9.46933 5.281 9.282C5.46833 9.09467 5.70267 9.001 5.984 9.001H8.984V9ZM11.468 9H12.968V15H11.468V9V9Z"></path><path d="M18.5 3H5.75C3.6875 3 2 4.6875 2 6.75V18C2 20.0625 3.6875 21.75 5.75 21.75H18.5C20.5625 21.75 22.25 20.0625 22.25 18V6.75C22.25 4.6875 20.5625 3 18.5 3ZM20.75 18C20.75 19.2375 19.7375 20.25 18.5 20.25H5.75C4.5125 20.25 3.5 19.2375 3.5 18V6.75C3.5 5.5125 4.5125 4.5 5.75 4.5H18.5C19.7375 4.5 20.75 5.5125 20.75 6.75V18Z"></path></svg></button><input id="wl-image-upload" class="upload" type="file" accept=".png,.jpg,.jpeg,.webp,.bmp,.gif"><label for="wl-image-upload" class="wl-action" title="上传图片"><svg viewBox="0 0 1024 1024" width="24" height="24"><path d="M784 112H240c-88 0-160 72-160 160v480c0 88 72 160 160 160h544c88 0 160-72 160-160V272c0-88-72-160-160-160zm96 640c0 52.8-43.2 96-96 96H240c-52.8 0-96-43.2-96-96V272c0-52.8 43.2-96 96-96h544c52.8 0 96 43.2 96 96v480z" fill="currentColor"></path><path d="M352 480c52.8 0 96-43.2 96-96s-43.2-96-96-96-96 43.2-96 96 43.2 96 96 96zm0-128c17.6 0 32 14.4 32 32s-14.4 32-32 32-32-14.4-32-32 14.4-32 32-32zm462.4 379.2-3.2-3.2-177.6-177.6c-25.6-25.6-65.6-25.6-91.2 0l-80 80-36.8-36.8c-25.6-25.6-65.6-25.6-91.2 0L200 728c-4.8 6.4-8 14.4-8 24 0 17.6 14.4 32 32 32 9.6 0 16-3.2 22.4-9.6L380.8 640l134.4 134.4c6.4 6.4 14.4 9.6 24 9.6 17.6 0 32-14.4 32-32 0-9.6-4.8-17.6-9.6-24l-52.8-52.8 80-80L769.6 776c6.4 4.8 12.8 8 20.8 8 17.6 0 32-14.4 32-32 0-8-3.2-16-8-20.8z" fill="currentColor"></path></svg></label><button type="button" class="wl-action" title="预览"><svg viewBox="0 0 1024 1024" width="24" height="24"><path d="M710.816 654.301c70.323-96.639 61.084-230.578-23.705-314.843-46.098-46.098-107.183-71.109-172.28-71.109-65.008 0-126.092 25.444-172.28 71.109-45.227 46.098-70.756 107.183-70.756 172.106 0 64.923 25.444 126.007 71.194 172.106 46.099 46.098 107.184 71.109 172.28 71.109 51.414 0 100.648-16.212 142.824-47.404l126.53 126.006c7.058 7.06 16.297 10.979 26.406 10.979 10.105 0 19.343-3.919 26.402-10.979 14.467-14.467 14.467-38.172 0-52.723L710.816 654.301zm-315.107-23.265c-65.88-65.88-65.88-172.54 0-238.42 32.069-32.07 74.245-49.149 119.471-49.149 45.227 0 87.407 17.603 119.472 49.149 65.88 65.879 65.88 172.539 0 238.42-63.612 63.178-175.242 63.178-238.943 0zm0 0" fill="currentColor"></path><path d="M703.319 121.603H321.03c-109.8 0-199.469 89.146-199.469 199.38v382.034c0 109.796 89.236 199.38 199.469 199.38h207.397c20.653 0 37.384-16.645 37.384-37.299 0-20.649-16.731-37.296-37.384-37.296H321.03c-68.582 0-124.352-55.77-124.352-124.267V321.421c0-68.496 55.77-124.267 124.352-124.267h382.289c68.582 0 124.352 55.771 124.352 124.267V524.72c0 20.654 16.736 37.299 37.385 37.299 20.654 0 37.384-16.645 37.384-37.299V320.549c-.085-109.8-89.321-198.946-199.121-198.946zm0 0" fill="currentColor"></path></svg></button></div><div class="wl-info"><div class="wl-captcha-container"></div><div class="wl-text-number">0 <!--v-if-->  字</div><button type="button" class="wl-btn">登录</button><button type="submit" class="primary wl-btn" title="Cmd|Ctrl + Enter"><!--[-->提交<!--]--></button></div><div class="wl-gif-popup"><input type="text" placeholder="搜索表情包"><!--v-if--><div class="wl-loading"><svg width="30" height="30" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid"><circle cx="50" cy="50" fill="none" stroke="currentColor" strokeWidth="4" r="40" stroke-dasharray="85 30"><animateTransform attributeName="transform" type="rotate" repeatCount="indefinite" dur="1s" values="0 50 50;360 50 50" keyTimes="0;1"></animateTransform></circle></svg></div></div><div class="wl-emoji-popup"><!--[--><!--]--><!--v-if--></div></div></div><!--v-if--></div><div class="wl-meta-head"><div class="wl-count"><!--v-if--> 评论</div><ul class="wl-sort"><!--[--><li class="active">按正序</li><li class="">按倒序</li><li class="">按热度</li><!--]--></ul></div><div class="wl-cards"><!--[--><!--]--></div><!--[--><div class="wl-loading"><svg width="30" height="30" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid"><circle cx="50" cy="50" fill="none" stroke="currentColor" strokeWidth="4" r="40" stroke-dasharray="85 30"><animateTransform attributeName="transform" type="rotate" repeatCount="indefinite" dur="1s" values="0 50 50;360 50 50" keyTimes="0;1"></animateTransform></circle></svg></div><!--]--><div class="wl-power"> Powered by <a href="https://github.com/walinejs/waline" target="_blank" rel="noopener noreferrer"> Waline </a> v2.15.5</div></div></div><!----><!--]--></main><!--]--><footer class="vp-footer-wrapper"><div class="vp-footer">T4mako's blog</div><div class="vp-copyright">Copyright © 2023 T4mako</div></footer></div><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app-80b25126.js" defer></script>
  </body>
</html>
