<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://T4mako.github.io/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://T4mako.github.io/rss.xml" rel="self" type="application/rss+xml"/>
    <title>T4mako</title>
    <link>https://T4mako.github.io/</link>
    <description>T4mako</description>
    <language>zh-CN</language>
    <pubDate>Thu, 25 Jan 2024 14:28:41 GMT</pubDate>
    <lastBuildDate>Thu, 25 Jan 2024 14:28:41 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>算法</category>
    <category>多线程</category>
    <category>java</category>
    <category>MySQL</category>
    <category>TypeScript</category>
    <category>SQL</category>
    <category>Vue</category>
    <category>部署</category>
    <category>MarkDown</category>
    <item>
      <title>1466. 重新规划路线</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1466_%E9%87%8D%E6%96%B0%E8%A7%84%E5%88%92%E8%B7%AF%E7%BA%BF.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1466_%E9%87%8D%E6%96%B0%E8%A7%84%E5%88%92%E8%B7%AF%E7%BA%BF.html</guid>
      <source url="https://T4mako.github.io/rss.xml">1466. 重新规划路线</source>
      <description>1466. 重新规划路线</description>
      <category>算法</category>
      <pubDate>Sun, 07 Jan 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 1466. 重新规划路线</h1>
]]></content:encoded>
    </item>
    <item>
      <title>714. 买卖股票的最佳时机含手续费</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_714_%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_714_%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9.html</guid>
      <source url="https://T4mako.github.io/rss.xml">714. 买卖股票的最佳时机含手续费</source>
      <description>714. 买卖股票的最佳时机含手续费</description>
      <category>算法</category>
      <pubDate>Sun, 07 Jan 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 714. 买卖股票的最佳时机含手续费</h1>
]]></content:encoded>
    </item>
    <item>
      <title>72. 编辑距离</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_072_%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_072_%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.html</guid>
      <source url="https://T4mako.github.io/rss.xml">72. 编辑距离</source>
      <description>72. 编辑距离</description>
      <category>算法</category>
      <pubDate>Sat, 06 Jan 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 72. 编辑距离</h1>
]]></content:encoded>
    </item>
    <item>
      <title>2542. 最大子序列的分数</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_2542_%E6%9C%80%E5%A4%A7%E5%BA%8F%E5%88%97%E7%9A%84%E5%88%86%E6%95%B0.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_2542_%E6%9C%80%E5%A4%A7%E5%BA%8F%E5%88%97%E7%9A%84%E5%88%86%E6%95%B0.html</guid>
      <source url="https://T4mako.github.io/rss.xml">2542. 最大子序列的分数</source>
      <description>2542. 最大子序列的分数</description>
      <category>算法</category>
      <pubDate>Fri, 05 Jan 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 2542. 最大子序列的分数</h1>
]]></content:encoded>
    </item>
    <item>
      <title>1143. 最长公共子序列</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1143_%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1143_%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.html</guid>
      <source url="https://T4mako.github.io/rss.xml">1143. 最长公共子序列</source>
      <description>1143. 最长公共子序列</description>
      <category>算法</category>
      <pubDate>Wed, 03 Jan 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 1143. 最长公共子序列</h1>
]]></content:encoded>
    </item>
    <item>
      <title>452. 用最少数量的箭引爆气球</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_452_%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_452_%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83.html</guid>
      <source url="https://T4mako.github.io/rss.xml">452. 用最少数量的箭引爆气球</source>
      <description>452. 用最少数量的箭引爆气球</description>
      <category>算法</category>
      <pubDate>Tue, 02 Jan 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 452. 用最少数量的箭引爆气球</h1>
]]></content:encoded>
    </item>
    <item>
      <title>435. 无重叠区间</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_435_%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_435_%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.html</guid>
      <source url="https://T4mako.github.io/rss.xml">435. 无重叠区间</source>
      <description>435. 无重叠区间</description>
      <category>算法</category>
      <pubDate>Mon, 01 Jan 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 435. 无重叠区间</h1>
]]></content:encoded>
    </item>
    <item>
      <title>160. 相交链表</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_160_%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_160_%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8.html</guid>
      <source url="https://T4mako.github.io/rss.xml">160. 相交链表</source>
      <description>160. 相交链表</description>
      <category>算法</category>
      <pubDate>Fri, 03 Nov 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 160. 相交链表</h1>
]]></content:encoded>
    </item>
    <item>
      <title>多线程练习</title>
      <link>https://T4mako.github.io/code/leetcode/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B.html</guid>
      <source url="https://T4mako.github.io/rss.xml">多线程练习</source>
      <description>多线程练习 leetcode 1114. 按序打印 题目：https://leetcode.cn/problems/print-in-order/description/ 方法一：使用 while 循环 class Foo { private AtomicInteger firstJobDone = new AtomicInteger(0); private AtomicInteger secondJobDone = new AtomicInteger(0); public Foo() {} public void first(Runnable printFirst) throws InterruptedException { // printFirst.run() outputs &amp;quot;first&amp;quot;. printFirst.run(); // mark the first job as done, by increasing its count. firstJobDone.incrementAndGet(); } public void second(Runnable printSecond) throws InterruptedException { while (firstJobDone.get() != 1) { // waiting for the first job to be done. } // printSecond.run() outputs &amp;quot;second&amp;quot;. printSecond.run(); // mark the second as done, by increasing its count. secondJobDone.incrementAndGet(); } public void third(Runnable printThird) throws InterruptedException { while (secondJobDone.get() != 1) { // waiting for the second job to be done. } // printThird.run() outputs &amp;quot;third&amp;quot;. printThird.run(); } }</description>
      <category>多线程</category>
      <pubDate>Thu, 02 Nov 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 多线程练习</h1>
<h3> leetcode 1114. 按序打印</h3>
<p>题目：<a href="https://leetcode.cn/problems/print-in-order/description/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/print-in-order/description/</a></p>
<h4> 方法一：使用 while 循环</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 方法二：使用锁 + wait</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 方法三：使用信号量</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>141. 环形链表</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_141_%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_141_%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8.html</guid>
      <source url="https://T4mako.github.io/rss.xml">141. 环形链表</source>
      <description>141. 环形链表 解法一：Set 存储 public class Solution { public boolean hasCycle(ListNode head) { HashSet&amp;lt;ListNode&amp;gt; set = new HashSet&amp;lt;&amp;gt;(); while (head != null){ if(!set.add(head)) return true; // add() 未添加成功返回 false head = head.next; } return false; } }</description>
      <category>算法</category>
      <pubDate>Sat, 28 Oct 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 141. 环形链表</h1>
<h2> 解法一：Set 存储</h2>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 解法二：快慢指针</h2>
<p>定义一个快指针一个慢指针，如果有环，快指针和满指正会相遇</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>234. 回文链表</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_234_%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_234_%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8.html</guid>
      <source url="https://T4mako.github.io/rss.xml">234. 回文链表</source>
      <description>234. 回文链表</description>
      <category>算法</category>
      <pubDate>Fri, 27 Oct 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 234. 回文链表</h1>
]]></content:encoded>
    </item>
    <item>
      <title>1318. 或运算的最小翻转次数</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1318_%E6%88%96%E8%BF%90%E7%AE%97%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BF%BB%E8%BD%AC%E6%AC%A1%E6%95%B0.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1318_%E6%88%96%E8%BF%90%E7%AE%97%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BF%BB%E8%BD%AC%E6%AC%A1%E6%95%B0.html</guid>
      <source url="https://T4mako.github.io/rss.xml">1318. 或运算的最小翻转次数</source>
      <description>1318. 或运算的最小翻转次数</description>
      <category>算法</category>
      <pubDate>Thu, 14 Sep 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 1318. 或运算的最小翻转次数</h1>
]]></content:encoded>
    </item>
    <item>
      <title>SpringBoot 常用注解总结</title>
      <link>https://T4mako.github.io/code/java/SpringBoot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%80%BB%E7%BB%93.html</link>
      <guid>https://T4mako.github.io/code/java/SpringBoot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%80%BB%E7%BB%93.html</guid>
      <source url="https://T4mako.github.io/rss.xml">SpringBoot 常用注解总结</source>
      <description>参考：https://javaguide.cn/system-design/framework/spring/spring-common-annotations.html 一、 @SpringBootApplication 这个注解是 Spring Boot 项目的基石，创建 SpringBoot 项目之后会默认在主类加上。</description>
      <category>java</category>
      <pubDate>Tue, 12 Sep 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>参考：<a href="https://javaguide.cn/system-design/framework/spring/spring-common-annotations.html" target="_blank" rel="noopener noreferrer">https://javaguide.cn/system-design/framework/spring/spring-common-annotations.html</a></p>
<h2> 一、 @SpringBootApplication</h2>
<p>这个注解是 Spring Boot 项目的基石，创建 SpringBoot 项目之后会默认在主类加上。</p>
<p>我们可以把 <code>@SpringBootApplication</code> 看作是 <code>@Configuration</code> + <code>@EnableAutoConfiguration</code> + <code>@ComponentScan</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>根据 SpringBoot 官网，这三个注解的作用分别是：</p>
<ul>
<li><code>@EnableAutoConfiguration</code>：启用 SpringBoot 的自动配置机制</li>
<li><code>@ComponentScan</code>：扫描被 @Component 注解的 bean，注解默认会扫描该类所在的<strong>包下所有的类</strong>。</li>
<li><code>@Configuration</code>：允许在 Spring 上下文中注册额外的 bean 或导入其他配置类</li>
</ul>
<h2> 二、Spring Bean 相关</h2>
<h3> 2.1 @Autowired</h3>
<p>一般使用<code> @Autowired</code> 注解让 Spring 容器帮我们自动装配 bean。</p>
<h3> 2.2 @Component 相关</h3>
<p>要想把类标识成可用于 @Autowired 注解自动装配的 bean 的类，可以采用以下注解：</p>
<ul>
<li><code>@Component</code>：通用的注解</li>
<li><code>@Repository</code>：持久层即 Dao 层，主要用于数据库相关操作</li>
<li><code>@Service</code>：服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层</li>
<li><code>@Controller</code>：控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面</li>
</ul>
<h3> 2.3 @RestController</h3>
<p><code>@RestController</code> = <code>@Controller</code> + <code>@ResponseBody</code><br>
表示这是个控制器 bean，并且是将函数的返回值直接填入 HTTP 响应体中，是 REST 风格的控制器。</p>
<h3> 2.4 @Scope</h3>
<p>声明 Spring Bean 的作用域，使用方法:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>四种常见的 Spring Bean 的作用域：</p>
<ul>
<li>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li>
<li>prototype : 每次请求都会创建一个新的 bean 实例。</li>
<li>request : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li>
<li>session : 每一个 HTTP Session 会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li>
</ul>
<h3> 2.5 @Configuration</h3>
<p>一般用来声明 <strong>配置类</strong> ，可以使用 @Component 注解替代，不过使用 @Configuration 注解声明配置类更加语义化。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 三、 处理常见的 HTTP 请求类型</h2>
<p>5 种常见的请求类型:</p>
<ul>
<li>GET：请求从服务器获取特定资源。</li>
<li>POST：在服务器上创建一个新的资源。</li>
<li>PUT：更新服务器上的资源（客户端提供更新后的整个资源）。</li>
<li>DELETE：从服务器删除特定的资源。</li>
<li>PATCH：更新服务器上的资源（客户端提供更改的属性，可以看做作是部分更新）。</li>
</ul>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p><code>@GetMapping("users")</code> 等价于 <code>@RequestMapping(value="/users",method=RequestMethod.GET)</code></p>
<p><code>@PostMapping("users")</code> 等价于 <code>@RequestMapping(value="/users",method=RequestMethod.POST)</code></p>
<p><code>@PutMapping("/users/{userId}")</code> 等价于 <code>@RequestMapping(value="/users/{userId}",method=RequestMethod.PUT)</code></p>
<p><code>@DeleteMapping("/users/{userId}")</code> 等价于 <code>@RequestMapping(value="/users/{userId}",method=RequestMethod.DELETE)</code></p>
<p>一般实际项目中，我们都是 PUT 不够用了之后才用 PATCH 请求去更新数据。<br>
<code>@PatchMapping("/profile")</code></p>
</div>
<h2> 四、 前后端传值</h2>
<h3> 4.1 @PathVariable 和 @RequestParam</h3>
<p><code>@PathVariable</code> 用于获取路径参数</p>
<p><code>@RequestParam</code> 用于获取查询参数。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>若请求的 url 是：/classes/123456/teachers?type=web<br>
则获取到的数据就是：classId=123456,type=web。</p>
<h3> 4.2 @RequestBody</h3>
<p>用于读取 Request 请求（可能是 POST,PUT,DELETE,GET 请求）的 body 部分并且 Content-Type 为 application/json 格式的数据<br>
接收到数据之后会自动将数据绑定到 Java 对象上去。系统会使用 <code>HttpMessageConverter</code> 或者自定义的 <code>HttpMessageConverter</code> 将请求的 body 中的 json 字符串转换为 java 对象。</p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>一个请求方法只可以有一个 @RequestBody，但是可以有多个 @RequestParam 和 @PathVariable。<br>
如果你的方法必须要用两个 @RequestBody 来接受数据的话，大概率是你的数据库设计或者系统设计出问题了！</p>
</div>
<h2> 五、 读取配置信息</h2>
<p>很多时候我们需要将一些常用的配置信息比如阿里云 oss、发送短信、微信认证的相关配置信息等等放到配置文件中。</p>
<p>Spring 为我们提供从配置文件中读取这些配置信息的方式如下。</p>
<p>假设数据源 <code>application.yml</code> 内容如下：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5.1 @Value（常用）</h3>
<p>使用 <code>@Value("${property}")</code> 读取比较简单的配置信息：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5.2 @ConfigurationProperties（常用）</h3>
<p>通过 <code>@ConfigurationProperties</code> 读取配置信息并与 bean 绑定。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以像使用普通的 Spring bean 一样，将其注入到类中使用</p>
<h3> 5.3 @PropertySource（不常用）</h3>
<p><code>@PropertySource</code> 读取指定 properties 文件</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 六、 参数校验</h2>
<p>JSR（Java Specification Requests） 是一套 JavaBean 参数校验的标准，它定义了很多常用的校验注解，我们可以直接将这些注解加在 JavaBean 的属性上面，这样就可以在需要校验的时候进行校验了</p>
<p>校验的时候我们实际用的是 Hibernate Validator 框架。<br>
SpringBoot 项目的 spring-boot-starter-web 依赖中已经有 hibernate-validator 包，不需要引用相关依赖。</p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>需要注意的是：<br>
所有的注解，推荐使用 JSR 注解，即 <code>javax.validation.constraints</code>，而不是 org.hibernate.validator.constraints</p>
</div>
<h3> 6.1 一些常用的字段验证的注解</h3>
<table>
<thead>
<tr>
<th>注解</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>@NotEmpty</td>
<td>被注释的字符串的不能为 null 也不能为空</td>
</tr>
<tr>
<td>@NotBlank</td>
<td>被注释的字符串非 null，并且必须包含一个非空白字符</td>
</tr>
<tr>
<td>@Null</td>
<td>被注释的元素必须为 null</td>
</tr>
<tr>
<td>@NotNull</td>
<td>被注释的元素必须不为 null</td>
</tr>
<tr>
<td>@AssertTrue</td>
<td>被注释的元素必须为 true</td>
</tr>
<tr>
<td>@AssertFalse</td>
<td>被注释的元素必须为 false</td>
</tr>
<tr>
<td>@Pattern(regex=,flag=)</td>
<td>被注释的元素必须符合指定的正则表达式</td>
</tr>
<tr>
<td>@Email</td>
<td>被注释的元素必须是 Email 格式</td>
</tr>
<tr>
<td>@Min(value)</td>
<td>被注释的元素必须是 &gt;= value 的数字</td>
</tr>
<tr>
<td>@Max(value)</td>
<td>被注释的元素必须是 &lt;= value 的数字</td>
</tr>
<tr>
<td>@DecimalMin(value)</td>
<td>被注释的元素必须是 &gt;= value 的数字</td>
</tr>
<tr>
<td>@DecimalMax(value)</td>
<td>被注释的元素必须是 &lt;= value 的数字</td>
</tr>
<tr>
<td>@Size(max=, min=)</td>
<td>被注释的元素的大小必须在指定的范围内</td>
</tr>
<tr>
<td>@Digits(integer, fraction)</td>
<td>被注释的元素必须是一个数字，其值必须在可接受的范围内</td>
</tr>
<tr>
<td>@Past</td>
<td>被注释的元素必须是一个过去的日期</td>
</tr>
<tr>
<td>@Future</td>
<td>被注释的元素必须是一个将来的日期</td>
</tr>
</tbody>
</table>
<h3> 6.2 验证请求体（RequestBody）</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在需要验证的参数上加上了 <code>@Valid</code> 注解，如果验证失败，它将抛出 <code>MethodArgumentNotValidException</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6.3 验证请求参数（Path Variables 和 Request Parameters）</h3>
<p>在类上加上 <code>@Validated</code> 注解，这个参数可以告诉 Spring 去校验方法参数</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 七、 全局处理 Controller 层异常</h2>
<p>Spring 项目必备全局处理 Controller 层异常</p>
<ul>
<li><code>@ControllerAdvice</code>：注解定义全局异常处理类</li>
<li><code>@ExceptionHandler</code>：注解声明异常处理方法</li>
</ul>
<p>以参数校验这块举例子。如果方法参数不对的话就会抛出 <code>MethodArgumentNotValidException</code>，我们来处理这个异常。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485568&amp;idx=2&amp;sn=c5ba880fd0c5d82e39531fa42cb036ac&amp;chksm=cea2474bf9d5ce5dcbc6a5f6580198fdce4bc92ef577579183a729cb5d1430e4994720d59b34&amp;token=2133161636&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">SpringBoot 处理异常的几种常见姿势</a><br>
<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247486379&amp;idx=2&amp;sn=48c29ae65b3ed874749f0803f0e4d90e&amp;chksm=cea24460f9d5cd769ed53ad7e17c97a7963a89f5350e370be633db0ae8d783c3a3dbd58c70f8&amp;token=1054498516&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">使用枚举简单封装一个优雅的 Spring Boot 全局异常处理</a></p>
<h2> 八、JPA 相关</h2>
<p>(Spring Data JPA)[<a href="https://spring.io/projects/spring-data-jpa#overview" target="_blank" rel="noopener noreferrer">https://spring.io/projects/spring-data-jpa#overview</a>]</p>
<h3> 8.1 创建表</h3>
<ul>
<li><code>@Entity</code> 声明一个类对应一个数据库实体</li>
<li><code>@Table</code> 设置表名</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8.2 创建主键</h3>
<ul>
<li><code>@Id</code>：声明一个字段为主键。声明后还需要定义主键的生成策略。</li>
</ul>
<h4> @GeneratedValue 生成</h4>
<p><code>@GeneratedValue</code> 直接使用 JPA 内置提供的四种主键生成策略来指定主键生成策略。<br>
<code>@GeneratedValue</code> 注解默认使用的策略是 <code>GenerationType.AUTO</code></p>
<p>一般使用 MySQL 数据库的话，使用 <code>GenerationType.IDENTITY</code> 策略比较普遍一点（分布式系统的话需要另外考虑使用分布式 ID）。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> @GenericGenerator</h4>
<p>通过 <code>@GenericGenerator</code> 声明一个主键策略，然后 <code>@GeneratedValue</code> 使用这个策略</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>jpa 提供的主键生成策略有如下几种：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8.3 设置字段类型</h3>
<p><code>@Column</code> 声明字段</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8.4 指定不持久化特定字段</h3>
<p><code>@Transient</code>：声明不需要与数据库映射的字段，在保存的时候不需要保存进数据库</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>还可以采用下面几种方法：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8.5 声明大字段</h3>
<p><code>@Lob</code>：声明某个字段为大字段。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8.6 创建枚举类型的字段</h3>
<p>可以使用枚举类型的字段，不过枚举字段要用 <code>@Enumerated</code> 注解修饰。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8.7 增加审计功能</h3>
<p>只要继承了 <code>@AbstractAuditBase</code> 的类都会默认加上下面四个字段。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们对应的审计功能对应地配置类可能是下面这样的（Spring Security 项目）:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><code>@CreatedDate</code>: 表示该字段为创建时间字段，在这个实体被 insert 的时候，会设置值</li>
<li><code>@CreatedBy</code> :表示该字段为创建人，在这个实体被 insert 的时候，会设置值<br>
<code>@LastModifiedDate</code>、<code>@LastModifiedBy</code> 同理。</li>
</ul>
<p><code>@EnableJpaAuditing</code>：开启 JPA 审计功能。</p>
<h3> 8.8 删除/修改数据</h3>
<p><code>@Modifying</code> 注解提示 JPA 该操作是修改操作，注意还要配合 · 注解使用。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8.9 关联关系</h3>
<ul>
<li><code>@OneToOne</code> 声明一对一关系</li>
<li><code>@OneToMany</code> 声明一对多关系</li>
<li><code>@ManyToOne</code> 声明多对一关系</li>
<li><code>@ManyToMany</code> 声明多对多关系</li>
</ul>
<h2> 九、事务 @Transactional</h2>
<p>在要开启事务的方法上使用 <code>@Transactional</code> 注解即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Exception 分为 运行时异常 和 非运行时异常。<br>
在 <code>@Transactional</code> 注解中如果不配置 <code>rollbackFor</code> 属性，那么事务只会在遇到 RuntimeException 的时候才会回滚<br>
加上 <code>rollbackFor=Exception.class</code> 可以让事务在遇到非运行时异常时也回滚。</p>
<p>@Transactional 注解一般可以作用在 <strong>类</strong> 或者 <strong>方法</strong> 上。</p>
<ul>
<li>作用于类：所有该类的 <code>public</code> 方法都配置相同的事务属性信息。</li>
<li>作用于方法：当类配置了 @Transactional，方法也配置了 @Transactional，方法的事务会覆盖类的事务配置信息。</li>
</ul>
<h2> 10、 json 数据处理</h2>
<h3> 10.1 过滤 json 数据</h3>
<p><code>@JsonIgnoreProperties</code> 作用在类上用于过滤掉特定字段不返回或者不解析。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>@JsonIgnore</code> 一般用于属性上，作用和 <code>@JsonIgnoreProperties</code> 一样。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 10.2 格式化 json 数据</h3>
<p><code>@JsonFormat</code> 一般用来格式化 json 数据。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 10.3 扁平化对象</h3>
<p>使用 <code>@JsonUnwrapped</code> 扁平对象，通常加在属性上</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 十一、测试相关</h2>
<p><code>@ActiveProfiles</code> 一般作用于测试类上， 用于声明生效的 Spring 配置文件。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>@Test</code>： 声明一个方法为测试方法<br>
<code>@Transactional</code>： 被声明的测试方法的数据会回滚，避免污染测试数据。<br>
<code>@WithMockUser</code>： Spring Security 提供的，用来模拟一个真实用户，并且可以赋予权限。</p>
]]></content:encoded>
    </item>
    <item>
      <title>136. 只出现一次的数字</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_136_%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_136_%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97.html</guid>
      <source url="https://T4mako.github.io/rss.xml">136. 只出现一次的数字</source>
      <description>136. 只出现一次的数字</description>
      <category>算法</category>
      <pubDate>Mon, 11 Sep 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 136. 只出现一次的数字</h1>
]]></content:encoded>
    </item>
    <item>
      <title>338. 比特位计数</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_338_%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_338_%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0.html</guid>
      <source url="https://T4mako.github.io/rss.xml">338. 比特位计数</source>
      <description>338. 比特位计数</description>
      <category>算法</category>
      <pubDate>Sun, 10 Sep 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 338. 比特位计数</h1>
]]></content:encoded>
    </item>
    <item>
      <title>208. 实现 Trie (前缀树)</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_208_%E5%AE%9E%E7%8E%B0%20Trie%20(%E5%89%8D%E7%BC%80%E6%A0%91).html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_208_%E5%AE%9E%E7%8E%B0%20Trie%20(%E5%89%8D%E7%BC%80%E6%A0%91).html</guid>
      <source url="https://T4mako.github.io/rss.xml">208. 实现 Trie (前缀树)</source>
      <description>208. 实现 Trie (前缀树)</description>
      <category>算法</category>
      <pubDate>Fri, 08 Sep 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 208. 实现 Trie (前缀树)</h1>
]]></content:encoded>
    </item>
    <item>
      <title>901. 股票价格跨度</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_901_%E8%82%A1%E7%A5%A8%E4%BB%B7%E6%A0%BC%E8%B7%A8%E5%BA%A6.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_901_%E8%82%A1%E7%A5%A8%E4%BB%B7%E6%A0%BC%E8%B7%A8%E5%BA%A6.html</guid>
      <source url="https://T4mako.github.io/rss.xml">901. 股票价格跨度</source>
      <description>901. 股票价格跨度</description>
      <category>算法</category>
      <pubDate>Thu, 07 Sep 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 901. 股票价格跨度</h1>
]]></content:encoded>
    </item>
    <item>
      <title>739. 每日温度</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_739_%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_739_%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.html</guid>
      <source url="https://T4mako.github.io/rss.xml">739. 每日温度</source>
      <description>739. 每日温度</description>
      <category>算法</category>
      <pubDate>Wed, 06 Sep 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 739. 每日温度</h1>
]]></content:encoded>
    </item>
    <item>
      <title>790. 多米诺和托米诺平铺</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_790_%E5%A4%9A%E7%B1%B3%E8%AF%BA%E5%92%8C%E6%89%98%E7%B1%B3%E8%AF%BA%E5%B9%B3%E9%93%BA.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_790_%E5%A4%9A%E7%B1%B3%E8%AF%BA%E5%92%8C%E6%89%98%E7%B1%B3%E8%AF%BA%E5%B9%B3%E9%93%BA.html</guid>
      <source url="https://T4mako.github.io/rss.xml">790. 多米诺和托米诺平铺</source>
      <description>790. 多米诺和托米诺平铺</description>
      <category>算法</category>
      <pubDate>Mon, 04 Sep 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 790. 多米诺和托米诺平铺</h1>
]]></content:encoded>
      <enclosure url="https://assets.leetcode-cn.com/solution-static/790/1.png" type="image/png"/>
    </item>
    <item>
      <title>198. 打家劫舍</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_198_%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_198_%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.html</guid>
      <source url="https://T4mako.github.io/rss.xml">198. 打家劫舍</source>
      <description>198. 打家劫舍</description>
      <category>算法</category>
      <pubDate>Sun, 03 Sep 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 198. 打家劫舍</h1>
]]></content:encoded>
    </item>
    <item>
      <title>875. 爱吃香蕉的珂珂</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_875_%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_875_%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82.html</guid>
      <source url="https://T4mako.github.io/rss.xml">875. 爱吃香蕉的珂珂</source>
      <description>875. 爱吃香蕉的珂珂</description>
      <category>算法</category>
      <pubDate>Sat, 02 Sep 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 875. 爱吃香蕉的珂珂</h1>
]]></content:encoded>
    </item>
    <item>
      <title>162. 寻找峰值</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_162_%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_162_%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC.html</guid>
      <source url="https://T4mako.github.io/rss.xml">162. 寻找峰值</source>
      <description>162. 寻找峰值</description>
      <category>算法</category>
      <pubDate>Fri, 01 Sep 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 162. 寻找峰值</h1>
]]></content:encoded>
    </item>
    <item>
      <title>MySQL 索引</title>
      <link>https://T4mako.github.io/code/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%B4%A2%E5%BC%95.html</link>
      <guid>https://T4mako.github.io/code/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%B4%A2%E5%BC%95.html</guid>
      <source url="https://T4mako.github.io/rss.xml">MySQL 索引</source>
      <description>参考： https://javaguide.cn/database/mysql/mysql-index.html https://www.bilibili.com/video/BV1Wm4y147mS</description>
      <category>MySQL</category>
      <pubDate>Thu, 31 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>参考：<br>
<a href="https://javaguide.cn/database/mysql/mysql-index.html" target="_blank" rel="noopener noreferrer">https://javaguide.cn/database/mysql/mysql-index.html</a><br>
<a href="https://www.bilibili.com/video/BV1Wm4y147mS" target="_blank" rel="noopener noreferrer">https://www.bilibili.com/video/BV1Wm4y147mS</a></p>
</blockquote>
<p>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。</p>
<p>索引底层数据结构存在很多种类型，常见的索引结构有: B 树， B+树 和 Hash、红黑树。<br>
在 MySQL 中，无论是 Innodb 还是 MyIsam，都使用了 <strong>B+树</strong> 作为索引结构。</p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>存储引擎是数据库的核心，在MySQL中，存储引擎是以插件的形式运行的。支持的引擎有十几种之多，实战常用到的，大概只有 <code>InnoDB</code>、<code>MyISAM</code> 和 <code>Memory</code></p>
<p><a href="https://cloud.tencent.com/developer/article/1662516" target="_blank" rel="noopener noreferrer">https://cloud.tencent.com/developer/article/1662516</a></p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>216. 组合总和 III</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_216_%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20III.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_216_%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20III.html</guid>
      <source url="https://T4mako.github.io/rss.xml">216. 组合总和 III</source>
      <description>216. 组合总和 III</description>
      <category>算法</category>
      <pubDate>Thu, 31 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 216. 组合总和 III</h1>
]]></content:encoded>
    </item>
    <item>
      <title>2300. 咒语和药水的成功对数</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_2300.%20%E5%92%92%E8%AF%AD%E5%92%8C%E8%8D%AF%E6%B0%B4%E7%9A%84%E6%88%90%E5%8A%9F%E5%AF%B9%E6%95%B0.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_2300.%20%E5%92%92%E8%AF%AD%E5%92%8C%E8%8D%AF%E6%B0%B4%E7%9A%84%E6%88%90%E5%8A%9F%E5%AF%B9%E6%95%B0.html</guid>
      <source url="https://T4mako.github.io/rss.xml">2300. 咒语和药水的成功对数</source>
      <description>2300. 咒语和药水的成功对数</description>
      <category>算法</category>
      <pubDate>Wed, 30 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 2300. 咒语和药水的成功对数</h1>
]]></content:encoded>
    </item>
    <item>
      <title>2336. 无限集中的最小数字</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_2336_%E6%97%A0%E9%99%90%E9%9B%86%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_2336_%E6%97%A0%E9%99%90%E9%9B%86%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97.html</guid>
      <source url="https://T4mako.github.io/rss.xml">2336. 无限集中的最小数字</source>
      <description>2336. 无限集中的最小数字</description>
      <category>算法</category>
      <pubDate>Tue, 29 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 2336. 无限集中的最小数字</h1>
]]></content:encoded>
    </item>
    <item>
      <title>215. 数组中的第K个最大元素</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_215_%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_215_%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0.html</guid>
      <source url="https://T4mako.github.io/rss.xml">215. 数组中的第K个最大元素</source>
      <description>215. 数组中的第K个最大元素</description>
      <category>算法</category>
      <pubDate>Mon, 28 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 215. 数组中的第K个最大元素</h1>
]]></content:encoded>
    </item>
    <item>
      <title>994. 腐烂的橘子</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_994_%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_994_%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90.html</guid>
      <source url="https://T4mako.github.io/rss.xml">994. 腐烂的橘子</source>
      <description>994. 腐烂的橘子</description>
      <category>算法</category>
      <pubDate>Sun, 27 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 994. 腐烂的橘子</h1>
]]></content:encoded>
    </item>
    <item>
      <title>1926. 迷宫中离入口最近的出口</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1926_%E8%BF%B7%E5%AE%AB%E4%B8%AD%E7%A6%BB%E5%85%A5%E5%8F%A3%E6%9C%80%E8%BF%91%E7%9A%84%E5%87%BA%E5%8F%A3.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1926_%E8%BF%B7%E5%AE%AB%E4%B8%AD%E7%A6%BB%E5%85%A5%E5%8F%A3%E6%9C%80%E8%BF%91%E7%9A%84%E5%87%BA%E5%8F%A3.html</guid>
      <source url="https://T4mako.github.io/rss.xml">1926. 迷宫中离入口最近的出口</source>
      <description>1926. 迷宫中离入口最近的出口</description>
      <category>算法</category>
      <pubDate>Sat, 26 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 1926. 迷宫中离入口最近的出口</h1>
]]></content:encoded>
    </item>
    <item>
      <title>547. 省份数量</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_547_%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_547_%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F.html</guid>
      <source url="https://T4mako.github.io/rss.xml">547. 省份数量</source>
      <description>547. 省份数量</description>
      <category>算法</category>
      <pubDate>Thu, 24 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 547. 省份数量</h1>
]]></content:encoded>
    </item>
    <item>
      <title>841. 钥匙和房间</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_841_%E9%92%A5%E5%8C%99%E5%92%8C%E6%88%BF%E9%97%B4.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_841_%E9%92%A5%E5%8C%99%E5%92%8C%E6%88%BF%E9%97%B4.html</guid>
      <source url="https://T4mako.github.io/rss.xml">841. 钥匙和房间</source>
      <description>841. 钥匙和房间</description>
      <category>算法</category>
      <pubDate>Wed, 23 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 841. 钥匙和房间</h1>
]]></content:encoded>
    </item>
    <item>
      <title>700. 二叉搜索树中的搜索</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_450_%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_450_%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html</guid>
      <source url="https://T4mako.github.io/rss.xml">700. 二叉搜索树中的搜索</source>
      <description>700. 二叉搜索树中的搜索</description>
      <category>算法</category>
      <pubDate>Tue, 22 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 700. 二叉搜索树中的搜索</h1>
]]></content:encoded>
    </item>
    <item>
      <title>700. 二叉搜索树中的搜索</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_700_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_700_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html</guid>
      <source url="https://T4mako.github.io/rss.xml">700. 二叉搜索树中的搜索</source>
      <description>700. 二叉搜索树中的搜索</description>
      <category>算法</category>
      <pubDate>Tue, 22 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 700. 二叉搜索树中的搜索</h1>
]]></content:encoded>
    </item>
    <item>
      <title>1161. 最大层内元素和</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1161_%E6%9C%80%E5%A4%A7%E5%B1%82%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1161_%E6%9C%80%E5%A4%A7%E5%B1%82%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C.html</guid>
      <source url="https://T4mako.github.io/rss.xml">1161. 最大层内元素和</source>
      <description>1161. 最大层内元素和</description>
      <category>算法</category>
      <pubDate>Mon, 21 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 1161. 最大层内元素和</h1>
]]></content:encoded>
    </item>
    <item>
      <title>746. 使用最小花费爬楼梯</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_746_%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_746_%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF.html</guid>
      <source url="https://T4mako.github.io/rss.xml">746. 使用最小花费爬楼梯</source>
      <description>746. 使用最小花费爬楼梯</description>
      <category>算法</category>
      <pubDate>Mon, 21 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 746. 使用最小花费爬楼梯</h1>
]]></content:encoded>
    </item>
    <item>
      <title>认识 JVM</title>
      <link>https://T4mako.github.io/code/java/JVM%E5%85%A5%E9%97%A8.html</link>
      <guid>https://T4mako.github.io/code/java/JVM%E5%85%A5%E9%97%A8.html</guid>
      <source url="https://T4mako.github.io/rss.xml">认识 JVM</source>
      <description>参考：https://javaguide.cn/java/jvm/jvm-intro.html JVM(Java Virtual Machine) 其实就类似于一台小电脑运行在 windows 或者 linux 这些操作系统环境下即可。 它直接和操作系统进行交互，与硬件不直接交互，而操作系统可以帮我们完成和硬件进行交互的工作。</description>
      <category>java</category>
      <pubDate>Sun, 20 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>参考：<a href="https://javaguide.cn/java/jvm/jvm-intro.html" target="_blank" rel="noopener noreferrer">https://javaguide.cn/java/jvm/jvm-intro.html</a></p>
</blockquote>
<p>JVM(Java Virtual Machine) 其实就类似于一台小电脑运行在 windows 或者 linux 这些操作系统环境下即可。<br>
它直接和操作系统进行交互，与硬件不直接交互，而操作系统可以帮我们完成和硬件进行交互的工作。</p>
<h2> 一、基础知识</h2>
<h3> JVM</h3>
<p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。</p>
<p>JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。</p>
<p>字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</p>
<p><strong>JVM 并不是只有一种！只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。</strong><br>
也就是说我们平时接触到的 HotSpot VM（Sun/Oracle JDK 和 OpenJDK 中所带的虚拟机） 仅仅是是 JVM 规范的一种实现而已</p>
<blockquote>
<p>Oracle JDK 是基于 OpenJDK 源代码构建的</p>
</blockquote>
<h3> JDK 和 JRE</h3>
<ul>
<li>JDK（Java Development Kit）= JRE + 开发工具集（javac.exe,java..exe,javadoc.exe...）</li>
<li>JRE（Java Runtime Environment Java运行环境）= JVM + Java SE 标准类库（Java Class Library）</li>
</ul>
<p>JDK（Java Development Kit），它是功能齐全的 Java SDK（软件开发套件 Software development kit），是提供给开发者使用的，能够创建和编译 Java 程序。</p>
<p>它包含了 JRE，同时还包含了编译 java 源码的编译器 javac 以及一些其他工具比如 javadoc（文档注释工具）、jdb（调试器）、jconsole（基于 JMX 的可视化监控⼯具）、javap（反编译工具）等等。</p>
<p>JRE（Java Runtime Environment） 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，主要包括 Java 虚拟机（JVM）、Java 基础类库（Class Library）。</p>
<p>JRE 是 Java 运行时环境，仅包含 Java 应用程序的运行时环境和必要的类库。</p>
<p>JDK 则包含了 JRE，同时还包括了 javac、javadoc、jdb、jconsole、javap 等工具，可以用于 Java 应用程序的开发和调试。</p>
<p>如果需要进行 Java 编程工作，比如编写和编译 Java 程序、使用 Java API 文档等，就需要安装 JDK。<br>
而对于某些需要使用 Java 特性的应用程序，如 JSP 转换为 Java Servlet、使用反射等，也需要 JDK 来编译和运行 Java 代码。<br>
因此，即使不打算进行 Java 应用程序的开发工作，也有可能需要安装 JDK。</p>
<h3> 字节码</h3>
<p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。</p>
<p>Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以， Java 程序运行时相对来说还是高效的（不过，和 C++，Rust，Go 等语言还是有一定差距的），而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>
<p><code>.class-&gt;机器码</code> 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器<strong>逐行解释执行</strong>，这种方式的执行速度会相对比较慢。</p>
<p>而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。</p>
<p>而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言</p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（<strong>热点代码</strong>），而这也就是 JIT 所需要编译的部分。</p>
<p>JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。</p>
<p>JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。</p>
</div>
<p>JVM 大致结构模型：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230821005244740.png" alt="image-20230821005244740" loading="lazy"></p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>为什么不全部使用 AOT 呢?</p>
<p>AOT 可以提前编译节省启动时间，那为什么不全部使用这种编译方式呢？</p>
<p>长话短说，这和 Java 语言的动态特性有千丝万缕的联系了。举个例子，CGLIB 动态代理使用的是 ASM 技术，而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 .class 文件，如果全部使用 AOT 提前编译，也就不能使用 ASM 技术了。为了支持类似的动态特性，所以选择使用 JIT 即时编译器。</p>
</div>
<h3> Java 语言“编译与解释并存”的原因</h3>
<p>高级编程语言按照程序的执行方式分为两种：</p>
<ul>
<li>编译型：编译型语言 会通过编译器将源代码 <strong>一次性翻译</strong> 成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。</li>
<li>解释型：解释型语言会通过解释器 <strong>一句一句的将代码解释</strong>（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。</li>
</ul>
<h3> Oracle JDK vs OpenJDK</h3>
<p>2006 年 SUN 公司将 Java 开源，也就有了 OpenJDK。<br>
2009 年 Oracle 收购了 Sun 公司，于是自己在 OpenJDK 的基础上搞了一个 Oracle JDK。  Oracle JDK 是不开源的，并且刚开始的几个版本（Java8 ~ Java11）还会相比于 OpenJDK 添加一些特有的功能和工具。</p>
<p>Oracle JDK 是基于 OpenJDK 7 构建的，只添加了一些小功能，由 Oracle 工程师参与维护。</p>
<p>Oracle JDK 和 OpenJDK 的区别：</p>
<ol>
<li>是否开源：OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是基于 OpenJDK 实现的，并不是完全开源的。<br>
OpenJDK 开源项目：<a href="https://github.com/openjdk/jdk" target="_blank" rel="noopener noreferrer">https://github.com/openjdk/jdk</a></li>
<li>是否免费：Oracle JDK 会提供免费版本，但一般有时间限制。<br>
JDK17 之后的版本可以免费分发和商用，但是仅有 3 年时间，3 年后无法免费商用<br>
不过，JDK8u221 之前只要不升级可以无限期免费。OpenJDK 是完全免费的。</li>
<li>功能性：Oracle JDK 在 OpenJDK 的基础上添加了一些特有的功能和工具，比如 Java Flight Recorder（JFR，一种监控工具）、Java Mission Control（JMC，一种监控工具）等工具。<br>
不过，在 Java 11 之后，OracleJDK 和 OpenJDK 的功能基本一致，之前 OracleJDK 中的私有组件大多数也已经被捐赠给开源组织。</li>
<li>稳定性：OpenJDK 不提供 LTS 服务，而 OracleJDK 大概每三年都会推出一个 LTS 版进行长期支持。<br>
不过，很多公司都基于 OpenJDK 提供了对应的和 OracleJDK 周期相同的 LTS 版。因此，两者稳定性其实也是差不多的。</li>
<li>协议：Oracle JDK 使用 <code>BCL/OTN</code> 协议获得许可，而 OpenJDK 根据 <code>GPL v2</code> 许可获得许可。</li>
</ol>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>既然 Oracle JDK 这么好，那为什么还要有 OpenJDK？</p>
<ul>
<li>OpenJDK 是开源的，开源意味着你可以对它根据你自己的需要进行修改、优化，比如 Alibaba 基于 OpenJDK 开发了 Dragonwell8：<a href="https://github.com/alibaba/dragonwell8" target="_blank" rel="noopener noreferrer">https://github.com/alibaba/dragonwell8</a></li>
<li>OpenJDK 是商业免费的（这也是为什么通过 yum 包管理器上默认安装的 JDK 是 OpenJDK 而不是 Oracle JDK）。虽然 Oracle JDK 也是商业免费（比如 JDK 8），但并不是所有版本都是免费的。</li>
<li>OpenJDK 更新频率更快。Oracle JDK 一般是每 6 个月发布一个新版本，而 OpenJDK 一般是每 3 个月发布一个新版本。（现在你知道为啥 Oracle JDK 更稳定了吧，先在 OpenJDK 试试水，把大部分问题都解决掉了才在 Oracle JDK 上发布）基于以上这些原因，OpenJDK 还是有存在的必要的！</li>
</ul>
</div>
<h3> Java 文件是如何被运行的</h3>
<p>假设编写了一个 <code>A.java</code> 文件，目前它只是一个文本文件且有一定的缩进<br>
JVM 是不认识文本文件的，所以它需要一个 <strong>编译</strong> ，让其成为一个它会读二进制文件的 <code>A.class</code></p>
<h4> ① 类加载器</h4>
<p>如果 JVM 想要执行这个 .class 文件，我们需要将其装进一个 <strong>类加载器</strong> 中，它就像一个搬运工一样，会把所有的 .class 文件全部搬进 JVM 里面来。</p>
<h4> ② 方法区</h4>
<p><strong>方法区</strong> 是用于存放类似于 <strong>元数据</strong> 信息方面的数据的<br>
比如类信息，常量，静态变量，编译后代码···等<br>
类加载器将 .class 文件搬过来就是先丢到这一块上</p>
<h4> ③ 堆</h4>
<p>堆 主要放了一些存储的数据，比如对象实例，数组···等，它和方法区都同属于 线程共享区域 。也就是说它们都是 <strong>线程不安全</strong> 的</p>
<h4> ④ 栈</h4>
<p>栈 这是我们的代码运行空间。我们编写的每一个方法都会放到 栈 里面运行。我们会听说过 本地方法栈 或者 本地方法接口 这两个名词，不过我们基本不会涉及这两块的内容，它俩底层是使用 C 来进行工作的，和 Java 没有太大的关系。</p>
<h4> ⑤ 程序计数器</h4>
<p>主要就是完成一个加载工作，类似于一个指针一样的，指向下一行我们需要执行的代码。和栈一样，都是 <strong>线程独享</strong> 的，就是说每一个线程都会有自己对应的一块区域而不会存在并发和多线程的问题。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230823001104289.png" alt="image-20230823001104289" loading="lazy"></p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<ul>
<li><code>.java</code> 文件经过编译后变成 <code>.class</code> 字节码文件</li>
<li>字节码文件通过 <code>类加载器</code> 被搬运到 JVM 虚拟机中</li>
<li>虚拟机主要的 5 大块：
<ul>
<li><code>方法区</code>，<code>堆</code> 都为<code>线程共享</code>区域，有线程安全问题</li>
<li><code>栈</code> 和 <code>本地方法栈</code> 和 <code>计数器</code> 都是 <code>独享区域</code>，不存在线程安全问题</li>
<li>而 JVM 的调优主要就是围绕 <code>堆</code>，<code>栈</code> 两大块进行</li>
</ul>
</li>
</ul>
</div>
<h3> 一个简单的示例</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol>
<li><code>App.java</code> 编译后得到 <code>App.class</code> ，执行 <code>App.class</code> ，系统会启动一个 <code>JVM 进程</code> ，从 <code>classpath</code> 路径中找到一个名为 <code>App.class</code> 的二进制文件，将 App 的类信息加载到运行时数据区的 <code>方法区</code> 内，这个过程叫做 App <code>类的加载</code></li>
<li>JVM 找到 App 的主程序入口，执行 main 方法</li>
<li>main 中的第一条语句为 <code>Stu stu = new Stu("T4mako");</code> ，就是让 JVM 创建一个 Stu 对象，但是这个时候方法区中是没有 Stu 类的信息的，所以 JVM 马上加载 Stu 类，把 Stu 类的信息放到 <code>方法区</code> 中</li>
<li>加载完 Stu 类后，JVM 在 <code>堆</code> 中为一个新的 stu 实例分配内存，然后调用构造函数初始化 stu 实例，这个 stu 实例持有 <strong>指向方法区中的 Stu 类的类型信息的引用</strong></li>
<li>执行 <code>stu.say();</code> 时，JVM 根据 stu 的引用找到 stu 对象，然后根据 stu 对象持有的引用定位到方法区中 Stu 类的类型信息的方法表，获得 say() 的字节码地址。</li>
<li>执行 say()</li>
</ol>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>只需要知道 <code>对象实例初始化</code> 时会去 <code>方法区中找类信息</code><br>
完成后再到 <code>栈</code> 那里去 <code>运行方法</code> 。<br>
找方法就在方法表中找</p>
</div>
<h2> 二、类加载器的介绍</h2>
<p>类的加载器：</p>
<ul>
<li>负责加载 .class 文件，.class 文件开头会有特定的文件标示</li>
<li><strong>将 class 文件字节码内容加载到内存中</strong>，并将这些内容转换成方法区中的运行时数据结构，并且 ClassLoader 只负责 class 文件的加载，而是否能够运行则由 Execution Engine 来决定</li>
</ul>
<h3> 2.1 类加载器的流程</h3>
<p>类被加载到虚拟机内存中开始，到释放内存总共有 7 个步骤：<br>
加载，连接（验证，准备，解析），初始化，使用，卸载。</p>
<h4> 2.1.1 加载</h4>
<ol>
<li>将 class 文件加载到内存</li>
<li>将 <strong>静态数据结构</strong> 转化成 <strong>方法区中运行时的数据结构</strong></li>
<li>在 <strong>堆</strong> 中生成一个代表这个类的 <code>java.lang.Class 对象</code> 作为数据访问的入口</li>
</ol>
<h4> 2.1.2 链接</h4>
<p>连接：为类的静态变量赋予正确的初始值</p>
<ol>
<li>验证：<br>
安全检查 （确保加载的类符合 JVM 规范和安全，保证被校验类的方法在运行时不会做出危害虚拟机的事件）</li>
<li>准备：<br>
为 <code>static</code> 变量在方法区中分配内存空间，设置变量的初始值<br>
（注意：准备阶段只设置类中的 <strong>静态</strong> 变量（ <strong>方法区</strong> 中），不包括 <strong>实例变量</strong>（ <strong>堆内存</strong> 中），实例变量是对象初始化时赋值的）</li>
<li>解析：<br>
虚拟机将常量池内的符号引用替换为直接引用的过程<br>
（符号引用比如我现在 <code>import java.util.ArrayList</code> 这就算符号引用<br>
直接引用就是指针或者对象地址，注意 <strong>引用对象</strong> 一定是在<strong>内存</strong>进行）</li>
</ol>
<h4> 2.1.3  初始化</h4>
<p>初始化：执行类构造器方法的 <code>&lt;clinit&gt;()</code> 的过程，且要保证父类的 <code>&lt;clinit&gt;()</code> 方法执行完毕<br>
这个方法由编译器收集，顺序执行所有 <strong>类变量（static）</strong> 显式初始化和 <strong>静态代码块</strong> 中语句。</p>
<p>初始化执行时机：</p>
<ul>
<li>new一个对象</li>
<li>访问某个类或接口的静态变量</li>
<li>调用类的静态方法，反射 <code>Class.forName</code></li>
<li>初始化一个类的子类</li>
<li>JVM启动时标明的启动类，即文件名和类名相同的那个类</li>
</ul>
<p>注：静态代码块 和 类变量初始化 顺序执行</p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>初始化顺序依次是：（静态变量、静态初始化块）–&gt;（变量、初始化块）–&gt; 构造器；如果有父类，则顺序是：父类 static 方法 –&gt; 子类 static 方法 –&gt; 父类构造方法- -&gt; 子类构造方法</p>
</div>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>字节码文件中初始化方法有两种，非静态资源初始化的 <code>&lt;init&gt;</code> 和静态资源初始化的 <code>&lt;clinit&gt;</code> ，类构造器方法 <code>&lt;clinit&gt;()</code> 不同于类的构造器，这些方法都是字节码文件中只能给 JVM 识别的特殊方法。</p>
</div>
<h4> 2.1.4 卸载</h4>
<p>GC 将无用对象从内存中卸载</p>
<h3> 2.2 类加载器加载顺序</h3>
<p>类加载器顺序：<br>
BootStrap ClassLoader：rt.jar<br>
Extension ClassLoader: 加载扩展的 jar 包<br>
App ClassLoader：指定的 classpath 下面的 jar 包<br>
Custom ClassLoader：自定义的类加载器</p>
<blockquote>
<p>第一步： 字底向上检查类是否已加载<br>
第二步： 自顶向下尝试加载类</p>
</blockquote>
<h3> 2.3 双亲委派机制</h3>
<p>当一个类收到了加载请求时，它是不会先自己去尝试加载的，而是委派给父类去完成，比如我现在要 new 一个 Person，这个 Person 是我们自定义的类，如果我们要加载它，就会先委派 App ClassLoader ，只有当父类加载器都反馈自己无法完成这个请求（也就是父类加载器都没有找到加载所需的 Class）时，子类加载器才会自行尝试加载。</p>
<p>这样做的好处是，加载位于 rt.jar 包中的类时不管是哪个加载器加载，最终都会委托到 BootStrap ClassLoader 进行加载，这样保证了使用不同的类加载器得到的都是同一个结果。</p>
<p>其实这个也是一个隔离的作用，避免了我们的代码影响了 JDK 的代码，比如我现在自己定义一个 java.lang.String：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>尝试运行当前类的 <code>main</code> 函数的时候，我们的代码肯定会报错。这是因为在加载的时候其实是找到了 <code>rt.jar</code> 中的 <code>java.lang.String</code>，然而发现这个里面并没有 <code>main</code> 方法。</p>
<h2> 三、运行时数据区</h2>
<h3> 3.1 本地方法栈和程序计数器</h3>
<ul>
<li>
<p>本地方法栈：<br>
<code>native</code> 修饰的方法就是本地方法，这是使用 C 来实现的（比如 Thread 类的 start0 方法）<br>
一般这些方法都会放到一个叫做本地方法栈的区域。</p>
</li>
<li>
<p>程序计数器其实就是一个指针，它指向了我们程序中下一句需要执行的指令<br>
它是内存区域中唯一一个不会出现 OutOfMemoryError 的区域，且占用很小的内存空间<br>
这个内存仅代表当前线程所执行的字节码的行号指示器，字节码解析器通过改变这个计数器的值选取下一条需要执行的字节码指令</p>
</li>
</ul>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>如果执行的是 native 方法，那这个指针就不工作了。</p>
</div>
<h3> 3.2 方法区</h3>
<p><strong>方法区</strong> 主要的作用是存放 <strong>类的元数据</strong> 信息，常量和静态变量···等。当它存储的信息过大时，会在无法满足内存分配时报错</p>
<h3> 3.3 虚拟机栈和虚拟机堆</h3>
<p>栈管运行，堆管存储。<br>
则虚拟机栈负责运行代码，而虚拟机堆负责存储数据</p>
<h4> 3.3.1、虚拟机栈</h4>
<p>它是 Java 方法执行的内存模型。<br>
里面会对局部变量，动态链表，方法出口，栈的操作（入栈和出栈）进行存储，且线程独享。<br>
同时如果我们听到 <strong>局部变量表</strong>，那也是在说 <strong>虚拟机栈</strong></p>
<h4> 3.3.2、虚拟机栈的异常</h4>
<p>线程请求的栈的深度大于虚拟机栈的最大深度，就会报 <code>StackOverflowError </code>（这种错误经常出现在递归中）<br>
Java 虚拟机也可以动态扩展，但随着扩展会不断地申请内存，当无法申请足够内存时就会报错 <code>OutOfMemoryError</code></p>
<h4> 3.3.3、虚拟机栈的生命周期</h4>
<p>对于栈来说，不存在垃圾回收。<br>
只要程序运行结束，栈的空间自然就会释放了。<br>
<strong>栈的生命周期</strong> 和 <strong>所处的线</strong>程是一致的。</p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>8 种基本类型的变量+对象的引用变量+实例方法都是在栈里面分配内存</p>
</div>
<h4> 3.3.4、虚拟机栈的执行</h4>
<p>我们经常说的栈帧数据（说白了在 JVM 中叫栈帧，放到 Java 中其实就是 <strong>方法</strong>）它也是存放在栈中的。</p>
<p>栈中的数据都是以栈帧的格式存在，它是一个关于方法和运行期数据的数据集。</p>
<p>比如我们执行一个方法 a，就会对应产生一个栈帧 A1，然后 A1 会被压入栈中。<br>
同理方法 b 会有一个 B1<br>
方法 c 会有一个 C1<br>
等到这个线程执行完毕后，栈弹出 C1，B1，A1。（<strong>先进后出</strong>）</p>
<h4> 3.3.5、局部变量的复用</h4>
<p>局部变量表用于存放方法参数和方法内部所定义的局部变量。<br>
它的容量是以 Slot 为最小单位，一个 slot 可以存放 32 位以内的数据类型。</p>
<p>为了节省栈帧空间，这些 slot 是可以复用的，当方法执行位置超过了某个变量，那么这个变量的 slot 可以被其它变量复用。当然如果需要复用，那我们的垃圾回收自然就不会去动这些内存</p>
<h4> 3.3.6、虚拟机堆的概念</h4>
<p>JVM 内存会划分为堆内存和非堆内存，堆内存中也会划分为 <strong>年轻代</strong> 和 <strong>老年代</strong>，而非堆内存则为 <strong>永久代</strong></p>
<p>Eden，FromPlace 和 ToPlace 的默认占比为 8:1:1。<br>
可以通过一个 <code>-XX:+UsePSAdaptiveSurvivorSizePolicy</code> 参数来根据生成对象的速率动态调整</p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p><strong>堆内存</strong> 中存放的是 <strong>对象</strong><br>
垃圾收集就是收集这些对象然后交给 GC 算法进行回收</p>
<p><strong>非堆内存</strong> 就是 <strong>方法区</strong></p>
<p>在 1.8 中已经移除永久代，替代品是 <strong>元空间（MetaSpace）</strong><br>
最大区别是 metaSpace 是不存在于 JVM 中的，它使用的是本地内存。并有两个参数：<br>
<code>MetaspaceSize</code>：初始化元空间大小，控制发生 GC<br>
<code>MaxMetaspaceSize</code>：限制元空间大小上限，防止占用过多物理内存。</p>
<p>移除的大致原因：融合 HotSpot JVM 和 JRockit VM 而做出的改变，因为 JRockit 是没有永久代的，不过这也间接性地解决了永久代的 OOM 问题。</p>
</div>
<h4> 3.3.7、Eden 年轻代</h4>
<p>对象放入 Eden：</p>
<ul>
<li>new 一个对象后，会先放到 Eden 划分出来的一块作为存储空间的内存</li>
<li>由于堆内存是线程共享的，所以有可能会出现两个对象共用一个内存的情况</li>
<li>JVM 的处理是为每个线程都预先申请好一块连续的内存空间并规定了对象存放的位置，而如果空间不足会再申请多块内存空间。这个操作我们会称作 TLAB</li>
</ul>
<p>Eden 空间满了后，会触发 <code>Minor GC</code>（一个发生在年轻代的 GC）<br>
存活下来的对象移动到 Survivor0 区，并把 from 和 to 两个指针交换，保证了一段时间内总有一个 survivor 区为空且 to 所指向的 survivor 区为空<br>
经过多次的 Minor GC 后仍然存活的对象（这里的存活判断是 15 次，对应到虚拟机参数为 <code>-XX:MaxTenuringThreshold</code> 。为什么是 15？，因为 HotSpot 会在对象头中的标记字段里记录年龄，分配到的空间仅有 4 位，所以最多只能记录到 15）会移动到 <strong>老年代</strong></p>
<p>当 Eden 区内存空间满了的时候，就会触发 Minor GC，Survivor0 区满不会触发 Minor GC<br>
Survivor0 区 的对象什么时候垃圾回收呢？<br>
假设 Survivor0 区现在是满的，此时又触发了 Minor GC ，发现 Survivor0 区依旧是满的，存不下，此时会将 S0 区与 Eden 区的对象一起进行可达性分析，找出活跃的对象，将它复制到 S1 区并且将 S0 区域和 Eden 区的对象给清空，这样那些不可达的对象进行清除，并且将 S0 区 和 S1 区交换。</p>
<p>老年代是存储长期存活的对象的，占满时就会触发我们最常听说的 Full GC，期间会停止所有线程等待 GC 的完成。<br>
所以对于响应要求高的应用应该尽量去减少发生 Full GC 从而避免响应超时的问题。</p>
<p>老年区执行了 full gc 之后仍然无法进行对象保存的操作，就会产生 <code>Out of Memory</code>，这时候就是虚拟机中的堆内存不足，原因可能会是堆内存设置的大小过小，这个可以通过参数 -Xms、-Xmx 来调整。也可能是代码中创建的对象大且多，而且它们一直在被引用从而长时间垃圾收集无法收集它们。</p>
<p>补充说明：关于 <code>-XX:TargetSurvivorRatio</code> 参数的问题。<br>
其实也不一定是要满足 <code>-XX:MaxTenuringThreshold</code> 才移动到老年代。<br>
举例：如对象年龄 5 的占 30%，年龄 6 的占 36%，年龄 7 的占 34%，加入某个年龄段后，当总占用超过 Survivor 空间  *TargetSurvivorRatio 的时候，从该年龄段开始及大于的年龄对象就要进入老年代，这时候无需等到 MaxTenuringThreshold 中要求的 15</p>
<h4> 3.3.8、判断一个对象需要被干掉</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230828223704998.png" alt="image-20230828223704998" loading="lazy"></p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>程序计数器、虚拟机栈、本地方法栈，3 个区域随着线程的生存而生存的。内存分配和回收都是确定的。<br>
随着线程的结束内存自然就被回收了，因此不需要考虑垃圾回收的问题</p>
<p>Java 堆和方法区，各线程共享，内存的分配和回收都是动态的。因此垃圾收集器所关注的都是堆和方法区这部分内存</p>
</div>
<p>判断哪些对象还存活，哪些已经死去:</p>
<ol>
<li>引用计数器计算：给对象添加一个引用计数器，每次引用这个对象时计数器加一，引用失效时减一，计数器等于 0 时就是不会再次使用的。不过这个方法有一种情况就是出现对象的循环引用时 GC 没法回收。</li>
<li>可达性分析计算：这是一种类似于二叉树的实现，将一系列的 GC ROOTS 作为起始的存活对象集，从这个节点往下搜索，搜索所走过的路径成为引用链，把能被该集合引用到的对象加入到集合中。搜索当一个对象到 GC Roots 没有使用任何引用链时，则说明该对象是不可用的。主流的商用程序语言，例如 Java，C#等都是靠这招去判定对象是否存活的。</li>
</ol>
<h4> 3.3.9、宣告一个对象的真正死亡</h4>
<p>判断一个对象的死亡至少需要两次标记</p>
<p><code>finalize()</code> 方法：<br>
<code>finalize()</code> 是 Object 类的一个方法、一个对象的 <code>finalize()</code> 方法只会被系统自动调用一次，经过 finalize()方法逃脱死亡的对象，第二次不会再调用。<br>
注：并不提倡在程序中调用 finalize()来进行自救</p>
<ol>
<li>如果对象进行可达性分析之后没发现与 GC Roots 相连的引用链，那它将会第一次标记并且进行一次筛选。判断的条件是决定这个对象是否有必要执行 <code>finalize()</code> 方法。如果对象有必要执行 <code>finalize()</code> 方法，则被放入 F-Queue 队列中。</li>
<li>GC 对 F-Queue 队列中的对象进行二次标记。如果对象在 <code>finalize()</code> 方法中重新与引用链上的任何一个对象建立了关联，那么二次标记时则会将它移出“即将回收”集合。如果此时对象还没成功逃脱，那么只能被回收了。</li>
</ol>
<p>对象宣告死亡后，下一步就是垃圾回收</p>
<h3> 3.4 垃圾回收算法</h3>
<p>常用的有标记清除，复制，标记整理和分代收集算法</p>
<h3> 3.5 各种垃圾回收器与 JVM 常用参数</h3>
<p><a href="https://javaguide.cn/java/jvm/jvm-intro.html#_3-5-%E4%BA%86%E8%A7%A3-%E5%90%84%E7%A7%8D%E5%90%84%E6%A0%B7%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8" target="_blank" rel="noopener noreferrer">各种各样的垃圾回收器</a><br>
<a href="https://javaguide.cn/java/jvm/jvm-intro.html#_3-6-%E4%BA%86%E8%A7%A3-jvm-%E7%9A%84%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0" target="_blank" rel="noopener noreferrer">JVM 的常用参数</a></p>
<h2> 四、JVM 调优</h2>
<p>JVM 调优，主要就是堆内存那块</p>
<p>所有线程共享数据区大小 = 新生代大小 + 年老代大小 + 持久代大小。<br>
持久代一般固定大小为 64m。所以 java 堆中增大年轻代后，将会减小年老代大小（因为老年代的清理是使用 fullgc，所以老年代过小的话反而是会增多 fullgc 的）。此值对系统性能影响较大，Sun 官方推荐配置为 java 堆的 3/8。</p>
<h3> 4.1 调整最大堆内存和最小堆内存</h3>
<ol>
<li><code>-Xmx</code><br>
指定 java 堆最大值（默认值是物理内存的 1/4(&lt;1GB)）<br>
如 <code>- Xmx3550m</code> 设置 JVM 堆最大值为 3550M。</li>
<li><code>–Xms</code>：初始 java 堆最小值（默认值是物理内存的 1/64(&lt;1GB)）<br>
如 <code>-Xms200m</code>，表示分配 200M</li>
<li><code>-Xss</code><br>
为 jvm 启动的每个线程分配的内存大小，默认 JDK1.4 中是256K，JDK1.5+ 中是 1M</li>
<li><code>-Xmn</code><br>
年轻代大小<br>
如 <code>-Xmn2g</code>：设置年轻代大小为 2G。整个堆大小 = 年轻代大小 + 年老代大小 + 持久代大小</li>
</ol>
<p>默认空余堆内存小于 40% 时，JVM 就会增大堆直到 -Xmx 的最大限制 （MinHeapFreeRatio 参数可以调整）<br>
默认空余堆内存大于 70% 时，JVM 会减少堆直到 -Xms 的最小限制（MaxHeapFreeRatio 参数可以调整）</p>
<p>简单来说，不停往堆内存里丢数据，等它剩余大小 &lt;40%，JVM 就会动态申请内存空间且 &lt;-Xmx<br>
如果剩余大小 &gt;70%，又会动态缩小 且 &gt;–Xms。</p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>开发过程中，通常会将 -Xms 与 -Xmx 两个参数配置成相同的值，其目的是为了能够在 java 垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小而浪费资源。</p>
</div>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>运行结果：<br>
Xmx=3621.5M<br>
free mem=240.37600708007812M<br>
total mem=245.5M</p>
</blockquote>
<p>可以设置 VM options 的参数：<code>-Xmx20m -Xms5m -XX:+PrintGCDetails</code></p>
<p>Java 会尽可能将 total mem 的值维持在最小堆内存大小<br>
当最小堆内存顶不住时。total memory 就会申请内存。</p>
<p>当手动执行 <code>System.gc();</code>（full gc）， total memory 会把申请的内存释放掉</p>
<h3> 4.2、调整新生代和老年代的比值</h3>
<p><code>-XX:NewRatio</code> ：新生代（eden + 2*Survivor）和老年代（不包含永久区）的比值</p>
<p>例如：<code>-XX:NewRatio=4</code>，表示 <code>新生代:老年代=1:4</code> ，即新生代占整个堆的 1/5。</p>
<p>在 Xms = Xmx 并且设置了 Xmn 的情况下，该参数不需要进行设置。</p>
<h3> 4.3、调整 Survivor 区和 Eden 区的比值</h3>
<p><code>-XX:SurvivorRatio</code>（幸存代）：设置两个 Survivor 区和 eden 的比值</p>
<p>如：<code>-XX:SurvivorRatio=8</code>，表示两个 <code>Survivor:eden=2:8</code>，即一个 Survivor 占年轻代的 1/10</p>
<h3> 4.4、设置年轻代和老年代的大小</h3>
<ul>
<li><code>-XX:NewSize</code> --- 设置年轻代大小</li>
<li><code>-XX:MaxNewSize</code> --- 设置年轻代最大值</li>
</ul>
<p>可以通过设置不同参数来测试不同的情况，反正最优解当然就是官方的 Eden 和 Survivor 的占比为 8:1:1</p>
<p>最大堆内存和最小堆内存如果数值不同会导致多次的 gc，需要注意。</p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>根据实际事情调整新生代和幸存代的大小，官方推荐新生代占 java 堆的 3/8，幸存代占新生代的 1/10<br>
在 OOM 时，记得 Dump 出堆，确保可以排查现场问题，通过下面命令你可以输出一个.dump 文件，这个文件可以使用 VisualVM 或者 Java 自带的 Java VisualVM 工具。</p>
<p><code>-Xmx20m -Xms5m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=你要输出的日志路径</code></p>
<p>一般我们也可以通过编写脚本的方式来让 OOM 出现时给我们报个信，可以通过发送邮件或者重启程序等来解决。</p>
</div>
<h3> 4.5、永久区的设置</h3>
<p><code>-XX:PermSize -XX:MaxPermSize</code></p>
<p>初始空间（默认为物理内存的 1/64）和最大空间（默认为物理内存的 1/4）。<br>
也就是说，jvm 启动时，永久区一开始就占用了 PermSize 大小的空间，如果空间还不够，可以继续扩展，但是不能超过 MaxPermSize，否则会 OOM。<br>
tips：如果堆空间没有用完也抛出了 OOM，有可能是永久区导致的。堆空间实际占用非常少，但是永久区溢出 一样抛出 OOM。</p>
<h3> 4.6、JVM 的栈参数调优</h3>
<h4> 调整每个线程栈空间的大小</h4>
<p>可以通过 <code>-Xss</code> ：调整每个线程栈空间的大小<br>
JDK5.0 以后每个线程堆栈大小为 1M，以前每个线程堆栈大小为 256K。<br>
在相同物理内存下，减小这个值能生成更多的线程。<br>
但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在 <code>3000~5000</code> 左右</p>
<h4> 设置线程栈的大小</h4>
<p><code>-XXThreadStackSize</code>：设置线程栈的大小(0 means use default stack size)</p>
<h3> 4.7、其他参数介绍</h3>
<ul>
<li><code>-XXThreadStackSize</code>：设置内存页的大小，不可设置过大，会影响Perm的大小</li>
<li><code>-XX:+UseFastAccessorMethods</code>：设置原始类型的快速优化</li>
<li><code>-XX:+DisableExplicitGC</code>：设置关闭 <code>System.gc()</code> (这个参数需要严格的测试)</li>
<li><code>-XX:MaxTenuringThreshold</code><br>
设置垃圾最大年龄。如果设置为0的话,则年轻代对象不经过 Survivor 区,直接进入年老代<br>
对于年老代比较多的应用,可以提高效率。如果将此值设置为一个较大值,<br>
则年轻代对象会在 Survivor 区进行多次复制,这样可以增加对象再年轻代的存活时间,<br>
增加在年轻代即被回收的概率。该参数只有在串行GC时才有效</li>
<li><code>-XX:+AggressiveOpts</code>：加快编译速度</li>
<li><code>-XX:+UseBiasedLocking</code>：改善锁机制性能</li>
<li><code>-Xnoclassgc</code>：禁用垃圾回收</li>
<li><code>-XX:SoftRefLRUPolicyMSPerMB</code>：设置每兆堆空闲空间中 SoftReference 的存活时间，默认值是 1s。</li>
<li><code>-XX:PretenureSizeThreshold</code>：设置对象超过多大时直接在老年代分配，默认值是 0。</li>
<li><code>-XX:TLABWasteTargetPercent</code>：设置 TLAB 占 eden 区的百分比，默认值是 1%</li>
<li><code>-XX:+CollectGen0First</code>：设置 FullGC 时是否先 YGC，默认值是 false</li>
</ul>
]]></content:encoded>
      <enclosure url="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230821005244740.png" type="image/png"/>
    </item>
    <item>
      <title>199. 二叉树的右视图</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_199.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_199.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE.html</guid>
      <source url="https://T4mako.github.io/rss.xml">199. 二叉树的右视图</source>
      <description>199. 二叉树的右视图</description>
      <category>算法</category>
      <pubDate>Sun, 20 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 199. 二叉树的右视图</h1>
]]></content:encoded>
    </item>
    <item>
      <title>236. 二叉树的最近公共祖先</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_236_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_236_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html</guid>
      <source url="https://T4mako.github.io/rss.xml">236. 二叉树的最近公共祖先</source>
      <description>236. 二叉树的最近公共祖先</description>
      <category>算法</category>
      <pubDate>Sat, 19 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 236. 二叉树的最近公共祖先</h1>
]]></content:encoded>
    </item>
    <item>
      <title>62. 不同路径</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_062_%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_062_%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.html</guid>
      <source url="https://T4mako.github.io/rss.xml">62. 不同路径</source>
      <description>62. 不同路径</description>
      <category>算法</category>
      <pubDate>Fri, 18 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 62. 不同路径</h1>
]]></content:encoded>
    </item>
    <item>
      <title>1372. 二叉树中的最长交错路径</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1372_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E4%BA%A4%E9%94%99%E8%B7%AF%E5%BE%84.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1372_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E4%BA%A4%E9%94%99%E8%B7%AF%E5%BE%84.html</guid>
      <source url="https://T4mako.github.io/rss.xml">1372. 二叉树中的最长交错路径</source>
      <description>1372. 二叉树中的最长交错路径</description>
      <category>算法</category>
      <pubDate>Fri, 18 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 1372. 二叉树中的最长交错路径</h1>
]]></content:encoded>
    </item>
    <item>
      <title>1448. 统计二叉树中好节点的数目</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1448_%E7%BB%9F%E8%AE%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%A5%BD%E8%8A%82%E7%82%B9%E7%9A%84%E6%95%B0%E7%9B%AE.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1448_%E7%BB%9F%E8%AE%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%A5%BD%E8%8A%82%E7%82%B9%E7%9A%84%E6%95%B0%E7%9B%AE.html</guid>
      <source url="https://T4mako.github.io/rss.xml">1448. 统计二叉树中好节点的数目</source>
      <description>1448. 统计二叉树中好节点的数目</description>
      <category>算法</category>
      <pubDate>Thu, 17 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 1448. 统计二叉树中好节点的数目</h1>
]]></content:encoded>
    </item>
    <item>
      <title>437. 路径总和 III</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_437_%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20III.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_437_%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20III.html</guid>
      <source url="https://T4mako.github.io/rss.xml">437. 路径总和 III</source>
      <description>437. 路径总和 III</description>
      <category>算法</category>
      <pubDate>Thu, 17 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 437. 路径总和 III</h1>
]]></content:encoded>
    </item>
    <item>
      <title>2130. 链表最大孪生和</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_2130_%E9%93%BE%E8%A1%A8%E6%9C%80%E5%A4%A7%E5%AD%AA%E7%94%9F%E5%92%8C.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_2130_%E9%93%BE%E8%A1%A8%E6%9C%80%E5%A4%A7%E5%AD%AA%E7%94%9F%E5%92%8C.html</guid>
      <source url="https://T4mako.github.io/rss.xml">2130. 链表最大孪生和</source>
      <description>2130. 链表最大孪生和</description>
      <category>算法</category>
      <pubDate>Wed, 16 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 2130. 链表最大孪生和</h1>
]]></content:encoded>
    </item>
    <item>
      <title>872. 叶子相似的树</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_872_%E5%8F%B6%E5%AD%90%E7%9B%B8%E4%BC%BC%E7%9A%84%E6%A0%91.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_872_%E5%8F%B6%E5%AD%90%E7%9B%B8%E4%BC%BC%E7%9A%84%E6%A0%91.html</guid>
      <source url="https://T4mako.github.io/rss.xml">872. 叶子相似的树</source>
      <description>872. 叶子相似的树</description>
      <category>算法</category>
      <pubDate>Wed, 16 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 872. 叶子相似的树</h1>
]]></content:encoded>
    </item>
    <item>
      <title>SpringBoot 自动装配原理</title>
      <link>https://T4mako.github.io/code/java/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86.html</link>
      <guid>https://T4mako.github.io/code/java/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86.html</guid>
      <source url="https://T4mako.github.io/rss.xml">SpringBoot 自动装配原理</source>
      <description>早期的Spring项目需要添加需要配置繁琐的xml,比如MVC、事务、数据库连接等繁琐的配置。SpringBoot的出现就无需这些繁琐的配置，因为SpringBoot基于约定大于配置的理念，在项目启动时候，将约定的配置类自动配置到IOC容器里。这些都因为SpringBoot有自动配置的特性。 Sping Boot 如何实现自动配置 Spring Boot都需要创建一个mian启动类，而启动类都含有@SpringBootApplication注解，从启动类，一步步探索源码。</description>
      <category>java</category>
      <pubDate>Tue, 15 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>早期的<code>Spring</code>项目需要添加需要配置繁琐的xml,比如<code>MVC</code>、事务、数据库连接等繁琐的配置。<code>SpringBoot</code>的出现就无需这些繁琐的配置，因为<code>SpringBoot</code>基于<strong>约定大于配置</strong>的理念，在项目启动时候，将约定的配置类自动配置到<code>IOC</code>容器里。这些都因为<code>SpringBoot</code>有自动配置的特性。</p>
<h2> Sping Boot 如何实现自动配置</h2>
<p><code>Spring Boot</code>都需要创建一个<code>mian</code>启动类，而启动类都含有<code>@SpringBootApplication</code>注解，从启动类，一步步探索源码。</p>
<h3> @SpringBootApplication注解</h3>
<p><code>Spring Boot</code> 启动类上都有一个 <code>@SpringBootApplication</code>注解：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> @EnableAutoConfiguration注解</h3>
<p><code>@SpringBootApplication</code> 里面有 <code>@EnableAutoConfiguration</code> 的注解：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> AutoConfigurationImportSelector类</h3>
<p><code>@EnableAutoConfiguration</code>注解导入<code>AutoConfigurationImportSelector</code>类：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> selectImports()方法</h3>
<p><code>AutoConfigurationImportSelector</code>类找到 <code>selectImports</code> 方法，里面有<code>getAutoConfigurationEntry</code>方法：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> SpringFactoriesLoader.loadFactoryNames() 方法</h3>
<p><code>getAutoConfigurationEntry</code>方法通过<code>SpringFactoriesLoader.loadFactoryNames()</code> 扫描所有含有<code>META-INF/spring.factories</code>的<code>jar</code>包：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>spring-boot-autoconfigure-xxx.jar</code>项目包含<code>META-INF/spring.factories</code>文件，<code>spring.factories</code>是一个键值对的形式，扫描该文件下<code>@EnableAutoConfiguration</code>对应类：</p>
<div class="hint-container info">
<p class="hint-container-title">总结</p>
<ul>
<li>自动配置主要由<code>@EnableAutoConfiguration</code>实现</li>
<li>添加了<code>@EnableAutoConfiguration</code>注解，会导入<code>AutoConfigurationImportSelector</code>类</li>
<li>里面的<code>selectImports</code>方法通过<code>SpringFactoriesLoader.loadFactoryNames()</code>扫描所有含有<code>META-INF/spring.factories</code>的<code>jar</code>包</li>
<li><code>spring.factories</code>是一个键值对的形式，扫描该文件下<code>@EnableAutoConfiguration</code>对应类：</li>
<li>将对应<code>key</code>为<code>@EnableAutoConfiguration</code>注解全名对应的<code>value</code>类全部装配到<code>IOC</code>容器中。</li>
</ul>
</div>
<p>这些属性自动配置到<code>IOC</code>之后就无需自己手动配置<code>bean</code>了，<code>Spring Boot</code>中的<code>约定大于配置</code>理念，约定是将需要的配置以约定的方式添加到<code>IOC</code>容器中。</p>
<h2> 自动配置生效条件</h2>
<p>那是不是<code>spring.factories</code>文件对应的配置都会加载到<code>IOC</code>容器中？</p>
<p>其中有几个注解：  <code>@ConditionalOnClass</code>, <code>@ConditionalOnMissingBean</code></p>
<ul>
<li><code>@ConditionalOnClass</code>表示在类路径中存在类才会配置该配置类。只有引入相关依赖才会自动配置该配置类。</li>
<li><code>@ConditionalOnMissingBean</code>表示只有不存在对应的类的<code>bean</code>才会自动配置该类。</li>
</ul>
<p>所以<code>spring.factories</code>里面并不是所有的<code>bean</code>都会装配到<code>IOC</code>容器中，只会按需配置对应的<code>bean</code>。</p>
]]></content:encoded>
    </item>
    <item>
      <title>数组</title>
      <link>https://T4mako.github.io/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScript/5%E3%80%81%E6%95%B0%E7%BB%84.html</link>
      <guid>https://T4mako.github.io/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScript/5%E3%80%81%E6%95%B0%E7%BB%84.html</guid>
      <source url="https://T4mako.github.io/rss.xml">数组</source>
      <description>五、数组 JavaScript 数组在 TypeScript 里面分成两种类型，分别是数组（array）和元组（tuple）。 1、简介 TypeScript 数组有一个根本特征：所有成员的类型必须相同，但是成员数量是不确定的，可以是无限数量的成员，也可以是零成员。 数组的类型有两种写法。第一种写法是在数组成员的类型后面，加上一对方括号。 let arr:number[] = [1, 2, 3];</description>
      <category>TypeScript</category>
      <pubDate>Tue, 15 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 五、数组</h2>
<p>JavaScript 数组在 TypeScript 里面分成两种类型，分别是<strong>数组（array）<strong>和</strong>元组（tuple）</strong>。</p>
<h3> 1、简介</h3>
<p>TypeScript 数组有一个根本特征：所有成员的<strong>类型必须相同</strong>，但是成员数量是不确定的，可以是无限数量的成员，也可以是零成员。</p>
<p>数组的类型有两种写法。第一种写法是在数组成员的类型后面，加上一对方括号。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面示例中，数组<code>arr</code>的类型是<code>number[]</code>，其中<code>number</code>表示数组成员类型是<code>number</code>。</p>
<p>如果数组成员的类型比较复杂，可以写在圆括号里面。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面示例中，数组<code>arr</code>的成员类型是<code>number|string</code>。</p>
<p>这个例子里面的圆括号是必须的，否则因为竖杠<code>|</code>的优先级低于<code>[]</code>，TypeScript 会把<code>number|string[]</code>理解成<code>number</code>和<code>string[]</code>的联合类型。</p>
<p>如果数组成员可以是任意类型，写成<code>any[]</code>。当然，这种写法是应该避免的。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>数组类型的第二种写法是使用 TypeScript 内置的 <code>Array </code>接口。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面示例中，数组<code>arr</code>的类型是<code>Array&lt;number&gt;</code>，其中<code>number</code>表示成员类型是<code>number</code>。</p>
<p>这种写法对于成员类型比较复杂的数组，代码<strong>可读性</strong>会稍微好一些。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这种写法本质上属于泛型，详细解释参见《泛型》一章。<br>
另外，数组类型还有第三种写法，因为很少用到，本章就省略了，详见《interface 接口》一章。</p>
<p>数组类型声明了以后，成员数量是不限制的，任意数量的成员都可以，也可以是空数组。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，数组<code>arr</code>无论有多少个成员，都是正确的。</p>
<p>这种规定的隐藏含义就是，数组的成员是可以动态变化的。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，数组增加成员或减少成员，都是可以的。</p>
<p>正是由于成员数量可以动态变化，所以 TypeScript 不会对数组边界进行检查，越界访问数组并不会报错。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>foo</code>的值是一个不存在的数组成员，TypeScript 并不会报错。</p>
<p>TypeScript 允许使用方括号读取数组成员的类型。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，类型<code>Names</code>是字符串数组，那么<code>Names[0]</code>返回的类型就是<code>string</code>。</p>
<p>由于数组成员的索引类型都是<code>number</code>，所以读取成员类型也可以写成下面这样。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>Names[number]</code>表示数组<code>Names</code>所有数值索引的成员类型，所以返回<code>string</code>。</p>
<h3> 2、数组的类型推断</h3>
<p>如果数组变量没有声明类型，TypeScript 就会推断数组成员的类型。这时，推断行为会因为值的不同，而有所不同。</p>
<p>如果变量的初始值是空数组，那么 TypeScript 会推断数组类型是<code>any[]</code>。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>后面，为这个数组赋值时，TypeScript 会自动更新类型推断。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>上面示例中，数组变量<code>arr</code>的初始值是空数组，然后随着新成员的加入，TypeScript 会自动修改推断的数组类型。</p>
<p>但是，类型推断的自动更新只发生初始值为空数组的情况。如果初始值不是空数组，类型推断就不会更新。</p>
</div>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，数组变量<code>arr</code>的初始值是<code>[123]</code>，TypeScript 就推断成员类型为<code>number</code>。新成员如果不是这个类型，TypeScript 就会报错，而不会更新类型推断。</p>
<h3> 3、只读数组，const 断言</h3>
<p>JavaScript 规定，<code>const</code>命令声明的数组变量是可以改变成员的。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，修改<code>const</code>命令声明的数组的成员是允许的。</p>
<p>但是，很多时候确实有声明为只读数组的需求，即不允许变动数组成员。</p>
<p>TypeScript 允许声明只读数组，方法是在数组类型前面加上<code>readonly</code>关键字。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>TypeScript 将<code>readonly number[]</code>与<code>number[]</code>视为两种不一样的类型，后者是前者的子类型。</p>
<p>这是因为只读数组没有<code>pop()</code>、<code>push()</code>之类会改变原数组的方法，所以<code>number[]</code>的方法数量要多于<code>readonly number[]</code>，这意味着<code>number[]</code>其实是<code>readonly number[]</code>的子类型。</p>
<p>我们知道，子类型继承了父类型的所有特征，并加上了自己的特征，所以子类型<code>number[]</code>可以用于所有使用父类型的场合，反过来就不行。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，子类型<code>number[]</code>可以赋值给父类型<code>readonly number[]</code>，但是反过来就会报错。</p>
<p>由于只读数组是数组的父类型，所以它不能代替数组。这一点很容易产生令人困惑的报错。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，函数<code>getSum()</code>的参数<code>s</code>是一个数组，传入只读数组就会报错。原因就是只读数组是数组的父类型，父类型不能替代子类型。这个问题的解决方法是使用类型断言<code>getSum(arr as number[])</code>，详见《类型断言》一章。</p>
<div class="hint-container warning">
<p class="hint-container-title">注意</p>
<p>注意，<code>readonly</code>关键字不能与数组的泛型写法一起使用。</p>
</div>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>readonly</code>与数组的泛型写法一起使用，就会报错。</p>
<p>实际上，TypeScript 提供了两个专门的泛型，用来生成只读数组的类型。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，泛型<code>ReadonlyArray&lt;T&gt;</code>和<code>Readonly&lt;T[]&gt;</code>都可以用来生成只读数组类型。两者尖括号里面的写法不一样，<code>Readonly&lt;T[]&gt;</code>的尖括号里面是整个数组（<code>number[]</code>），而<code>ReadonlyArray&lt;T&gt;</code>的尖括号里面是数组成员（<code>number</code>）。</p>
<p>只读数组还有一种声明方法，就是使用“const 断言”。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>as const</code>告诉 TypeScript，推断类型时要把变量<code>arr</code>推断为只读数组，从而使得数组成员无法改变。</p>
<h3> 4、多维数组</h3>
<p>TypeScript 使用<code>T[][]</code>的形式，表示二维数组，<code>T</code>是最底层数组成员的类型。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>multi</code>的类型是<code>number[][]</code>，表示它是一个二维数组，最底层的数组成员类型是<code>number</code>。</p>
]]></content:encoded>
    </item>
    <item>
      <title>元组</title>
      <link>https://T4mako.github.io/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScript/6%E3%80%81%E5%85%83%E7%A5%96.html</link>
      <guid>https://T4mako.github.io/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScript/6%E3%80%81%E5%85%83%E7%A5%96.html</guid>
      <source url="https://T4mako.github.io/rss.xml">元组</source>
      <description>六、元祖 1、简介 元组（tuple）是 TypeScript 特有的数据类型，JavaScript 没有单独区分这种类型。 元组必须明确声明每个成员的类型。 const s:[string, string, boolean] = [&amp;apos;a&amp;apos;, &amp;apos;b&amp;apos;, true];</description>
      <category>TypeScript</category>
      <pubDate>Tue, 15 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 六、元祖</h2>
<h3> 1、简介</h3>
<p>元组（tuple）是 TypeScript 特有的数据类型，JavaScript 没有单独区分这种类型。</p>
<p>元组必须明确声明每个成员的类型。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，元组<code>s</code>的前两个成员的类型是<code>string</code>，最后一个成员的类型是<code>boolean</code>。</p>
<p>元组类型的写法，与上一章的数组有一个重大差异。数组的成员类型写在方括号外面（<code>number[]</code>），元组的成员类型是写在方括号里面（<code>[number]</code>）。</p>
<p>TypeScript 的区分方法是，成员类型写在方括号里面的就是元组，写在外面的就是数组。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面示例中，变量<code>a</code>是一个元组，只有一个成员，类型是<code>number</code>。</p>
<p>使用元组时，必须明确给出类型声明（上例的<code>[number]</code>），不能省略，否则 TypeScript 会把一个值自动推断为数组。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>a</code>的值其实是一个元组，但是 TypeScript 会将其推断为一个联合类型的数组，即<code>a</code>的类型为<code>(number | boolean)[]</code>。</p>
<p>元组成员的类型可以添加问号后缀（<code>?</code>），表示该成员是可选的。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面示例中，元组<code>a</code>的第二个成员是可选的，可以省略。</p>
<div class="hint-container warning">
<p class="hint-container-title">注意</p>
<p>注意，问号只能用于元组的尾部成员，也就是说，所有可选成员必须在必选成员之后。</p>
</div>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，元组<code>myTuple</code>的最后两个成员是可选的。也就是说，它的成员数量可能有两个、三个和四个。</p>
<p>由于需要声明每个成员的类型，所以大多数情况下，元组的成员数量是有限的，从类型声明就可以明确知道，元组包含多少个成员，越界的成员会报错。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>x</code>是一个只有两个成员的元组，如果对第三个成员赋值就报错了。</p>
<p>但是，使用扩展运算符（<code>...</code>），可以表示不限成员数量的元组。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，元组类型<code>NamedNums</code>的第一个成员是字符串，后面的成员使用扩展运算符来展开一个数组，从而实现了不定数量的成员。</p>
<p>扩展运算符用在元组的任意位置都可以，但是它后面只能是数组或元组。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，扩展运算符分别在元组的尾部、中部和头部。</p>
<p>如果不确定元组成员的类型和数量，可以写成下面这样。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面示例中，元组<code>Tuple</code>可以放置任意数量和类型的成员。但是这样写，也就失去了使用元组和 TypeScript 的意义。</p>
<p>元组可以通过方括号，读取成员类型。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>Tuple[1]</code>返回1号位置的成员类型。</p>
<p>由于元组的成员都是数值索引，即索引类型都是<code>number</code>，所以可以像下面这样读取。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>Tuple[number]</code>表示元组<code>Tuple</code>的所有数值索引的成员类型，所以返回<code>string|number|Date</code>，即这个类型是三种值的联合类型。</p>
<h3> 2、只读元组</h3>
<p>元组也可以是只读的，不允许修改，有两种写法。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，两种写法都可以得到只读元组，其中写法二是一个泛型，用到了工具类型<code>Readonly&lt;T&gt;</code>。</p>
<p>跟数组一样，只读元组是元组的父类型。所以，元组可以替代只读元组，而只读元组不能替代元组。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，类型<code>t1</code>是只读元组，类型<code>t2</code>是普通元组。<code>t2</code>类型可以赋值给<code>t1</code>类型，反过来就会报错。</p>
<p>由于只读元组不能替代元组，所以会产生一些令人困惑的报错。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，函数<code>distanceFromOrigin()</code>的参数是一个元组，传入只读元组就会报错，因为只读元组不能替代元组。</p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>读者可能注意到了，上例中<code>[3, 4] as const</code>的写法，在上一章讲到，生成的是只读数组，其实生成的同时也是只读元组。因为它生成的实际上是一个只读的“值类型”<code>readonly [3, 4]</code>，把它解读成只读数组或只读元组都可以。</p>
</div>
<p>上面示例报错的解决方法，就是使用类型断言，在最后一行将传入的参数断言为普通元组，详见《类型断言》一章。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3、成员数量的推断</h3>
<p>如果没有可选成员和扩展运算符，TypeScript 会推断出元组的成员数量（即元组长度）。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例会报错，原因是 TypeScript 发现元组<code>point</code>的长度是<code>2</code>，不可能等于<code>3</code>，这个判断无意义。</p>
<p>如果包含了可选成员，TypeScript 会推断出可能的成员数量。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例会报错，原因是 TypeScript 发现<code>point.length</code>的类型是<code>1|2|3</code>，不可能等于<code>4</code>。</p>
<p>如果使用了扩展运算符，TypeScript 就无法推断出成员数量。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>myTuple</code>只有三个成员，但是 TypeScript 推断不出它的成员数量，因为它的类型用到了扩展运算符，TypeScript 把<code>myTuple</code>当成数组看待，而数组的成员数量是不确定的。</p>
<p>一旦扩展运算符使得元组的成员数量无法推断，TypeScript 内部就会把该元组当成数组处理。</p>
<h3> 4、扩展运算符与成员数量</h3>
<p>扩展运算符（<code>...</code>）将数组（注意，不是元组）转换成一个逗号分隔的序列，这时 TypeScript 会认为这个序列的成员数量是不确定的，因为数组的成员数量是不确定的。</p>
<p>这导致如果函数调用时，使用扩展运算符传入函数参数，可能发生参数数量与数组长度不匹配的报错。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例会报错，原因是函数<code>add()</code>只能接受两个参数，但是传入的是<code>...arr</code>，TypeScript 认为转换后的参数个数是不确定的。</p>
<p>有些函数可以接受任意数量的参数，这时使用扩展运算符就不会报错。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>console.log()</code>可以接受任意数量的参数，所以传入<code>...arr</code>就不会报错。</p>
<p>解决这个问题的一个方法，就是把成员数量不确定的数组，写成成员数量确定的元组，再使用扩展运算符。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>arr</code>是一个拥有两个成员的元组，所以 TypeScript 能够确定<code>...arr</code>可以匹配函数<code>add()</code>的参数数量，就不会报错了。</p>
<p>另一种写法是使用<code>as const</code>断言。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面这种写法也可以，因为 TypeScript 会认为<code>arr</code>的类型是<code>readonly [1, 2]</code>，这是一个只读的值类型，可以当作数组，也可以当作元组。</p>
]]></content:encoded>
    </item>
    <item>
      <title>symbol 类型</title>
      <link>https://T4mako.github.io/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScript/7%E3%80%81symbol%20%E7%B1%BB%E5%9E%8B.html</link>
      <guid>https://T4mako.github.io/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScript/7%E3%80%81symbol%20%E7%B1%BB%E5%9E%8B.html</guid>
      <source url="https://T4mako.github.io/rss.xml">symbol 类型</source>
      <description>七、symbol 类型 1、简介 Symbol 是 ES2015 新引入的一种原始类型的值。它类似于字符串，但是每一个 Symbol 值都是独一无二的，与其他任何值都不相等。 Symbol 值通过Symbol()函数生成。在 TypeScript 里面，Symbol 的类型使用symbol表示。 let x:symbol = Symbol(); let y:symbol = Symbol(); x === y // false</description>
      <category>TypeScript</category>
      <pubDate>Tue, 15 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 七、symbol 类型</h2>
<h3> 1、简介</h3>
<p>Symbol 是 ES2015 新引入的一种原始类型的值。它类似于字符串，但是每一个 Symbol 值都是独一无二的，与其他任何值都不相等。</p>
<p>Symbol 值通过<code>Symbol()</code>函数生成。在 TypeScript 里面，Symbol 的类型使用<code>symbol</code>表示。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>x</code>和<code>y</code>的类型都是<code>symbol</code>，且都用<code>Symbol()</code>生成，但是它们是不相等的。</p>
<h3> 2、unique symbol</h3>
<p><code>symbol</code>类型包含所有的 Symbol 值，但是无法表示某一个具体的 Symbol 值。</p>
<p>比如，<code>5</code>是一个具体的数值，就用<code>5</code>这个字面量来表示，这也是它的值类型。但是，Symbol 值不存在字面量，必须通过变量来引用，所以写不出只包含单个 Symbol 值的那种值类型。</p>
<p>为了解决这个问题，TypeScript 设计了<code>symbol</code>的一个子类型<code>unique symbol</code>，它表示单个的、某个具体的 Symbol 值。</p>
<p>因为<code>unique symbol</code>表示单个值，所以这个类型的变量是不能修改值的，只能用<code>const</code>命令声明，不能用<code>let</code>声明。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>let</code>命令声明的变量，不能是<code>unique symbol</code>类型，会报错。</p>
<p><code>const</code>命令为变量赋值 Symbol 值时，变量类型默认就是<code>unique symbol</code>，所以类型可以省略不写。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>每个声明为<code>unique symbol</code>类型的变量，它们的值都是不一样的，其实属于两个值类型。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>a</code>和变量<code>b</code>的类型虽然都是<code>unique symbol</code>，但其实是两个值类型。不同类型的值肯定是不相等的，所以最后一行就报错了。</p>
<p>由于 Symbol 类似于字符串，可以参考下面的例子来理解。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>a</code>和<code>b</code>都是字符串，但是属于不同的值类型，不能使用严格相等运算符进行比较。</p>
<p>而且，由于变量<code>a</code>和<code>b</code>是两个类型，就不能把一个赋值给另一个。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>a</code>和变量<code>b</code>的类型都是<code>unique symbol</code>，但是其实类型不同，所以把<code>a</code>赋值给<code>b</code>会报错。</p>
<p>上例变量<code>b</code>的类型，如果要写成与变量<code>a</code>同一个<code>unique symbol</code>值类型，只能写成类型为<code>typeof a</code>。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>不过我们知道，相同参数的<code>Symbol.for()</code>方法会返回相同的 Symbol 值。TypeScript 目前无法识别这种情况，所以可能出现多个 unique symbol 类型的变量，等于同一个 Symbol 值的情况。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>a</code>和<code>b</code>是两个不同的值类型，但是它们的值其实是相等的。</p>
<p>unique symbol 类型是 symbol 类型的子类型，所以可以将前者赋值给后者，但是反过来就不行。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，unique symbol 类型（变量<code>a</code>）赋值给 symbol 类型（变量<code>b</code>）是可以的，但是 symbol 类型（变量<code>b</code>）赋值给 unique symbol 类型（变量<code>c</code>）会报错。</p>
<p>unique symbol 类型的一个作用，就是用作属性名，这可以保证不会跟其他属性名冲突。如果要把某一个特定的 Symbol 值当作属性名，那么它的类型只能是 unique symbol，不能是 symbol。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>y</code>当作属性名，但是<code>y</code>的类型是 symbol，不是固定不变的值，导致报错。</p>
<p><code>unique symbol</code>类型也可以用作类（class）的属性值，但只能赋值给类的<code>readonly static</code>属性。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，静态只读属性<code>foo</code>的类型就是<code>unique symbol</code>。注意，这时<code>static</code>和<code>readonly</code>两个限定符缺一不可，这是为了保证这个属性是固定不变的。</p>
<h3> 3、类型推断</h3>
<p>如果变量声明时没有给出类型，TypeScript 会推断某个 Symbol 值变量的类型。</p>
<p><code>let</code>命令声明的变量，推断类型为 symbol。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>const</code>命令声明的变量，推断类型为 unique symbol。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>但是，<code>const</code>命令声明的变量，如果赋值为另一个 symbol 类型的变量，则推断类型为 symbol。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>let</code>命令声明的变量，如果赋值为另一个 unique symbol 类型的变量，则推断类型还是 symbol。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>函数</title>
      <link>https://T4mako.github.io/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScript/8%E3%80%81%E5%87%BD%E6%95%B0.html</link>
      <guid>https://T4mako.github.io/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScript/8%E3%80%81%E5%87%BD%E6%95%B0.html</guid>
      <source url="https://T4mako.github.io/rss.xml">函数</source>
      <description>八、函数 1、简介 函数的类型声明，需要在声明函数时，给出参数的类型和返回值的类型。 function hello( txt:string // 参数类型 ):void { // 返回值类型 console.log(&amp;apos;hello &amp;apos; + txt); }</description>
      <category>TypeScript</category>
      <pubDate>Tue, 15 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 八、函数</h2>
<h3> 1、简介</h3>
<p>函数的类型声明，需要在声明函数时，给出参数的类型和返回值的类型。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果不指定参数类型（比如上例不写<code>txt</code>的类型），TypeScript 就会推断参数类型，如果缺乏足够信息，就会推断该参数的类型为<code>any</code>。</p>
<p>返回值的类型<strong>通常可以不写</strong>，因为 TypeScript 自己会推断出来。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，由于没有<code>return</code>语句，TypeScript 会推断出函数<code>hello()</code>没有返回值。</p>
<p>不过，有时候出于文档目的，或者为了防止不小心改掉返回值，还是会写返回值的类型。</p>
<p>如果变量被赋值为一个函数，变量的类型有两种写法。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>hello</code>被赋值为一个函数，它的类型有两种写法。写法一是通过等号右边的函数类型，推断出变量<code>hello</code>的类型；写法二则是使用箭头函数的形式，为变量<code>hello</code>指定类型，参数的类型写在箭头左侧，返回值的类型写在箭头右侧。</p>
<p>写法二有两个地方需要注意。</p>
<p>首先，函数的参数要放在圆括号里面，不放会报错。</p>
<p>其次，类型里面的参数名（本例是<code>txt</code>）是必须的。有的语言的函数类型可以不写参数名（比如 C 语言），但是 TypeScript 不行。如果写成<code>(string) =&gt; void</code>，TypeScript 会理解成函数有一个名叫 string 的参数，并且这个<code>string</code>参数的类型是<code>any</code>。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，函数类型没写参数名，导致 TypeScript 认为参数类型都是<code>any</code>。</p>
<p>函数类型里面的参数名与实际参数名，可以不一致。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，函数类型里面的参数名为<code>x</code>，实际的函数定义里面，参数名为<code>y</code>，两者并不相同。</p>
<p>如果函数的类型定义很冗长，或者多个函数使用同一种类型，写法二用起来就很麻烦。因此，往往用<code>type</code>命令为函数类型定义一个别名，便于指定给其他变量。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>type</code>命令为函数类型定义了一个别名<code>MyFunc</code>，后面使用就很方便，变量可以指定为这个类型。</p>
<p>函数的实际参数个数，可以少于类型指定的参数个数，但是不能多于，即 TypeScript 允许省略参数。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>myFunc</code>的类型只能接受两个参数，如果被赋值为只有一个参数的函数，并不报错。但是，被赋值为有三个参数的函数，就会报错。</p>
<p>这是因为 JavaScript 函数在声明时往往有多余的参数，实际使用时可以只传入一部分参数。比如，数组的<code>forEach()</code>方法的参数是一个函数，该函数默认有三个参数<code>(item, index, array) =&gt; void</code>，实际上往往只使用第一个参数<code>(item) =&gt; void</code>。因此，TypeScript 允许函数传入的参数不足。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，函数<code>x</code>只有一个参数，函数<code>y</code>有两个参数，<code>x</code>可以赋值给<code>y</code>，反过来就不行。</p>
<p>如果一个变量要套用另一个函数类型，有一个小技巧，就是使用<code>typeof</code>运算符。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，函数<code>myAdd()</code>的类型与函数<code>add()</code>是一样的，那么就可以定义成<code>typeof add</code>。因为函数名<code>add</code>本身不是类型，而是一个值，所以要用<code>typeof</code>运算符返回它的类型。</p>
<p>这是一个很有用的技巧，任何需要类型的地方，都可以使用<code>typeof</code>运算符从一个值获取类型。</p>
<p>函数类型还可以采用对象的写法。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>add</code>的类型就写成了一个对象。</p>
<p>函数类型的对象写法如下。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，这种写法的函数参数与返回值之间，间隔符是冒号<code>:</code>，而不是正常写法的箭头<code>=&gt;</code>，因为这里采用的是对象类型的写法，对象的属性名与属性值之间使用的是冒号。</p>
<p>这种写法平时很少用，但是非常合适用在一个场合：函数本身存在属性。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，函数<code>f()</code>本身还有一个属性<code>version</code>。这时，<code>f</code>完全就是一个对象，类型就要使用对象的写法。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>函数类型也可以使用 Interface 来声明，这种写法就是对象写法的翻版，详见《Interface》一章。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，interface 命令定义了接口<code>myfn</code>，这个接口的类型就是一个用对象表示的函数。</p>
<h3> 2、Function 类型</h3>
<p>TypeScript 提供 Function 类型表示函数，任何函数都属于这个类型。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，参数<code>f</code>的类型就是<code>Function</code>，代表这是一个函数。</p>
<p>Function 类型的值都可以直接执行。</p>
<p>Function 类型的函数可以接受任意数量的参数，每个参数的类型都是<code>any</code>，返回值的类型也是<code>any</code>，代表没有任何约束，所以不建议使用这个类型，给出函数详细的类型声明会更好。</p>
<h3> 3、箭头函数</h3>
<p>箭头函数是普通函数的一种简化写法，它的类型写法与普通函数类似。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>repeat</code>被赋值为一个箭头函数，类型声明写在箭头函数的定义里面。其中，参数的类型写在参数名后面，返回值类型写在参数列表的圆括号后面。</p>
<p>注意，类型写在箭头函数的定义里面，与使用箭头函数表示函数类型，写法有所不同。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，函数<code>greet()</code>的参数<code>fn</code>是一个函数，类型就用箭头函数表示。这时，<code>fn</code>的返回值类型要写在箭头右侧，而不是写在参数列表的圆括号后面。</p>
<p>下面再看一个例子。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>Person</code>是一个类型别名，代表一个对象，该对象有属性<code>name</code>。变量<code>people</code>是数组的<code>map()</code>方法的返回值。</p>
<p><code>map()</code>方法的参数是一个箭头函数<code>(name):Person =&gt; ({name})</code>，该箭头函数的参数<code>name</code>的类型省略了，因为可以从<code>map()</code>的类型定义推断出来，箭头函数的返回值类型为<code>Person</code>。相应地，变量<code>people</code>的类型是<code>Person[]</code>。</p>
<p>至于箭头后面的<code>({name})</code>，表示返回一个对象，该对象有一个属性<code>name</code>，它的属性值为变量<code>name</code>的值。这里的圆括号是必须的，否则<code>(name):Person =&gt; {name}</code>的大括号表示函数体，即函数体内有一行语句<code>name</code>，同时由于没有<code>return</code>语句，这个函数不会返回任何值。</p>
<p>注意，下面两种写法都是不对的。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的两种写法在本例中都是错的。第一种写法表示，箭头函数的参数<code>name</code>的类型是<code>Person</code>，同时没写函数返回值的类型，让 TypeScript 自己去推断。第二种写法中，函数参数缺少圆括号。</p>
<h3> 4、可选参数</h3>
<p>如果函数的某个参数可以省略，则在参数名后面加问号表示。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，参数<code>x</code>后面有问号，表示该参数可以省略。</p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>参数名带有问号，表示该参数的类型实际上是<code>原始类型|undefined</code>，它有可能为<code>undefined</code>。<br>
比如，上例的<code>x</code>虽然类型声明为<code>number</code>，但是实际上是<code>number|undefined</code>。</p>
</div>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，参数<code>x</code>是可选的，等同于说<code>x</code>可以赋值为<code>undefined</code>。</p>
<p>但是，反过来就不成立，类型显式设为<code>undefined</code>的参数，就不能省略。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，参数<code>x</code>的类型是<code>number|undefined</code>，表示要么传入一个数值，要么传入<code>undefined</code>，如果省略这个参数，就会报错。</p>
<div class="hint-container warning">
<p class="hint-container-title">注意</p>
<p>函数的可选参数只能在参数列表的尾部，跟在必选参数的后面。</p>
</div>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，可选参数在必选参数前面，就报错了。</p>
<p>如果前部参数有可能为空，这时只能显式注明该参数类型可能为<code>undefined</code>。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，参数<code>a</code>有可能为空，就只能显式注明类型包括<code>undefined</code>，传参时也要显式传入<code>undefined</code>。</p>
<p>函数体内部用到可选参数时，需要判断该参数是否为<code>undefined</code>。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，由于函数的第二个参数为可选参数，所以函数体内部需要判断一下，该参数是否为空。</p>
<h3> 5、参数默认值</h3>
<p>TypeScript 函数的参数默认值写法，与 JavaScript 一致。</p>
<p>设置了默认值的参数，就是可选的。如果不传入该参数，它就会等于默认值。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，参数<code>x</code>和<code>y</code>的默认值都是<code>0</code>，调用<code>createPoint()</code>时，这两个参数都是可以省略的。这里其实可以省略<code>x</code>和<code>y</code>的类型声明，因为可以从默认值推断出来。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可选参数与默认值不能同时使用。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>x</code>是可选参数，还设置了默认值，结果就报错了。</p>
<p>设有默认值的参数，如果传入<code>undefined</code>，也会触发默认值。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>具有默认值的参数如果不位于参数列表的末尾，调用时不能省略，如果要触发默认值，必须显式传入<code>undefined</code>。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6、参数解构</h3>
<p>函数参数如果存在变量解构，类型写法如下。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>参数解构可以结合类型别名（type 命令）一起使用，代码会看起来简洁一些。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7、rest 参数</h3>
<p>rest 参数表示函数剩余的所有参数，它可以是数组（剩余参数类型相同），也可能是元组（剩余参数类型不同）。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，元组需要声明每一个剩余参数的类型。如果元组里面的参数是可选的，则要使用可选参数。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是一个 rest 参数的例子。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，参数<code>m</code>就是 rest 类型，它的类型是一个数组。</p>
<p>rest 参数甚至可以嵌套。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>rest 参数可以与变量解构结合使用。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8、readonly 只读参数</h3>
<p>如果函数内部不能修改某个参数，可以在函数定义时，在参数类型前面加上<code>readonly</code>关键字，表示这是只读参数。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，参数<code>arr</code>的类型是<code>readonly number[]</code>，表示为只读参数。如果函数体内部修改这个数组，就会报错。</p>
<h3> 9、void 类型</h3>
<p>void 类型表示函数没有返回值。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，函数<code>f</code>没有返回值，类型就要写成<code>void</code>。</p>
<p>如果返回其他值，就会报错。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>void 类型允许返回<code>undefined</code>或<code>null</code>。</p>
</div>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果打开了<code>strictNullChecks</code>编译选项，那么 void 类型只允许返回<code>undefined</code>。如果返回<code>null</code>，就会报错。这是因为 JavaScript 规定，如果函数没有返回值，就等同于返回<code>undefined</code>。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>需要特别注意的是，如果变量、对象方法、函数参数的类型是 void 类型的函数，那么并不代表不能赋值为有返回值的函数。恰恰相反，该变量、对象方法和函数参数可以接受返回任意值的函数，这时并不会报错。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>f</code>的类型是<code>voidFunc</code>，是一个没有返回值的函数类型。但是实际上，<code>f</code>的值是一个有返回值的函数（返回<code>123</code>），编译时不会报错。</p>
<p>这是因为，这时 TypeScript 认为，这里的 void 类型只是表示该函数的返回值没有利用价值，或者说不应该使用该函数的返回值。<strong>只要不用到这里的返回值，就不会报错。</strong></p>
<p>这样设计是有现实意义的。举例来说，数组方法<code>Array.prototype.forEach(fn)</code>的参数<code>fn</code>是一个函数，而且这个函数应该没有返回值，即返回值类型是<code>void</code>。</p>
<p>但是，实际应用中，很多时候传入的函数是有返回值，但是它的返回值不重要，或者不产生作用。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>push()</code>有返回值，表示新插入的元素在数组里面的位置。但是，对于<code>forEach()</code>方法来说，这个返回值是没有作用的，根本用不到，所以 TypeScript 不会报错。</p>
<p>如果后面使用了这个函数的返回值，就违反了约定，则会报错。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，最后一行报错了，因为根据类型声明，<code>f()</code>没有返回值，但是却用到了它的返回值，因此报错了。</p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>注意，这种情况仅限于变量、对象方法和函数参数，函数字面量如果声明了返回值是 void 类型，还是不能有返回值。</p>
</div>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，函数字面量声明了返回<code>void</code>类型，这时只要有返回值（除了<code>undefined</code>和<code>null</code>）就会报错。</p>
<p>除了函数，其他变量声明为<code>void</code>类型没有多大意义，因为这时只能赋值为<code>undefined</code>或者<code>null</code>（假定没有打开<code>strictNullChecks</code>) 。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 10、never 类型</h3>
<p><code>never</code>类型表示肯定不会出现的值。它用在函数的返回值，就表示某个函数肯定不会返回值，即函数不会正常执行结束。</p>
<p>它主要有以下两种情况。</p>
<p>（1）抛出错误的函数。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，函数<code>fail()</code>会抛错，不会正常退出，所以返回值类型是<code>never</code>。</p>
<p>注意，只有抛出错误，才是 never 类型。如果显式用<code>return</code>语句返回一个 Error 对象，返回值就不是 never 类型。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（2）无限执行的函数。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，函数<code>sing()</code>会永远执行，不会返回，所以返回值类型是<code>never</code>。</p>
<p>注意，<code>never</code>类型不同于<code>void</code>类型。前者表示函数没有执行结束，不可能有返回值；后者表示函数正常执行结束，但是不返回值，或者说返回<code>undefined</code>。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，函数<code>sing()</code>虽然没有<code>return</code>语句，但实际上是<strong>省略了<code>return undefined</code>这行语句</strong>，真实的返回值是<code>undefined</code>。所以，它的返回值类型要写成<code>void</code>，而不是<code>never</code>，写成<code>never</code>会报错。</p>
<p>如果一个函数抛出了异常或者陷入了死循环，那么该函数无法正常返回一个值，因此该函数的返回值类型就是<code>never</code>。<br>
如果程序中调用了一个返回值类型为<code>never</code>的函数，那么就意味着程序会在该函数的调用位置<strong>终止</strong>，永远不会继续执行后续的代码。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，函数<code>f()</code>的参数<code>x</code>的类型为<code>string|undefined</code>。但是，<code>x</code>类型为<code>undefined</code>时，调用了<code>neverReturns()</code>。这个函数不会返回，因此 TypeScript 可以推断出，判断语句后面的那个<code>x</code>，类型一定是<code>string</code>。</p>
<h3> 11、局部类型</h3>
<p>函数内部允许声明其他类型，该类型只在函数内部有效，称为局部类型。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，类型<code>message</code>是在函数<code>hello()</code>内部定义的，只能在函数内部使用。在函数外部使用，就会报错。</p>
<h3> 12、高阶函数</h3>
<p>一个函数的返回值还是一个函数，那么前一个函数就称为高阶函数（higher-order function）。</p>
<p>下面就是一个例子，箭头函数返回的还是一个箭头函数。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 13、函数重载</h3>
<p>有些函数可以接受不同类型或不同个数的参数，并且根据参数的不同，会有不同的函数行为。这种根据参数类型不同，执行不同逻辑的行为，称为函数重载（function overload）。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，函数<code>reverse()</code>可以将参数颠倒输出。参数可以是字符串，也可以是数组。</p>
<p>这意味着，该函数内部有处理字符串和数组的两套逻辑，根据参数类型的不同，分别执行对应的逻辑。这就叫“函数重载”。</p>
<p>TypeScript 对于“函数重载”的类型声明方法是，逐一定义每一种情况的类型。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，分别对函数<code>reverse()</code>的两种参数情况，给予了类型声明。但是，到这里还没有结束，后面还必须对函数<code>reverse()</code>给予完整的类型声明。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，前两行类型声明列举了重载的各种情况。<strong>第三行是函数本身的类型声明，它必须与前面已有的重载声明兼容。</strong></p>
<p>有一些编程语言允许不同的函数参数，对应不同的函数实现。<br>
但是，JavaScript 函数只能有一个实现，必须在这个实现当中，处理不同的参数。<br>
因此，<strong>函数体内部</strong>就需要<strong>判断参数的类型及个数</strong>，并根据判断结果执行不同的操作。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，函数<code>add()</code>内部使用<code>if</code>代码块，分别处理参数的两种情况。</p>
<p>注意，重载的各个类型描述与函数的具体实现之间，不能有其他代码，否则报错。</p>
<p>另外，虽然函数的具体实现里面，有完整的类型声明。但是，函数实际调用的类型，以前面的类型声明为准。比如，上例的函数实现，参数类型和返回值类型都是<code>number|any[]</code>，但不意味着参数类型为<code>number</code>时返回值类型为<code>any[]</code>。</p>
<p>函数重载的每个类型声明之间，以及类型声明与函数实现的类型之间，不能有冲突。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，函数重载的类型声明与函数实现是冲突的，导致报错。</p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>重载声明的<strong>排序</strong>很重要，因为 TypeScript 是按照顺序进行检查的，一旦发现符合某个类型声明，就不再往下检查了，所以类型最宽的声明应该放在最后面，防止覆盖其他类型声明。</p>
</div>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面声明中，第一行类型声明<code>x:any</code>范围最宽，导致函数<code>f()</code>的调用都会匹配这行声明，无法匹配第二行类型声明，所以最后一行调用就报错了，因为等号两侧类型不匹配，左侧类型是<code>0|1</code>，右侧类型是<code>number</code>。这个函数重载的正确顺序是，第二行类型声明放到第一行的位置。</p>
<p>对象的方法也可以使用重载。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，方法<code>add()</code>也使用了函数重载。</p>
<p>函数重载也可以用来精确描述函数参数与返回值之间的对应关系。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，函数重载精确描述了参数<code>tag</code>的三个值，所对应的不同的函数返回值。</p>
<p>这个示例的函数重载，也可以用对象表示。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>由于重载是一种比较复杂的类型声明方法，为了降低复杂性，一般来说，如果可以的话，应该优先使用<strong>联合类型</strong>替代函数重载。</p>
</div>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，写法二使用<strong>联合类型</strong>，要比写法一的函数重载简单很多。</p>
<h3> 14、构造函数</h3>
<p>JavaScript 语言使用构造函数，生成对象的实例。</p>
<p>构造函数的最大特点，就是必须使用<code>new</code>命令调用。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面示例中，<code>Date()</code>就是一个构造函数，使用<code>new</code>命令调用，返回 Date 对象的实例。</p>
<p>构造函数的类型写法，就是在参数列表前面加上<code>new</code>命令。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>:::indo</p>
<p>上面示例中，类型<code>AnimalConstructor</code>就是一个构造函数，而函数<code>create()</code>需要传入一个构造函数。<br>
在 JavaScript 中，类（class）本质上是构造函数，所以<code>Animal</code>这个类可以传入<code>create()</code>。</p>
<p>:::</p>
<p>构造函数还有另一种类型写法，就是采用<strong>对象形式</strong>。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，类型 F 就是一个构造函数。类型写成一个可执行对象的形式，并且在参数列表前面要加上<code>new</code>命令。</p>
<p>某些函数既是构造函数，又可以当作普通函数使用，比如<code>Date()</code>。这时，类型声明可以写成下面这样。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，F 既可以当作普通函数执行，也可以当作构造函数使用。</p>
]]></content:encoded>
    </item>
    <item>
      <title>2095. 删除链表的中间节点</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_2095_%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_2095_%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9.html</guid>
      <source url="https://T4mako.github.io/rss.xml">2095. 删除链表的中间节点</source>
      <description>2095. 删除链表的中间节点</description>
      <category>算法</category>
      <pubDate>Tue, 15 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 2095. 删除链表的中间节点</h1>
]]></content:encoded>
    </item>
    <item>
      <title>328. 奇偶链表</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_328_%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_328_%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8.html</guid>
      <source url="https://T4mako.github.io/rss.xml">328. 奇偶链表</source>
      <description>328. 奇偶链表</description>
      <category>算法</category>
      <pubDate>Tue, 15 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 328. 奇偶链表</h1>
]]></content:encoded>
    </item>
    <item>
      <title>any，unknown ，never 类型</title>
      <link>https://T4mako.github.io/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScript/3%E3%80%81any%EF%BC%8Cunknown%20%EF%BC%8Cnever%20%E7%B1%BB%E5%9E%8B.html</link>
      <guid>https://T4mako.github.io/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScript/3%E3%80%81any%EF%BC%8Cunknown%20%EF%BC%8Cnever%20%E7%B1%BB%E5%9E%8B.html</guid>
      <source url="https://T4mako.github.io/rss.xml">any，unknown ，never 类型</source>
      <description>三、any，unknown ，never 类型 1、any 类型 1.1、基本含义 any 类型表示没有任何限制，该类型的变量可以赋予任意类型的值。 let x:any; x = 1; // 正确 x = &amp;apos;foo&amp;apos;; // 正确 x = true; // 正确 let x:any = &amp;apos;hello&amp;apos;; x(1) // 不报错 x.foo = 100; // 不报错</description>
      <category>TypeScript</category>
      <pubDate>Mon, 14 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 三、any，unknown ，never 类型</h2>
<h3> 1、any 类型</h3>
<h4> 1.1、基本含义</h4>
<p>any 类型表示没有任何限制，该类型的变量可以赋予任意类型的值。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>变量类型一旦设为<code>any</code>，TypeScript 实际上会关闭这个变量的类型检查。只要句法正确，都不会报错。</p>
<p>由于这个原因，应该尽量避免使用<code>any</code>类型，否则就失去了使用 TypeScript 的意义。</p>
<p><code>any</code>类型主要适用以下两个场合：</p>
<ol>
<li>需要关闭某些变量的类型检查</li>
<li>为了适配以前老的 JavaScript 项目，让代码快速迁移到 TypeScript，可以把变量类型设为<code>any</code></li>
</ol>
<h4> 1.2、类型推断问题</h4>
<p>对于开发者没有指定类型、TypeScript 必须自己推断类型的那些变量，如果无法推断出类型，TypeScript 就会认为该变量的类型是<code>any</code></p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，函数<code>add()</code>的参数变量<code>x</code>和<code>y</code>，都没有足够的信息，TypeScript 无法推断出它们的类型，就会认为这两个变量和函数返回值的类型都是<code>any</code>。以至于后面就不再对函数<code>add()</code>进行类型检查了，怎么用都可以。</p>
<p>TypeScript 提供了一个编译选项<code>noImplicitAny</code>，打开该选项，只要推断出<code>any</code>类型就会报错。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这里有一个特殊情况，即使打开了<code>noImplicitAny</code>，使用<code>let</code>和<code>var</code>命令声明变量，但不赋值也不指定类型，是不会报错的。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>建议使用<code>let</code>和<code>var</code>声明变量时，如果不赋值，就一定要显式声明类型，否则可能存在安全隐患。</p>
<p><code>const</code>命令没有这个问题，因为 JavaScript 语言规定<code>const</code>声明变量时，必须同时进行初始化（赋值）</p>
<p><code>const</code>命令声明的<code>x</code>是不能改变值的，声明时必须同时赋值，否则报错，所以它不存在类型推断为<code>any</code>的问题。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></div>
<h4> 1.3、污染问题</h4>
<p><code>any</code>类型除了关闭类型检查，还有一个很大的问题，就是它会“污染”其他变量。它可以赋值给其他任何类型的变量（因为没有类型检查），导致其他变量出错。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>污染其他具有正确类型的变量，把错误留到运行时，这就是不宜使用<code>any</code>类型的另一个主要原因。</p>
</div>
<h3> 2、unknown 类型</h3>
<p>为了解决<code>any</code>类型“污染”其他变量的问题，TypeScript 3.0 引入了<a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type" target="_blank" rel="noopener noreferrer"><code>unknown</code>类型</a>。它与<code>any</code>含义相同，表示类型不确定，可能是任意类型，但是它的使用有一些限制，不像<code>any</code>那样自由，可以视为 <strong>严格版的<code>any</code></strong>。</p>
<p><code>unknown</code>跟<code>any</code>的<strong>相似</strong>之处，在于所有类型的值都可以分配给<code>unknown</code>类型。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>unknown</code>类型跟<code>any</code>类型的不同之处在于，它不能直接使用。主要有以下几个限制。</p>
<ol>
<li>
<p><code>unknown</code>类型的变量，不能直接赋值给其他类型的变量（除了<code>any</code>类型和<code>unknown</code>类型）。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>变量<code>v</code>是<code>unknown</code>类型，<strong>赋值给<code>any</code>和<code>unknown</code>以外类型的变量都会报错</strong>，这就避免了污染问题，从而克服了<code>any</code>类型的一大缺点。</p>
</li>
<li>
<p>不能直接调用<code>unknown</code>类型变量的方法和属性。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接调用<code>unknown</code>类型变量的属性和方法，或者直接当作函数执行，都会报错。</p>
</li>
<li>
<p>再次，<code>unknown</code>类型变量能够进行的运算是有限的</p>
<p>只能进行比较运算（运算符<code>==</code>、<code>===</code>、<code>!=</code>、<code>!==</code>、<code>||</code>、<code>&amp;&amp;</code>、<code>?</code>）、取反运算（运算符<code>!</code>）、<code>typeof</code>运算符和<code>instanceof</code>运算符这几种，其他运算都会报错。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>使用<code>unknown</code>类型变量</p>
<p>只有经过“<strong>类型缩小</strong>”，<code>unknown</code>类型变量才可以使用。所谓“类型缩小”，就是缩小<code>unknown</code>变量的类型范围，确保不会出错。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>unknown</code>类型的变量<code>a</code>经过**<code>typeof</code>**运算以后，能够确定实际类型是<code>number</code>，就能用于加法运算了。这就是“类型缩小”，即将一个不确定的类型缩小为更明确的类型。</p>
<p><code>unknown</code>可以看作是更安全的<code>any</code>。一般来说，凡是需要设为<code>any</code>类型的地方，通常都应该优先考虑设为<code>unknown</code>类型。</p>
<p>在集合论上，<code>unknown</code>也可以视为所有其他类型（除了<code>any</code>）的全集，所以它和<code>any</code>一样，也属于 TypeScript 的顶层类型。</p>
</li>
</ol>
<h3> 3、never 类型</h3>
<p>为了保持与集合论的对应关系，以及类型运算的完整性，TypeScript 还引入了“<strong>空类型</strong>”的概念，即该类型为空，不包含任何值。</p>
<p>由于不存在任何属于“空类型”的值，所以该类型被称为<code>never</code>，即不可能有这样的值。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面示例中，变量<code>x</code>的类型是<code>never</code>，就不可能赋给它任何值，否则都会报错。</p>
<p><code>never</code>类型的使用场景，主要是在一些类型运算之中，保证类型运算的完整性，详见后面章节。<br>
另外，不可能返回值的函数，返回值的类型就可以写成<code>never</code>，详见《函数》一章。</p>
<p>如果一个变量可能有多种类型（即联合类型），通常需要使用分支处理每一种类型。这时，处理所有可能的类型之后，剩余的情况就属于<code>never</code>类型。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，参数变量<code>x</code>可能是字符串，也可能是数值，判断了这两种情况后，剩下的最后那个<code>else</code>分支里面，<code>x</code>就是<code>never</code>类型了。</p>
<p><strong><code>never</code>类型的一个重要特点是，可以赋值给任意其他类型。</strong></p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，函数<code>f()</code>会抛错，所以返回值类型可以写成<code>never</code>，即不可能返回任何值。各种其他类型的变量都可以赋值为<code>f()</code>的运行结果（<code>never</code>类型）。</p>
<p>为什么<code>never</code>类型可以赋值给任意其他类型呢？这也跟集合论有关，空集是任何集合的子集。TypeScript 就相应规定，任何类型都包含了<code>never</code>类型。因此，<code>never</code>类型是任何其他类型所共有的，TypeScript 把这种情况称为“底层类型”（bottom type）。</p>
<p>总之，TypeScript 有两个“<strong>顶层类型</strong>”（<code>any</code>和<code>unknown</code>），但是“<strong>底层类型</strong>”只有<code>never</code>唯一一个。</p>
]]></content:encoded>
    </item>
    <item>
      <title>系统类型</title>
      <link>https://T4mako.github.io/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScript/4%E3%80%81%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%9E%8B.html</link>
      <guid>https://T4mako.github.io/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScript/4%E3%80%81%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%9E%8B.html</guid>
      <source url="https://T4mako.github.io/rss.xml">系统类型</source>
      <description>四、系统类型 1、基本类型 JavaScript 语言 将值分成8种类型。 boolean string number bigint symbol object undefined null TypeScript 继承了 JavaScript 的类型设计，以上8种类型可以看作 TypeScript 的基本类型。 相关信息 注意，上面所有类型的名称都是小写字母，首字母大写的Number、String、Boolean等在 JavaScript 语言中都是内置对象，而不是类型名称。 另外，undefined 和 null 既可以作为值，也可以作为类型，取决于在哪里使用它们。</description>
      <category>TypeScript</category>
      <pubDate>Mon, 14 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 四、系统类型</h2>
<h3> 1、基本类型</h3>
<p><strong>JavaScript</strong> 语言 将值分成8种类型。</p>
<ul>
<li>boolean</li>
<li>string</li>
<li>number</li>
<li>bigint</li>
<li>symbol</li>
<li>object</li>
<li>undefined</li>
<li>null</li>
</ul>
<p>TypeScript 继承了 JavaScript 的类型设计，以上8种类型可以看作 TypeScript 的基本类型。</p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>注意，上面所有类型的名称都是小写字母，首字母大写的<code>Number</code>、<code>String</code>、<code>Boolean</code>等在 JavaScript 语言中都是内置对象，而不是类型名称。</p>
<p>另外，undefined 和 null 既可以作为值，也可以作为类型，取决于在哪里使用它们。</p>
</div>
<p>这8种基本类型是 TypeScript 类型系统的基础，复杂类型由它们组合而成。</p>
<h4> 1.1、boolean类型</h4>
<p><code>boolean</code>类型只包含<code>true</code>和<code>false</code>两个布尔值。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.2、string 类型</h4>
<p>string类型包含所有字符串。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.3、number 类型</h4>
<p><code>number</code>类型包含所有<strong>整数</strong>和<strong>浮点数</strong>。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.4、bigint 类型</h4>
<p>bigint 类型包含所有的大整数。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.5、symbol 类型</h4>
<p>symbol 类型包含所有的 Symbol 值。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>symbol 类型的详细介绍，参见《Symbol》一章。</p>
<h4> 1.6、object 类型</h4>
<p>根据 JavaScript 的设计，object 类型包含了所有对象、数组和函数。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.7、undefined 类型，null 类型</h4>
<p>undefined 和 null 是两种独立类型，它们各自都只有一个值。</p>
<p>undefined 类型只包含一个值<code>undefined</code>，表示未定义（即还未给出定义，以后可能会有定义）。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>x</code>就属于 undefined 类型。两个<code>undefined</code>里面，第一个是类型，第二个是值。</p>
<p>null 类型也只包含一个值<code>null</code>，表示为空（即此处没有值）。</p>
<div class="hint-container warning">
<p class="hint-container-title">注意</p>
<p>注意，如果没有声明类型的变量，被赋值为<code>undefined</code>或<code>null</code>，它们的类型会被推断为<code>any</code>。</p>
</div>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果希望避免这种情况，则需要打开编译选项<code>strictNullChecks</code>。（vscode默认打开）</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，打开编译设置<code>strictNullChecks</code>以后，赋值为<code>undefined</code>的变量会被推断为<code>undefined</code>类型，赋值为<code>null</code>的变量会被推断为<code>null</code>类型。</p>
<h3> 2、包装对象类型</h3>
<h4> 2.1、包装对象的概念</h4>
<p>JavaScript 的8种类型之中（boolean，number，bigint，stristring，symbol，undefined，null，object），<code>undefined</code>和<code>null</code>其实是两个特殊值，<code>object</code>属于复合类型，剩下的五种属于原始类型（primitive value），代表最基本的、不可再分的值。</p>
<ul>
<li>boolean、string、number、bigint、symbol</li>
</ul>
<p>上面这五种原始类型的值，都有对应的包装对象（wrapper object）。所谓“包装对象”，指的是这些值在需要时，会自动产生的对象。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面示例中，字符串<code>hello</code>执行了<code>charAt()</code>方法。但是，在 JavaScript 语言中，只有对象才有方法，原始类型的值本身没有方法。这行代码之所以可以运行，就是因为在调用方法时，字符串会<strong>自动转为包装对象</strong>，<code>charAt()</code>方法其实是定义在包装对象上。</p>
<p>五种包装对象之中，symbol 类型和 bigint 类型无法直接获取它们的包装对象（即<code>Symbol()</code>和<code>BigInt()</code>不能作为构造函数使用），但是剩下三种可以。</p>
<ul>
<li><code>Boolean()</code>、<code>String()</code>、<code>Number()</code></li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>::warning</p>
<p>注意，<code>String()</code>只有当作构造函数使用时（即带有<code>new</code>命令调用），才会返回包装对象。如果当作普通函数使用（不带有<code>new</code>命令），返回就是一个普通字符串。其他两个构造函数<code>Number()</code>和<code>Boolean()</code>也是如此。</p>
<p>:::</p>
<h4> 2.2、包装对象类型与字面量类型</h4>
<p>由于包装对象的存在，导致每一个原始类型的值都有包装<strong>对象</strong>和<strong>字面量</strong>两种情况。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>为了区分这两种情况，TypeScript 对五种原始类型分别提供了大写和小写两种类型。</p>
<ul>
<li>Boolean 和 boolean</li>
<li>String 和 string</li>
<li>Number 和 number</li>
<li>BigInt 和 bigint</li>
<li>Symbol 和 symbol</li>
</ul>
<p>其中，大写类型同时包含包装对象和字面量两种情况，小写类型只包含字面量，不包含包装对象。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>建议只使用小写类型，不使用大写类型。因为绝大部分使用原始类型的场合，都是使用字面量，不使用包装对象。<br>
而且，TypeScript 把很多内置方法的参数，定义成小写类型，使用大写类型会报错。</p>
</div>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>Math.abs()</code>方法的参数类型被定义成小写的<code>number</code>，传入大写的<code>Number</code>类型就会报错。</p>
<p>上一小节说过，<code>Symbol()</code>和<code>BigInt()</code>这两个函数不能当作构造函数使用，所以没有办法直接获得 symbol 类型和 bigint 类型的包装对象，除非使用下面的写法。但是，它们没有使用场景，因此<code>Symbol</code>和<code>BigInt</code>这两个类型虽然存在，但是完全没有使用的理由。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，得到的就是 Symbol 和 BigInt 的包装对象，但是没有使用的意义。</p>
<h3> 3、Object 类型与 object 类型</h3>
<p>TypeScript 的<strong>对象类型</strong>也有大写<code>Object</code>和小写<code>object</code>两种。</p>
<h4> 3.1、Object 类型</h4>
<p>大写的<code>Object</code>类型代表 JavaScript 语言里面的广义对象。所有可以转成对象的值，都是<code>Object</code>类型，这囊括了几乎所有的值。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，原始类型值、对象、数组、函数都是合法的<code>Object</code>类型。</p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>事实上，除了<code>undefined</code>和<code>null</code>这两个值不能转为对象，其他任何值都可以赋值给<code>Object</code>类型。</p>
<p>上面示例中，<code>undefined</code>和<code>null</code>赋值给<code>Object</code>类型，就会报错。</p>
</div>
<p>另外，空对象<code>{}</code>是<code>Object</code>类型的简写形式，所以使用<code>Object</code>时常常用空对象代替。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>obj</code>的类型是空对象<code>{}</code>，就代表<code>Object</code>类型。</p>
<p>显然，无所不包的<code>Object</code>类型既不符合直觉，也不方便使用。</p>
<h4> 3.2、object 类型</h4>
<p>小写的<code>object</code>类型代表 JavaScript 里面的狭义对象，即可以用字面量表示的对象，只包含对象、数组和函数，<strong>不包括原始类型</strong>的值。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>object</code>类型不包含原始类型值，只包含<strong>对象、数组和函数</strong>。</p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>所以，建议总是使用小写类型<code>object</code>，不使用大写类型<code>Object</code>。</p>
<p>注意，无论是大写的<code>Object</code>类型，还是小写的<code>object</code>类型，都只包含 JavaScript 内置对象原生的属性和方法，用户自定义的属性和方法都不存在于这两个类型之中。</p>
</div>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>toString()</code>是对象的原生方法，可以正确访问。<code>foo</code>是自定义属性，访问就会报错。<br>
如何描述对象的自定义属性，详见《对象类型》一章。</p>
<h3> 4、undefined 和 null 的特殊性</h3>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p><code>undefined</code>和<code>null</code>既是 <strong>值</strong>，又是 <strong>类型</strong>。</p>
<p>作为值，它们有一个特殊的地方：任何<strong>其他类型</strong>的变量都可以赋值为<code>undefined</code>或<code>null</code>。</p>
</div>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中，变量<code>age</code>的类型是<code>number</code>，但是赋值为<code>null</code>或<code>undefined</code>并不报错。</p>
<p>这并不是因为<code>undefined</code>和<code>null</code>包含在<code>number</code>类型里面，而是故意这样设计<br>
任何类型的变量都可以赋值为<code>undefined</code>和<code>null</code>，以便跟 JavaScript 的行为保持一致。</p>
<p>JavaScript 的行为是，变量如果等于<code>undefined</code>就表示还没有赋值，如果等于<code>null</code>就表示值为空。所以，TypeScript 就允许了任何类型的变量都可以赋值为这两个值。</p>
<p>但是有时候，这并不是开发者想要的行为，也不利于发挥类型系统的优势。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>obj</code>等于<code>undefined</code>，编译不会报错。但是，实际执行时，调用<code>obj.toString()</code>就报错了，因为<code>undefined</code>不是对象，没有这个方法。</p>
<p>为了避免这种情况，及早发现错误，TypeScript 提供了一个编译选项<code>strictNullChecks</code>。<br>
只要打开这个选项，<code>undefined</code>和<code>null</code>就不能赋值给其他类型的变量（除了<code>any</code>类型和<code>unknown</code>类型）。</p>
<p>下面是 tsc 命令打开这个编译选项的例子。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，打开<code>--strictNullChecks</code>以后，<code>number</code>类型的变量<code>age</code>就不能赋值为<code>undefined</code>和<code>null</code>。</p>
<p>这个选项在配置文件**<code>tsconfig.json</code>**的写法如下。</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>打开<code>strictNullChecks</code>以后，<code>undefined</code>和<code>null</code>这两种值也不能互相赋值了。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>undefined</code>类型的变量赋值为<code>null</code>，或者<code>null</code>类型的变量赋值为<code>undefind</code>，都会报错。</p>
<p>总之，打开<code>strictNullChecks</code>以后，<code>undefined</code>和<code>null</code>只能赋值给自身，或者<code>any</code>类型和<code>unknown</code>类型的变量。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5、值类型</h3>
<p>TypeScript 规定，单个值也是一种类型，称为“值类型”。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>x</code>的类型是字符串<code>hello</code>，导致它只能赋值为这个字符串，赋值为其他字符串就会报错。</p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>TypeScript 推断类型时，遇到<code>const</code>命令声明的变量，如果代码里面没有注明类型，就会推断该变量是值类型。</p>
</div>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>x</code>是<code>const</code>命令声明的，TypeScript 就会推断它的类型是值<code>https</code>，而不是<code>string</code>类型。</p>
<p>这样推断是合理的，因为<code>const</code>命令声明的变量，一旦声明就不能改变，相当于常量。值类型就意味着不能赋为其他值。</p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>注意，<code>const</code>命令声明的变量，如果赋值为对象，并不会推断为值类型。</p>
</div>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>x</code>没有被推断为值类型，而是推断属性<code>foo</code>的类型是<code>number</code>。<br>
这是因为 JavaScript 里面，<strong><code>const</code>变量赋值为对象时，属性值是可以改变的</strong>。</p>
<p>值类型可能会出现一些很奇怪的报错。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面示例中，等号左侧的类型是数值<code>5</code>，等号右侧<code>4 + 1</code>的类型，TypeScript 推测为<code>number</code>。由于<code>5</code>是<code>number</code>的子类型，<code>number</code>是<code>5</code>的父类型，父类型不能赋值给子类型，所以报错了（详见本章后文）。</p>
<p>但是，反过来是可以的，子类型可以赋值给父类型。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>x</code>属于子类型，变量<code>y</code>属于父类型。<code>y</code>不能赋值为子类型<code>x</code>，但是反过来是可以的。</p>
<p>如果一定要让子类型可以赋值为父类型的值，就要用到类型断言（详见《类型断言》一章）。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面示例中，在<code>4 + 1</code>后面加上<code>as 5</code>，就是告诉编译器，可以把<code>4 + 1</code>的类型视为值类型<code>5</code>，这样就不会报错了。</p>
<p>只包含单个值的值类型，用处不大。实际开发中，往往将多个值结合，作为联合类型使用。</p>
<h3> 6、联合类型 |</h3>
<p>联合类型（union types）指的是多个类型组成的一个新类型，使用符号<code>|</code>表示。</p>
<p>联合类型<code>A|B</code>表示，任何一个类型只要属于<code>A</code>或<code>B</code>，就属于联合类型<code>A|B</code>。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>x</code>就是联合类型<code>string|number</code>，表示它的值既可以是字符串，也可以是数值。</p>
<p>联合类型可以与值类型相结合，表示一个变量的值有若干种可能。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的示例都是由值类型组成的联合类型，非常清晰地表达了变量的取值范围。其中，<code>true|false</code>其实就是布尔类型<code>boolean</code>。</p>
<p>前面提到，打开编译选项<code>strictNullChecks</code>后，其他类型的变量不能赋值为<code>undefined</code>或<code>null</code>。这时，如果某个变量确实可能包含空值，就可以采用联合类型的写法。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>name</code>的值可以是字符串，也可以是<code>null</code>。</p>
<p>联合类型的第一个成员前面，也可以加上竖杠<code>|</code>，这样便于多行书写。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果一个变量有多种类型，读取该变量时，往往需要进行“类型缩小”（type narrowing），区分该值到底属于哪一种类型，然后再进一步处理。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解决方法就是对参数<code>id</code>做一下类型缩小，确定它的类型以后再进行处理。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，函数体内部会判断一下变量<code>id</code>的类型，如果是字符串，就对其执行<code>toUpperCase()</code>方法。</p>
<p>“类型缩小”是 TypeScript 处理联合类型的标准方法，凡是遇到可能为多种类型的场合，都需要先缩小类型，再进行处理。<br>
实际上，联合类型本身可以看成是一种“<strong>类型放大</strong>”（type widening），处理时就需要“<strong>类型缩小</strong>”（type narrowing）。</p>
<p>下面是“类型缩小”的另一个例子。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，函数体内部对参数变量<code>scheme</code>进行类型缩小，根据不同的值类型，返回不同的结果。</p>
<h3> 7、交叉类型 &amp;</h3>
<p>交叉类型（intersection types）指的多个类型组成的一个新类型，使用符号<code>&amp;</code>表示。</p>
<p>交叉类型<code>A&amp;B</code>表示，任何一个类型必须<strong>同时属于<code>A</code>和<code>B</code></strong>，才属于交叉类型<code>A&amp;B</code>，即交叉类型同时满足<code>A</code>和<code>B</code>的特征。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面示例中，变量<code>x</code>同时是数值和字符串，这当然是不可能的，所以 TypeScript 会认为<code>x</code>的类型实际是**<code>never</code>**。</p>
<p>交叉类型的主要用途是表示<strong>对象的合成</strong>。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>obj</code>同时具有属性<code>foo</code>和属性<code>bar</code>。</p>
<p>交叉类型常常用来为对象类型添加新属性。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，类型<code>B</code>是一个交叉类型，用来在<code>A</code>的基础上增加了属性<code>bar</code>。</p>
<h3> 8、type 命令</h3>
<p><code>type</code>命令用来定义一个类型的别名。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>type</code>命令为<code>number</code>类型定义了一个别名<code>Age</code>。这样就能像使用<code>number</code>一样，使用<code>Age</code>作为类型。</p>
<p>别名可以让类型的名字变得更有意义，也能增加代码的可读性，还可以使复杂类型用起来更方便，便于以后修改变量的类型。</p>
<p><strong>别名不允许重名</strong>。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，同一个别名<code>Color</code>声明了两次，就报错了。</p>
<p>别名的作用域是<strong>块级作用域</strong>。这意味着，代码块内部定义的别名，影响不到外部。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>if</code>代码块内部的类型别名<code>Color</code>，跟外部的<code>Color</code>是不一样的。</p>
<p>别名支持使用表达式，也可以在定义一个别名时，使用另一个别名，即<strong>别名允许嵌套</strong>。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，别名<code>Greeting</code>使用了模板字符串，读取另一个别名<code>World</code>。</p>
<p><code>type</code>命令属于类型相关的代码，编译成 JavaScript 的时候，会被全部删除。</p>
<h3> 9、typeof 运算符</h3>
<p>JavaScript 语言中，typeof 运算符是一个一元运算符，返回一个字符串，代表操作数的类型。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面示例中，<code>typeof</code>运算符返回字符串<code>foo</code>的类型是<code>string</code>。</p>
<div class="hint-container warning">
<p class="hint-container-title">注意</p>
<p>注意，这时 typeof 的操作数是一个<strong>值</strong>。</p>
</div>
<p>JavaScript 里面，<code>typeof</code>运算符只可能返回八种结果，而且都是字符串。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>TypeScript 将<code>typeof</code>运算符移植到了<strong>类型</strong>运算，它的操作数依然是一个值，但是返回的不是字符串，而是该值的 TypeScript 类型。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>typeof a</code>表示返回变量<code>a</code>的 TypeScript 类型（<code>{ x: number }</code>）。同理，<code>typeof a.x</code>返回的是属性<code>x</code>的类型（<code>number</code>）。</p>
<p>这种用法的<code>typeof</code>返回的是 TypeScript 类型，所以只能用在<strong>类型运算</strong>之中（即跟类型相关的代码之中），不能用在<strong>值运算</strong>。</p>
<p>也就是说，同一段代码可能存在两种<code>typeof</code>运算符，一种用在值相关的 JavaScript 代码部分，另一种用在类型相关的 TypeScript 代码部分。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，用到了两个<code>typeof</code>，第一个是类型运算，第二个是值运算。它们是不一样的，不要混淆。</p>
<p>JavaScript 的 typeof 遵守 JavaScript 规则，TypeScript 的 typeof 遵守 TypeScript 规则。<br>
它们的一个重要区别在于，编译后，前者会保留，后者会被全部删除。</p>
<p>上例的代码编译结果如下。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，只保留了原始代码的第二个 typeof，删除了第一个 typeof。</p>
<p>由于编译时不会进行 JavaScript 的值运算，所以TypeScript 规定，typeof 的参数只能是<strong>标识符</strong>，不能是需要运算的表达式。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面示例会报错，原因是 typeof 的参数不能是一个值的运算式，而<code>Date()</code>需要运算才知道结果。</p>
<p>另外，<code>typeof</code>命令的参数不能是类型。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>Age</code>是一个类型别名，用作<code>typeof</code>命令的参数就会报错。</p>
<p>typeof 是一个很重要的 TypeScript 运算符，有些场合不知道某个变量<code>foo</code>的类型，这时使用<code>typeof foo</code>就可以获得它的类型。</p>
<h3> 10、块级类型声明</h3>
<p>TypeScript 支持块级类型声明，即类型可以声明在代码块（用大括号表示）里面，并且只在当前代码块有效。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，存在两个代码块，其中分别有一个类型<code>T</code>的声明。这两个声明都只在自己的代码块内部有效，在代码块外部无效。</p>
<h3> 11、类型的兼容</h3>
<p>TypeScript 的类型存在兼容关系，某些类型可以兼容其他类型。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>a</code>和<code>b</code>的类型是不一样的，但是变量<code>a</code>赋值给变量<code>b</code>并不会报错。这时，我们就认为，<code>b</code>的类型兼容<code>a</code>的类型。</p>
<p>TypeScript 为这种情况定义了一个专门术语。如果类型<code>A</code>的值可以赋值给类型<code>B</code>，那么类型<code>A</code>就称为类型<code>B</code>的<strong>子类型</strong>（subtype）。<br>
在上例中，类型<code>number</code>就是类型<code>number|string</code>的子类型。</p>
<p>TypeScript 的一个规则是，凡是可以使用父类型的地方，都可以使用子类型，但是反过来不行。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>hi</code>是<code>string</code>的子类型，<code>string</code>是<code>hi</code>的父类型。所以，变量<code>a</code>可以赋值给变量<code>b</code>，但是反过来就会报错。</p>
<p>之所以有这样的规则，是因为子类型继承了父类型的所有特征，所以可以用在父类型的场合。但是，子类型还可能有一些父类型没有的特征，所以父类型不能用在子类型的场合。</p>
]]></content:encoded>
    </item>
    <item>
      <title>649. Dota2 参议院</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_649_Dota2%20%E5%8F%82%E8%AE%AE%E9%99%A2.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_649_Dota2%20%E5%8F%82%E8%AE%AE%E9%99%A2.html</guid>
      <source url="https://T4mako.github.io/rss.xml">649. Dota2 参议院</source>
      <description>649. Dota2 参议院</description>
      <category>算法</category>
      <pubDate>Mon, 14 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 649. Dota2 参议院</h1>
]]></content:encoded>
    </item>
    <item>
      <title>374. 猜数字大小</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_374_%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8F.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_374_%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8F.html</guid>
      <source url="https://T4mako.github.io/rss.xml">374. 猜数字大小</source>
      <description>374. 猜数字大小</description>
      <category>算法</category>
      <pubDate>Sun, 13 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 374. 猜数字大小</h1>
]]></content:encoded>
    </item>
    <item>
      <title>TypeScript语言简介</title>
      <link>https://T4mako.github.io/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScript/1%E3%80%81TypeScript%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B.html</link>
      <guid>https://T4mako.github.io/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScript/1%E3%80%81TypeScript%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B.html</guid>
      <source url="https://T4mako.github.io/rss.xml">TypeScript语言简介</source>
      <description>官方文档 参考文章 官网的在线编译页面 TypeScript Playground。</description>
      <category>TypeScript</category>
      <pubDate>Sat, 12 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p><a href="https://www.typescriptlang.org/zh/docs/" target="_blank" rel="noopener noreferrer">官方文档</a></p>
<p><a href="https://wangdoc.com/typescript/" target="_blank" rel="noopener noreferrer">参考文章</a></p>
<p>官网的在线编译页面 <a href="http://www.typescriptlang.org/play/" target="_blank" rel="noopener noreferrer">TypeScript Playground</a>。</p>
<h2> 一、TypeScript 语言简介</h2>
<h3> 1、概述</h3>
<p>TypeScript（简称 TS）是微软公司开发的一种 <strong>基于 JavaScript</strong> （简称 JS）语言的编程语言。</p>
<p>它的目的并不是创造一种全新语言，而是 <strong>增强 JavaScript</strong> 的功能，使其更适合多人合作的企业级项目。</p>
<p>TypeScript 可以看成是 JavaScript 的 <strong>超集</strong>（superset），即它继承了后者的全部语法，所有 JavaScript 脚本都可以当作 TypeScript 脚本（但是可能会报错），此外它再增加了一些自己的语法。</p>
<h3> 2、类型的概念</h3>
<p><strong>类型是人为添加的一种编程约束和用法提示</strong>，目的是在软件开发过程中，为编译器和开发工具提供更多的验证和帮助，帮助提高代码质量，减少错误。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>TypeScript 是在开发阶段报错，这样有利于提早发现错误，避免使用时报错。<br>
另一方面，函数定义里面加入类型，具有提示作用，可以告诉开发者这个函数怎么用。</p>
<h3> 3、动态类型与静态类型</h3>
<p><strong>JavaScript</strong> 的类型系统非常弱，而且没有使用限制，运算符可以接受各种类型的值。在语法上，JavaScript 属于 <strong>动态类型语言</strong><br>
<strong>TypeScript</strong> 引入了一个更强大、更严格的类型系统，属于 <strong>静态类型语言</strong></p>
<h3> 4、静态类型的优缺点</h3>
<p>优点：</p>
<ul>
<li>有利于代码的静态分析。</li>
<li>有利于发现错误。</li>
<li>更好的 IDE 支持，做到语法提示和自动补全。</li>
<li>提供了代码文档。</li>
<li>有助于代码重构。</li>
</ul>
<p>缺点：</p>
<ul>
<li>丧失了动态类型的代码灵活性。</li>
<li>增加了编程工作量。</li>
<li>更高的学习成本。</li>
<li>引入了独立的编译步骤。</li>
<li>兼容性问题。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>TypeScript基本用法</title>
      <link>https://T4mako.github.io/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScript/2%E3%80%81%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95.html</link>
      <guid>https://T4mako.github.io/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/TypeScript/2%E3%80%81%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95.html</guid>
      <source url="https://T4mako.github.io/rss.xml">TypeScript基本用法</source>
      <description>二、基本用法 1、类型声明 TypeScript 代码最明显的特征，就是为 JavaScript 变量加上了类型声明。 类型声明的写法，一律为在标识符后面添加“冒号 + 类型”。函数参数和返回值，也是这样来声明类型。 let foo:string; //声明了它的类型为string function toString(num:number):string { //num的类型是number。参数列表的圆括号后面，声明了返回值的类型是string return String(num); }</description>
      <category>TypeScript</category>
      <pubDate>Sat, 12 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 二、基本用法</h2>
<h3> 1、类型声明</h3>
<p>TypeScript 代码最明显的特征，就是为 JavaScript 变量加上了类型声明。</p>
<p>类型声明的写法，一律为在标识符后面添加“<strong>冒号 + 类型</strong>”。函数参数和返回值，也是这样来声明类型。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>变量的值应该与声明的类型一致，如果不一致，TypeScript 就会报错。</p>
<p>另外，TypeScript 规定，变量只有<strong>赋值后才能使用</strong>，否则就会报错。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2、类型推断</h3>
<p>类型声明并不是必需的，如果没有，TypeScript 会自己 <strong>推断类型</strong>。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>TypeScript 推断它的类型为<code>number</code>。</p>
<p>后面，如果变量<code>foo</code>更改为其他类型的值，跟推断的类型不一致，TypeScript 就会报错。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>TypeScript 也可以<strong>推断</strong>函数的<strong>返回值</strong>。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>正是因为 TypeScript 的类型推断，所以函数返回值的类型通常是省略不写的。</p>
<p>这样设计还有一个好处，将以前的 JavaScript 项目改为 TypeScript 项目时，你可以逐步地为老代码添加类型，即使有些代码没有添加，也不会无法运行。</p>
</div>
<h3> 3、TypeScript 的编译</h3>
<p><strong>JavaScript</strong> 的运行环境（<strong>浏览器</strong> 和 <strong>Node.js</strong>）不认识 <strong>TypeScript</strong> 代码。所以，TypeScript 项目要想运行，必须先转为 JavaScript 代码，这个代码转换的过程就叫做“<strong>编译</strong>”（compile）。</p>
<p>TypeScript 官方没有做运行环境，只提供编译器。编译时，会将类型声明和类型相关的代码全部删除，只留下能运行的 JavaScript 代码，并且不会改变 JavaScript 的运行结果。</p>
<p>因此，TypeScript 的类型检查只是编译时的类型检查，而不是运行时的类型检查。一旦代码编译为 JavaScript，运行时就不再检查类型了。</p>
<h3> 4、值与类型</h3>
<p>TypeScript 代码只涉及类型，不涉及值。所有跟“值”相关的处理，都由 JavaScript 完成。</p>
<p>它们是可以分离的，TypeScript 的编译过程，实际上就是把“类型代码”全部拿掉，只保留“值代码”。</p>
<h3> 5、TypeScript Playground</h3>
<p>最简单的 TypeScript 使用方法，就是使用官网的在线编译页面，叫做 <a href="http://www.typescriptlang.org/play/" target="_blank" rel="noopener noreferrer">TypeScript Playground</a>。</p>
<p>把 TypeScript 代码贴进文本框，它就会在当前页面自动编译出 JavaScript 代码，还可以在浏览器执行编译产物。如果编译报错，它也会给出详细的报错信息。</p>
<p>这个页面还具有支持完整的 IDE 支持，可以自动语法提示。此外，它支持把代码片段和编译器设置保存成 URL，分享给他人。</p>
<h3> 6、tsc 编辑器</h3>
<p>TypeScript 官方提供的编译器叫做 tsc，可以将 TypeScript 脚本编译成 JavaScript 脚本。本机想要编译 TypeScript 代码，必须安装 tsc。</p>
<p>根据约定，TypeScript 脚本文件使用<code>.ts</code>后缀名，JavaScript 脚本文件使用<code>.js</code>后缀名。tsc 的作用就是把<code>.ts</code>脚本转变成<code>.js</code>脚本。</p>
<h4> 6.1、安装</h4>
<p>tsc 是一个 npm 模块，使用下面的命令安装（必须先安装 npm）。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面命令是全局安装 tsc，也可以在项目中将 tsc 安装为一个依赖模块。</p>
<p>安装完成后，检查一下是否安装成功。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面命令中，<code>-v</code>或<code>--version</code>参数可以输出当前安装的 tsc 版本。</p>
<h4> 6.2、帮助信息</h4>
<p><code>-h</code>或<code>--help</code>参数输出帮助信息。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>默认情况下，“--help”参数仅显示基本的可用选项。我们可以使用“--all”参数，查看完整的帮助信息。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 6.3、编译脚本</h4>
<p>安装 tsc 之后，就可以编译 TypeScript 脚本了。</p>
<p><code>tsc</code>命令后面，加上 TypeScript 脚本文件，就可以将其编译成 JavaScript 脚本。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面命令会在当前目录下，生成一个<code>app.js</code>脚本文件，这个脚本就完全是编译后生成的 JavaScript 代码。</p>
<p><code>tsc</code>命令也可以一次编译多个 TypeScript 脚本。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面命令会在当前目录生成三个 JavaScript 脚本文件<code>file1.js</code>、<code>file2.js</code>、<code>file3.js</code>。</p>
<p>tsc 有很多参数，可以调整编译行为。</p>
<p><strong>（1）--outFile</strong></p>
<p>如果想将多个 TypeScript 脚本编译成一个 JavaScript 文件，使用<code>--outFile</code>参数。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面命令将<code>file1.ts</code>和<code>file2.ts</code>两个脚本编译成一个 JavaScript 文件<code>app.js</code>。</p>
<p><strong>（2）--outDir</strong></p>
<p>编译结果默认都保存在当前目录，<code>--outDir</code>参数可以指定保存到其他目录。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面命令会在<code>dist</code>子目录下生成<code>app.js</code>。</p>
<p><strong>（3）--target</strong></p>
<p>为了保证编译结果能在各种 JavaScript 引擎运行，tsc 默认会将 TypeScript 代码编译成很<strong>低版本</strong>的 JavaScript，即3.0版本（以<code>es3</code>表示）。这通常不是我们想要的结果。</p>
<p>这时可以使用<code>--target</code>参数，指定编译后的 JavaScript 版本。建议使用<code>es2015</code>，或者<strong>更新版本</strong>。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 6.4、编译错误的处理</h4>
<p>编译过程中，如果没有报错，<code>tsc</code>命令不会有任何显示。所以，如果你没有看到任何提示，就表示编译成功了。</p>
<p>如果<strong>编译报错</strong>，<code>tsc</code>命令就会显示报错信息，但是这种情况下，<strong>依然会编译生成 JavaScript 脚本</strong>。</p>
<p>举例来说，下面是一个错误的 TypeScript 脚本<code>app.ts</code>。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，变量<code>foo</code>是数值类型，赋值为字符串，<code>tsc</code>命令编译这个脚本就会报错。</p>
<div class="language-txt line-numbers-mode" data-ext="txt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，<code>tsc</code>命令输出报错信息，表示变量<code>foo</code>被错误地赋值为字符串。</p>
<p>这种情况下，编译产物<code>app.js</code>还是会照样生成，下面就是编译后的结果。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，<strong>尽管有错，tsc 依然原样将 TypeScript 编译成 JavaScript 脚本</strong>。</p>
<p>如果希望一旦报错就停止编译，不生成编译产物，可以使用<code>--noEmitOnError</code>参数。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面命令在报错后，就不会生成<code>app.js</code>。</p>
<p>tsc 还有一个<code>--noEmit</code>参数，只检查类型是否正确，不生成 JavaScript 文件。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面命令只检查是否有编译错误，不会生成<code>app.js</code>。</p>
<p>tsc 命令的更多参数，详见《tsc 编译器》一章。</p>
<h4> 6.5、tsconfig.json</h4>
<p>TypeScript 允许将<code>tsc</code>的编译参数，写在配置文件<code>tsconfig.json</code>。只要当前目录有这个文件，<code>tsc</code>就会自动读取，所以运行时可以不写参数。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面这个命令写成<code>tsconfig.json</code>，就是下面这样。</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有了这个配置文件，编译时直接调用<code>tsc</code>命令就可以了。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>tsconfig.json</code>的详细介绍，参见《tsconfig.json 配置文件》一章。</p>
<h3> 7、ts-node 模块</h3>
<p><a href="https://github.com/TypeStrong/ts-node" target="_blank" rel="noopener noreferrer">ts-node</a> 是一个非官方的 npm 模块，可以直接运行 TypeScript 代码。</p>
<p>使用时，可以先全局安装它。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>安装后，就可以直接运行 TypeScript 脚本。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面命令运行了 TypeScript 脚本<code>script.ts</code>，给出运行结果。</p>
<p>如果不安装 ts-node，也可以通过 npx 调用它来运行 TypeScript 脚本。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面命令中，<code>npx</code>会在线调用 ts-node，从而在不安装的情况下，运行<code>script.ts</code>。</p>
<p>如果执行 ts-node 命令不带有任何参数，它会提供一个 TypeScript 的命令行 REPL 运行环境，你可以在这个环境中输入 TypeScript 代码，逐行执行。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，单独运行<code>ts-node</code>命令，会给出一个大于号，这就是 TypeScript 的 REPL 运行环境，可以逐行输入代码运行。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例中，在 TypeScript 命令行 REPL 环境中，先输入一个函数<code>twice</code>，然后调用该函数，就会得到结果。</p>
<p>要退出这个 REPL 环境，可以按下 Ctrl + d，或者输入<code>.exit</code>。</p>
<p>如果只是想简单运行 TypeScript 代码看看结果，ts-node 不失为一个便捷的方法。</p>
]]></content:encoded>
    </item>
    <item>
      <title>206. 反转链表</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_206_%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_206_%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.html</guid>
      <source url="https://T4mako.github.io/rss.xml">206. 反转链表</source>
      <description>206. 反转链表</description>
      <category>算法</category>
      <pubDate>Sat, 12 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 206. 反转链表</h1>
]]></content:encoded>
    </item>
    <item>
      <title>394. 字符串解码</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_394_%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_394_%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81.html</guid>
      <source url="https://T4mako.github.io/rss.xml">394. 字符串解码</source>
      <description>394. 字符串解码</description>
      <category>算法</category>
      <pubDate>Sat, 12 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 394. 字符串解码</h1>
]]></content:encoded>
    </item>
    <item>
      <title>735. 行星碰撞</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_735_%E8%A1%8C%E6%98%9F%E7%A2%B0%E6%92%9E.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_735_%E8%A1%8C%E6%98%9F%E7%A2%B0%E6%92%9E.html</guid>
      <source url="https://T4mako.github.io/rss.xml">735. 行星碰撞</source>
      <description>735. 行星碰撞</description>
      <category>算法</category>
      <pubDate>Fri, 11 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 735. 行星碰撞</h1>
]]></content:encoded>
    </item>
    <item>
      <title>933. 最近的请求次数</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_933_%E6%9C%80%E8%BF%91%E7%9A%84%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_933_%E6%9C%80%E8%BF%91%E7%9A%84%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0.html</guid>
      <source url="https://T4mako.github.io/rss.xml">933. 最近的请求次数</source>
      <description>933. 最近的请求次数</description>
      <category>算法</category>
      <pubDate>Fri, 11 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 933. 最近的请求次数</h1>
]]></content:encoded>
    </item>
    <item>
      <title>高频 SQL 50 题</title>
      <link>https://T4mako.github.io/code/leetcode/SQL/%E9%AB%98%E9%A2%91%20SQL%2050%20%E9%A2%98%EF%BC%88%E5%9F%BA%E7%A1%80%E7%89%88%EF%BC%89.html</link>
      <guid>https://T4mako.github.io/code/leetcode/SQL/%E9%AB%98%E9%A2%91%20SQL%2050%20%E9%A2%98%EF%BC%88%E5%9F%BA%E7%A1%80%E7%89%88%EF%BC%89.html</guid>
      <source url="https://T4mako.github.io/rss.xml">高频 SQL 50 题</source>
      <description>高频 SQL 50 题 题目集合 查询 1757. 可回收且低脂的产品</description>
      <category>SQL</category>
      <pubDate>Thu, 10 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 高频 SQL 50 题</h1>
<p><a href="https://leetcode.cn/studyplan/sql-free-50/" target="_blank" rel="noopener noreferrer">题目集合</a></p>
<h2> 查询</h2>
<h3> 1757. 可回收且低脂的产品</h3>
]]></content:encoded>
    </item>
    <item>
      <title>1657. 确定两个字符串是否接近</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1657_%E7%A1%AE%E5%AE%9A%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E6%8E%A5%E8%BF%91.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1657_%E7%A1%AE%E5%AE%9A%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E6%8E%A5%E8%BF%91.html</guid>
      <source url="https://T4mako.github.io/rss.xml">1657. 确定两个字符串是否接近</source>
      <description>1657. 确定两个字符串是否接近</description>
      <category>算法</category>
      <pubDate>Thu, 10 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 1657. 确定两个字符串是否接近</h1>
]]></content:encoded>
    </item>
    <item>
      <title>2390. 从字符串中移除星号</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_2390_%E4%BB%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%A7%BB%E9%99%A4%E6%98%9F%E5%8F%B7.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_2390_%E4%BB%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%A7%BB%E9%99%A4%E6%98%9F%E5%8F%B7.html</guid>
      <source url="https://T4mako.github.io/rss.xml">2390. 从字符串中移除星号</source>
      <description>2390. 从字符串中移除星号</description>
      <category>算法</category>
      <pubDate>Thu, 10 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 2390. 从字符串中移除星号</h1>
]]></content:encoded>
    </item>
    <item>
      <title>1207. 独一无二的出现次数</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1207_%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1207_%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0.html</guid>
      <source url="https://T4mako.github.io/rss.xml">1207. 独一无二的出现次数</source>
      <description>1207. 独一无二的出现次数</description>
      <category>算法</category>
      <pubDate>Wed, 09 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 1207. 独一无二的出现次数</h1>
]]></content:encoded>
    </item>
    <item>
      <title>2352. 相等行列对</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_2352_%E7%9B%B8%E7%AD%89%E8%A1%8C%E5%88%97%E5%AF%B9.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_2352_%E7%9B%B8%E7%AD%89%E8%A1%8C%E5%88%97%E5%AF%B9.html</guid>
      <source url="https://T4mako.github.io/rss.xml">2352. 相等行列对</source>
      <description>2352. 相等行列对</description>
      <category>算法</category>
      <pubDate>Wed, 09 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 2352. 相等行列对</h1>
]]></content:encoded>
    </item>
    <item>
      <title>1456. 定长子串中元音的最大数目</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1456_%E5%AE%9A%E9%95%BF%E5%AD%90%E4%B8%B2%E4%B8%AD%E5%85%83%E9%9F%B3%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1456_%E5%AE%9A%E9%95%BF%E5%AD%90%E4%B8%B2%E4%B8%AD%E5%85%83%E9%9F%B3%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE.html</guid>
      <source url="https://T4mako.github.io/rss.xml">1456. 定长子串中元音的最大数目</source>
      <description>1456. 定长子串中元音的最大数目</description>
      <category>算法</category>
      <pubDate>Tue, 08 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 1456. 定长子串中元音的最大数目</h1>
]]></content:encoded>
    </item>
    <item>
      <title>1493. 删掉一个元素以后全为 1 的最长子数组</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1493_%E5%88%A0%E6%8E%89%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E4%BB%A5%E5%90%8E%E5%85%A8%E4%B8%BA%201%20%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1493_%E5%88%A0%E6%8E%89%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E4%BB%A5%E5%90%8E%E5%85%A8%E4%B8%BA%201%20%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84.html</guid>
      <source url="https://T4mako.github.io/rss.xml">1493. 删掉一个元素以后全为 1 的最长子数组</source>
      <description>1493. 删掉一个元素以后全为 1 的最长子数组</description>
      <category>算法</category>
      <pubDate>Tue, 08 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 1493. 删掉一个元素以后全为 1 的最长子数组</h1>
]]></content:encoded>
    </item>
    <item>
      <title>2215. 找出两数组的不同</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_2215_%E6%89%BE%E5%87%BA%E4%B8%A4%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%8D%E5%90%8C.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_2215_%E6%89%BE%E5%87%BA%E4%B8%A4%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%8D%E5%90%8C.html</guid>
      <source url="https://T4mako.github.io/rss.xml">2215. 找出两数组的不同</source>
      <description>2215. 找出两数组的不同</description>
      <category>算法</category>
      <pubDate>Tue, 08 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 2215. 找出两数组的不同</h1>
]]></content:encoded>
    </item>
    <item>
      <title>1004. 最大连续1的个数 III</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1004_%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%20III.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1004_%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%20III.html</guid>
      <source url="https://T4mako.github.io/rss.xml">1004. 最大连续1的个数 III</source>
      <description>1004. 最大连续1的个数 III</description>
      <category>算法</category>
      <pubDate>Mon, 07 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 1004. 最大连续1的个数 III</h1>
]]></content:encoded>
    </item>
    <item>
      <title>1732. 找到最高海拔</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1732_%E6%89%BE%E5%88%B0%E6%9C%80%E9%AB%98%E6%B5%B7%E6%8B%94.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1732_%E6%89%BE%E5%88%B0%E6%9C%80%E9%AB%98%E6%B5%B7%E6%8B%94.html</guid>
      <source url="https://T4mako.github.io/rss.xml">1732. 找到最高海拔</source>
      <description>1732. 找到最高海拔</description>
      <category>算法</category>
      <pubDate>Mon, 07 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 1732. 找到最高海拔</h1>
]]></content:encoded>
    </item>
    <item>
      <title>643_子数组最大平均数 I</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_643_%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B0%20I.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_643_%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B0%20I.html</guid>
      <source url="https://T4mako.github.io/rss.xml">643_子数组最大平均数 I</source>
      <description>643_子数组最大平均数 I</description>
      <category>算法</category>
      <pubDate>Mon, 07 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 643_子数组最大平均数 I</h1>
]]></content:encoded>
    </item>
    <item>
      <title>283_移动0</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_283_%E7%A7%BB%E5%8A%A80.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_283_%E7%A7%BB%E5%8A%A80.html</guid>
      <source url="https://T4mako.github.io/rss.xml">283_移动0</source>
      <description>283_移动0</description>
      <category>算法</category>
      <pubDate>Sun, 06 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 283_移动0</h1>
]]></content:encoded>
    </item>
    <item>
      <title>392_判断子序列</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_392_%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_392_%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97.html</guid>
      <source url="https://T4mako.github.io/rss.xml">392_判断子序列</source>
      <description>392_判断子序列</description>
      <category>算法</category>
      <pubDate>Sun, 06 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 392_判断子序列</h1>
]]></content:encoded>
    </item>
    <item>
      <title>1679_K 和数对的最大数目</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1679_K%20%E5%92%8C%E6%95%B0%E5%AF%B9%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1679_K%20%E5%92%8C%E6%95%B0%E5%AF%B9%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE.html</guid>
      <source url="https://T4mako.github.io/rss.xml">1679_K 和数对的最大数目</source>
      <description>1679_K 和数对的最大数目</description>
      <category>算法</category>
      <pubDate>Sat, 05 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 1679_K 和数对的最大数目</h1>
]]></content:encoded>
    </item>
    <item>
      <title>443_压缩字符串</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_443_%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_443_%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2.html</guid>
      <source url="https://T4mako.github.io/rss.xml">443_压缩字符串</source>
      <description>443_压缩字符串</description>
      <category>算法</category>
      <pubDate>Sat, 05 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 443_压缩字符串</h1>
]]></content:encoded>
    </item>
    <item>
      <title>1071_字符串的最大公因子</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1071_%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1071_%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90.html</guid>
      <source url="https://T4mako.github.io/rss.xml">1071_字符串的最大公因子</source>
      <description>1071_字符串的最大公因子</description>
      <category>算法</category>
      <pubDate>Fri, 04 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 1071_字符串的最大公因子</h1>
]]></content:encoded>
    </item>
    <item>
      <title>151_反转字符串中的单词</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_151_%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_151_%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D.html</guid>
      <source url="https://T4mako.github.io/rss.xml">151_反转字符串中的单词</source>
      <description>151_反转字符串中的单词</description>
      <category>算法</category>
      <pubDate>Fri, 04 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 151_反转字符串中的单词</h1>
]]></content:encoded>
    </item>
    <item>
      <title>Stream API 的理解与使用</title>
      <link>https://T4mako.github.io/code/java/Java%20%E5%9F%BA%E7%A1%80/%E5%B8%B8%E7%94%A8%E7%B1%BB/Stream%20API.html</link>
      <guid>https://T4mako.github.io/code/java/Java%20%E5%9F%BA%E7%A1%80/%E5%B8%B8%E7%94%A8%E7%B1%BB/Stream%20API.html</guid>
      <source url="https://T4mako.github.io/rss.xml">Stream API 的理解与使用</source>
      <description>Stream API 的理解与使用 流表示包含着一系列元素的集合，可以对其做不同类型的操作，用来对这些元素执行计算 Stream执行流程 Stream的实例化 一系列中间操作（过滤，映射、......） 终止操作 中间操作与终端操作: 中间操作会再次返回一个流，所以可以链接多个中间操作，上述代码中的 filter 过滤，map 对象转换，sorted 排序，就属于中间操作。 终端操作是对流操作的一个结束动作，一般返回 void 或者一个非流的结果。上述代码中的 forEach循环 就是一个终止操作。</description>
      <category>java</category>
      <pubDate>Fri, 04 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Stream API 的理解与使用</h1>
<p>流表示包含着一系列<code>元素的集合</code>，可以对其做不同类型的操作，用来对这些元素执行计算</p>
<p>Stream执行流程</p>
<ul>
<li>Stream的实例化</li>
<li>一系列中间操作（过滤，映射、......）</li>
<li>终止操作</li>
</ul>
<!-- more    -->
<p>中间操作与终端操作:</p>
<ol>
<li>中间操作会再次返回一个流，所以可以链接多个中间操作，上述代码中的 filter 过滤，map 对象转换，sorted 排序，就属于中间操作。</li>
<li>终端操作是对流操作的一个结束动作，一般返回 <code>void</code> 或者一个<code>非流的结果</code>。上述代码中的 forEach循环 就是一个终止操作。</li>
</ol>
<p>大部分流操作都支持 <code>lambda</code> 表达式作为参数，应该说是接受一个函数式接口的实现作为参数。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 1、一些 Stream API</h2>
<h3> 创建流</h3>
<ul>
<li><code>stream()</code> 方法 通过集合获取 Stream 流</li>
<li><code>Stream.of()</code> 从一堆对象中创建 Stream 流。</li>
<li><code>IntStream</code>，<code>LongStream</code>，<code>DoubleStream</code>：特殊类型的流，用于处理原始数据类型int，long以及double</li>
</ul>
<h3> 中间操作</h3>
<h4> 1、筛选与切片</h4>
<table>
<thead>
<tr>
<th>方 法</th>
<th>描 述</th>
</tr>
</thead>
<tbody>
<tr>
<td>filter(Predicate p)</td>
<td>接收 Lambda ， 从流中排除某些元素</td>
</tr>
<tr>
<td>distinct()</td>
<td>筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素</td>
</tr>
<tr>
<td>limit(long maxSize)</td>
<td>截断流，使其元素不超过给定数量</td>
</tr>
<tr>
<td>skip(long n)</td>
<td>跳过元素，返回一个扔掉了前 个空流。与 limit(n) 互补 n 个元素的流。若流中元素不足 n 个，则返回一</td>
</tr>
</tbody>
</table>
<h4> 2、映射</h4>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>map(Function f)</td>
<td>接收一个函数作为参数，该函数会被应用到每个元 素上，并将其映射成一个新的元素。</td>
</tr>
<tr>
<td>mapToDouble(ToDoubleFunction f)</td>
<td>接收一个函数作为参数，该函数会被应用到每个元 素上，产生一个新的 DoubleStream。</td>
</tr>
<tr>
<td>mapToInt(ToIntFunction f)</td>
<td>接收一个函数作为参数，该函数会被应用到每个元 素上，产生一个新的 IntStream。</td>
</tr>
<tr>
<td>mapToLong(ToLongFunction f)</td>
<td>接收一个函数作为参数，该函数会被应用到每个元 素上，产生一个新的 LongStream。</td>
</tr>
<tr>
<td>flatMap(Function f)</td>
<td>接收一个函数作为参数，将流中的每个值都换成另 一个流，然后把所有流连接成一个流</td>
</tr>
</tbody>
</table>
<h4> 3、排序</h4>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>sorted()</td>
<td>产生一个新流，其中按自然顺序排序</td>
</tr>
<tr>
<td>sorted(Comparator com)</td>
<td>产生一个新流，其中按比较器顺序排序</td>
</tr>
</tbody>
</table>
<h3> 终止操作</h3>
<p>1、匹配与查找</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>allMatch(Predicate p)</td>
<td>检查是否匹配所有元素</td>
</tr>
<tr>
<td>anyMatch(Predicate p)</td>
<td>检查是否至少匹配一个元素</td>
</tr>
<tr>
<td>noneMatch(Predicate p)</td>
<td>检查是否没有匹配所有元素</td>
</tr>
<tr>
<td>findFirst()</td>
<td>返回第一个元素</td>
</tr>
<tr>
<td>findAny()</td>
<td>返回当前流中的任意元素</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>count()</td>
<td>返回流中元素总数</td>
</tr>
<tr>
<td>max(Comparator c)</td>
<td>返回流中最大值</td>
</tr>
<tr>
<td>min(Comparator c)</td>
<td>返回流中最小值</td>
</tr>
<tr>
<td>forEach(Consumer c)</td>
<td>内部迭代(使用 Collection 接口需要用户去做迭代， 称为外部迭代。相反， Stream API 使用内部迭 代——它帮你把迭代做了)</td>
</tr>
</tbody>
</table>
<h3> collect(),reduce(),flatMap()</h3>
<h2> 2、不同类型的 Stream 流</h2>
<p>流按对象类型可分为 <code>原始流</code> 和 <code>对象流</code></p>
<p>可以从各种数据源中创建 Stream 流，其中以 <code>Collection</code> 集合最为常见。如 <code>List</code> 和 <code>Set</code> 均支持 <code>stream()</code> 方法来创建顺序流或者是并行流。</p>
<blockquote>
<p>并行流与顺序流：并行流是通过多线程的方式来执行的，本文先讨论顺序流</p>
</blockquote>
<h3> 创建流的方式</h3>
<ul>
<li><code>stream()</code> 方法 通过集合获取 Stream 流</li>
<li><code>Stream.of()</code> 从一堆对象中创建 Stream 流。</li>
<li><code>IntStream</code>，<code>LongStream</code>，<code>DoubleStream</code>：特殊类型的流，用于处理原始数据类型int，long以及double</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>IntStreams.range()</code>方法还可以被用来取代常规的 for 循环</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>原始类型流使用其独有的函数式接口，例如IntFunction代替Function，IntPredicate代替Predicate。</li>
<li>原始类型流支持额外的终端聚合操作，<code>sum()</code> 以及 <code>average()</code></li>
</ul>
<h3> 原始流和对象流的转换</h3>
<ol>
<li>
<p>将常规对象流转换为原始类型流：<br>
<code>mapToInt()</code>，<code>mapToLong()</code>，<code>mapToDouble</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>原始类型流装换成对象流<br>
<code>mapToObj()</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<h2> 3、Stream 流的处理顺序</h2>
<h3> 垂直执行</h3>
<p>垂直执行：输出的结果是随着链条垂直移动的。<br>
上一个中间操作的结果顺势往下执行直到终端操作。</p>
<p>典型的方法如：<code>filter</code>，<code>map</code>，<code>forEach</code>，<code>anyMatch</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>中间操作顺序的不同会影响性能</p>
</div>
<h3> 水平执行</h3>
<p>所有元素都要完成这个操作<br>
比如 <code>sorted</code> 排序方法是水平执行的<br>
如果 元素只有一个，<code>sorted</code> 方法不执行</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 4、数据流复用</h2>
<p>Java8 Stream 流是不能被复用的，调用任何终端操作，流就会关闭<br>
为了克服这个限制，可以为想要执行的每个终端操作创建一个新的流链，例如，可以通过 Supplier 来包装一下流，通过 <code>get()</code> 方法来构建一个新的 <code>Stream</code> 流：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 5、常用操作</h2>
<h3> collect()收集器</h3>
<p><code>collect</code> 是终端操作,将流中的元素转变成另外一个不同的对象，例如一个<code>List</code>，<code>Set</code>或<code>Map</code>。<code>collect</code> 接受入参为<code>Collector</code>（收集器），它由四个不同的操作组成：供应器（supplier）、累加器（accumulator）、组合器（combiner）和终止器（finisher）。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 自定义收集器</h3>
<p>比如将流中的所有人转换成一个字符串，包含所有大写的名称，并以|分割。为了达到这种效果，可以通过<code>Collector.of()</code>创建一个新的收集器。同时，我们还需要传入收集器的四个组成部分：<code>供应器</code>、<code>累加器</code>、<code>组合器</code>和<code>终止器</code>。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于Java 中的字符串是 <code>final</code> 类型的，我们需要借助辅助类<code>StringJoiner</code>，来帮我们构造字符串。<br>
最开始供应器使用分隔符构造了一个<code>StringJointer</code>。<br>
累加器用于将每个人的人名转大写，然后加到<code>StringJointer</code>中。<br>
组合器将两个<code>StringJointer</code>合并为一个。<br>
最终，终结器从<code>StringJointer</code>构造出预期的字符串。</p>
<h3> FlatMap()</h3>
<p><code>FlatMap</code> 能够将流的每个元素, 转换为其他对象的流。<br>
因此，每个对象可以被转换为零个，一个或多个其他对象，并以流的方式返回。<br>
之后，这些流的内容会被放入<code>flatMap</code>返回的流中。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简化上述操作</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>flatMap</code>也可用于Java8引入的<code>Optional</code>类。<code>Optional</code>的<code>flatMap</code>操作返回一个<code>Optional</code>或其他类型的对象。所以它可以用于避免繁琐的null检查。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果不为空的话，每个<code>flatMap</code>的调用都会返回预期对象的<code>Optional</code>包装，否则返回为<code>null</code>的<code>Optional</code>包装类。</p>
<h3> Reduce()</h3>
<p>Java8 三种不同的Reduce方法</p>
<ol>
<li>
<p>第一种将流中的元素规约成流中的一个元素。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>第二种<code>reduce</code>方法接受标识值和BinaryOperator累加器。此方法可用于构造一个新的 <code>Person</code>，其中包含来自流中所有其他人的聚合名称和年龄：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>第三种reduce方法接受三个参数：标识值，BiFunction累加器和类型的组合器函数BinaryOperator。由于初始值的类型不一定为Person，我们可以使用这个归约函数来计算所有人的年龄总和：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<h2> 6、并行流</h2>
<p>流是可以并行执行的，当流中存在<strong>大量元素</strong>时，可以<strong>显著提升性能</strong>。<br>
并行流底层使用的<code>ForkJoinPool</code>, 它由<code>ForkJoinPool.commonPool()</code>方法提供。底层线程池的大小<strong>最多为五个</strong> - 默认值取决于 CPU 可用核心数</p>
<h3> 创建并行流</h3>
<p>集合支持<code>parallelStream()</code>方法来创建元素的并行流。<br>
或者在已存在的数据流上调用中间方法<code>parallel()</code>，将串行流转换为并行流</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码输出：</p>
<div class="language-apache line-numbers-mode" data-ext="apache"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>238_除自身以外数组的乘积</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_238_%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_238_%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF.html</guid>
      <source url="https://T4mako.github.io/rss.xml">238_除自身以外数组的乘积</source>
      <description>238_除自身以外数组的乘积</description>
      <category>算法</category>
      <pubDate>Thu, 03 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 238_除自身以外数组的乘积</h1>
]]></content:encoded>
    </item>
    <item>
      <title>334. 递增的三元子序列</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_334_%E9%80%92%E5%A2%9E%E7%9A%84%E4%B8%89%E5%85%83%E5%AD%90%E5%BA%8F%E5%88%97.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_334_%E9%80%92%E5%A2%9E%E7%9A%84%E4%B8%89%E5%85%83%E5%AD%90%E5%BA%8F%E5%88%97.html</guid>
      <source url="https://T4mako.github.io/rss.xml">334. 递增的三元子序列</source>
      <description>334. 递增的三元子序列</description>
      <category>算法</category>
      <pubDate>Thu, 03 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 334. 递增的三元子序列</h1>
]]></content:encoded>
    </item>
    <item>
      <title>1431_拥有最多糖果的孩子</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1431_%E6%8B%A5%E6%9C%89%E6%9C%80%E5%A4%9A%E7%B3%96%E6%9E%9C%E7%9A%84%E5%AD%A9%E5%AD%90.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1431_%E6%8B%A5%E6%9C%89%E6%9C%80%E5%A4%9A%E7%B3%96%E6%9E%9C%E7%9A%84%E5%AD%A9%E5%AD%90.html</guid>
      <source url="https://T4mako.github.io/rss.xml">1431_拥有最多糖果的孩子</source>
      <description>1431_拥有最多糖果的孩子</description>
      <category>算法</category>
      <pubDate>Wed, 02 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 1431_拥有最多糖果的孩子</h1>
]]></content:encoded>
    </item>
    <item>
      <title>1768_交替合并字符串</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1768_%E4%BA%A4%E6%9B%BF%E5%90%88%E5%B9%B6%E5%AD%97%E7%AC%A6%E4%B8%B2.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1768_%E4%BA%A4%E6%9B%BF%E5%90%88%E5%B9%B6%E5%AD%97%E7%AC%A6%E4%B8%B2.html</guid>
      <source url="https://T4mako.github.io/rss.xml">1768_交替合并字符串</source>
      <description>1768_交替合并字符串</description>
      <category>算法</category>
      <pubDate>Wed, 02 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 1768_交替合并字符串</h1>
]]></content:encoded>
    </item>
    <item>
      <title>345_反转字符串中的元音字母</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_345_%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_345_%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D.html</guid>
      <source url="https://T4mako.github.io/rss.xml">345_反转字符串中的元音字母</source>
      <description>345_反转字符串中的元音字母</description>
      <category>算法</category>
      <pubDate>Wed, 02 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 345_反转字符串中的元音字母</h1>
]]></content:encoded>
    </item>
    <item>
      <title>605_种花问题</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_605_%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_605_%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98.html</guid>
      <source url="https://T4mako.github.io/rss.xml">605_种花问题</source>
      <description>605_种花问题</description>
      <category>算法</category>
      <pubDate>Tue, 01 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 605_种花问题</h1>
]]></content:encoded>
    </item>
    <item>
      <title>056. 合并区间</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_056_%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_056_%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.html</guid>
      <source url="https://T4mako.github.io/rss.xml">056. 合并区间</source>
      <description>056. 合并区间</description>
      <category>算法</category>
      <pubDate>Mon, 31 Jul 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 056. 合并区间</h1>
<!-- more -->
<p><a href="https://leetcode.cn/problems/merge-intervals/description/" target="_blank" rel="noopener noreferrer">题目描述</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>724_寻找数组的中心下标</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_724_%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E4%B8%8B%E6%A0%87.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_724_%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E4%B8%8B%E6%A0%87.html</guid>
      <source url="https://T4mako.github.io/rss.xml">724_寻找数组的中心下标</source>
      <description>724_寻找数组的中心下标</description>
      <category>算法</category>
      <pubDate>Mon, 31 Jul 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 724_寻找数组的中心下标</h1>
]]></content:encoded>
    </item>
    <item>
      <title>个人介绍 / 留言板</title>
      <link>https://T4mako.github.io/intro.html</link>
      <guid>https://T4mako.github.io/intro.html</guid>
      <source url="https://T4mako.github.io/rss.xml">个人介绍 / 留言板</source>
      <description>个人介绍 / 留言板</description>
      <pubDate>Thu, 27 Jul 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 个人介绍 / 留言板</h1>
<!-- more -->
<h2> 我是谁？</h2>
<ul>
<li>T4mako</li>
<li>经典社恐</li>
<li>性别：男</li>
<li>年龄：22</li>
<li>婚姻情况: 未婚</li>
<li>单身: 是</li>
<li>学历：苏州科技大学 CS在读</li>
</ul>
<p>T4mako名字的由来：Tamako来自于<a href="https://www.kyotoanimation.co.jp/" target="_blank" rel="noopener noreferrer">京都动画</a>公司第二部原创动画<a href="http://tamakomarket.com/" target="_blank" rel="noopener noreferrer">《玉子市场》</a>的女主人公北白川たまこ（Kitashirakawa Tamako）。<br>
同时作为一名CSGO玩家，受职业选手启发，有着数字代表字母的‘美德’<code>1-&gt;i/l,3-&gt;e,4-&gt;a···</code>。<s>CSGO？赚钱工具！</s><br>
因此T4mako从宇宙诞生了。</p>
<h2> 兴趣爱好</h2>
<ul>
<li>编程 <s>解决吃饭</s></li>
<li>打游戏 <s>电子阳痿</s></li>
<li>MAD/摸鱼 <s>计算机图形学实验员</s></li>
<li>看番 <s>婆罗门</s></li>
<li>厨艺 <s>吃饭糊弄学研究方向</s></li>
<li>more and more <s>感兴趣但不会</s></li>
</ul>
<h2> 社交媒体与联系方式</h2>
<p>联系方式：</p>
<ul>
<li>你可以在下方留言</li>
<li>或通过QQ号查找到我：1536954632</li>
</ul>
<p>社交媒体：</p>
<ul>
<li><a href="https://space.bilibili.com/313309138" target="_blank" rel="noopener noreferrer">Bilibili</a> <s>（home）</s></li>
<li><a href="https://github.com/T4mako" target="_blank" rel="noopener noreferrer">GitHub</a> <s>（学习与整活）</s></li>
<li><a href="https://bgm.tv/user/t4mako" target="_blank" rel="noopener noreferrer">Bangumi</a> <s>（速来看番）</s></li>
<li><a href="https://steamcommunity.com/profiles/76561199025694576/" target="_blank" rel="noopener noreferrer">Steam</a> <s>（Van♂游戏）</s></li>
<li><a href="https://music.163.com/#/user/home?id=559686132" target="_blank" rel="noopener noreferrer">网易云</a> <s>（没有音乐会死）</s></li>
<li><a href="https://m.weibo.cn/u/6321875003" target="_blank" rel="noopener noreferrer">微博</a> <s>（理发店）</s></li>
<li><a href="https://www.douyin.com/user/MS4wLjABAAAA32mwXDHtuWrwk5MD48IWbQCxLEzl1K-wBpUKNiH6NdA" target="_blank" rel="noopener noreferrer">抖音</a> <s>（随心发）</s></li>
</ul>
<h2> 日常</h2>
<p>学习、睡觉、吃饭、玩</p>
<h2> 关于博客</h2>
<p>本博客基于<a href="https://theme-hope.vuejs.press/zh/" target="_blank" rel="noopener noreferrer">vuepress-theme-hope</a>主题搭建的<a href="https://vuejs.press/zh/" target="_blank" rel="noopener noreferrer">vuepress</a>博客。<br>
该博客存储我的大部分笔记，并提供搜索、评论服务<s>我真会来搜吗</s></p>
<h2> 请我喝一杯</h2>
<p><s>我看看会不会真有人Vme</s></p>
<table>
<thead>
<tr>
<th style="text-align:center">微信</th>
<th style="text-align:center">支付宝</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h2> 博客待完善的内容</h2>
<ul>
<li>文章格式整理</li>
<li>RSS订阅</li>
<li>背景图更换</li>
<li>更多玩法</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>基于 vue-theme-hope 的博客搭建指南</title>
      <link>https://T4mako.github.io/code/%E5%85%B6%E4%BB%96/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA.html</link>
      <guid>https://T4mako.github.io/code/%E5%85%B6%E4%BB%96/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA.html</guid>
      <source url="https://T4mako.github.io/rss.xml">基于 vue-theme-hope 的博客搭建指南</source>
      <description>基于 vue-theme-hope 的博客搭建指南 在构建博客时，推荐参照官方文档进行构建，本文知识大致介绍与提出基本概念，帮助大家快速构建博客。</description>
      <category>Vue</category>
      <pubDate>Thu, 27 Jul 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 基于 vue-theme-hope 的博客搭建指南</h1>
<p>在构建博客时，推荐参照<a href="https://theme-hope.vuejs.press/zh/" target="_blank" rel="noopener noreferrer">官方文档</a>进行构建，本文知识大致介绍与提出基本概念，帮助大家快速构建博客。</p>
<!-- more -->
<p>搭建个人博客的好处有很多，包括笔记管理，快速定位搜索，知识点复习，激发创作欲等，每个程序员都应有一个个人博客。<s>什么暴论</s><br>
目前搭建个人博客、资料库的手段很多。例如hexo，wordpress，VuePress，自行搭建······。<br>
<a href="https://v2.vuepress.vuejs.org/zh/" target="_blank" rel="noopener noreferrer">VuePress</a>是Vue 驱动的静态网站生成器，VuePress的核心是以Markdown文件为中心，由 Vue、Vue Router 和 webpack驱动的单页应用，它功能强大并支持诸多插件。<br>
<a href="https://theme-hope.vuejs.press/zh/" target="_blank" rel="noopener noreferrer">VuePress Theme Hope</a>是一个具有强大功能的 vuepress 主题，它基于VuePress2.x并提供了更强大的功能。</p>
<h2> 构建项目</h2>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>在搭建blog之前，你需要准备：</p>
<ul>
<li><a href="https://nodejs.org/zh-cn" target="_blank" rel="noopener noreferrer">Node.js</a> 16+</li>
<li>推荐使用<a href="https://pnpm.io/" target="_blank" rel="noopener noreferrer">pnpm</a> 7+作为包管理工具</li>
</ul>
</div>
<p>初始化项目：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的<code>my-docs</code>代表当前目录下的项目文件夹名称<br>
构建项目时，可以选择<code>简体中文</code>并回车来在后续流程中使用中文进行显示。<br>
在模板初始化成功后选择立即启动开发服务器，你就可以在浏览器地址栏输入 <code>localhost:8080/</code> 访问你的博客。</p>
<h2> 基本概念</h2>
<p>在构建项目后，开发项目前，你需要了解的<strong>基础知识</strong>：</p>
<ol>
<li>VuePress 是以<a href="https://theme-hope.vuejs.press/zh/cookbook/markdown/" target="_blank" rel="noopener noreferrer">Markdown</a> 为中心的。你项目中的每一个 Markdown 文件都是一个单独的页面。</li>
<li>主要配置文件：
<ul>
<li><code>.vuepress/config.ts</code>：<strong>VuePress的配置文件</strong>，用于配置主题，插件，站点等，<a href="https://vuejs.press/zh/reference/config.html" target="_blank" rel="noopener noreferrer">相关配置</a></li>
<li><code>.vuepress/theme.ts</code>：<strong>主题配置</strong>，用于配置主题的功能、布局、外观等，<a href="https://theme-hope.vuejs.press/zh/config/theme/layout.html" target="_blank" rel="noopener noreferrer">相关配置</a></li>
<li><code>narbar.ts</code>：用于配置<strong>导航栏</strong>布局，<a href="https://theme-hope.vuejs.press/zh/guide/layout/navbar.html" target="_blank" rel="noopener noreferrer">相关配置</a></li>
<li><code>sidebat.ts</code>：用于配置<strong>侧边栏</strong>布局，<a href="https://theme-hope.vuejs.press/zh/guide/layout/sidebar.html" target="_blank" rel="noopener noreferrer">相关配置</a></li>
</ul>
</li>
<li><code>frontmatter</code>：必须放在.md文件的<strong>开头</strong>，可以配置Markdown文件的相关信息，这些信息用于显示在博客上的标题，图标，时间，分类等，<a href="https://theme-hope.vuejs.press/zh/config/frontmatter/" target="_blank" rel="noopener noreferrer">相关配置</a></li>
<li>博客首页（<code>.vuepress/README.md</code>）：如果你创建的是博客项目，那么你打开博客后的初始页面为首页，你可以对其进行配置，也可以更改首页。<a href="https://theme-hope.vuejs.press/zh/guide/blog/" target="_blank" rel="noopener noreferrer">相关配置</a></li>
<li>个人介绍页（<code>.vuepress/intro.md</code>）</li>
<li>.vuepress/styles：样式配置，用于配置主题样式，添加自己的样式等，<a href="https://theme-hope.vuejs.press/zh/config/style.html" target="_blank" rel="noopener noreferrer">相关配置</a></li>
<li><a href="https://theme-hope.vuejs.press/zh/cookbook/tutorial/content.html#%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%94%9F%E6%88%90" target="_blank" rel="noopener noreferrer">Markdown 文件路由路径</a></li>
</ol>
<p><strong>你可以在vueprress-theme-hope<a href="https://theme-hope.vuejs.press/zh/" target="_blank" rel="noopener noreferrer">官方文档</a>中查询所有的配置与功能</strong></p>
<h2> MarkDown增强</h2>
<p>有了MarkDown增强即可在编写文章时使用更多的语法来实现更丰富的效果。</p>
<ul>
<li><a href="https://v2.vuepress.vuejs.org/zh/guide/markdown.html#%E8%AF%AD%E6%B3%95%E6%89%A9%E5%B1%95" target="_blank" rel="noopener noreferrer">VuePress 本身新增了一些 Markdown 语法</a></li>
<li>vuepress-theme-hope 通过 <a href="https://plugin-md-enhance.vuejs.press/zh/" target="_blank" rel="noopener noreferrer">vuepress-plugin-md-enhance</a> 在 Markdown 中启用了更多的语法与新功能。</li>
</ul>
<h2> 在MarkDown中使用Vue</h2>
<p>在MarkDown文件中可以使用Vue语法和Vue组件<br>
建议在<code>.vuepress/components</code>文件夹下创建组件<br>
通过<code>@vuepress/plugin-register-components</code>插件可以进行组件的注册</p>
<p><a href="https://vuejs.press/zh/reference/plugin/register-components.html" target="_blank" rel="noopener noreferrer">安装插件与配置项</a></p>
<p><a href="https://theme-hope.vuejs.press/zh/cookbook/customize/component.html#%E5%9C%A8-markdown-%E4%B8%AD%E4%BD%BF%E7%94%A8-vue-%E8%AF%AD%E6%B3%95%E4%B8%8E%E7%BB%84%E4%BB%B6" target="_blank" rel="noopener noreferrer">在vuepress-theme-hope中使用</a>：<br>
为了正确导入自己的组件，你需要为它们创建别名，你可以通过 alias 选项实现这一点:</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在MarkDown中引入：</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 插件</h2>
<p>vuepress的官方<a href="https://vuejs.press/zh/reference/plugin/" target="_blank" rel="noopener noreferrer">插件</a><br>
vuepress-theme-hope内置的<a href="https://theme-hope.vuejs.press/zh/config/plugins/" target="_blank" rel="noopener noreferrer">插件</a><br>
<a href="https://marketplace.vuejs.press/zh/" target="_blank" rel="noopener noreferrer">插件市场</a>包括更强的搜索，博客，live-2d等功能</p>
<h2> 常见问题</h2>
<p>在构建过程中，难免会发生问题，大部分问题你可以在<a href="https://theme-hope.vuejs.press/zh/faq/" target="_blank" rel="noopener noreferrer">常见问题</a>和<a href="https://github.com/vuepress-theme-hope/vuepress-theme-hope/issues" target="_blank" rel="noopener noreferrer">GitHub issues</a>上找到</p>
<h2> 项目的部署</h2>
<p><a href="https://t4mako.github.io/code/%E8%BF%90%E7%BB%B4%E4%B8%8E%E9%83%A8%E7%BD%B2/GitHub%20Actions.html" target="_blank" rel="noopener noreferrer">推荐使用 GitHub Actions 部署到 GitHub Pages</a><br>
<a href="https://vuejs.press/zh/guide/deployment.html" target="_blank" rel="noopener noreferrer">其他方式部署</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>GitHub Actions 部署</title>
      <link>https://T4mako.github.io/code/%E8%BF%90%E7%BB%B4%E4%B8%8E%E9%83%A8%E7%BD%B2/GitHub%20Actions.html</link>
      <guid>https://T4mako.github.io/code/%E8%BF%90%E7%BB%B4%E4%B8%8E%E9%83%A8%E7%BD%B2/GitHub%20Actions.html</guid>
      <source url="https://T4mako.github.io/rss.xml">GitHub Actions 部署</source>
      <description>使用 GitHub Actions 部署，以 vuepress-theme-hope Blog 为例</description>
      <category>部署</category>
      <pubDate>Mon, 24 Jul 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>使用 GitHub Actions 部署，以 vuepress-theme-hope Blog 为例</p>
<!-- more -->
<p>关于 git  相关使用  <a href="/code/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Git">GIt基础</a></p>
<p><a href="https://github.com/features/actions" target="_blank" rel="noopener noreferrer">GitHub Actions</a> 是 GitHub 的 <a href="https://www.ruanyifeng.com/blog/2015/09/continuous-integration.html" target="_blank" rel="noopener noreferrer">持续集成服务(CI/CD)</a></p>
<h3> GitHub Actions 术语：</h3>
<ul>
<li><strong>workflow</strong> （工作流程）：持续集成一次运行的过程，就是一个 wor	kflow。</li>
<li><strong>job</strong> （任务）：一个 workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务。</li>
<li><strong>step</strong>（步骤）：每个 job 由多个 step 构成，一步步完成。</li>
<li><strong>action</strong> （动作）：每个 step 可以依次执行一个或多个命令（action）。</li>
</ul>
<h3> workflow 文件</h3>
<p>GitHub Actions 的配置文件叫做 workflow 文件，存放在代码仓库的<code>.github/workflows</code>目录。</p>
<p>workflow 文件采用 YAML 格式，文件名可以任意取<br>
一个库可以有多个 workflow 文件<br>
GitHub 只要发现<code>.github/workflows</code>目录里面有<code>.yml</code>文件，就会自动运行该文件。</p>
<p>workflow 文件配置规则：<a href="https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions" target="_blank" rel="noopener noreferrer">https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions</a></p>
<h3> 部署 vuepress-theme-hope Blog 到 GitHub pages</h3>
<p>当 commit 到 main 分支后，GitHub Actions 就会执行 jobs 下的步骤</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后，提交到 main 分支下的内容通过自动构建并将 dist 目录部署到 GitHub Pages 上（注意设置GitHub Pages的依赖分支）</p>
]]></content:encoded>
    </item>
    <item>
      <title>VuePress 中的 Markdown 扩展</title>
      <link>https://T4mako.github.io/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/vue/vuepress/markdown%E6%89%A9%E5%B1%95.html</link>
      <guid>https://T4mako.github.io/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/vue/vuepress/markdown%E6%89%A9%E5%B1%95.html</guid>
      <source url="https://T4mako.github.io/rss.xml">VuePress 中的 Markdown 扩展</source>
      <description>VuePress 中的 Markdown 扩展 https://theme-hope.vuejs.press/zh/guide/markdown/intro.html VuePress 会使用 markdown-it 来解析 Markdown 内容，因此可以借助于 markdown-it 插件来实现 语法扩展</description>
      <category>MarkDown</category>
      <pubDate>Thu, 20 Jul 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> VuePress 中的 Markdown 扩展</h1>
<p><a href="https://theme-hope.vuejs.press/zh/guide/markdown/intro.html" target="_blank" rel="noopener noreferrer">https://theme-hope.vuejs.press/zh/guide/markdown/intro.html</a></p>
<p>VuePress 会使用 <a href="https://github.com/markdown-it/markdown-it" target="_blank" rel="noopener noreferrer">markdown-it</a> 来解析 Markdown 内容，因此可以借助于 markdown-it 插件来实现 <a href="https://github.com/markdown-it/markdown-it#syntax-extensions" target="_blank" rel="noopener noreferrer">语法扩展</a></p>
<h2> 链接</h2>
<p>VuePress 中的 链接语法 转换：</p>
<p>原始Markdown：</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>转换为：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>内部链接会被转换为 <code>&lt;RouterLink&gt;</code> 以便进行 SPA 导航。</li>
<li>指向 <code>.md</code> 文件的内部链接会被转换为目标页面的 <a href="https://theme-hope.vuejs.press/zh/cookbook/vuepress/page.html#%E8%B7%AF%E7%94%B1" target="_blank" rel="noopener noreferrer">路由路径</a>，并且支持绝对路径和相对路径。</li>
<li>外部链接会被添加 <code>target="_blank" rel="noopener noreferrer"</code> 属性。</li>
</ul>
<h3> 建议</h3>
<p>对于 <strong>内部链接</strong>，尽可能使用 <strong>相对路径</strong> 而不是绝对路径。</p>
<p>在使用绝对路径时，如果你站点的 base 不是 <code>"/"</code>，你需要手动添加 <code>base</code> 或者使用  base helper 。</p>
<h3> 引入目录</h3>
<p>如果你想要把当前页面的目录添加到 Markdown 内容中，你可以使用 <code>[[toc]]</code> 语法。</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 代码块</h2>
<p>代码块在 Node 端处理</p>
<h3> 行高亮</h3>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>行数范围标记的例子:</p>
<ul>
<li>行数范围: <code>{5-8}</code></li>
<li>多个单行: <code>{4,7,9}</code></li>
<li>组合: <code>{4,7-13,16,23-27,40}</code></li>
</ul>
<h3> 行号</h3>
<p>行号默认启用</p>
<p>局部禁用方式：</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> :no-v-pre</h3>
<p>为了避免你的代码块被 Vue 编译<br>
可以在代码块添加 <code>:v-pre</code> / <code>:no-v-pre</code> 标记来覆盖配置项中的设置。</p>
<h3> 导入代码块</h3>
<p>从文件中导入代码块: <a href="https://theme-hope.vuejs.press/zh/cookbook/vuepress/markdown.html#%E5%AF%BC%E5%85%A5%E4%BB%A3%E7%A0%81%E5%9D%97" target="_blank" rel="noopener noreferrer">https://theme-hope.vuejs.press/zh/cookbook/vuepress/markdown.html#导入代码块</a></p>
<h2> 在 Markdown中使用 Vue</h2>
<ul>
<li>Markdown 中允许使用 HTML。</li>
<li>Vue 模板语法是和 HTML 兼容的。</li>
</ul>
<p>Markdown 中允许直接使用 <a href="https://v3.vuejs.org/guide/template-syntax.html" target="_blank" rel="noopener noreferrer">Vue 模板语法</a></p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：不要在 VuePress 的 Markdown 中使用已废弃的 html 标签</p>
<h3> 使用Vue组件</h3>
<p>在MarkDown文件中可以使用Vue语法和Vue组件<br>
建议在<code>.vuepress/components</code>文件夹下创建组件<br>
通过<code>@vuepress/plugin-register-components</code>插件可以进行组件的注册</p>
<p><a href="https://vuejs.press/zh/reference/plugin/register-components.html" target="_blank" rel="noopener noreferrer">安装插件与配置项</a></p>
<p><a href="https://theme-hope.vuejs.press/zh/cookbook/customize/component.html#%E5%9C%A8-markdown-%E4%B8%AD%E4%BD%BF%E7%94%A8-vue-%E8%AF%AD%E6%B3%95%E4%B8%8E%E7%BB%84%E4%BB%B6" target="_blank" rel="noopener noreferrer">在vuepress-theme-hope中使用</a>：<br>
为了正确导入自己的组件，你需要为它们创建别名，你可以通过 alias 选项实现这一点:</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在MarkDown中引入：</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>JWT 教程</title>
      <link>https://T4mako.github.io/code/java/JWT.html</link>
      <guid>https://T4mako.github.io/code/java/JWT.html</guid>
      <source url="https://T4mako.github.io/rss.xml">JWT 教程</source>
      <description>JSON Web Token (JWT) 是一个开放标准（rfc7519），它定义了一种紧凑的、自包含的方式，用于在各方之间以 JSON对象 安全地传输信息。此信息可以验证和信任，因为它是数字签名的。JWT 可以使用 HMAC算法 或 使用 RSA 或 ECDSA 的公钥/私钥对进行签名</description>
      <category>java</category>
      <pubDate>Fri, 09 Jun 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>JSON Web Token (<a href="https://jwt.io/introduction/" target="_blank" rel="noopener noreferrer">JWT</a>) 是一个开放标准（rfc7519），它定义了一种紧凑的、自包含的方式，用于在各方之间以 <strong>JSON对象</strong> 安全地传输信息。此信息可以验证和信任，因为它是数字签名的。JWT 可以使用 HMAC算法 或 使用 RSA 或 ECDSA 的公钥/私钥对进行签名</p>
<!-- more -->
<p>JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案</p>
<h3> 1、JWT 作用</h3>
<p>1、<strong>登录授权</strong></p>
<ul>
<li>用户登录，后续每个请求将包括 JWT，从而允许用户访问该令牌允许的路由，服务和资源。|<br>
<strong>单点登录</strong> 是当今广泛使用JWT的一项功能，因为它的开销小且能在不同的域中使用。</li>
</ul>
<p>2、<strong>信息交换</strong></p>
<ul>
<li>JSON Web Token 可以在各方之间安全传输信息<br>
通过对 JWT 进行签名（例如，使用公钥/私钥对），可以确保发件人是他们所说的人。<br>
此外，由于签名是使用标头和有效负载计算的，因此您还可以验证内容是否遭到篡改。</li>
</ul>
<h3> 2、session 与 JWT 对比</h3>
<h4> 传统的Session认证</h4>
<p>认证方式：</p>
<ol>
<li>用户向服务器发送用户名和密码。</li>
<li>服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</li>
<li>服务器向用户返回一个 session_id，写入用户的 Cookie。</li>
<li>用户 <strong>随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器</strong>。</li>
<li>服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</li>
</ol>
<blockquote>
<p>这种模式的问题在于，扩展性（scaling）不好。<br>
单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，<strong>每台服务器都能够读取 session</strong></p>
<p>http 协议本身是一种 无状态 的协议，我们并不能知道是哪个用户发出的请求</p>
<p>所以为了让我们的应用能识别是哪个用户发出的请求，我们只能在 <strong>服务器存储</strong> 一份用户登录的信息，这份登录信息会在响应时传递给浏览器，告诉其保存为cookie,以便下次请求时发送给我们的应用，这样我们的应用就能识别请求来自哪个用户了,这就是传统的基于session认证。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20200726103959013.png" alt="image-20200726103959013" loading="lazy"></p>
<p>暴露问题：</p>
<ol>
<li>每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，通常而言 session 都是保存在 <strong>内存</strong> 中，而随着认证用户的增多，服务端的开销会明显增大</li>
<li>用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上，这样在分布式的应用上，相应的限制了 <strong>负载均衡</strong> 器的能力。这也意味着限制了应用的扩展能力。</li>
<li>因为是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。</li>
<li>在前后端分离系统中：<br>
① 通常用户一次请求就要转发多次。如果每次携带 sessionid 到服务器，服务器还要查询用户信息。<br>
② 如果用户很多。这些信息存储在服务器内存中，给 <strong>服务器增加负担</strong>。<br>
③ <strong>CSRF</strong> 攻击：session 是基于cookie 进行用户识别的, cookie 如果被截获，用户就会很容易受到 跨站请求伪造 的攻击。<br>
④ sessionid 就是一个特征值，<strong>表达的信息不够丰富</strong>。不容易扩展。而且如果你后端应用是多节点部署。那么就需要实现session共享机制。不方便集群应用。</li>
</ol>
<blockquote>
<p>一种解决方案是 <strong>session 数据持久化</strong>，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。</p>
<p>另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。</p>
</blockquote>
<h4> JWT认证</h4>
<p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20200726183248298.png" alt="" loading="lazy"></p>
<p><strong>认证流程</strong></p>
<ul>
<li>
<p>前端通过表单将用户名、密码发送到后端。</p>
</li>
<li>
<p>后端核对用户名和密码成功后，将用户的 <strong>id等信息</strong> 作为 <strong>JWT Payload（负载）</strong>，将其与头部分别进行Base64编码拼接后签名，形成一个JWT(Token)。</p>
</li>
<li>
<p>后端将 JWT字符串 作为登录成功的返回结果返回给前端。前端可以将返回的结果保存在 <strong>localStorage</strong> 或 <strong>sessionStorage</strong>上，退出登录时前端删除保存的JWT即可。</p>
</li>
<li>
<p>前端在每次请求时将 JWT 放入 HTTP Header 中的 <strong>Authorization</strong> 位。(解决XSS和XSRF问题)</p>
</li>
<li>
<p>后端验证 JWT 的有效性。例如，检查签名是否正确、Token是否过期、Token的接收方是否是自己等。</p>
</li>
<li>
<p>验证通过后后端使用 JWT 中包含的用户信息进行其他逻辑操作，返回相应结果。</p>
</li>
</ul>
<p><strong>JWT优势</strong></p>
<ul>
<li>
<p>简洁(Compact): 可以通过URL，POST参数或者在HTTP header发送，因为数据量小，传输速度也很快</p>
</li>
<li>
<p>自包含(Self-contained)：负载中包含了所有用户所需要的信息，避免了多次查询数据库</p>
</li>
<li>
<p>因为 Token 是以 JSON 加密的形式保存在客户端的，所以 JWT 是跨语言的，原则上任何web形式都支持。</p>
</li>
<li>
<p>不需要在服务端保存会话信息，特别适用于分布式微服务。</p>
</li>
</ul>
<h3> 3、JWT 结构</h3>
<p><strong>header.payload.singnature</strong></p>
<ul>
<li>1.标头(Header)</li>
<li>2.有效载荷(Payload)</li>
<li>3.签名(Signature)</li>
</ul>
<h4> Header</h4>
<p>标头通常由两部分组成：<br>
① 令牌的类型（即JWT）<br>
② 所使用的签名算法，例如HMAC SHA256或RSA。<br>
它会使用 Base64 编码组成 JWT 结构的第一部分。</p>
<blockquote>
<p>注：Base64是一种编码，并不是一种加密过程，它可以被翻译回原来的样子。</p>
</blockquote>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> Payload</h4>
<p>令牌第二部分是 有效负载，其中包含声明。<br>
声明是有关实体（通常是用户）和其他数据的声明。<br>
同样，它会使用 Base64 编码组成 JWT 结构的第二部分</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>注：JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。</p>
</blockquote>
<h4> Signature</h4>
<ul>
<li>
<p>Signature 需要使用编码后的 header 和 payload 以及我们提供的一个密钥（<strong>盐</strong>），然后使用 header 中指定的签名算法（HS256）进行签名。签名的作用是保证 JWT 没有被篡改过</p>
<p>Signature = HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload),secret);</p>
</li>
</ul>
<p>签名目的</p>
<ul>
<li>最后一步签名的过程，实际上是对头部以及负载内容进行签名，防止内容被窜改。</li>
<li>如果有人对头部以及负载的内容解码之后进行修改，再进行编码，最后加上之前的签名组合形成新的JWT的话，那么服务器端会判断出新的头部和负载形成的签名和JWT附带上的签名是不一样的。</li>
<li>如果要对新的头部和负载进行签名，在不知道服务器加密时用的密钥的话，得出来的签名也是不一样的。</li>
</ul>
<p>信息安全问题</p>
<ul>
<li>
<p>Base64是一种编码，是可逆的，那么信息会暴露</p>
</li>
<li>
<p>因此在 JWT 中，所以不要把秘密信息放在这个部分。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20200726181136113.png" alt="image-20200726181136113" loading="lazy"></p>
<h4> 放在一起</h4>
<p><strong>header.payload.singnature</strong></p>
<ul>
<li>输出是三个由点分隔的Base64-URL字符串</li>
<li>可以通过URL, POST 参数或者在 HTTP header 发送，数据量小，传输速度快</li>
<li>自包含(Self-contained)<br>
负载中包含了所有用户所需要的信息，避免了多次查询数据库</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20200726124257203.png" alt="image-20200726124257203" loading="lazy"></p>
<h3> 4、JWT 使用</h3>
<p><a href="https://jwt.io/libraries" target="_blank" rel="noopener noreferrer">JWT官网提供的使用</a></p>
<p><a href="https://github.com/auth0/java-jwt" target="_blank" rel="noopener noreferrer">基于 Java 的使用</a>：</p>
<h4> 1、引入依赖</h4>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2、生成token</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3、根据令牌和签名解析数据</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4、常见异常信息</h4>
<ul>
<li>SignatureVerificationException:				签名不一致异常</li>
<li>TokenExpiredException:    						令牌过期异常</li>
<li>AlgorithmMismatchException:						算法不匹配异常</li>
<li>InvalidClaimException:								失效的payload异常</li>
</ul>
<h3> 6.封装工具类</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6.整合springboot</h3>
<h4> Controller 层开发</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 测试类编写</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过 Postman 携带 token 测试</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20200805215451442.png" alt="image-20200805215451442" loading="lazy"></p>
<h4> 优化</h4>
<ul>
<li>使用上述方式每次都要传递 token 数据,每个方法都需要 <strong>验证 token 代码冗余</strong></li>
<li>可以使用 <strong>拦截器</strong> 进行优化</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>参考：<br>
<a href="https://www.bilibili.com/video/BV1i54y1m7cP/" target="_blank" rel="noopener noreferrer">https://www.bilibili.com/video/BV1i54y1m7cP/</a><br>
<a href="https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener noreferrer">https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html</a></p>
</blockquote>
]]></content:encoded>
      <enclosure url="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20200726103959013.png" type="image/png"/>
    </item>
    <item>
      <title>LCP 68_美观的花束</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_LCP68_%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E6%9D%9F.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_LCP68_%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E6%9D%9F.html</guid>
      <source url="https://T4mako.github.io/rss.xml">LCP 68_美观的花束</source>
      <description>LCP 68_美观的花束</description>
      <category>算法</category>
      <pubDate>Thu, 24 Nov 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> LCP 68_美观的花束</h1>
]]></content:encoded>
    </item>
    <item>
      <title>代码笔记</title>
      <link>https://T4mako.github.io/code/</link>
      <guid>https://T4mako.github.io/code/</guid>
      <source url="https://T4mako.github.io/rss.xml">代码笔记</source>
      <description>基础知识 (/code/基础知识) 前端开发 (/code/前端开发) Java后端 (/code/java) 数据库 (/code/数据库) 运维与部署 (/code/运维与部署) Python (/code/python) Leetcode (/code/Leetcode) 其他 (/code/其他)</description>
      <content:encoded><![CDATA[<h1> </h1>
<!-- more -->
<h3> <a href="/code/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">基础知识</a></h3>
<h3> <a href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91">前端开发</a></h3>
<h3> <a href="/code/java">Java后端</a></h3>
<h3> <a href="/code/%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a></h3>
<h3> <a href="/code/%E8%BF%90%E7%BB%B4%E4%B8%8E%E9%83%A8%E7%BD%B2">运维与部署</a></h3>
<h3> <a href="/code/python">Python</a></h3>
<h3> <a href="/code/Leetcode">Leetcode</a></h3>
<h3> <a href="/code/%E5%85%B6%E4%BB%96">其他</a></h3>
]]></content:encoded>
    </item>
    <item>
      <title>友链</title>
      <link>https://T4mako.github.io/friends/</link>
      <guid>https://T4mako.github.io/friends/</guid>
      <source url="https://T4mako.github.io/rss.xml">友链</source>
      <description>友链</description>
      <content:encoded><![CDATA[<h1> 友链</h1>
]]></content:encoded>
    </item>
    <item>
      <title>IDE 快捷键</title>
      <link>https://T4mako.github.io/code/java/IDEA%E3%80%81Eclipse%E5%BF%AB%E6%8D%B7%E9%94%AE.html</link>
      <guid>https://T4mako.github.io/code/java/IDEA%E3%80%81Eclipse%E5%BF%AB%E6%8D%B7%E9%94%AE.html</guid>
      <source url="https://T4mako.github.io/rss.xml">IDE 快捷键</source>
      <description># Eclipse 补全代码的声明： alt + /; 快速修复: ctrl + 1 *; 批量导包： ctrl + shift + o; 使用单行注释： ctrl + / ; 使用多行注释： ctrl + shift + /; 取消多行注释： ctrl + shift + \; 复制指定行的代码： ctrl + alt + down 或 ctrl +...</description>
      <category>java</category>
      <content:encoded><![CDATA[<h1> </h1>
<!-- more -->
<h2> Eclipse</h2>
<ul>
<li>补全代码的声明： alt + /</li>
<li>*快速修复: ctrl + 1 **</li>
<li>批量导包： ctrl + shift + o</li>
<li>使用单行注释： ctrl + /</li>
<li>使用多行注释： ctrl + shift + /</li>
<li>取消多行注释： ctrl + shift + \</li>
<li>复制指定行的代码： ctrl + alt + down 或 ctrl + alt + up</li>
<li>删除指定行的代码： ctrl + d</li>
<li>上下移动代码： alt + up 或 alt + down</li>
<li>切换到下一行代码空位： shift + enter</li>
<li>切换到上一行代码空位： ctrl + shift + enter</li>
<li>如何查看源码： ctrl + 选中指定的结构 或 ctrl + shift + t</li>
<li>退回到前一个编辑的页面： alt + left</li>
<li>进入到下一个编辑的页面(针对于上面那条来说的)： alt + right</li>
<li>光标选中指定的类，查看继承树结构： ctrl + t</li>
<li>复制代码： ctrl + c</li>
<li>撤销： ctrl + z</li>
<li>反撤销： ctrl + y</li>
<li>剪切： ctrl + x</li>
<li>粘贴： ctrl + v</li>
<li>保存： ctrl + s</li>
<li>全选： ctrl + a</li>
<li>格式化代码： ctrl + shift + f （整理代码）</li>
<li>选中数行，整体往后移动： tab</li>
<li>选中数行，整体往前移动： shift + tab</li>
<li>在当前类中，显示类结构，并支持搜索指定的方法、属性等： ctrl + o</li>
<li>批量修改指定的变量名、方法名、类名等： alt + shift + r</li>
<li>选中的结构的大小写的切换：变成大写： ctrl + shift + x</li>
<li>选中的结构的大小写的切换：变成小写： ctrl + shift + y</li>
<li>调出生成 getter/setter/构造器等结构： alt + shift + s</li>
<li>显示当前选择资源(工程 or 文件)的属性： alt + enter</li>
<li>快速查找：参照选中的 Word 快速定位到下一个 ： ctrl + k</li>
<li>关闭当前窗口： ctrl + w</li>
<li>关闭所有的窗口： ctrl + shift + w</li>
<li>查看指定的结构使用过的地方： ctrl + alt + g</li>
<li>查找与替换： ctrl + f</li>
<li>最大化当前的 View： ctrl + m</li>
<li>直接定位到当前行的首位： home</li>
<li>直接定位到当前行的末位： end</li>
</ul>
<p>提示显示的设置：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230718154551691.png" alt="image-20230718154551691" loading="lazy"></p>
<h2> IDEA</h2>
<ul>
<li>alt+insert		选择生成构造器，getter、setter方法......</li>
<li>ctrl+F12		快速找方法</li>
<li>alt+enter		快速声明对象名，提供解异常的方式</li>
<li>ctrl+alt+t		将选中的代码用...包围起来</li>
<li>ctrl+p		将光标放置在()中，显示需要的形参</li>
<li>ctrl+alt+shift+s	文件-项目结构</li>
<li>ctrl+shift+方向键	整体移动代码</li>
<li>alt+←/→		查看左右的文件</li>
<li>ctrl+h		选中类，查看类的继承树</li>
<li>ctrl+shift+z	取消撤销</li>
<li>ctrl+shift+t	(右键代码，GO to Test 选择方法单元测试)单元测试</li>
<li>shift+F6		重命名</li>
<li>ctrl+alt+l		快速整理代码</li>
<li>ctrl+shift+'-/+'	折叠或展开选中的代码</li>
<li>ctrl+shift+/	舒服的快速注释</li>
<li>ctrl+o		重写父类、接口的方法</li>
<li>sout</li>
<li>soutv</li>
</ul>
]]></content:encoded>
      <enclosure url="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230718154551691.png" type="image/png"/>
    </item>
    <item>
      <title>JDBC 基础</title>
      <link>https://T4mako.github.io/code/java/JDBC.html</link>
      <guid>https://T4mako.github.io/code/java/JDBC.html</guid>
      <source url="https://T4mako.github.io/rss.xml">JDBC 基础</source>
      <description>JDBC核心技术 第1章：JDBC概述 1.1 数据的持久化 持久化(persistence)：把数据保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企业级应用，数据持久化意味着将内存中的数据保存到硬盘上加以”固化”，而持久化的实现过程大多通过各种关系数据库来完成。</description>
      <category>java</category>
      <content:encoded><![CDATA[<h2> JDBC核心技术</h2>
<hr>
<h3> 第1章：JDBC概述</h3>
<h4> 1.1 数据的持久化</h4>
<ul>
<li>持久化(persistence)：<strong>把数据保存到可掉电式存储设备中以供之后使用</strong>。大多数情况下，特别是企业级应用，<strong>数据持久化意味着将内存中的数据保存到硬盘</strong>上加以”固化”<strong>，而持久化的实现过程大多通过各种关系数据库来完成</strong>。</li>
</ul>
<!-- more -->
<ul>
<li>
<p>持久化的主要应用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1566741430592.png" alt="1566741430592" loading="lazy"></p>
</li>
</ul>
<h4> 1.2 Java中的数据存储技术</h4>
<ul>
<li>
<p>在Java中，数据库存取技术可分为如下几类：</p>
<ul>
<li>
<p><strong>JDBC</strong>直接访问数据库</p>
</li>
<li>
<p>JDO (Java Data Object )技术</p>
</li>
<li>
<p><strong>第三方O/R工具</strong>，如Hibernate, Mybatis 等</p>
</li>
</ul>
</li>
<li>
<p>JDBC是 java 访问数据库的基石，JDO、Hibernate、MyBatis 等只是更好的封装了JDBC。</p>
</li>
</ul>
<h4> 1.3 JDBC介绍</h4>
<ul>
<li>JDBC(Java Database Connectivity)是一个<strong>独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口</strong>（一组API），定义了用来访问数据库的标准Java类库，（<strong>java.sql,javax.sql</strong>）使用这些类库可以以一种 <strong>标准</strong> 的方法、方便地访问数据库资源。</li>
<li>JDBC为访问不同的数据库提供了一种<strong>统一的途径</strong>，为开发者屏蔽了一些细节问题。</li>
<li>JDBC的目标是使Java程序员使用JDBC可以连接任何<strong>提供了JDBC驱动程序</strong>的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。</li>
<li><strong>简单理解为：JDBC是SUN公司提供的一套API，通过这套API实现具体的数据库操作(获取、关闭连接，CRUD)</strong></li>
<li>如果没有JDBC，那么Java程序访问数据库时是这样的：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1555575760234.png" alt="1555575760234" loading="lazy"></p>
<hr>
<ul>
<li>有了JDBC，Java程序访问数据库时是这样的：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1555575981203.png" alt="1555575981203" loading="lazy"></p>
<hr>
<ul>
<li>总结如下：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1566741692804.png" alt="1566741692804" loading="lazy"></p>
<h4> 1.4 JDBC体系结构</h4>
<ul>
<li>JDBC接口（API）包括两个层次：
<ul>
<li><strong>面向应用的API</strong>：Java API，抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果）。</li>
<li><strong>面向数据库的API</strong>：Java Driver API，供开发商开发数据库驱动程序用。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>JDBC是sun公司提供一套用于数据库操作的接口，java程序员只需要面向这套接口编程即可。</strong></p>
<p><strong>不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。																————面向接口编程</strong></p>
</blockquote>
<h4> 1.5 JDBC程序编写步骤</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1565969323908.png" alt="1565969323908" loading="lazy"></p>
<blockquote>
<p>补充：ODBC(Open Database Connectivity，开放式数据库连接)，是微软在Windows平台下推出的。使用者在程序中只需要调用ODBC API，由 ODBC 驱动程序将调用转换成为对特定的数据库的调用请求。</p>
</blockquote>
<h3> 第2章：获取数据库连接</h3>
<h4> 2.1 、① Driver接口实现类</h4>
<h5> 2.1.1 Driver接口介绍</h5>
<ul>
<li>
<p>java.sql.Driver 接口是所有 JDBC 驱动程序需要实现的。这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现。</p>
</li>
<li>
<p>在程序中不需要直接去访问实现了 Driver 接口的类，而是<em>由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver</em>实现。</p>
<ul>
<li>Oracle的驱动：<strong>oracle.jdbc.driver.OracleDriver</strong></li>
<li>mySql的驱动： <strong>com.mysql.jdbc.Driver</strong></li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1555576157618.png" alt="1555576157618" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1555576170074.png" alt="1555576170074" loading="lazy"></p>
<ul>
<li>将上述jar包拷贝到Java工程的一个目录中，习惯上新建一个lib文件夹。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1566134718955.png" alt="1566134718955" loading="lazy"></p>
<p>在驱动jar上右键--&gt;Build Path--&gt;Add to Build Path</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1566134781682.png" alt="1566134781682" loading="lazy"></p>
<p>注意：如果是Dynamic Web Project（动态的web项目）话，则是把驱动jar放到WebContent（有的开发工具叫WebRoot）目录中的WEB-INF目录中的lib目录下即可</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1566135290460.png" alt="1566135290460" loading="lazy"></p>
<h5> 2.1.2 加载与注册JDBC驱动</h5>
<ul>
<li>
<p>加载驱动：加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名</p>
<ul>
<li><strong>Class.forName(“com.mysql.jdbc.Driver”);</strong></li>
</ul>
</li>
<li>
<p>注册驱动：DriverManager 类是驱动程序管理器类，负责管理驱动程序</p>
<ul>
<li>
<p><strong>使用DriverManager.registerDriver(com.mysql.jdbc.Driver)来注册驱动</strong></p>
</li>
<li>
<p>通常不用显式调用 DriverManager 类的 registerDriver() 方法来注册驱动程序类的实例，因为 Driver 接口的驱动程序类 都包含了 <strong>静态代码块</strong>，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注册自身的一个实例。下图是MySQL的Driver实现类的源码：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1566136831283.png" alt="1566136831283" loading="lazy"></p>
</li>
</ul>
</li>
</ul>
<h4> 2.2 、② URL</h4>
<ul>
<li>
<p>JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。</p>
</li>
<li>
<p>JDBC URL的标准由三部分组成，各部分间用冒号分隔。</p>
<ul>
<li><strong>jdbc:子协议:子名称</strong></li>
<li><strong>协议</strong>：JDBC URL中的协议总是jdbc</li>
<li><strong>子协议</strong>：子协议用于标识一个数据库驱动程序</li>
<li><strong>子名称</strong>：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了<strong>定位数据库</strong>提供足够的信息。包含<strong>主机名</strong>(对应服务端的ip地址)<strong>，端口号，数据库名</strong></li>
</ul>
</li>
<li>
<p>举例：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1555576477107.png" alt="1555576477107" loading="lazy"></p>
</li>
<li>
<p><strong>几种常用数据库的 JDBC URL</strong></p>
<ul>
<li>
<p>MySQL的连接URL编写方式：</p>
<ul>
<li>jdbc:mysql://主机名称:mysql服务端口号/数据库名称?参数=值&amp;参数=值</li>
<li>jdbc:mysql://localhost:3306/atguigu</li>
<li>jdbc:mysql://localhost:3306/atguigu**?useUnicode=true&amp;characterEncoding=utf8**（如果JDBC程序与服务器端的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集）</li>
<li>jdbc:mysql://localhost:3306/atguigu?user=root&amp;password=123456</li>
</ul>
</li>
<li>
<p>Oracle 9i的连接URL编写方式：</p>
<ul>
<li>jdbc:oracle:thin:@主机名称:oracle服务端口号:数据库名称</li>
<li>jdbc:oracle:thin:@localhost:1521:atguigu</li>
</ul>
</li>
<li>
<p>SQLServer的连接URL编写方式：</p>
<ul>
<li>
<p>jdbc:sqlserver://主机名称:sqlserver服务端口号:DatabaseName=数据库名称</p>
</li>
<li>
<p>jdbc:sqlserver://localhost:1433:DatabaseName=atguigu</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4> 2.3、 ③ 用户名和密码</h4>
<ul>
<li>user,password可以用“属性名=属性值”方式告诉数据库</li>
<li>可以调用 DriverManager 类的 getConnection() 方法建立到数据库的连接</li>
</ul>
<h4> 2.4、 数据库连接方式举例</h4>
<h5> 2.4.1 连接方式一</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>说明：上述代码中显式出现了第三方数据库的API</p>
</blockquote>
<h5> 2.4.2 连接方式二</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>说明：相较于方式一，这里使用反射实例化Driver，不在代码中体现第三方数据库的API。体现了面向接口编程思想。</p>
</blockquote>
<h5> 2.4.3 连接方式三</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>说明：使用DriverManager实现数据库的连接。体会获取连接必要的4个基本要素。</p>
</blockquote>
<h5> 2.4.4 连接方式四</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>说明：不必显式的注册驱动了。因为在DriverManager的源码中已经存在静态代码块，实现了驱动的注册。</p>
</blockquote>
<h5> 2.4.5 连接方式五(最终版)</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中，配置文件声明在工程的src目录下：【jdbc.properties】</p>
<div class="language-properties line-numbers-mode" data-ext="properties"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>说明：使用配置文件的方式保存配置信息，在代码中加载配置文件</p>
<p><strong>使用配置文件的好处：</strong></p>
<p>①实现了代码和数据的分离，如果需要修改配置信息，直接在配置文件中修改，不需要深入代码<br>
②如果修改了配置信息，省去重新编译的过程。</p>
</blockquote>
<h3> 第3章：使用PreparedStatement实现CRUD操作</h3>
<h4> 3.1 操作和访问数据库</h4>
<ul>
<li>
<p>数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。其实一个数据库连接就是一个Socket连接。</p>
</li>
<li>
<p>在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式：</p>
<ul>
<li>Statement：用于执行 **静态 SQL **语句并返回.它所生成结果的对象。</li>
<li><strong>PrepatedStatement：SQL 语句被预编译并存储在此对象中，可以使用此对象多次高效地执行该语句。</strong></li>
<li>CallableStatement：用于执行 SQL 存储过程</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1566573842140.png" alt="1566573842140" loading="lazy"></p>
</li>
</ul>
<h4> 3.2 使用 Statement 操作数据表的弊端</h4>
<ul>
<li>
<p>通过调用 Connection 对象的 createStatement() 方法创建该对象。该对象用于执行静态的 SQL 语句，并且返回执行结果。</p>
</li>
<li>
<p>Statement 接口中定义了下列方法用于执行 SQL 语句：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>但是使用 Statement 操作数据表存在弊端：</p>
<ul>
<li><strong>问题一：存在拼串操作，繁琐</strong></li>
<li><strong>问题二：存在SQL注入问题</strong></li>
</ul>
</li>
<li>
<p>SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令(如：SELECT user, password FROM user_table WHERE user='a' OR 1 = ' AND password = ' OR '1' = '1') ，从而利用系统的 SQL 引擎完成恶意行为的做法。</p>
</li>
<li>
<p>对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement(从Statement扩展而来) 取代 Statement 就可以了。</p>
</li>
<li>
<p>代码演示：</p>
</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>综上：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1566569819744.png" alt="1566569819744" loading="lazy"></p>
<h4> 3.3 PreparedStatement的使用</h4>
<h5> 3.3.1 PreparedStatement介绍</h5>
<ul>
<li>
<p>可以通过调用 Connection 对象的 <strong>preparedStatement(String sql)</strong> 方法获取 PreparedStatement 对象</p>
</li>
<li>
<p><strong>PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句</strong></p>
</li>
<li>
<p>PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值</p>
</li>
</ul>
<h5> 3.3.2 PreparedStatement vs Statement</h5>
<ul>
<li>
<p>代码的可读性和可维护性。</p>
</li>
<li>
<p><strong>PreparedStatement 能最大可能提高性能：</strong></p>
<ul>
<li>DBServer会对<strong>预编译</strong>语句提供性能优化。因为预编译语句有可能被重复调用，所以<u>语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。</u></li>
<li>在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样<u>每执行一次都要对传入的语句编译一次。</u></li>
<li>(语法检查，语义检查，翻译成二进制命令，缓存)</li>
</ul>
</li>
<li>
<p>PreparedStatement 可以防止 SQL 注入</p>
</li>
</ul>
<h5> 3.3.3 Java与SQL对应数据类型转换表</h5>
<table>
<thead>
<tr>
<th>Java类型</th>
<th>SQL类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>BIT</td>
</tr>
<tr>
<td>byte</td>
<td>TINYINT</td>
</tr>
<tr>
<td>short</td>
<td>SMALLINT</td>
</tr>
<tr>
<td>int</td>
<td>INTEGER</td>
</tr>
<tr>
<td>long</td>
<td>BIGINT</td>
</tr>
<tr>
<td>String</td>
<td>CHAR,VARCHAR,LONGVARCHAR</td>
</tr>
<tr>
<td>byte   array</td>
<td>BINARY  ,    VAR BINARY</td>
</tr>
<tr>
<td>java.sql.Date</td>
<td>DATE</td>
</tr>
<tr>
<td>java.sql.Time</td>
<td>TIME</td>
</tr>
<tr>
<td>java.sql.Timestamp</td>
<td>TIMESTAMP</td>
</tr>
</tbody>
</table>
<h5> 3.3.4 使用PreparedStatement实现增、删、改操作</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 3.3.5 使用PreparedStatement实现查询操作</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>说明：使用PreparedStatement实现的查询操作可以替换Statement实现的查询操作，解决Statement拼串和SQL注入问题。</p>
</blockquote>
<h4> 3.4 ResultSet与ResultSetMetaData</h4>
<h5> 3.4.1 ResultSet</h5>
<ul>
<li>
<p>查询需要调用PreparedStatement 的 executeQuery() 方法，查询结果是一个ResultSet 对象</p>
</li>
<li>
<p>ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet 接口由数据库厂商提供实现</p>
</li>
<li>
<p>ResultSet 返回的实际上就是一张数据表。有一个指针指向数据表的第一条记录的前面。</p>
</li>
<li>
<p>ResultSet 对象维护了一个指向当前数据行的<strong>游标</strong>，初始的时候，游标在第一行之前，可以通过 ResultSet 对象的 next() 方法移动到下一行。调用 next()方法检测下一行是否有效。若有效，该方法返回 true，且指针下移。相当于Iterator对象的 hasNext() 和 next() 方法的结合体。</p>
</li>
<li>
<p>当指针指向一行时, 可以通过调用 getXxx(int index) 或 getXxx(int columnName) 获取每一列的值。</p>
<ul>
<li>例如: getInt(1), getString("name")</li>
<li><strong>注意：Java与数据库交互涉及到的相关Java API中的索引都从1开始。</strong></li>
</ul>
</li>
<li>
<p>ResultSet 接口的常用方法：</p>
<ul>
<li>
<p>boolean next()</p>
</li>
<li>
<p>getString()</p>
</li>
<li>
<p>…</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1555580152530.png" alt="1555580152530" loading="lazy"></p>
</li>
</ul>
<h5> 3.4.2 ResultSetMetaData</h5>
<ul>
<li>
<p>可用于获取关于 ResultSet 对象中列的类型和属性信息的对象</p>
</li>
<li>
<p>ResultSetMetaData meta = rs.getMetaData();</p>
<ul>
<li>
<p><strong>getColumnName</strong>(int column)：获取指定列的名称</p>
</li>
<li>
<p><strong>getColumnLabel</strong>(int column)：获取指定列的别名</p>
</li>
<li>
<p><strong>getColumnCount</strong>()：返回当前 ResultSet 对象中的列数。</p>
</li>
<li>
<p>getColumnTypeName(int column)：检索指定列的数据库特定的类型名称。</p>
</li>
<li>
<p>getColumnDisplaySize(int column)：指示指定列的最大标准宽度，以字符为单位。</p>
</li>
<li>
<p><strong>isNullable</strong>(int column)：指示指定列中的值是否可以为 null。</p>
</li>
<li>
<p>isAutoIncrement(int column)：指示是否自动为指定列进行编号，这样这些列仍然是只读的。</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1555579494691.png" alt="1555579494691" loading="lazy"></p>
<p><strong>问题1：得到结果集后, 如何知道该结果集中有哪些列 ？ 列名是什么？</strong></p>
<p>​     需要使用一个描述 ResultSet 的对象， 即 ResultSetMetaData</p>
<p><strong>问题2：关于ResultSetMetaData</strong></p>
<ol>
<li><strong>如何获取 ResultSetMetaData</strong>： 调用 ResultSet 的 getMetaData() 方法即可</li>
<li><strong>获取 ResultSet 中有多少列</strong>：调用 ResultSetMetaData 的 getColumnCount() 方法</li>
<li><strong>获取 ResultSet 每一列的列的别名是什么</strong>：调用 ResultSetMetaData 的getColumnLabel() 方法</li>
</ol>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1555579816884.png" alt="1555579816884" loading="lazy"></p>
<h4> 3.5 资源的释放</h4>
<ul>
<li>释放ResultSet, Statement,Connection。</li>
<li>数据库连接（Connection）是<em>非常稀有的资源</em>，用完后<em>必须马上释放</em>，如果Connection不能及时正确的关闭将导致系统宕机。Connection的使用原则是<strong>尽量晚创建，尽量早的释放。</strong></li>
<li>可以在finally中关闭，保证及时其他代码出现异常，资源也一定能被关闭。</li>
</ul>
<h4> 3.6 JDBC API小结</h4>
<ul>
<li>
<p>两种思想</p>
<ul>
<li>
<p>面向接口编程的思想</p>
</li>
<li>
<p>ORM思想(object relational mapping)</p>
<ul>
<li><strong>一个数据表对应一个java类</strong></li>
<li><strong>表中的一条记录对应java类的一个对象</strong></li>
<li><strong>表中的一个字段对应java类的一个属性</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p>sql是需要结合列名和表的属性名来写。注意起别名。</p>
</blockquote>
</li>
<li>
<p>两种技术</p>
<ul>
<li>JDBC结果集的元数据：ResultSetMetaData
<ul>
<li>获取列数：getColumnCount()</li>
<li>获取列的别名：getColumnLabel()</li>
</ul>
</li>
<li>通过反射，创建指定类的对象，获取指定的属性并赋值</li>
</ul>
</li>
</ul>
<hr>
<h3> 章节练习</h3>
<p><strong>练习题1：从控制台向数据库的表customers中插入一条数据，表结构如下：</strong></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1555580275036.png" alt="1555580275036" loading="lazy"></p>
<p><strong>练习题2：创立数据库表 examstudent，表结构如下：</strong></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1555580735377.png" alt="1555580735377" loading="lazy"></p>
<p>向数据表中添加如下数据：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1555580763636.png" alt="1555580763636" loading="lazy"></p>
<p><strong>代码实现1：插入一个新的student 信息</strong></p>
<p>请输入考生的详细信息</p>
<p>Type:<br>
IDCard:<br>
ExamCard:<br>
StudentName:<br>
Location:<br>
Grade:</p>
<p>信息录入成功!</p>
<p><strong>代码实现2：在 eclipse中建立 java 程序：输入身份证号或准考证号可以查询到学生的基本信息。结果如下：</strong></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1555580937490.png" alt="1555580937490" loading="lazy"></p>
<p><strong>代码实现3：完成学生信息的删除功能</strong></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1555580965019.png" alt="1555580965019" loading="lazy"></p>
<hr>
<h3> 第4章 操作BLOB类型字段</h3>
<h4> 4.1 MySQL BLOB类型</h4>
<ul>
<li>
<p>MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。</p>
</li>
<li>
<p>插入BLOB类型的数据必须使用PreparedStatement，因为BLOB类型的数据无法使用字符串拼接写的。</p>
</li>
<li>
<p>MySQL的四种BLOB类型(除了在存储的最大信息量上不同外，他们是等同的)</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1555581069798.png" alt="1555581069798" loading="lazy"></p>
<ul>
<li>实际使用中根据需要存入的数据大小定义不同的BLOB类型。</li>
<li>需要注意的是：如果存储的文件过大，数据库的性能会下降。</li>
<li>如果在指定了相关的Blob类型以后，还报错：xxx too large，那么在mysql的安装目录下，找my.ini文件加上如下的配置参数： <strong>max_allowed_packet=16M</strong>。同时注意：修改了my.ini文件之后，需要重新启动mysql服务。</li>
</ul>
<h4> 4.2 向数据表中插入大数据类型</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4.3 修改数据表中的Blob类型字段</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4.4 从数据表中读取大数据类型</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 第5章 批量插入</h3>
<h4> 5.1 批量执行SQL语句</h4>
<p>当需要成批插入或者更新记录时，可以采用Java的批量<strong>更新</strong>机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率</p>
<p>JDBC的批量处理语句包括下面三个方法：</p>
<ul>
<li><strong>addBatch(String)：添加需要批量处理的SQL语句或是参数；</strong></li>
<li><strong>executeBatch()：执行批量处理语句；</strong></li>
<li><strong>clearBatch():清空缓存的数据</strong></li>
</ul>
<p>通常我们会遇到两种批量执行SQL语句的情况：</p>
<ul>
<li>多条SQL语句的批量处理；</li>
<li>一个SQL语句的批量传参；</li>
</ul>
<h4> 5.2 高效的批量插入</h4>
<p>举例：向数据表中插入20000条数据</p>
<ul>
<li>数据库中提供一个goods表。创建如下：</li>
</ul>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 5.2.1 实现层次一：使用Statement</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 5.2.2 实现层次二：使用PreparedStatement</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 5.2.3 实现层次三</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 5.2.4 实现层次四</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 第6章： 数据库事务</h3>
<h4> 6.1 数据库事务介绍</h4>
<ul>
<li>
<p><strong>事务：一组逻辑操作单元,使数据从一种状态变换到另一种状态。</strong></p>
</li>
<li>
<p><strong>事务处理（事务操作）：<strong>保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都</strong>被提交(commit)</strong>，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务**回滚(rollback)**到最初状态。</p>
</li>
<li>
<p>为确保数据库中数据的<strong>一致性</strong>，数据的操纵应当是离散的成组的逻辑单元：当它全部完成时，数据的一致性可以保持，而当这个单元中的一部分操作失败，整个事务应全部视为错误，所有从起始点以后的操作应全部回退到开始状态。</p>
</li>
</ul>
<h4> 6.2 JDBC事务处理</h4>
<ul>
<li>
<p>数据一旦提交，就不可回滚。</p>
</li>
<li>
<p>数据什么时候意味着提交？</p>
<ul>
<li><strong>当一个连接对象被创建时，默认情况下是自动提交事务</strong>：每次执行一个 SQL 语句时，如果执行成功，就会向数据库自动提交，而不能回滚。</li>
<li>**关闭数据库连接，数据就会自动的提交。**如果多个操作，每个操作使用的是自己单独的连接，则无法保证事务。即同一个事务的多个操作必须在同一个连接下。</li>
</ul>
</li>
<li>
<p><strong>JDBC程序中为了让多个 SQL 语句作为一个事务执行：</strong></p>
<ul>
<li>调用 Connection 对象的 <strong>setAutoCommit(false);</strong> 以取消自动提交事务</li>
<li>在所有的 SQL 语句都成功执行后，调用 <strong>commit();</strong> 方法提交事务</li>
<li>在出现异常时，调用 <strong>rollback();</strong> 方法回滚事务</li>
</ul>
<blockquote>
<p>若此时 Connection 没有被关闭，还可能被重复使用，则需要恢复其自动提交状态 setAutoCommit(true)。尤其是在使用数据库连接池技术时，执行close()方法前，建议恢复自动提交状态。</p>
</blockquote>
</li>
</ul>
<p>【案例：用户AA向用户BB转账100】</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中，对数据库操作的方法为：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 6.3 事务的ACID属性</h4>
<ol>
<li>
<p><strong>原子性（Atomicity）</strong><br>
原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</p>
</li>
<li>
<p><strong>一致性（Consistency）</strong><br>
事务必须使数据库从一个一致性状态变换到另外一个一致性状态。</p>
</li>
<li>
<p><strong>隔离性（Isolation）</strong><br>
事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
</li>
<li>
<p><strong>持久性（Durability）</strong><br>
持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。</p>
</li>
</ol>
<h5> 6.3.1 数据库的并发问题</h5>
<ul>
<li>
<p>对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:</p>
<ul>
<li><strong>脏读</strong>: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还<strong>没有被提交</strong>的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。</li>
<li><strong>不可重复读</strong>: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 <strong>更新</strong>了该字段。之后, T1再次读取同一个字段, 值就不同了。</li>
<li><strong>幻读</strong>: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中<strong>插入</strong>了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。</li>
</ul>
</li>
<li>
<p><strong>数据库事务的隔离性</strong>: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。</p>
</li>
<li>
<p>一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, <strong>隔离级别越高, 数据一致性就越好, 但并发性越弱。</strong></p>
</li>
</ul>
<h5> 6.3.2 四种隔离级别</h5>
<ul>
<li>
<p>数据库提供的4种事务隔离级别：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1555586275271.png" alt="1555586275271" loading="lazy"></p>
</li>
<li>
<p>Oracle 支持的 2 种事务隔离级别：<strong>READ COMMITED</strong>, SERIALIZABLE。 Oracle 默认的事务隔离级别为: <strong>READ COMMITED</strong> 。</p>
</li>
<li>
<p>Mysql 支持 4 种事务隔离级别。Mysql 默认的事务隔离级别为: <strong>REPEATABLE READ。</strong></p>
</li>
</ul>
<h5> 6.3.3 在MySql中设置隔离级别</h5>
<ul>
<li>
<p>每启动一个 mysql 程序, 就会获得一个单独的数据库连接. 每个数据库连接都有一个全局变量 @@tx_isolation, 表示当前的事务隔离级别。</p>
</li>
<li>
<p>查看当前的隔离级别:</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>设置当前 mySQL 连接的隔离级别:</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>设置数据库系统的全局的隔离级别:</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>补充操作：</p>
<ul>
<li>
<p>创建mysql数据库用户：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>授予权限</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
</li>
</ul>
<h3> 第7章：DAO及相关实现类</h3>
<ul>
<li><strong>DAO：Data Access Object访问数据信息的类和接口</strong>，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息。有时也称作：BaseDAO</li>
<li>作用：为了实现功能的模块化，更有利于代码的维护和升级。</li>
<li>下面是尚硅谷JavaWeb阶段书城项目中DAO使用的体现：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1566726681515.png" alt="1566726681515" loading="lazy"></p>
<ul>
<li>层次结构：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1566745811244.png" alt="1566745811244" loading="lazy"></p>
<h4> 【BaseDAO.java】</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 【BookDAO.java】</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 【UserDAO.java】</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 【BookDaoImpl.java】</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 【UserDaoImpl.java】</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 【Book.java】</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 【Page.java】</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 【User.java】</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 第8章：数据库连接池</h3>
<h4> 8.1 JDBC数据库连接池的必要性</h4>
<ul>
<li>
<p>在使用开发基于数据库的web程序时，传统的模式基本是按以下步骤：</p>
<ul>
<li><strong>在主程序（如servlet、beans）中建立数据库连接</strong></li>
<li><strong>进行sql操作</strong></li>
<li><strong>断开数据库连接</strong></li>
</ul>
</li>
<li>
<p>这种模式开发，存在的问题:</p>
<ul>
<li>普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。**数据库的连接资源并没有得到很好的重复利用。**若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。</li>
<li>**对于每一次数据库连接，使用完后都得断开。**否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将导致重启数据库。（回忆：何为Java的内存泄漏？）</li>
<li><strong>这种开发不能控制被创建的连接对象数</strong>，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。</li>
</ul>
</li>
</ul>
<h4> 8.2 数据库连接池技术</h4>
<ul>
<li>
<p>为解决传统开发中的数据库连接问题，可以采用数据库连接池技术。</p>
</li>
<li>
<p><strong>数据库连接池的基本思想</strong>：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。</p>
</li>
<li>
<p><strong>数据库连接池</strong>负责分配、管理和释放数据库连接，它<strong>允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个</strong>。</p>
</li>
<li>
<p>数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由<strong>最小数据库连接数来设定</strong>的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的<strong>最大数据库连接数量</strong>限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1555593464033.png" alt="1555593464033" loading="lazy"></p>
<ul>
<li><strong>工作原理：</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1555593598606.png" alt="1555593598606" loading="lazy"></p>
<ul>
<li>
<p><strong>数据库连接池技术的优点</strong></p>
<p><strong>1. 资源重用</strong></p>
<p>由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。</p>
<p><strong>2. 更快的系统反应速度</strong></p>
<p>数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间</p>
<p><strong>3. 新的资源分配手段</strong></p>
<p>对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源</p>
<p><strong>4. 统一的连接管理，避免数据库连接泄漏</strong></p>
<p>在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露</p>
</li>
</ul>
<h4> 8.3 多种开源的数据库连接池</h4>
<ul>
<li>JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现：
<ul>
<li><strong>DBCP</strong> 是Apache提供的数据库连接池。tomcat 服务器自带dbcp数据库连接池。<strong>速度相对c3p0较快</strong>，但因自身存在BUG，Hibernate3已不再提供支持。</li>
<li><strong>C3P0</strong> 是一个开源组织提供的一个数据库连接池，**速度相对较慢，稳定性还可以。**hibernate官方推荐使用</li>
<li><strong>Proxool</strong> 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，<strong>稳定性较c3p0差一点</strong></li>
<li><strong>BoneCP</strong> 是一个开源组织提供的数据库连接池，速度快</li>
<li><strong>Druid</strong> 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，但是速度不确定是否有BoneCP快</li>
</ul>
</li>
<li>DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池</li>
<li><strong>DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库访问速度。</strong></li>
<li>特别注意：
<ul>
<li>数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此<strong>整个应用只需要一个数据源即可。</strong></li>
<li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。</li>
</ul>
</li>
</ul>
<h5> 8.3.1 C3P0数据库连接池</h5>
<ul>
<li>获取连接方式一</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>获取连接方式二</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中，src下的配置文件为：【c3p0-config.xml】</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 8.3.2 DBCP数据库连接池</h5>
<ul>
<li>DBCP 是 Apache 软件基金组织下的开源连接池实现，该连接池依赖该组织下的另一个开源系统：Common-pool。如需使用该连接池实现，应在系统中增加如下两个 jar 文件：
<ul>
<li>Commons-dbcp.jar：连接池的实现</li>
<li>Commons-pool.jar：连接池实现的依赖库</li>
</ul>
</li>
<li>**Tomcat 的连接池正是采用该连接池来实现的。**该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用。</li>
<li>数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。</li>
<li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但上面的代码并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。</li>
<li>配置属性说明</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>initialSize</td>
<td>0</td>
<td>连接池启动时创建的初始化连接数量</td>
</tr>
<tr>
<td>maxActive</td>
<td>8</td>
<td>连接池中可同时连接的最大的连接数</td>
</tr>
<tr>
<td>maxIdle</td>
<td>8</td>
<td>连接池中最大的空闲的连接数，超过的空闲连接将被释放，如果设置为负数表示不限制</td>
</tr>
<tr>
<td>minIdle</td>
<td>0</td>
<td>连接池中最小的空闲的连接数，低于这个数量会被创建新的连接。该参数越接近maxIdle，性能越好，因为连接的创建和销毁，都是需要消耗资源的；但是不能太大。</td>
</tr>
<tr>
<td>maxWait</td>
<td>无限制</td>
<td>最大等待时间，当没有可用连接时，连接池等待连接释放的最大时间，超过该时间限制会抛出异常，如果设置-1表示无限等待</td>
</tr>
<tr>
<td>poolPreparedStatements</td>
<td>false</td>
<td>开启池的Statement是否prepared</td>
</tr>
<tr>
<td>maxOpenPreparedStatements</td>
<td>无限制</td>
<td>开启池的prepared 后的同时最大连接数</td>
</tr>
<tr>
<td>minEvictableIdleTimeMillis</td>
<td></td>
<td>连接池中连接，在时间段内一直空闲， 被逐出连接池的时间</td>
</tr>
<tr>
<td>removeAbandonedTimeout</td>
<td>300</td>
<td>超过时间限制，回收没有用(废弃)的连接</td>
</tr>
<tr>
<td>removeAbandoned</td>
<td>false</td>
<td>超过removeAbandonedTimeout时间后，是否进 行没用连接（废弃）的回收</td>
</tr>
</tbody>
</table>
<ul>
<li>获取连接方式一：</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>获取连接方式二：</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中，src下的配置文件为：【dbcp.properties】</p>
<div class="language-properties line-numbers-mode" data-ext="properties"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 8.3.3 Druid（德鲁伊）数据库连接池</h5>
<p>Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，<strong>可以说是目前最好的连接池之一。</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中，src下的配置文件为：【druid.properties】</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>详细配置参数：</li>
</ul>
<table>
<thead>
<tr>
<th><strong>配置</strong></th>
<th><strong>缺省</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td></td>
<td>配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。   如果没有配置，将会生成一个名字，格式是：”DataSource-” +   System.identityHashCode(this)</td>
</tr>
<tr>
<td>url</td>
<td></td>
<td>连接数据库的url，不同数据库不一样。例如：mysql :   jdbc:mysql://10.20.153.104:3306/druid2      oracle :   jdbc:oracle:thin:@10.20.149.85:1521:ocnauto</td>
</tr>
<tr>
<td>username</td>
<td></td>
<td>连接数据库的用户名</td>
</tr>
<tr>
<td>password</td>
<td></td>
<td>连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：<a href="https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter" target="_blank" rel="noopener noreferrer">https://github.com/alibaba/druid/wiki/使用ConfigFilter</a></td>
</tr>
<tr>
<td>driverClassName</td>
<td></td>
<td>根据url自动识别   这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下)</td>
</tr>
<tr>
<td>initialSize</td>
<td>0</td>
<td>初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时</td>
</tr>
<tr>
<td>maxActive</td>
<td>8</td>
<td>最大连接池数量</td>
</tr>
<tr>
<td>maxIdle</td>
<td>8</td>
<td>已经不再使用，配置了也没效果</td>
</tr>
<tr>
<td>minIdle</td>
<td></td>
<td>最小连接池数量</td>
</tr>
<tr>
<td>maxWait</td>
<td></td>
<td>获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。</td>
</tr>
<tr>
<td>poolPreparedStatements</td>
<td>false</td>
<td>是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。</td>
</tr>
<tr>
<td>maxOpenPreparedStatements</td>
<td>-1</td>
<td>要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100</td>
</tr>
<tr>
<td>validationQuery</td>
<td></td>
<td>用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。</td>
</tr>
<tr>
<td>testOnBorrow</td>
<td>true</td>
<td>申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。</td>
</tr>
<tr>
<td>testOnReturn</td>
<td>false</td>
<td>归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能</td>
</tr>
<tr>
<td>testWhileIdle</td>
<td>false</td>
<td>建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。</td>
</tr>
<tr>
<td>timeBetweenEvictionRunsMillis</td>
<td></td>
<td>有两个含义： 1)Destroy线程会检测连接的间隔时间2)testWhileIdle的判断依据，详细看testWhileIdle属性的说明</td>
</tr>
<tr>
<td>numTestsPerEvictionRun</td>
<td></td>
<td>不再使用，一个DruidDataSource只支持一个EvictionRun</td>
</tr>
<tr>
<td>minEvictableIdleTimeMillis</td>
<td></td>
<td></td>
</tr>
<tr>
<td>connectionInitSqls</td>
<td></td>
<td>物理连接初始化的时候执行的sql</td>
</tr>
<tr>
<td>exceptionSorter</td>
<td></td>
<td>根据dbType自动识别   当数据库抛出一些不可恢复的异常时，抛弃连接</td>
</tr>
<tr>
<td>filters</td>
<td></td>
<td>属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：   监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall</td>
</tr>
<tr>
<td>proxyFilters</td>
<td></td>
<td>类型是List，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系</td>
</tr>
</tbody>
</table>
<h3> 第9章：Apache-DBUtils实现CRUD操作</h3>
<h4> 9.1 Apache-DBUtils简介</h4>
<ul>
<li>
<p>commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。</p>
</li>
<li>
<p>API介绍：</p>
<ul>
<li>org.apache.commons.dbutils.QueryRunner</li>
<li>org.apache.commons.dbutils.ResultSetHandler</li>
<li>工具类：org.apache.commons.dbutils.DbUtils</li>
</ul>
</li>
<li>
<p>API包说明：</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1555595163263.png" alt="1555595163263" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1555595198644.png" alt="1555595198644" loading="lazy"></p>
<h4> 9.2 主要API的使用</h4>
<h5> 9.2.1 DbUtils</h5>
<ul>
<li>DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下：
<ul>
<li><strong>public static void close(…) throws java.sql.SQLException</strong>：　DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。</li>
<li>public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。</li>
<li>public static void commitAndClose(Connection conn)throws SQLException： 用来提交连接的事务，然后关闭连接</li>
<li>public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在关闭连接时不抛出SQL异常。</li>
<li>public static void rollback(Connection conn)throws SQLException：允许conn为null，因为方法内部做了判断</li>
<li>public static void rollbackAndClose(Connection conn)throws SQLException</li>
<li>rollbackAndCloseQuietly(Connection)</li>
<li>public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。</li>
</ul>
</li>
</ul>
<h5> 9.2.2 QueryRunner类</h5>
<ul>
<li>
<p><strong>该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。</strong></p>
</li>
<li>
<p>QueryRunner类提供了两个构造器：</p>
<ul>
<li>默认的构造器</li>
<li>需要一个 javax.sql.DataSource 来作参数的构造器</li>
</ul>
</li>
<li>
<p>QueryRunner类的主要方法：</p>
<ul>
<li><strong>更新</strong>
<ul>
<li>public int update(Connection conn, String sql, Object... params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。</li>
<li>......</li>
</ul>
</li>
<li><strong>插入</strong>
<ul>
<li><code>public &lt;T&gt; T insert(Connection conn,String sql,ResultSetHandler&lt;T&gt; rsh, Object... params) throws SQLException</code>：只支持INSERT语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys.  返回值: An object generated by the handler.即自动生成的键值</li>
<li>....</li>
</ul>
</li>
<li><strong>批处理</strong>
<ul>
<li><code>public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException</code>： INSERT, UPDATE, or DELETE语句</li>
<li><code>public &lt;T&gt; T insertBatch(Connection conn,String sql,ResultSetHandler&lt;T&gt;</code> rsh,Object[][] params)throws SQLException：只支持INSERT语句</li>
<li>.....</li>
</ul>
</li>
<li><strong>查询</strong>
<ul>
<li><code>public Object query(Connection conn, String sql, ResultSetHandler rsh,Object... params) throws SQLException</code>：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。</li>
<li>......</li>
</ul>
</li>
</ul>
</li>
<li>
<p>测试</p>
</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 9.2.3 ResultSetHandler接口及实现类</h5>
<ul>
<li>
<p>该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。</p>
</li>
<li>
<p>ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs)。</p>
</li>
<li>
<p>接口的主要实现类：</p>
<ul>
<li>ArrayHandler：把结果集中的第一行数据转成对象数组。</li>
<li>ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。</li>
<li>**BeanHandler：**将结果集中的第一行数据封装到一个对应的JavaBean实例中。</li>
<li>**BeanListHandler：**将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。</li>
<li>ColumnListHandler：将结果集中某一列的数据存放到List中。</li>
<li>KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。</li>
<li>**MapHandler：**将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。</li>
<li>**MapListHandler：**将结果集中的每一行数据都封装到一个Map里，然后再存放到List</li>
<li>**ScalarHandler：**查询单个值对象</li>
</ul>
</li>
<li>
<p>测试</p>
</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> JDBC总结</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://raw.githubusercontent.com/T4mako/ImageBed/main/1566741430592.png" type="image/png"/>
    </item>
    <item>
      <title>JVM</title>
      <link>https://T4mako.github.io/code/java/JVM.html</link>
      <guid>https://T4mako.github.io/code/java/JVM.html</guid>
      <source url="https://T4mako.github.io/rss.xml">JVM</source>
      <description>初识虚拟机 JVM 全称 Java Virtual Machine，即 Java 虚拟机 Java 虚拟机的职责是运行字节码文件 JVM 三大核心功能： JVM 包内存管理 自动为对象，方法等分配内存 自动垃圾回收机制，回收不再使用的对象 解释执行虚拟机指令 对字节码文件中的指令实时解释成机器码，让计算机执行 及时编译 对热点代码进行优化，提升执行效率</description>
      <category>java</category>
      <content:encoded><![CDATA[<h2> 初识虚拟机</h2>
<p>JVM 全称 Java Virtual Machine，即 Java 虚拟机<br>
Java 虚拟机的职责是运行字节码文件</p>
<p>JVM 三大核心功能：</p>
<ul>
<li>JVM 包内存管理
<ul>
<li>自动为对象，方法等分配内存</li>
<li>自动垃圾回收机制，回收不再使用的对象</li>
</ul>
</li>
<li>解释执行虚拟机指令
<ul>
<li>对字节码文件中的指令实时解释成机器码，让计算机执行</li>
</ul>
</li>
<li>及时编译
<ul>
<li>对热点代码进行优化，提升执行效率</li>
</ul>
</li>
</ul>
<p>常见的 Java 虚拟机：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20231114225258529.png" alt="image-20231114225258529" loading="lazy"></p>
<p>JVM 的组成：</p>
<ul>
<li>类加载器 ClassLoader</li>
<li>运行时数据区（JVM 管理的内存）</li>
<li>执行引擎（即使编译器、解释器、垃圾回收器）</li>
<li>本地接口（通常为 native 修饰）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20231116222801070.png" alt="image-20231116222801070" loading="lazy"></p>
<h2> 字节码文件的组成</h2>
<ul>
<li>基本信息：
<ul>
<li>魔数、字节码文件对应的 Java 版本号</li>
<li>访问标识（public final 等）</li>
<li>父类和接口</li>
</ul>
</li>
<li>常量池
<ul>
<li>保存字符串常量、类或接口名、字段名</li>
</ul>
</li>
<li>字段
<ul>
<li>当前类或接口声明的字段信息</li>
</ul>
</li>
<li>方法
<ul>
<li>当前类或接口声明的方法信息</li>
</ul>
</li>
<li>属性
<ul>
<li>类的属性、比如源码文件名、内部类的列表等</li>
</ul>
</li>
</ul>
<h2> 类的生命周期</h2>
<p>类的生命周期：<br>
加载、连接、初始化、使用、卸载</p>
<h3> 加载阶段</h3>
<ol>
<li>类加载器根据类的全限定名通过不同的渠道以二进制流的方式获取字节码信息</li>
<li>类加载器在加载完之后，Java 虚拟机会将字节码中的信息保存到方法区中</li>
<li>类加载器在加载完类之后，Java 虚拟机会将字节码中的信息保存到内存的方法区中<br>
生成一个 InstanceKlass 对象，保存类的所有信息，里面包含实现特定功能比如多态的信息</li>
<li>同时，Java 虚拟机还在堆中生成一份与方法区中数据类似的 Java.lang.Class 对象<br>
作用在 Java 代码中去获取类的信息以及存储静态字段的数据（JDK 8 以后）</li>
</ol>
<h3> 连接阶段</h3>
<ol>
<li>验证：验证验证内容是否满足《Java 虚拟机规范》</li>
<li>准备：给静态变量赋初值</li>
<li>解析：将常量池中的符号引用替换成指向内存的直接引用</li>
</ol>
<h3> 初始化阶段</h3>
<ul>
<li>初始化阶段会执行静态代码块中的代码，并为静态变量赋值</li>
<li>初始化阶段会执行字节码文件中的 clinit 部分的字节码指令</li>
</ul>
<h2> 类加载器</h2>
<p>类加载器是什么：<br>
类加载器（ClassLoader）是 Java 虚拟机提供给应用程序去实现获取类和接口字节码数据的技术<br>
类加载器只参与加载过程中的字节码获取并加载内存这一部分</p>
<p>类加载器的作用：<br>
类加载器（ClassLoader）负责在类加载过程中的字节码获取并加载到内存这一部分。通过加载字节码数据放入内存转换为 byte[]，接下来调用虚拟机底层将 byte[] 转换成方法区和堆中的数据</p>
<p>类加载器分为两类：一类是 Java 代码中实现，一类是 Java 虚拟机底层源码实现</p>
<ul>
<li>虚拟机底层源码实现：
<ul>
<li>源代码位于 Java 虚拟机源码中，实现语言与底层语言一致（如 C++）</li>
<li>用于加载程序运行时的基础类，如 java.lang.String</li>
</ul>
</li>
<li>Java 代码中实现：
<ul>
<li>JDK 中默认提供或自定义</li>
<li>所有 Java 中实现的类加载器都要继承 ClassLoader 这个抽象类</li>
</ul>
</li>
</ul>
<h3> JDK8 及以前的类加载器</h3>
<p>虚拟机底层实现（C++）：</p>
<ul>
<li>启动类加载器 BootStrap：加载 Java 中最核心的类<br>
Java 实现：</li>
<li>扩展类加载器 Extension：允许扩展 Java 中比较通用的类</li>
<li>应用程序类加载器 Application：加载应用使用的类</li>
</ul>
<h4> 启动类加载器 BootStrap</h4>
<p>什么是启动类加载器：启动类加载器（Bootstrap ClassLoader）时有 Hotspot 虚拟机提供的、使用 C++ 编写的类加载器<br>
启动类加载器的作用：默认加载 Java 「安装目录/jre/lib」 下的文件，比如 rt.jar（包含 java.lang 中的常用类），tools.jar，resource.jar 等</p>
<p>通过启动类加载器加载用户 jar 包：</p>
<ul>
<li>使用参数进行扩展：<br>
使用 <code>-Xbootclasspath/xxx:jar包目录/jar包名</code> 进行扩展</li>
</ul>
<h4> Java 实现</h4>
<ul>
<li>
<p>扩展类加载器 Extension<br>
什么是扩展类加载器、应用程序类加载器：扩展类加载器和应用程序类加载器都是 JDK 中提供的、使用 Java 编写的类加载器<br>
它们的源码位于 sun.misc.Launcher 中，是一个静态内部类，继承自 URLClassLoader<br>
继承 URLClassLoader 的作用：具备通过目录或指定 jar 包将字节码文件加载到内存中</p>
</li>
<li>
<p>扩展类加载器 Extension<br>
加载 Java 安装目录 /jre/lib/ext 下的文件<br>
通过扩展类加载器加载用户 jar 包：使用 <code>-Djava.ext.dirs=jar包目录</code> 扩展，这种方式会覆盖掉原始目录，可使用 <code>;</code> (windows) <code>:</code> (macos/linux) 追加原始目录</p>
</li>
<li>
<p>应用程序类加载器<br>
加载 classpath 下的类文件</p>
</li>
</ul>
<h3> 双亲委派机制</h3>
<p>由于 Java 虚拟机有多个类加载器，双亲委派机制的核心就是解决一个类到底由谁加载的问题</p>
<p>双亲委派机制的作用：</p>
<ul>
<li>保证类加载的安全性（避免恶意代码薙魂 JDK 中的核心类库）</li>
<li>避免重复加载（避免一个类被加载多次）</li>
</ul>
<p>类加载器的双亲委派机制：当一个类加载器接受到加载类的任务时，会自底向上查找是否加载过，再由顶向下进行加载</p>
<h3> 自定义类加载器</h3>
<p>自定义类加载器的父加载器是应用程序类加载器 Application</p>
<h3> JDK9 及以后的类加载器</h3>
<p>JDK 引入了 module 的概念，类加载器在设计上发生了好多变化</p>
<ol>
<li>启动类加载器使用 Java 编写，位于 jdk.internal.loader.ClassLoaders 类中<br>
Java 中的 BootClassLoader 继承自 BuiltinClassLoader 实现从模块中找到要加载的字节码资源文件<br>
启动类加载器依然无法获得通过 java 代码获取到，返回的仍然是 null，保持了统一</li>
<li>扩展类加载器被替换成了平台类加载器（Platform Class Loader）<br>
平台类加载器遵循模块化方法加载字节码文件，所以继承关系从 URLClassLoader 变成了 BuiltinClassLoader，BuiltinClassLoader 实现了从模块中加载字节码文件。平台类加载器的存在更过的是为了与老版本的设计方案兼容，自身没有特殊的逻辑</li>
</ol>
<h2> 运行时数据区（Jvm 管理的内存）</h2>
<p>Java 虚拟机在运行 java 程序过程中管理的内存其余，称为运行时数据区</p>
<p>分类：</p>
<ul>
<li>程序计数器（线程不共享）</li>
<li>Java 虚拟机栈（线程不共享）</li>
<li>本地方法栈（线程不共享）</li>
<li>方法区（线程共享）</li>
<li>堆（线程共享）</li>
</ul>
<h3> 程序计数器</h3>
<p>程序计数器（Program Counter Register）也叫 PC 寄存器，每个线程会通过程序计数器记录当前要执行的字节码指令的地址</p>
<h3> Java 虚拟机栈</h3>
<p>Java 虚拟机栈采用栈的数据结构管理「方法调用」中的基本数据（方法以先进后出的形式）每一个方法的调用使用一个「栈帧」（Stack Frame）来保存</p>
<p>栈帧的组成：局部变量表、操作数栈、帧数据</p>
<ul>
<li>局部变量表：局部变量表的作用是方法执行过程中存放所有的局部变量</li>
<li>操作数栈：操作数栈是栈帧中虚拟机在执行指令过程中用来存放临时数据的一块区域</li>
<li>帧数据：帧数据主要包含动态链接、方法出口、异常表的引用</li>
</ul>
<p>栈内存溢出：<br>
Java 虚拟机栈如果栈帧过多，占用内存超过栈内存分配的最大的大小就会出现内存溢出<br>
Java 虚拟机栈内存溢出时会出现 StackOverflowError 错误</p>
<p>修改 Java 虚拟机栈的大小，可以使用虚拟机参数 -Xss</p>
<ul>
<li><code>-Xss 栈大小</code></li>
<li>单位：字节（默认，必须是 1024 的倍数）、k/K、m/M、g/G</li>
</ul>
<h3> 本地方法栈</h3>
<ul>
<li>Java 虚拟机栈存储 Java 方法调用时的栈帧、本地方法栈存储 native 本地方法的栈帧</li>
<li>在 Hotsot 虚拟机中，Java 虚拟机栈和本地方法栈实现上使用同一个栈空间</li>
</ul>
<h3> 堆</h3>
<ul>
<li>Java 程序中堆内存是空间最大的一块内存区域，创建出来的对象都在堆上</li>
<li>栈中的局部变量表可以存放堆上对象的引用，静态变量也可以存放堆对象的引用，通过静态变量可以实现对象在线程之间的共享</li>
</ul>
<p>堆内存大小有上限，达到上限抛出 OutOfMermory 错误</p>
<p>堆空间的三个值：</p>
<ul>
<li>used：当前已使用的堆内存</li>
<li>total：java 虚拟机已分配的可用堆内存</li>
<li>max：java 虚拟机可分配的最大堆内存</li>
</ul>
<p>要修改堆的大小，可以使用虚拟机参数 -Xmx（max 最大值）和 -Xms（初始的 total）<br>
单位：字节（默认，必须是 1024 的倍数）、k/K、m/M、g/G<br>
限制：Xmx 必须大于 2 MB，Xms 必须大于 1 MB<br>
开发时，建议将 -Xmx 和 -Xms 设置为相同的值</p>
<h3> 方法区</h3>
<p>方法区是存放基础信息的位置，线程共享，主要包括：</p>
<ul>
<li>类的元信息</li>
<li>运行时常量池</li>
<li>字符串常量池</li>
</ul>
<p>详细描述：</p>
<ul>
<li>元信息：存储每个类的 「基本信息（元信息）」，一般称之为 InstanceKclass 对象，在类的「加载阶段」完成</li>
<li>运行时常量池：<br>
常量池中存放的是字节码中的常量池的内容<br>
字节码文件中通过编号表的方式找到常量，这种常量池称为「静态常量池」。当常量池加载到内存中后，可用过内存地址快速定位到常量池中的内容，这种常量池称为运行时常量池</li>
</ul>
<p>方法区是《Java 虚拟机规范》中设计的虚拟概念，每款 Java 虚拟机在实现上都各不相同。Hotspot 设计如下：</p>
<ul>
<li>JDK 7及之前的版本：将方法区在「堆区域中的永久代空间」，堆的大小由虚拟机参数来控制</li>
<li>JDK 8 及之后的版本：将方法区存放在「元空间」中，元空间位于 OS 的直接内存中，默认不超过 OS 承受上限，可以一直分配</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20231118224434253.png" alt="image-20231118224434253" loading="lazy"></p>
<p>JDK 7 堆大小虚拟机参数： -XX:MaxPermSize=值<br>
JDK 8 限制大小参数：-XX:MaxMetaspaceSize=值</p>
<p>字符串常量池：</p>
<p>字符串常量池用于存放字符串</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20231118230548338.png" alt="image-20231118230548338" loading="lazy"></p>
<p>JDK7 及之后的版本中，静态变量存放在堆中的 Class 对象中，脱离了永久代</p>
<h3> 直接内存</h3>
<p>如果需要手动调整直接内存大小，可以使用 <code>-XX:MaxDirectMemorySize=大小</code><br>
单位：k/K、m/M、g/G<br>
默认不设置该参数的情况下，JVM 自动选择最大分配的大小</p>
<h3> 不同 JDK 版本之间的运行时数据区：</h3>
<p>JDK 6：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20231118232011117.png" alt="image-20231118232011117" loading="lazy"></p>
<p>JDK 7：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20231118232113434.png" alt="image-20231118232113434" loading="lazy"></p>
<p>JDK 8：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20231118232125654.png" alt="image-20231118232125654" loading="lazy"></p>
<h2> 自动垃圾回收</h2>
<p>Java 引入了自动的垃圾回收（Garbage Collection / GC）机制，垃圾回收器主要负责对「堆」上的内存（不再使用的对象）进行回收</p>
<p>对于线程不共享的部分（程序计数器、java 虚拟机栈、本地方法栈）都伴随着线程的创建而创建、线程的销毁而销毁。即方法的栈帧在执行完方法后就会自动弹出栈并释放掉对应内存</p>
<h3> 方法区的回收</h3>
<p>方法区中能回收的主要内容是「不再使用的类」</p>
<p>判定一个类是否可被卸载，需同时满足下面三个条件：</p>
<ul>
<li>此类的所有实例对象都已经被回收，在堆中不存在任何该类的实例对象以及子类对象</li>
<li>加载该类的类的加载器已被回收</li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用</li>
</ul>
<h3> 堆内存回收</h3>
<p>如何判断堆上的对象可以回收：</p>
<ul>
<li>Java 中的对象是能否能被回收，是根据对象时否被引用来决定的。如果对象被引用了，说明该对象还在使用，不允许回收</li>
</ul>
<p>如何判断堆上的对象没有被引用：</p>
<ul>
<li>
<p>引用计数法</p>
<ul>
<li>为每个对象维护一个引用计数器，当对象被引用时 +1、取消引用时 -1（该方法会出现循环引用问题）</li>
</ul>
</li>
<li>
<p>可达性分析算法（java 使用的方法）</p>
</li>
</ul>
<h4> 可达性分析</h4>
<p>Java 使用可达性分析算法来判断对象是否可以被回收<br>
可达性分析将对象分为两类：垃圾回收的跟对象（GC Root）和普通对象<br>
GC Root 对象一般不被回收，如果普通对象可以通过引用链找到 GC Root 对象，则不可被回收</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20231119220514771.png" alt="image-20231119220514771" loading="lazy"></p>
<h4> GC Root 对象</h4>
<p>哪些对象被称之为 GC Root 对象：</p>
<ul>
<li>线程 Thread 对象</li>
<li>系统类加载器加载的 java.lang.Class 对象</li>
<li>监视器对象，用来保存 synchronized 关键字持有的对象</li>
<li>本地方法调用时使用的全局对象</li>
</ul>
<h4> 其他常见对象引用</h4>
<p>可达性算法描述的对象引用、一般指强引用，即 GCRoot 对象对普通对象的引用</p>
<p>Java 中其他引用方式：</p>
<ul>
<li>软引用：如果只有一个对象只有软引用关联到它，当程序内存不足时，就会将软引用中的数据进行回收</li>
<li>弱引用：弱引用包含的对象在垃圾回收时，不管内存够不够都不会直接被回收</li>
<li>虚引用</li>
<li>终结器引用</li>
</ul>
<h3> 垃圾回收算法</h3>
<p>垃圾回收算法流程：</p>
<ol>
<li>找到内存中欧存活的对象</li>
<li>释放不在存活对象的内存，使得程序能再次利用这部分空间</li>
</ol>
<p>四种垃圾回收算法：</p>
<ul>
<li>标记-清除算法</li>
<li>复制算法</li>
<li>标记-整理算法</li>
<li>分代 GC</li>
</ul>
<p>垃圾回收会通过单独的 GC 线程完成，GC 线程在执行时需要暂停所有用户线程，这个过程称为 Stop The World（STW），如果 STW 时间过长则会影响用户使用</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20231119225412229.png" alt="image-20231119225412229" loading="lazy"></p>
<p>垃圾回收算法评价指标</p>
<ul>
<li>吞吐量：吞吐量 = 执行用户代码时间 / （执行用户代码时间 + GC 时间）</li>
<li>最大暂停时间：STW 的最大值</li>
<li>堆使用效率：不同垃圾回收算法，堆内存使用方式不同</li>
</ul>
<h4> 标记清除算法</h4>
<p>算法描述</p>
<ol>
<li>标记阶段：通过可达性分析算法，从 GC Root 开始通过引用链遍历出所有存活对象</li>
<li>清除阶段：从内存中删除没有被标记的非存活对象</li>
</ol>
<p>标记清除算法的优缺点</p>
<ul>
<li>优点：实现简单，只需在第一阶段标记，第二阶段删除</li>
<li>缺点：
<ul>
<li>碎片化问题：对象被删除后，内存中会出现很多细小可用内存，无法分配给大内存对象</li>
<li>分配速度慢：由于内存碎片存在，需要维护一个空闲链表连接内存碎片，很可能需要遍历到链表最后才获得合适空间</li>
</ul>
</li>
</ul>
<h4> 复制算法</h4>
<p>算法描述：</p>
<ol>
<li>将内存分割成两块空间，From 和 To 空间，对象分配阶段，创建对象</li>
<li>GC 阶段开始时，将 GC Root 搬运到 To 空间</li>
<li>将 GC Root 关联的对象搬运到 To 空间</li>
<li>清理 From 空间，将 From 和 To 名字互换</li>
</ol>
<p>复制算法优缺点</p>
<ul>
<li>优点：
<ul>
<li>吞吐量高</li>
<li>不会发生碎片化</li>
</ul>
</li>
<li>缺点：内存使用效率低</li>
</ul>
<h4> 标记整理算法</h4>
<p>标记整理算法（标记压缩算法）是对清理算法容易产生内存碎片的一种解决方案</p>
<p>算法描述：</p>
<ol>
<li>标记阶段：通过可达性分析算法，从 GC Root 开始通过引用链遍历出所有存活对象</li>
<li>整理阶段：将存活对象移动到堆的一端清理掉存活对象的内存空间，这样便于清理出一整大块的内存空间</li>
</ol>
<p>标记整理算法优缺点</p>
<ul>
<li>优点
<ul>
<li>内存使用效率高</li>
<li>不会发生碎片化</li>
</ul>
</li>
<li>缺点：整理阶段的效率不高</li>
</ul>
<h4> 分代垃圾回收</h4>
<p>现代优秀垃圾回收算法将上述算法组合使用，其中应用最广的为分代垃圾回收算法（Generational GC）<br>
分代垃圾回收算法将整个内存区域划分为年轻代和老年代</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20231120205858862.png" alt="image-20231120205858862" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20231120205934031.png" alt="image-20231120205934031" loading="lazy"></p>
<p>分代回收执行流程：</p>
<ol>
<li>新创建的对象首先被放入 Eden 区</li>
<li>当 Eden 区满时，新创建的对象无法放入，此时触发年轻代 GC，称为 Minor GC 或 Young GC</li>
<li>Minor GC 会把 Eden 中和 From 中需要回收的对象回收（可达性分析法），把没有回收的对象放入 To 区</li>
<li>接下来 S0 变为 To 区，S1 变为 From 区。当 Eden 满时再往里放对象，依然进行 Minor GC，此时回收 Eden 和 S1(From) 的对象，并把 eden 和 From 中剩余对象放入 S0
<ul>
<li>注意：每次 Minor GC 中为存活对象记录年龄，初始为 0，每次 GC 完 +1</li>
</ul>
</li>
<li>如果 Minor GC 后对象的年龄达到阈值（最大 15，默认值和垃圾会回收器有关），对象就会晋升至老年代</li>
<li>当老年代空间不足，无法放入新的对象时，先尝试 Minor GC ，如果还不足就会触 Full GC，Full GC 会对整个堆进行垃圾回收</li>
<li>如果 Full GC 依然无法回收掉老年代的对象，那么当兑现继续放入老年代时，就会抛出 Out Of Menory 异常</li>
</ol>
<p>分代 GC 算法把堆分成年轻代和老年代的原因：</p>
<ul>
<li>可以通过调整年轻代和老年代的比例来适应不同类型的应用程序，提高内存的利用率和性能</li>
<li>新生代和老年代使用不同的垃圾回收算法，新生代一般选择复制算法，老年代可以选择标记 - 清除和标记 - 整理算法，由程序员来选择灵活度较高<br>
3、分代的设计中允许只回收新生代 (minor gc)，如果能满足对象分配的要求就不需要对整个堆进行回收 (full gc)，STW 时间就会减少。</li>
</ul>
<h4> 垃圾回收器的组合关系</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20231120213538476.png" alt="image-20231120213538476" loading="lazy"></p>
<p>G1 垃圾回收器：<br>
JDK9 之后默认的垃圾回收器是 G1 (Garbage First) 垃圾回收器<br>
Parallel Scavenge 关注吞吐量，允许用户设置最大暂停时间，但是会减少年轻代可用空间的大小<br>
CMS 关注暂停时间，但是吞吐量方面会下降。<br>
而 G1 设计目标就是将上述两种垃圾回收器的优点融合</p>
<ul>
<li>支持巨大的堆空间回收，并有较高的吞吐量。</li>
<li>支持多 CPU 并行垃圾回收。</li>
<li>允许用户设置最大暂停时间。</li>
</ul>
<p>JDK9 之后强烈建议使用 G1 垃圾回收器</p>
]]></content:encoded>
      <enclosure url="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20231114225258529.png" type="image/png"/>
    </item>
    <item>
      <title>Java Web 基础</title>
      <link>https://T4mako.github.io/code/java/JavaWeb%E5%9F%BA%E7%A1%80.html</link>
      <guid>https://T4mako.github.io/code/java/JavaWeb%E5%9F%BA%E7%A1%80.html</guid>
      <source url="https://T4mako.github.io/rss.xml">Java Web 基础</source>
      <description>一、配置文件 1、XML配置文件 1、名词解释 XML是eXtensible Markup Language的缩写，翻译过来就是可扩展标记语言。XML和HTML一样都是标记语言，也就是说它们的基本语法都是标签。</description>
      <category>java</category>
      <content:encoded><![CDATA[<h2> 一、配置文件</h2>
<h3> 1、XML配置文件</h3>
<h4> 1、名词解释</h4>
<p>XML是e<strong>X</strong>tensible <strong>M</strong>arkup <strong>L</strong>anguage的缩写，翻译过来就是<strong>可扩展标记语言</strong>。<strong>XML和HTML一样都是标记语言</strong>，也就是说它们的基本语法都是<strong>标签</strong>。</p>
<!-- more -->
<p><strong>可扩展</strong>意思是XML允许<strong>自定义格式</strong></p>
<p>在XML基本语法规范的基础上，第三方应用程序、框架通过设计**『XML约束』<strong>的方式</strong>『强制规定』**配置文件中可以写什么和怎么写</p>
<h4> 2、XML基本语法</h4>
<p>XML的基本语法和HTML的基本语法如出一辙，XML基本语法+HTML约束=HTML语法。在逻辑上HTML是XML的子集。</p>
<p>①根标签<br>
根标签有且只能有一个</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>②单双标签<br>
双标签：开始标签和结束标签必须成对出现。<br>
单标签：单标签在标签内关闭。</p>
<p>③属性<br>
属性必须有值<br>
属性值必须加引号，单双都行</p>
<h4> 3、XML约束</h4>
<p>我们主要就是根据XML约束中的规定来编写XML配置文件。而XML约束主要包括<strong>DTD和Schema</strong>两种。如果XML配置文件使用的是DTD，那么对我们几乎没有影响。如果是Schema约束，需要我们稍微参与一点点。</p>
<p>详情见https://heavy_code_industry.gitee.io/code_heavy_industry/pro001-javaweb/lecture/chapter05/verse01.html#_2%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6</p>
<h3> 2、属性文件</h3>
<p>以<strong>properties作为扩展名</strong>的文件<br>
由<strong>键值对</strong>组成<br>
键和值之间的符号是<strong>等号</strong><br>
每一行都必须顶格写，前面<strong>不能有空格之类的其他符号</strong></p>
<div class="language-properties line-numbers-mode" data-ext="properties"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3、其他形式</h3>
<p>①YAML语言的配置文件：在SpringBoot中使用。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>②JSON格式的配置文件：一般是前端使用。</p>
<h2> 二、Tomcat</h2>
<h3> 1、Tomcat扮演的角色</h3>
<p><strong>① 对外：Web服务器</strong></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220914194924351.png" alt="image-20220914194924351" loading="lazy"></p>
<p><strong>② 对内：Servlet容器</strong></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220914195004706.png" alt="image-20220914195004706" loading="lazy"></p>
<h3> 2、部署</h3>
<p><mark>Tomcat本身是一个Java程序</mark>，所以当前系统中必须正确配置了JAVA_HOME <strong>环境变量</strong>。<br>
将Tomcat压缩包解压到一个<strong>非中文无空格</strong>的目录下。<br>
Tomcat的目录结构：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220914204033528.png" alt="image-20220914204033528" loading="lazy"></p>
<p>启动Tomcat：运行Tomcat解压后根目录下\bin\startup.bat即可</p>
<h3> 3、在IDEA中关联Tomcat</h3>
<p>https://heavy_code_industry.gitee.io/code_heavy_industry/pro001-javaweb/lecture/chapter05/verse03.html</p>
<h3> 4、动态Web工程目录结构介绍</h3>
<table>
<thead>
<tr>
<th>目录或文件名</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>src目录</td>
<td>存放Java源文件</td>
</tr>
<tr>
<td>web目录</td>
<td>存放Web开发相关资源</td>
</tr>
<tr>
<td>web/WEB-INF目录</td>
<td>存放web.xml文件、classes目录、lib目录</td>
</tr>
<tr>
<td>web/WEB-INF/web.xml文件</td>
<td>别名：部署描述符，deployment descriptor 作用：Web工程的核心配置文件</td>
</tr>
<tr>
<td>web/WEB-INF/classes目录</td>
<td>存放编译得到的*.class字节码文件</td>
</tr>
<tr>
<td>web/WEB-INF/lib目录</td>
<td>存放第三方jar包</td>
</tr>
</tbody>
</table>
<p><mark>新建web项目并在Tomcat中部署，访问</mark></p>
<p><strong>context root 相当于 application context</strong>（Tomcat中application context Server中的url）</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/03.第一次使用Servlet.png" alt="03.第一次使用Servlet" loading="lazy"></p>
<p><mark>action为add，向服务器的add组件发请求，add对应AddServler这个类</mark>，将request这个对象传给服务器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><mark>request设置相应字符集</mark></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>打开网页URL设置可以直接设置为组件（Tomcat Server OpenBrowser URL）</p>
<h2> 三、HTTP协议</h2>
<p>HTTP：<strong>H</strong>yper <strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol超文本传输协议。HTTP最大的作用就是<strong>确定了请求和响应数据的格式</strong>。<br>
<strong>浏览器发送给服务器的数据：请求报文</strong><br>
<strong>服务器返回给浏览器的数据：响应报文。</strong></p>
<p>1） Http 称之为 超文本传输协议<br>
2） Http 是 无状态 的<br>
3） Http 请求响应包含两个部分：<mark>请求和响应</mark></p>

<h3> 1、请求报文</h3>
<p><mark>请求报文的三部分：请求行、请求消息头、请求体</mark></p>
<p><strong>浏览器→服务器</strong></p>
<h4> 1、请求行</h4>
<p>作用：展示当前请求的最基本信息</p>
<div class="language-http line-numbers-mode" data-ext="http"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>请求方式<br>
访问地址<br>
HTTP协议的版本</p>
<h4> 2、请求消息头</h4>
<p>作用：通过具体的参数<strong>对本次请求进行详细的说明</strong><br>
格式：键值对，键和值之间使用冒号隔开</p>
<p>相对比较重要的请求消息头：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Host</td>
<td>服务器的主机地址</td>
</tr>
<tr>
<td>Accept</td>
<td>声明当前请求能够接受的『媒体类型』</td>
</tr>
<tr>
<td>Referer</td>
<td>当前请求来源页面的地址</td>
</tr>
<tr>
<td>Content-Length</td>
<td>请求体内容的长度</td>
</tr>
<tr>
<td>Content-Type</td>
<td>请求体的内容类型，这一项的具体值是媒体类型中的某一种</td>
</tr>
<tr>
<td>Cookie</td>
<td><strong>浏览器访问服务器时携带的Cookie数据</strong></td>
</tr>
</tbody>
</table>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917150026204.png" alt="image-20220917150026204" loading="lazy"></p>
<h4> 3、请求体</h4>
<p>作用：作为请求的主体，发送数据给服务器。具体来说其实就是<strong>POST请求方式下的请求参数</strong>。</p>
<p>[1]form data<br>
含义：当前请求体是一个<strong>表单提交的请求参数</strong></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917150418728.png" alt="image-20220917150418728" loading="lazy"></p>
<p>[2]Request Payload<br>
含义：<strong>整个请求体</strong>以某种<strong>特定格式</strong>来组织数据，例如JSON格式。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917150459419.png" alt="image-20220917150459419" loading="lazy"></p>
<h3> 2、请求方式</h3>
<h4> ①HTTP协议已定义的请求方式</h4>
<p>HTTP1.1中共定义了八种请求方式：</p>
<p><strong>GET</strong>：<em>从服务器端获取</em>数据<br>
<strong>POST</strong>：将数据保存到服务器端<br>
<strong>PUT</strong>：命令服务器对数据执行更新<br>
<strong>DELETE</strong>：命令服务器删除数据*<br>
HEAD<br>
CONNECT<br>
OPTIONS<br>
TRACE</p>
<h4> ②GET请求</h4>
<p>特征1：<strong>没有请求体</strong><br>
特征2：<strong>请求参数</strong>附着在<strong>URL地址后面</strong><br>
特征3：请求参数在浏览器地址栏<strong>能够直接被看到</strong>，存在安全隐患<br>
特征4：在URL地址后面携带请求参数，<strong>数据容量非常有限</strong>。如果数据量大，那么超出容量的数据会丢失<br>
特征5：从报文角度分析，<strong>请求参数是在请求行中携带的</strong>，因为访问地址在请求行</p>
<h4> ③POST请求</h4>
<p>特征1：<strong>有请求体</strong><br>
特征2：<strong>请求参数放在请求体中</strong><br>
特征3：请求体发送<strong>数据的空间没有限制</strong><br>
特征4：可以<strong>发送各种不同类型</strong>的数据<br>
特征5：从报文角度分析，<strong>请求参数是在请求体中</strong>携带的<br>
特征6：由于<strong>请求参数是放在请求体</strong>中，所以<strong>浏览器地址栏看不到</strong></p>
<h3> 3、响应报文</h3>
<p><mark>响应报文的三部分：响应状态行、响应消息头、响应体</mark></p>
<p><strong>服务器→浏览器</strong></p>
<h4> ①响应状态行</h4>
<div class="language-http line-numbers-mode" data-ext="http"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>HTTP协议版本<br>
<strong>响应状态码</strong><br>
响应状态的说明文字</p>
<h4> ②响应消息头</h4>
<p>响应体的说明书。<br>
<strong>服务器端对浏览器端设置数据</strong>，例如：服务器端返回Cookie信息。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Content-Type</td>
<td>响应体的内容类型</td>
</tr>
<tr>
<td>Content-Length</td>
<td>响应体的内容长度</td>
</tr>
<tr>
<td>Set-Cookie</td>
<td><strong>服务器返回新的Cookie信息给浏览器</strong></td>
</tr>
<tr>
<td>location</td>
<td>在<strong>重定向</strong>的情况下，告诉<strong>浏览器访问下一个资源的地址</strong></td>
</tr>
</tbody>
</table>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917151743113.png" alt="image-20220917151743113" loading="lazy"></p>
<h4> ③响应体</h4>
<p>服务器返回的数据主体，有可能是各种数据类型。</p>
<p>HTML页面、图片、视频以下载形式返回的文件<br>
CSS文件、JavaScript文件</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917151835657.png" alt="image-20220917151835657" loading="lazy"></p>
<h4> ④响应状态码</h4>
<p>作用：以编码的形式告诉浏览器当前请求处理的结果</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>200</td>
<td>服务器成功处理了当前请求，成功返回响应</td>
</tr>
<tr>
<td>302</td>
<td>重定向</td>
</tr>
<tr>
<td>400</td>
<td>[SpringMVC特定环境]请求参数问题</td>
</tr>
<tr>
<td>403</td>
<td>没有权限</td>
</tr>
<tr>
<td><strong>404</strong></td>
<td><strong>找不到目标资源</strong></td>
</tr>
<tr>
<td><strong>405</strong></td>
<td>**请求方式和服务器端对应的处理方式不一致 **（请求为get而处理为post）</td>
</tr>
<tr>
<td>406</td>
<td>[SpringMVC特定环境]请求扩展名和实际返回的响应体类型不一致</td>
</tr>
<tr>
<td><strong>50X</strong></td>
<td><strong>服务器端内部错误，通常都是服务器端抛异常了</strong></td>
</tr>
</tbody>
</table>
<p><strong>404产生的具体原因：</strong><br>
访问地址写错了，确实是没有这个资源<br>
访问了WEB-INF目录下的资源<br>
Web应用启动的时候，控制台已经抛出异常，导致整个Web应用不可用，访问任何资源都是404<br>
服务器端缓存</p>
<h3> 4、会话</h3>
<p>1、http是 <strong>无状态</strong> 的<br>
无状态：服务器无法判断两次请求是否是同一个客户端还是不同客户端<br>
通过 <strong>会话跟踪技术</strong> 解决无状态的问题</p>
<p>2、会话跟踪技术：<br>
<strong>客户端第一次发请求给服务器，服务器获取session</strong>，<strong>获取不到，则创建新的</strong>，然后响应给客户端<br>
下一次客户端给服务器发请求时，会把sessionID带给服务器服务器判断这次和上次请求是否是同一个客户端，从而区分开客户端<br>
常用API：<br>
<strong>request.getSession() -&gt; 获取当前的会话，没有则创建一个新的会话<br>
request.getSession(true)-&gt; 效果和不带参数相同<br>
request.getSession(false) -&gt; 获取当前会话，没有则返回null，不会创建新的<br>
session.getId() -&gt; 获取sessionId<br>
session.isNew() -&gt; 判断当前session是否是新的<br>
session.getMaxInactiveInterval() -&gt; session的非激活间隔时长，默认1800秒 （session持续时间）<br>
session.setMaxInactiveInterval()<br>
session.invalidate() -&gt; 强制让会话立即失效</strong></p>
<p>3、session保存作用域<br>
sessioin保存作用域是和具体的某一个session对应的 <strong>（一次会话范围内有效 （<em>一个客户端一个session</em>））</strong><br>
常用的API：<br>
<strong>void session.setAttribute(k,v)  往session保存作用域中保存数据<br>
Object session.getAttribute(k)  往session保存作用域中获取数据<br>
void removeAttribute(k)</strong></p>
<h3> 5、服务器内部转发以及客户端重定向</h3>
<p>1） <strong>服务器内部转发 : request.getRequestDispatcher("...").forward(request,response);</strong></p>

<p>2）<strong>客户端重定向：response.sendRedirect("....");</strong></p>
<ul>
<li>两次请求响应的过程。客户端肯定知道请求URL有变化<br>
<strong>地址栏有变化</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/04.服务器内部转发.png" alt="04.服务器内部转发" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/05.客户端重定向.png" alt="05.客户端重定向" loading="lazy"></p>
<h2> 四、Servlet</h2>
<h3> 1、Servlet概述</h3>
<p><strong>Servlet=Server+applet</strong><br>
<em>Server：服务器、applet：小程序</em><br>
<strong>Servlet含义是服务器端的小程序</strong>*</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917152349188.png" alt="image-20220917152349188" loading="lazy"></p>
<p>在整个Web应用中，Servlet主要负责 <strong>处理请求、协调调度功能</strong>。我们可以把Servlet称为Web应用中的 <strong>控制器</strong></p>
<h3> 2、Servlet  HelloWorld</h3>
<p>在页面上点击超链接，由Servlet处理这个请求，并返回一个响应字符串：Hello,I am Servlet</p>
<p>①第一步：创建动态 Web module<br>
②第二步：创建超链接</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>③第三步：创建HelloServlet的Java类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>④第四步：配置HelloServlet<br>
配置文件位置：WEB-INF/web.xml</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917153143610.png" alt="image-20220917153143610" style="zoom:200%;">
<p><strong>虚拟路径</strong>：Servlet并<strong>不是</strong>文件系统中<strong>实际存在</strong>的<strong>目录或文件</strong>，所以为了方便浏览器访问，我们创建了<strong>虚拟</strong>出来的路径来访问它。</p>
<h4> Web工程中的资源：</h4>
<p>静态资源：HTML，CSS，JS，图片<br>
动态资源：Servlet</p>
<p>访问资源的地址：<br>
静态资源：/Web应用名称/静态资源本身的路径<br>
动态资源：/Web应用名称/虚拟路径</p>
<h4> 总体逻辑结构：</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917153538804.png" alt="image-20220917153538804" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917153638692.png" alt="image-20220917153638692" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917153645060.png" alt="image-20220917153645060" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917153654438.png" alt="image-20220917153654438" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917153702954.png" alt="image-20220917153702954" loading="lazy"></p>
<h3> 3、Servlet生命周期</h3>
<p>生命周期：从出生到死亡的过程就，对应Servlet的三个方法：<mark>init(),service(),destroy()</mark></p>
<p>默认情况下：Servlet在<strong>第一次接收到请求</strong>的时候才<strong>创建对象</strong>(调用<strong>构造器</strong>，实例化)，然后初始化（init方法）、然后服务（service方法）<br>
当容器关闭时，其中的所有servlet实例被销毁，调用销毁方法</p>
<p>创建对象后，所有的URL地址匹配的请求都由这同一个对象来处理<br>
Tomcat中，每一个请求会被分配一个线程来处理，所以可以说：Servlet是<strong>单实例，多线程</strong>方式运行的。<br>
既然Servlet是多线程方式运行，所以有线程安全方面的可能性，所以<strong>不能在处理请求的方法中修改公共属性</strong>。</p>
<p>在web.xml中修改Servlet配置，使得在Web应用启动的时候创建Servlet对象</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4、Servlet容器</h3>
<p>①容器<br>
在开发使用的各种技术中，经常会有<strong>很多对象会放在容器</strong>中。</p>
<p>②容器提供的功能<br>
容器会管理内部对象的整个生命周期。<strong>对象在容器中才能够正常的工作，得到来自容器的全方位的支持</strong>。</p>
<p>创建对象<br>
初始化<br>
工作<br>
清理</p>
<p>③容器本身也是对象<br>
特点1：往往是非常大的对象<br>
特点2：通常的单例的</p>
<p>④典型Servlet容器产品举例<br>
Tomcat、jetty、jboss、Weblogic、WebSphere、glassfish</p>
<h4> </h4>
<table>
<thead>
<tr>
<th>名称</th>
<th>时机</th>
<th>次数</th>
</tr>
</thead>
<tbody>
<tr>
<td>创建对象</td>
<td>默认情况：接收到第一次请求 修改启动顺序后：Web应用启动过程中</td>
<td>一次</td>
</tr>
<tr>
<td>初始化操作</td>
<td>创建对象之后</td>
<td>一次</td>
</tr>
<tr>
<td>处理请求</td>
<td>接收到请求</td>
<td>多次</td>
</tr>
<tr>
<td>销毁操作</td>
<td>Web应用卸载之前</td>
<td>一次</td>
</tr>
</tbody>
</table>
<h3> 5、ServletConfig和ServletContext</h3>
<h4> 1、ServletConfig接口</h4>
<p>接口方法：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>getServletName()</td>
<td>获取定义的Servlet名称</td>
</tr>
<tr>
<td><strong>getServletContext()</strong></td>
<td>获取ServletContext对象</td>
</tr>
<tr>
<td>getInitParameter()</td>
<td>获取配置Servlet时设置的『初始化参数』，根据名字获取值</td>
</tr>
<tr>
<td>getInitParameterNames()</td>
<td>获取所有初始化参数名组成的Enumeration对象</td>
</tr>
</tbody>
</table>
<p>使用举例：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Servlet标准和JDBC标准对比：</p>
<table>
<thead>
<tr>
<th>Servlet标准</th>
<th>JDBC标准</th>
</tr>
</thead>
<tbody>
<tr>
<td>javax.servlet包下的一系列接口</td>
<td>javax.sql包下的一系列接口</td>
</tr>
<tr>
<td>Servlet容器厂商提供的具体实现类</td>
<td>数据库厂商提供的实现类（数据库驱动）</td>
</tr>
</tbody>
</table>
<h4> 2、ServletContext接口</h4>
<p>功能：<br>
获取 <strong>某个资源的真实路径</strong>：getRealPath()<br>
<strong>获取</strong> 整个Web应用级别的 <strong>初始化参数</strong>：getInitParameter()<br>
作为Web应用范围的域对象<br>
<strong>存入数据：setAttribute()</strong><br>
<strong>取出数据：getAttribute()</strong></p>
<p>使用举例：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6、Servlet继承关系</h3>
<p>1、继承关系：<br>
javax.servlet.Servlet接口<br>
javax.servlet.GenericServlet抽象类<br>
javax.servlet.http.HttpServlet抽象子类</p>
<p>2、相关方法：<br>
<strong>javax.servlet.Servlet接口：</strong><br>
void init(config)	初始化方法<br>
void service(request,response)	服务方法<br>
void destory()	销毁方法</p>
<p><strong>对于service方法：</strong><br>
①在javax.servlet.GenericServlet抽象类中，void service(request,response)仍然是抽象的<br>
在java.servlet.HttpServlet抽象子类：void service(request,response)不是抽象的<br>
②<strong>当有请求过来时，service方法会自动响应</strong>（其实是tomcat容器调用的）<br>
③servlet方法所做的事：<br>
<strong>获取的请求方式</strong><br>
<strong>根据请求方式的不同，调用不同的doXXX方法</strong><br>
在HttpServlet中这些doXXX方法默认都是405实现风格-&gt;要子类实现对应方法，否则报405错误<br>
④因此，我们在新建Servlet时，我们才会去考虑请求方法，从而决定重写哪个do方法</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917160608144.png" alt="image-20220917160608144" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917160624439.png" alt="image-20220917160624439" loading="lazy"></p>
<h3> 7、动态web工程内编写路径</h3>
<p>整个系统要根据功能拆分成许许多多<strong>独立</strong>的<strong>资源</strong><br>
资源之间既要完成自身的功能又要和其他资源<strong>配合</strong><br>
写路径就是为了<strong>从一个资源跳转到下一个资源</strong></p>
<p><strong>工程目录</strong>：我们<strong>写代码的地方</strong>，但是在服务器上运行的不是这个。<br>
<strong>部署目录</strong>：经过Java源文件<strong>编译</strong>和<strong>目录重组</strong>后，IDEA就替我们准备好了可以在服务器上运行的部署目录。<br>
部署目录经过了目录重组，所以目录结构不一样<br>
用户通过浏览器访问服务器，而服务器上运行的是部署目录，<strong>所以写路径的时候参考部署目录而不是工程目录。</strong><br>
<strong>对应关系</strong>：<strong>工程目录下的web目录对应部署目录的根目录</strong>，同时部署目录的根目录也是路径中的<strong>Web应用根目录</strong>。</p>
<h4> <strong>①具体文件：</strong></h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917161721361.png" alt="image-20220917161721361" loading="lazy"></p>
<h4> ②<strong>Servlert路径</strong></h4>
<p>访问Servlet的路径是我们在web.xml中配置的，大家可能注意到了，url-pattern里面的路径我们也是<strong>斜杠开头</strong>的，但是这个开头的斜杠代表<strong>Web应用根目录</strong>。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917161801727.png" alt="image-20220917161801727" loading="lazy"></p>
<h4> 准则：</h4>
<p>一个路径由谁来解析(浏览器、服务器)，其实就是这个路径是谁来用。</p>
<table>
<thead>
<tr>
<th>路径类型</th>
<th>解析方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>由浏览器解析的路径</td>
<td>开头斜杠代表服务器根目录</td>
</tr>
<tr>
<td>由服务器解析的路径</td>
<td>开头斜杠代表Web应用根目录</td>
</tr>
</tbody>
</table>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917161926471.png" alt="image-20220917161926471" loading="lazy"></p>
<ul>
<li>浏览器解析的路径举例：
<ul>
<li>所有HTML标签中的路径</li>
<li>重定向过程中指定的路径</li>
</ul>
</li>
<li>服务器解析的路径举例：
<ul>
<li>所有web.xml中配置的路径</li>
<li>请求转发过程中指定的路径</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917162121772.png" alt="image-20220917162121772" loading="lazy"></p>
<h4> 动态获取上下文路径：</h4>
<p><strong>上下文路径（context path）=/Web应用名称</strong></p>
<p>由于项目部署的时候，上下文路径是可以变化的，所以写死有可能发生错误。此时我们通过<strong>request对象动态获取上下文路径</strong>就不用担心这个问题了。调用下面这个方法，每一次获取的都是当前环境下实际的上下文路径的值。</p>
<p><strong>request.getContextPath()</strong></p>
<h3> 8、请求转发和重定向</h3>
<h4> 1、服务器内部转发</h4>
<p>在请求的处理过程中，Servlet完成了自己的任务，需要把请求<strong>转交给下一个资源</strong>继续处理。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><table>
<thead>
<tr>
<th>代码</th>
<th>类比</th>
</tr>
</thead>
<tbody>
<tr>
<td>request</td>
<td>小货车</td>
</tr>
<tr>
<td>getRequestDispatcher("转发地址")</td>
<td>告诉司机要去哪</td>
</tr>
<tr>
<td>forward(request, response)</td>
<td>出发</td>
</tr>
</tbody>
</table>
<p>由于转发操作的核心部分是<strong>在服务器端完成</strong>的，所以<strong>浏览器感知不到</strong>，整个过程中<strong>浏览器只发送一次请求</strong>。</p>
<h4> 2、浏览器重定向</h4>
<p>在请求的处理过程中，Servlet完成了自己的任务，然后以一个<strong>响应</strong>的方式告诉浏览器：“要完成这个任务还需要你另外<strong>再访问下一个资源</strong>”。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>由于重定向操作的核心部分是<strong>在浏览器端完成</strong>的，所以整个过程中浏览器<strong>共发送两次请求</strong>。</p>
<table>
<thead>
<tr>
<th>转发</th>
<th>重定向</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>一次请求</strong></td>
<td><strong>两次请求</strong></td>
</tr>
<tr>
<td>浏览器<strong>地址栏显示</strong>的是<strong>第一个</strong>资源的地址</td>
<td>浏览器<strong>地址栏显示</strong>的是<strong>第二个</strong>资源的地址</td>
</tr>
<tr>
<td>全程使用的是<strong>同一个request对象</strong></td>
<td>全程使用的是<strong>不同的request对象</strong></td>
</tr>
<tr>
<td>在<strong>服务器端完成</strong></td>
<td>在<strong>浏览器端完成</strong></td>
</tr>
<tr>
<td>目标资源地址由服务器解析</td>
<td>目标资源地址由浏览器解析</td>
</tr>
<tr>
<td>目标资源可以在WEB-INF目录下</td>
<td>目标资源不能在WEB-INF目录下</td>
</tr>
<tr>
<td>目标资源仅限于本应用内部</td>
<td>目标资源可以是外部资源</td>
</tr>
</tbody>
</table>
<p>使用场景：<br>
能用转发的先用转发，如果转发不行，再使用重定向。</p>
<p>需要通过同一个request对象把数据携带到目标资源：只能用转发<br>
如果希望前往下一个资源之后，浏览器刷新访问的是第二个资源：只能用重定向</p>
<h3> 9、获取请求参数</h3>
<p>浏览器在给服务器发送请求的同时，携带的参数数据。<br>
请求参数的基本形式：<br>
URL地址后面附着的请求参数<br>
表单<br>
Ajax请求</p>
<p>总体上来说，服务器端将请求参数封装为<strong>Map&lt;String, String[]&gt;</strong>。<br>
<strong>键：请求参数的名字</strong><br>
<strong>值：请求参数的值组成的数组</strong></p>
<h4> 获取请求参数的方法(request.)</h4>
<table>
<thead>
<tr>
<th>方法名</th>
<th>返回值类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>request.getParameterMap()</td>
<td><code>Map&lt;String, String[]&gt;</code></td>
</tr>
<tr>
<td>request.getParameter("请求参数的名字")</td>
<td>String</td>
</tr>
<tr>
<td>request.getParameterValues("请求参数的名字")</td>
<td>String []</td>
</tr>
<tr>
<td>request.getParameterNames()</td>
<td><code>Enumeration&lt;String&gt;</code></td>
</tr>
</tbody>
</table>
<h3> 10、请求响应设置字符集</h3>
<h4> 1、请求</h4>
<h4> 1、GET</h4>
<p>设置方式</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917164406033.png" alt="image-20220917164406033" loading="lazy"></p>
<h4> 2、Post</h4>
<p>设置方式<br>
注：设置字符集必须在获取请求参数之前</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2、响应</h4>
<p>1、设置方式一：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>2、设置方式二：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>response.getWriter()不能出现在设置字符集操作的前面（两种方式都不行）</p>
<h2> 五、Thymeleaf</h2>
<p>1） 添加thymeleaf的jar包<br>
2） <mark>新建一个Servlet类<strong>ViewBaseServlet</strong></mark><br>
3） 在web.xml文件中添加配置</p>

<p>4） <mark>使得<strong>我们的Servlet继承ViewBaseServlet</strong></mark><br>
<strong>VIewBaseServlet继承了HttpServlet<br>
我们创建的Servlet继承了ViewServlet</strong></p>
<p>5） 根据逻辑视图名称 得到 物理视图名称<br>
//此处的视图名称是 index<br>
//那么thymeleaf会将这个 逻辑视图名称 对应到 物理视图 名称上去<br>
//逻辑视图名称 ：   index<br>
//物理视图名称 ： <strong>view-prefix + 逻辑视图名称 + view-suffix</strong><br>
//所以真实的视图名称是：      /       index       .html<br>
super.processTemplate("index",request,response);<br>
6） 使用thymeleaf的标签<br>
th:if   ,  th:unless   , th:each   ,   th:text</p>
<h3> ViewBaseServlet</h3>
<p>有关ViewBaseServlet</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1、Thymeleaf简介</h3>
<p>Thymeleaf、JSP、Freemarker、Velocity等等，它们有一个共同的名字：<strong>服务器端模板技术</strong></p>
<p><strong>thymeleaf帮助我们做视图渲染</strong><br>
<strong>渲染：在html页面上加载java内存中的数据</strong></p>
<p>Thymeleaf的优势：<br>
SpringBoot官方推荐使用的视图模板技术，和SpringBoot完美整合。<br>
不经过服务器运算仍然可以直接查看原始值，对前端工程师更友好。</p>
<p>物理视图和逻辑视图<br>
①物理视图<br>
在Servlet中，将请求转发到一个HTML页面文件时，使用的完整的转发路径就是<strong>物理视图</strong>。</p>
<p>如果我们把所有的HTML页面都放在某个统一的目录下，那么转发地址就会呈现出明显的规律：<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917185459523.png" alt="image-20220917185459523" loading="lazy"></p>
<p>所以，路径开头的部分我们称之为<strong>视图前缀</strong>，路径结尾的部分我们称之为<strong>视图后缀</strong>。</p>
<p>②逻辑视图<br>
物理视图=视图前缀+逻辑视图+视图后缀<br>
上面的例子中：</p>
<table>
<thead>
<tr>
<th>视图前缀</th>
<th>逻辑视图</th>
<th>视图后缀</th>
<th>物理视图</th>
</tr>
</thead>
<tbody>
<tr>
<td>/pages/user/</td>
<td>login</td>
<td>.html</td>
<td>/pages/user/login.html</td>
</tr>
<tr>
<td>/pages/user/</td>
<td>login_success</td>
<td>.html</td>
<td>/pages/user/login_success.html</td>
</tr>
</tbody>
</table>
<h3> 2、在服务器端引入Thymeleaf环境</h3>
<p>https://heavy_code_industry.gitee.io/code_heavy_industry/pro001-javaweb/lecture/chapter08/verse03.html</p>
<h3> 3、基本语法：th名称空间</h3>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917190228445.png" alt="image-20220917190228445" loading="lazy"></p>
<h3> 4、基本语法：表达式语法</h3>
<h4> 1、修改标签文本值</h4>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h5> ①th:text作用</h5>
<p>不经过服务器解析，直接用浏览器打开HTML文件，看到的是标签体原始值<br>
<strong>经过服务器解析</strong>，Thymeleaf引擎根<strong>据th:text属性指定</strong>的标签体新值去<strong>替换</strong>标签体原始值</p>
<h5> ②字面量</h5>
<p>字面量是一个经常会遇到的概念，我们可以对照变量来理解它的含义<br>
<strong>变量</strong>：变量名字符串本身不是它的值，<strong>它指向的才是它的值</strong><br>
<strong>字面量</strong>：它就是字面上的含义，我们<strong>从字面上看到的直接就是它的值</strong><br>
现在我们在th:text属性中使用的就是<strong>字面量</strong>，它<strong>不指代任何其他值</strong></p>
<h4> 2、修改指定属性值</h4>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>语法：任何HTML标签原有的属性，<strong>前面加上『th:』就都可以通过Thymeleaf来设定新值。</strong></p>
<h4> <mark>3、解析URL地址</mark></h4>
<h5> ①基本语法</h5>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>经过解析后得到：/view/aaa/bbb/ccc</p>
<p>所以==@{}==的作用是<strong>在字符串前附加『上下文路径』</strong></p>
<p>这个语法的好处是：实际开发过程中，项目在不同环境部署时，Web应用的名字有可能发生变化。所以上下文路径不能写死。而通过@{}动态获取上下文路径后，不管怎么变都不怕啦！</p>
<h5> ②首页使用URL地址解析</h5>
<p>如果我们直接访问index.html本身，那么<strong>index.html是不需要通过Servlet</strong>，<strong>当然也不经过模板引擎</strong>，所以<strong>index.html上的Thymeleaf的任何表达式都不会被解析</strong>。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917191612545.png" alt="image-20220917191612545" loading="lazy"></p>
<p>解决办法：通过Servlet访问index.html，这样就可以让模板引擎渲染页面了：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917191730539.png" alt="image-20220917191730539" loading="lazy"></p>
<h5> ③<mark>给URL地址后面附加请求参数</mark></h5>
<p><strong>一个变量对应一个value值</strong></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220923195523837.png" alt="image-20220923195523837" loading="lazy"></p>
<h4> 4、直接执行表达式</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917191950294.png" alt="image-20220917191950294" loading="lazy"></p>
<h3> 5、基本语法：访问域对象（保存作用域）</h3>
<h4> 1、域对象</h4>
<h5> ①请求域：HttpServletRequest对象内部给我们提供的存储空间（requese 一次会话范围有效）</h5>
<h5> ②会话域（session 一次会话范围有效）</h5>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220923154339888.png" alt="image-20220923154339888" loading="lazy"></p>
<h5> ③应用域（application 一次应用程序范围有效）</h5>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220923154427454.png" alt="image-20220923154427454" loading="lazy"></p>
<h4> 2、在servlet中将数据存入域</h4>
<h5> ①操作请求域</h5>
<p><strong>Servlet中：</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>thymeleaf中：</strong></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h5> ②操作会话域</h5>
<p><strong>Servlet中代码：</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>thymeleaf中：</strong></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h5> ③操作应用域</h5>
<p><strong>Servlet中代码：</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Thymeleaf表达式：</strong></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 6、获取请求参数</h3>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220923161405776.png" alt="image-20220923161405776" loading="lazy"></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7、内置对象</h3>
<p>所谓内置对象其实就是在表达式中<strong>可以直接使用</strong>的对象</p>
<p><strong>基本内置对象：</strong></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220923162427773.png" alt="image-20220923162427773" loading="lazy"></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>基本思路：<br>
如果不清楚这个对象有哪些方法可以使用，那么就<strong>通过getClass().getName()获取全类名</strong>，再<strong>回到Java环境查看这个对象有哪些方法</strong><br>
内置对象的<strong>方法可以直接调用</strong><br>
<strong>调用方法</strong>时<strong>需要传参</strong>的也可以<strong>直接传入参数</strong></p>
<p><strong>公共内置对象：</strong></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220923162455736.png" alt="image-20220923162455736" loading="lazy"></p>
<p>Servlet中将List集合数据存入请求域：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>页面代码：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8、${ }中的表达式本质是OGNL</h3>
<p>OGNL：Object-Graph Navigation Language对象-图 导航语言</p>
<h3> 9、OGNL语法</h3>
<h4> ①起点</h4>
<p>在Thymeleaf环境下，${}中的表达式可以从下列元素开始：</p>
<p>访问属性域的起点:<br>
请求域属性名<br>
session<br>
application<br>
param<br>
内置对象<br>
#request<br>
#session<br>
#lists<br>
#strings</p>
<h4> ②属性访问语法</h4>
<p>访问对象属性：使用getXxx()、setXxx()方法定义的属性<br>
对象.属性名<br>
访问List集合或数组<br>
集合或数组[下标]<br>
访问Map集合<br>
Map集合.key<br>
Map集合['key']</p>
<h3> 10、分支与迭代</h3>
<h4> 1、分支</h4>
<p><strong>①if和unless</strong><br>
让标记了th:if、th:unless的标签根据条件决定是否显示。</p>
<p>示例的实体类：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>示例的Servlet代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>示例的HTML代码：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> ②switch</h4>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2、迭代</h4>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220923164310877.png" alt="image-20220923164310877" loading="lazy"></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 11、包含其他模板文件</h3>
<p>https://heavy_code_industry.gitee.io/code_heavy_industry/pro001-javaweb/lecture/chapter08/verse11.html</p>
<h2> CRUD练习</h2>
<p>https://heavy_code_industry.gitee.io/code_heavy_industry/pro001-javaweb/lecture/chapter08/verse12.html</p>
<h2> Fruit项目优化</h2>
<ol>
<li>一个请求对应一个Servlet，这样存在的问题是servlet太多了</li>
<li>把一些列的请求都对应一个Servlet, IndexServlet/AddServlet/EditServlet/DelServlet/UpdateServlet -&gt; 合并成FruitServlet<br>
通过一个operate的值来决定调用FruitServlet中的哪一个方法<br>
使用的是switch-case</li>
<li>在上一个版本中，Servlet中充斥着大量的switch-case，试想一下，随着我们的项目的业务规模扩大，那么会有很多的Servlet，也就意味着会有很多的switch-case，这是一种代码冗余<br>
因此，我们在servlet中使用了反射技术，我们规定operate的值和方法名一致，那么接收到operate的值是什么就表明我们需要调用对应的方法进行响应，如果找不到对应的方法，则抛异常</li>
<li>在上一个版本中我们使用了反射技术，但是其实还是存在一定的问题：每一个servlet中都有类似的反射技术的代码。因此继续抽取，设计了中央控制器类：<code>DispatcherServlet</code><br>
<code> DispatcherServlet</code>这个类的工作分为两大部分：</li>
<li>根据url定位到能够处理这个请求的controller组件：
<ul>
<li>从url中提取servletPath : /fruit.do -&gt; fruit</li>
<li>根据fruit找到对应的组件:FruitController ， 这个对应的依据我们存储在applicationContext.xml中<br>
<code>&lt;bean id="fruit" class="com.atguigu.fruit.controllers.FruitController/&gt;</code><br>
通过DOM技术我们去解析XML文件，在中央控制器中形成一个beanMap容器，用来存放所有的Controller组件</li>
<li>根据获取到的operate的值定位到我们FruitController中需要调用的方法</li>
</ul>
</li>
<li>调用Controller组件中的方法：
<ul>
<li>获取参数<br>
获取即将要调用的方法的参数签名信息: Parameter[] parameters = method.getParameters();<br>
通过parameter.getName()获取参数的名称；<br>
准备了Object[] parameterValues 这个数组用来存放对应参数的参数值<br>
另外，我们需要考虑参数的类型问题，需要做类型转化的工作。通过parameter.getType()获取参数的类型</li>
<li>执行方法<br>
Object returnObj = method.invoke(controllerBean , parameterValues);</li>
<li>视图处理</li>
</ul>
</li>
</ol>
<h2> 六、MVC</h2>
<h3> 1、servlet初始化回顾</h3>
<p>Servlet生命周期：实例化、初始化、服务、销毁</p>
<p>Servlet中的初始化方法有两个：init() , init(config)<br>
其中带参数的方法代码如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们想要在Servlet<strong>初始化时做一些准备工作，那么我们可以重写init方法</strong><br>
我们可以通过如下步骤去获取初始化设置的数据</p>
<p><strong>获取config对象：ServletConfig config = getServletConfig();<br>
获取初始化参数值： config.getInitParameter(key);</strong></p>
<p>在web.xml文件中配置Servlet</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也可以通过注解的方式进行配置：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2、学习Servlet中的ServletContext和&lt;context-param&gt;</h3>
<ol>
<li>获取ServletContext，有很多方法<br>
在初始化方法中： ServletContxt servletContext = getServletContext();<br>
在服务方法中也可以通过request对象获取，也可以通过session获取：<br>
request.getServletContext(); session.getServletContext()</li>
<li>获取初始化值：<br>
servletContext.getInitParameter();</li>
</ol>
<p>通过ServletContext获取配置的上下文参数</p>
<h3> 3业务层</h3>
<p>Model1和Model2<br>
<strong>MVC : Model（模型）、View（视图）、Controller（控制器）</strong><br>
视图层：用于做<strong>数据展示</strong>以及和<strong>用户交互的</strong>一个<strong>界面</strong><br>
控制层：能够<strong>接受客户端的请求</strong>，<strong>具体的业务功能还是需要借助于模型组件来完成</strong><br>
模型层：模型分为很多种：有比较简单的pojo/vo(value object)，有业务模型组件，有数据访问层组件<br>
pojo/vo : 值对象<br>
DAO ： 数据访问对象<br>
BO ： 业务对象</p>
<p>模型有很多种类：数据访问模型（DAO）；业务逻辑模型（BO）；值对象模型（POJO）；数据传输对象（DTO）</p>
<p><strong>DAO中的方法</strong>都是<strong>单精度</strong>方法或称<strong>细粒度</strong>方法。一个方法只考虑一个操作，比如添加，那就是insert操作、查询那就是select操作....(<strong>只是一种操作</strong>)<br>
<strong>BO</strong>中的方法属于<strong>业务方法</strong>，也实际的业务是<strong>比较复杂</strong>的，因此业务方法的<strong>粒度是比较粗</strong>的<br>
注册这个功能属于业务功能，也就是说注册这个方法属于业务方法。<br>
那么这个<strong>业务方法中包含了多个DAO方法</strong>。</p>
<h2> 七、IOC（控制反转）</h2>
<p><strong>IOC - 控制反转 / DI - 依赖注入</strong></p>
<p><strong>控制反转：</strong><br>
之前在Servlet中，我们创建service对象 ， FruitService fruitService = new FruitServiceImpl();<br>
这句话如果出现在servlet中的<strong>某个方法内部</strong>，那么这个fruitService的作用域（生命周期）应该就是<strong>这个方法级别</strong>；<br>
如果这句话出现在servlet的<strong>类中</strong>，也就是说fruitService是一个<strong>成员变量</strong>，那么这个fruitService的作用域（生命周期）应该就是这个<strong>servlet实例级别</strong></p>
<p>​	之后我们在<strong>applicationContext.xml中定义了这个fruitService</strong>。然后<strong>通过解析XML</strong>，<strong>产生fruitService实例</strong>，<strong>存放在beanMap中</strong>，这个<strong>beanMap在一个BeanFactory中 **<br>
​	因此，我们</strong>转移（改变）了之前的service实例、dao实例等等他们的生命周期**。控制权从程序员转移到<strong>BeanFactory(IOC容器)</strong>。这个现象我们称之为<strong>控制反转</strong></p>
<p><strong>依赖注入：</strong><br>
之前我们在控制层出现代码：FruitService fruitService = new FruitServiceImpl()；<br>
那么，控制层和service层存在耦合。<br>
之后，我们将代码修改成FruitService fruitService = null ;<br>
然后，在配置文件中配置:</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 配置监听器要读取的文件，目的是加载IOC容器的配置文件</h3>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>根据bean获取所有元素节点，添加到map中，对于每个节点的子节点，通过反射添加它们中的依赖</strong></p>
<h2> 八、过滤器Filter</h2>
<h3> 1、过滤器的三要素：</h3>
<p>①拦截：<br>
过滤器之所以能够对请求进行预处理，关键是对请求进行拦截，把请求拦截下来才能够做后续的操作。而且对于一个具体的过滤器，它<strong>必须明确它要拦截的请求</strong>，而不是所有请求都拦截。</p>
<p>②过滤：<br>
根据业务功能实际的需求，看看在把请求拦截到之后，需要<strong>做什么检查或什么操作，写对应的代码即可</strong>。</p>
<p>③放行：<br>
过滤器完成自己的任务或者是检测到当前请求符合过滤规则，那么可以将请求放行。所谓放行，就是<strong>让请求继续去访问它原本要访问的资源</strong>。</p>
<h3> 2、操作步骤</h3>
<ol>
<li>
<p>Filter也属于Servlet规范</p>
</li>
<li>
<p>Filter开发步骤：新建类<strong>实现javax.servlet.Filter接口</strong>，然后实现其中的三个方法：init、doFilter、destroy<br>
配置Filter，可以用注解@WebFilter，<code>也可以使用xml文件 &lt;filter&gt; &lt;filter-mapping&gt;</code></p>
<p><strong>在doFilter()方法中执行过滤</strong></p>
<p>如果<strong>满足过滤条件</strong>使用<strong>chain.doFilter(request, response);放行</strong></p>
<p>如果<strong>不满足过滤条件转发或重定向请求</strong></p>
</li>
<li>
<p>Filter在配置时，和servlet一样，也可以配置通配符，例如 @WebFilter("*.do")表示<strong>拦截所有以.do结尾的请求</strong></p>
</li>
<li>
<p>过滤器链<br>
1）如果采取的是<strong>注解的方式进行配置</strong>，那么过滤器链的拦截顺序是<strong>按照全类名的先后顺序</strong>排序的<br>
2）如果采取的是<strong>xml的方式</strong>进行配置，那么按照<strong>配置的先后顺序</strong>进行排序</p>
</li>
<li>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/01.Filter.png" alt="01.Filter" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/02.CharacterEncodingFilter.png" alt="02.CharacterEncodingFilter" loading="lazy"></p>
<h3> 3、过滤器生命周期</h3>
<p>和Servlet生命周期类比，Filter生命周期的关键区别是：<strong>在Web应用启动时创建对象</strong></p>
<table>
<thead>
<tr>
<th>生命周期阶段</th>
<th>执行时机</th>
<th>执行次数</th>
</tr>
</thead>
<tbody>
<tr>
<td>创建对象</td>
<td>Web应用启动时</td>
<td>一次</td>
</tr>
<tr>
<td>初始化</td>
<td>创建对象后</td>
<td>一次</td>
</tr>
<tr>
<td>拦截请求</td>
<td>接收到匹配的请求</td>
<td>多次</td>
</tr>
<tr>
<td>销毁</td>
<td>Web应用卸载前</td>
<td>一次</td>
</tr>
</tbody>
</table>
<h2> 九、事务管理</h2>
<ol>
<li>
<p>涉及到的组件：</p>
<ul>
<li>OpenSessionInViewFilter</li>
<li>TransactionManager</li>
<li>ThreadLocal</li>
<li>ConnUtil</li>
<li>BaseDAO</li>
</ul>
</li>
<li>
<p>ThreadLocal</p>
<p>get() , set(obj)方法（对于同一个线程中）</p>
<p>ThreadLocal称之为本地线程 。 我们可以<strong>通过set方法在当前线程上存储数据、通过get方法在当前线程上获取数据</strong></p>
<p>set方法源码分析：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>get方法源码分析：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/05.编程式事务管理03.png" alt="05.编程式事务管理03" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/06.ThreadLocal.png" alt="06.ThreadLocal" loading="lazy"></p>
<h2> 十、监听器</h2>
<h3> 1、观察者模式</h3>
<ul>
<li>观察者：监控『被观察者』的行为，一旦发现『被观察者』触发了事件，就会调用事先准备好的方法执行操作。</li>
<li>被观察者：『被观察者』一旦触发了被监控的事件，就会被『观察者』发现。</li>
</ul>
<h3> 2、监听器简介</h3>
<p>1、<strong>Servlet监听器</strong>：Servlet规范中定义的一种特殊类，它用于监听Web应用程序中的<strong>ServletContext，HttpSession 和HttpServletRequest等域对象的创建与销毁事件</strong>，以及监听这些<strong>域对象中的属性发生修改的事件</strong></p>
<p>2、监听器分类</p>
<ul>
<li>域对象监听器</li>
<li>域对象的属性域监听器</li>
<li>Session域中数据的监听器</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221003161917547.png" alt="image-20221003161917547" loading="lazy"></p>
<h3> 3、监听器列表</h3>
<h4> ①ServletContextListener</h4>
<p>作用：监听<strong>ServletContext对象</strong>的创建与销毁</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>contextInitialized(ServletContextEvent sce)</td>
<td>ServletContext创建时调用</td>
</tr>
<tr>
<td>contextDestroyed(ServletContextEvent sce)</td>
<td>ServletContext销毁时调用</td>
</tr>
</tbody>
</table>
<p>ServletContextEvent对象代表从ServletContext对象身上捕获到的事件，通过这个事件对象我们可以获取到ServletContext对象。</p>
<h4> ②HttpSessionListener</h4>
<p>作用：监听<strong>HttpSession对象</strong>的创建与销毁</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>sessionCreated(HttpSessionEvent hse)</td>
<td>HttpSession对象创建时调用</td>
</tr>
<tr>
<td>sessionDestroyed(HttpSessionEvent hse)</td>
<td>HttpSession对象销毁时调用</td>
</tr>
</tbody>
</table>
<p>HttpSessionEvent对象代表从HttpSession对象身上捕获到的事件，通过这个事件对象我们可以获取到触发事件的HttpSession对象。</p>
<h4> ③ServletRequestListener</h4>
<p>作用：监听<strong>ServletRequest对象</strong>的创建与销毁</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>requestInitialized(ServletRequestEvent sre)</td>
<td>ServletRequest对象创建时调用</td>
</tr>
<tr>
<td>requestDestroyed(ServletRequestEvent sre)</td>
<td>ServletRequest对象销毁时调用</td>
</tr>
</tbody>
</table>
<p>ServletRequestEvent对象代表从HttpServletRequest对象身上捕获到的事件，通过这个事件对象我们可以获取到触发事件的HttpServletRequest对象。另外还有一个方法可以获取到当前Web应用的ServletContext对象。</p>
<h4> ④ServletContextAttributeListener</h4>
<p>作用：监听<strong>ServletContext中属性</strong>的创建、修改和销毁</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>attributeAdded(ServletContextAttributeEvent scab)</td>
<td>向ServletContext中添加属性时调用</td>
</tr>
<tr>
<td>attributeRemoved(ServletContextAttributeEvent scab)</td>
<td>从ServletContext中移除属性时调用</td>
</tr>
<tr>
<td>attributeReplaced(ServletContextAttributeEvent scab)</td>
<td>当ServletContext中的属性被修改时调用</td>
</tr>
</tbody>
</table>
<p>ServletContextAttributeEvent对象代表属性变化事件，它包含的方法如下：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>getName()</td>
<td>获取<strong>修改或添加的属性名</strong></td>
</tr>
<tr>
<td>getValue()</td>
<td>获取<strong>被修改或添加的属性值</strong></td>
</tr>
<tr>
<td>getServletContext()</td>
<td>获取<strong>ServletContext对象</strong></td>
</tr>
</tbody>
</table>
<h4> ⑤HttpSessionAttributeListener</h4>
<p>作用：监听<strong>HttpSession中属性</strong>的创建、修改和销毁</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>attributeAdded(HttpSessionBindingEvent se)</td>
<td>向HttpSession中<strong>添加属性时</strong>调用</td>
</tr>
<tr>
<td>attributeRemoved(HttpSessionBindingEvent se)</td>
<td>从HttpSession中<strong>移除属性时</strong>调用</td>
</tr>
<tr>
<td>attributeReplaced(HttpSessionBindingEvent se)</td>
<td>当HttpSession中的<strong>属性被修改时</strong>调用</td>
</tr>
</tbody>
</table>
<p><strong>HttpSessionBindingEvent对象</strong>代表属性变化事件，它包含的方法如下：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>getName()</td>
<td>获取修改或添加的属性名</td>
</tr>
<tr>
<td>getValue()</td>
<td>获取被修改或添加的属性值</td>
</tr>
<tr>
<td>getSession()</td>
<td>获取触发事件的HttpSession对象</td>
</tr>
</tbody>
</table>
<h4> ⑥ServletRequestAttributeListener</h4>
<p>作用：监听<strong>ServletRequest中属性</strong>的创建、修改和销毁</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>attributeAdded(ServletRequestAttributeEvent srae)</td>
<td>向ServletRequest中添加属性时调用</td>
</tr>
<tr>
<td>attributeRemoved(ServletRequestAttributeEvent srae)</td>
<td>从ServletRequest中移除属性时调用</td>
</tr>
<tr>
<td>attributeReplaced(ServletRequestAttributeEvent srae)</td>
<td>当ServletRequest中的属性被修改时调用</td>
</tr>
</tbody>
</table>
<p>ServletRequestAttributeEvent对象代表属性变化事件，它包含的方法如下：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>getName()</td>
<td>获取修改或添加的属性名</td>
</tr>
<tr>
<td>getValue()</td>
<td>获取被修改或添加的属性值</td>
</tr>
<tr>
<td>getServletRequest ()</td>
<td>获取触发事件的ServletRequest对象</td>
</tr>
</tbody>
</table>
<h4> ⑦HttpSessionBindingListener</h4>
<p>作用：监听某个对象在Session域中的创建与移除</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>valueBound(HttpSessionBindingEvent event)</td>
<td>该类的实例被放到Session域中时调用</td>
</tr>
<tr>
<td>valueUnbound(HttpSessionBindingEvent event)</td>
<td>该类的实例从Session中移除时调用</td>
</tr>
</tbody>
</table>
<p>HttpSessionBindingEvent对象代表属性变化事件，它包含的方法如下：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>getName()</td>
<td>获取当前事件涉及的属性名</td>
</tr>
<tr>
<td>getValue()</td>
<td>获取当前事件涉及的属性值</td>
</tr>
<tr>
<td>getSession()</td>
<td>获取触发事件的HttpSession对象</td>
</tr>
</tbody>
</table>
<h4> ⑧HttpSessionActivationListener</h4>
<p>作用：监听某个对象在Session中的序列化与反序列化。</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>sessionWillPassivate(HttpSessionEvent se)</td>
<td>该类实例和Session一起钝化到硬盘时调用</td>
</tr>
<tr>
<td>sessionDidActivate(HttpSessionEvent se)</td>
<td>该类实例和Session一起活化到内存时调用</td>
</tr>
</tbody>
</table>
<p>HttpSessionEvent对象代表事件对象，通过getSession()方法获取事件涉及的HttpSession对象。</p>
<h3> 4、监听器的使用</h3>
<h4> ①创建监听器类</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> ②注册监听器</h4>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 目前我们进行javaweb项目开发的“套路”是这样的：</h2>
<ol>
<li>
<p>拷贝 myssm包</p>
</li>
<li>
<p>新建配置文件applicationContext.xml或者可以不叫这个名字，在web.xml中指定文件名</p>
</li>
<li>
<p>在web.xml文件中配置：</p>
<ol>
<li>配置前缀和后缀，这样thymeleaf引擎就可以根据我们返回的字符串进行拼接，再跳转</li>
</ol>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2">
<li>配置监听器要读取的参数，目的是加载IOC容器的配置文件（也就是applicationContext.xml）</li>
</ol>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>开发具体的业务模块：<br>
1） 一个具体的业务模块纵向上由几个部分组成：</p>
<ul>
<li>html页面</li>
<li>POJO类</li>
<li>DAO接口和实现类</li>
<li>Service接口和实现类</li>
<li>Controller 控制器组件<br>
2） 如果html页面有thymeleaf表达式，一定不能够直接访问，必须要经过PageController<br>
3） 在applicationContext.xml中配置 DAO、Service、Controller，以及三者之间的依赖关系<br>
4） DAO实现类中 ， 继承BaseDAO，然后实现具体的接口, 需要注意，BaseDAO后面的泛型不能写错。</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>5） Service是业务控制类，这一层我们只需要记住一点：<br>
- 业务逻辑我们都封装在service这一层，不要分散在Controller层。也不要出现在DAO层（我们需要保证DAO方法的单精度特性）<br>
- 当某一个业务功能需要使用其他模块的业务功能时，尽量的调用别人的service，而不是深入到其他模块的DAO细节<br>
6） Controller类的编写规则<br>
① 在applicationContext.xml中配置Controller<br>
&lt;bean id="user" class="com.atguigu.qqzone.controllers.UserController&gt;<br>
那么，用户在前端发请求时，对应的servletpath就是   /user.do   , 其中的“user”就是对应此处的bean的id值<br>
② 在Controller中设计的方法名需要和operate的值一致<br>
public String login(String loginId , String pwd , HttpSession session){<br>
return "index";<br>
}<br>
因此，我们的登录验证的表单如下：<br>
</p><form th:action="@{/user.do}" method="post"><br>
</form></li>
</ol>
<h2> 十一、其他知识</h2>
<h3> 1、cookie</h3>
<p>cookie时客户端保存的一些数据，比如sessioinID<br>
给服务器发请求时，服务器会产生cookie，响应时将cookie带给客户端，客户端将cookie文件保存在本地电脑下</p>
<ol>
<li>
<p>创建Cookie对象</p>
</li>
<li>
<p>在客户端保存Cookie</p>
</li>
<li>
<p>设置Cookie的有效时长</p>
<p>cookie.setMaxAge(60)  ， 设置cookie的有效时长是60秒<br>
cookie.setDomain(pattern);<br>
cookie.setPath(uri);</p>
</li>
<li>
<p>Cookie的应用：<br>
4-1: 记住用户名和密码十天 setMaxAge(60 * 60 * 24 * 10)<br>
4-2: 十天免登录</p>
</li>
</ol>
<p>创建cookie并返回：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>服务器端读取cookie信息</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>cookie的时效性</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2、Kaptcha</h3>
<p>1、验证码的作用：防止机器发送大量请求<br>
2、Kaptcha的使用：<br>
添加jar包<br>
在web.xml文件中注册KaptchaServlet，并设置验证码图片的相关属性<br>
在html页面上编写一个img标签，然后设置src等于KaptchaServlet对应的url-pattern<br>
3、kaptcha验证码图片的各个属性在常量接口：Constants中<br>
4、KaptchaServlet在生成验证码图片时，会同时将验证码信息保存到session中<br>
因此，我们在注册请求时，首先将用户文本框中输入的验证码值和session中保存的值进行比较，相等，则进行注册</p>
<h2> 十二、JavaWeb总结</h2>
<p>java实体类的不同名称</p>
<ul>
<li>POJO：Plain old Java Object，传统的普通的Java对象</li>
<li>entity：实体类</li>
<li>bean或Java bean</li>
<li>domain：领域模型</li>
</ul>
<p>DAO：dao中的方法都是单精度的</p>
<p>Servce：一个业务方法，它对应多个单精度方法，将其封装到service方法中</p>
<p>Controller：主要分为三个部分， 参数获取，服务，资源转发，将部分代码抽取到中央控制器中</p>
<p>IOC容器：层与层之间有耦合，降低耦合，依赖注入，管理对象的生命周期（对bean的组装，添加依赖关系）</p>
<p>filter：设置编码，开启事务，对事务的try-catch</p>
<p>listener：监听上下文启动，在上下文启动的时候去创建IOC容器,然后将其保存到application作用域，后面中央控制器再从application作用域中去获取IOC容器</p>
<p>threadLocal的引入</p>
<p>DispatcherServlet:中央控制器</p>
<h3> MVC各个层的设计</h3>
]]></content:encoded>
      <enclosure url="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220914194924351.png" type="image/png"/>
    </item>
    <item>
      <title>Maven 基础</title>
      <link>https://T4mako.github.io/code/java/Maven%E5%9F%BA%E7%A1%80.html</link>
      <guid>https://T4mako.github.io/code/java/Maven%E5%9F%BA%E7%A1%80.html</guid>
      <source url="https://T4mako.github.io/rss.xml">Maven 基础</source>
      <description>1、Maven概述 1、为什么要学习Maven？ 1、Maven 作为依赖管理工具 ①jar 包的规模 随着我们使用越来越多的框架，或者框架封装程度越来越高，项目中使用的jar包也越来越多。项目中，一个模块里面用到上百个jar包是非常正常的。</description>
      <category>java</category>
      <content:encoded><![CDATA[<h2> 1、Maven概述</h2>
<h3> 1、为什么要学习Maven？</h3>
<h4> 1、Maven 作为依赖管理工具</h4>
<h5> ①jar 包的规模</h5>
<p>随着我们使用越来越多的框架，或者框架封装程度越来越高，项目中使用的jar包也越来越多。项目中，一个模块里面用到上百个jar包是非常正常的。</p>
<!-- more -->
<p>比如下面的例子，我们只用到 SpringBoot、SpringCloud 框架中的三个功能：Nacos 服务注册发现、Web 框架环境、图模板技术 Thymeleaf<br>
最终却导入了 106 个 jar 包</p>
<p>而如果使用 Maven 来引入这些 jar 包只需要配置三个『<strong>依赖</strong>』：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> ②jar 包的来源</h5>
<p>使用 Maven 后，依赖对应的 jar 包能够<strong>自动下载</strong>，方便、快捷又规范</p>
<h5> ③jar 包之间的依赖关系</h5>
<p>框架中使用的 jar 包，不仅数量庞大，而且彼此之间存在错综复杂的依赖关系。依赖关系的复杂程度，已经上升到了完全不能靠人力手动解决的程度。另外，jar 包之间有可能产生冲突。进一步增加了我们在 jar 包使用过程中的难度。</p>
<p>而实际上 jar 包之间的依赖关系是普遍存在的，如果要由程序员手动梳理无疑会增加极高的学习成本，而这些工作又对实现业务功能毫无帮助。</p>
<p><strong>而使用 Maven 则几乎不需要管理这些关系，极个别的地方调整一下即可，极大的减轻了我们的工作量</strong>。</p>
<h4> 2、Maven 作为构建管理工具</h4>
<h5> ①你没有注意过的构建</h5>
<p>你可以不使用 Maven，但是构建必须要做。当我们使用 IDEA 进行开发时，构建是 IDEA 替我们做的。</p>
<h5> ②脱离 IDE 环境仍需构建</h5>
<h4> 结论</h4>
<ul>
<li><strong>管理规模庞大的 jar 包，需要专门工具。</strong></li>
<li><strong>脱离 IDE 环境执行构建操作，需要专门工具。</strong></li>
</ul>
<h3> 2、什么是 Maven？</h3>
<p>Maven 是 Apache 软件基金会组织维护的一款专门为 Java 项目提供<strong>构建</strong>和<strong>依赖</strong>管理支持的工具。</p>
<h4> 1、构建</h4>
<p>Java 项目开发过程中，构建指的是使用**『原材料生产产品』**的过程。<br>
原材料：Java 源代码、基于 HTML 的 Thymeleaf 文件、图片、配置文件等<br>
产品：一个可以在服务器上运行的项目</p>
<p><strong>构建过程</strong>包含的<strong>主要的环节</strong>：<br>
清理：删除上一次构建的结果，为下一次构建做好准备<br>
编译：Java 源程序编译成 *.class 字节码文件<br>
测试：运行提前准备好的测试程序<br>
报告：针对刚才测试的结果生成一个全面的信息<br>
打包：<br>
Java工程：jar包<br>
Web工程：war包<br>
安装：把一个 Maven 工程经过打包操作生成的 jar 包或 war 包存入 Maven 仓库<br>
部署：<br>
部署 jar 包：把一个 jar 包部署到 Nexus 私服服务器上<br>
部署 war 包：借助相关 Maven 插件（例如 cargo），将 war 包部署到 Tomcat 服务器上</p>
<h4> 2、依赖</h4>
<p>如果 A 工程里面用到了 B 工程的类、接口、配置文件等等这样的资源，那么我们就可以说 A 依赖 B。</p>
<p>例如：<br>
junit-4.12 依赖 hamcrest-core-1.3<br>
thymeleaf-3.0.12.RELEASE 依赖 ognl-3.1.26<br>
ognl-3.1.26 依赖 javassist-3.20.0-GA<br>
thymeleaf-3.0.12.RELEASE 依赖 attoparser-2.0.5.RELEASE<br>
thymeleaf-3.0.12.RELEASE 依赖 unbescape-1.1.6.RELEASE<br>
thymeleaf-3.0.12.RELEASE 依赖 slf4j-api-1.7.26</p>
<p>依赖管理中要解决的具体问题：</p>
<ul>
<li>jar 包的下载：使用 Maven 之后，jar 包会从规范的远程仓库下载到本地</li>
<li>jar 包之间的依赖：通过依赖的传递性自动完成</li>
<li>jar 包之间的冲突：通过对依赖的配置进行调整，让某些jar包不会被导入</li>
</ul>
<h4> 3、Maven 的工作机制（关键作战地图）</h4>
<p>核心程序：官网下载的Maven解压<br>
Maven仓库：conf/settings.xml中修改的地址为仓库地址</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221219164435561.png" alt="image-20221219164435561" loading="lazy"></p>
<h2> 2、Maven 核心程序解压和配置</h2>
<h3> 1、Maven核心程序解压与配置</h3>
<h4> 1、Maven 官网地址</h4>
<p>首页：<br>
<a href="https://maven.apache.org/" target="_blank" rel="noopener noreferrer">https://maven.apache.org/</a></p>
<p>下载页面：<br>
<a href="https://maven.apache.org/download.cgi" target="_blank" rel="noopener noreferrer">https://maven.apache.org/download.cgi</a></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221219170219783.png" alt="image-20221219170311882" loading="lazy"></p>
<h4> 2、解压Maven核心程序</h4>
<p>解压到<strong>非中文、没有空格</strong>的目录，在解压目录中，我们需要着重关注 Maven 的核心配置文件：<strong>conf/settings.xml</strong></p>
<h4> 3、指定本地仓库</h4>
<p>本地仓库默认值：用户home目录/.m2/repository。由于本地仓库的默认位置是在用户的家目录下，而家目录往往是在 C 盘，也就是系统盘。将来 Maven 仓库中jar 包越来越多，仓库体积越来越大，可能会拖慢 C 盘运行速度，影响系统性能。所以建议将 Maven 的本地仓库放在其他盘符下。配置方式如下：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>本地仓库这个目录，我们手动创建一个空的目录即可。<br>
<strong>记住</strong>：一定要把 localRepository 标签<strong>从注释中拿出来</strong>。<br>
<strong>注意</strong>：本地仓库本身也需要使用一个<strong>非中文、没有空格</strong>的目录。</p>
<h4> 4、配置阿里云提供的镜像仓库</h4>
<p>Maven 下载 jar 包默认访问境外的中央仓库，而国外网站速度很慢。改成阿里云提供的镜像仓库，<strong>访问国内网站</strong>，可以让 Maven 下载 jar 包的时候速度更快。配置的方式是：</p>
<h6> ①将原有的例子配置注释掉</h6>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h6> ②加入我们的配置</h6>
<p>将下面 mirror 标签整体复制到 settings.xml 文件的 mirrors 标签的内部。</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 5、配置 Maven 工程的基础 JDK 版本</h4>
<p>如果按照默认配置运行，Java 工程使用的默认 JDK 版本是 1.5，而我们熟悉和常用的是 JDK 1.8 版本。修改配置的方式是：将 profile 标签整个复制到 settings.xml 文件的 profiles 标签内。</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2、配置环境变量</h3>
<h4> 1、检查 JAVA_HOME 配置是否正确</h4>
<h4> 2、配置 MAVEN_HOME、PATH</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221219175732833.png" alt="image-20221219175732833" loading="lazy"><br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221219175744782.png" alt="image-20221219175744782" loading="lazy"></p>
<h4> 3、验证</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221219175812570.png" alt="image-20221219175812570" loading="lazy"></p>
<h2> 3、使用 Maven：命令行环境</h2>
<h3> 1、根据坐标创建 Maven 工程</h3>
<h4> 1、向量说明</h4>
<p>在数学中，使用 x、y、z 三个**『向量』<strong>作为空间的坐标系，可以在</strong>『空间』<strong>中唯一的定位到一个</strong>『点』**。</p>
<p><strong>在Maven中</strong>，使用三个**『向量』<strong>在</strong>『Maven的仓库』<strong>中</strong>唯一<strong>的定位到一个</strong>『jar』**包。</p>
<ul>
<li>​	<strong>groupId</strong>：公司或组织的 id</li>
<li>​	<strong>artifactId</strong>：一个项目或者是项目中的一个模块的 id</li>
<li>​	<strong>version</strong>：版本号</li>
</ul>
<h4> 2、三个向量的取值方式</h4>
<p><strong>groupId</strong>：公司或组织域名的倒序，通常也会加上项目名称s<br>
例如：com.atguigu.maven<br>
<strong>artifactId</strong>：模块的名称，将来作为 Maven 工程的工程名<br>
<strong>version</strong>：模块的版本号，根据自己的需要设定<br>
例如：SNAPSHOT 表示快照版本，正在迭代过程中，不稳定的版本<br>
例如：RELEASE 表示正式版本</p>
<p>举例：<br>
groupId：com.atguigu.maven<br>
artifactId：pro01-atguigu-maven<br>
version：1.0-SNAPSHOT</p>
<h4> 3、坐标和仓库中 jar 包的存储路径之间的对应关系</h4>
<p>坐标：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面坐标对应的 jar 包在 Maven 本地仓库中的位置：<br>
<strong>Maven本地仓库根目录</strong>\javax\servlet\servlet-api\2.5\servlet-api-2.5.jar<br>
要学会根据坐标到本地仓库中找到对应的 jar 包</p>
<h4> 4、实验操作</h4>
<h5> ①创建目录作为后面操作的工作空间</h5>
<p>例如：D:\maven-workspace\space201026</p>
<p>此时我们已经有了<strong>三个目录</strong>，分别是：<br>
<strong>Maven 核心程序：中军大帐<br>
Maven 本地仓库：兵营<br>
本地工作空间：战场</strong></p>
<h5> ②在工作空间目录下打开命令行窗口</h5>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221220102348639.png" alt="image-20221220102348639" loading="lazy"></p>
<h5> ③使用命令生成Maven工程</h5>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221220102412287.png" alt="image-20221220102412287" loading="lazy"></p>
<p>下面是运行提示操作：<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221220102451513.png" alt="image-20221220102451513" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221220104454725.png" alt="image-20221220104454725" loading="lazy"></p>
<h5> ④调整</h5>
<p>Maven 默认生成的工程，对 junit 依赖的是较低的 3.8.1 版本，我们可以改成较适合的 4.12 版本。<br>
自动生成的 App.java 和 AppTest.java 可以删除。<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221220104639499.png" alt="image-20221220104639499" loading="lazy"></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> ⑤自动生成的 pom.xml 解读</h5>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 5、Maven核心概念：POM</h4>
<h5> ①含义</h5>
<p>POM：<strong>P</strong>roject <strong>O</strong>bject <strong>M</strong>odel，**项目对象模型。和 POM 类似的是：DOM（Document Object Model），文档对象模型。它们都是模型化思想的具体体现。</p>
<h5> ②模型化思想</h5>
<p>POM 表示将工程抽象为一个模型，再用程序中的对象来描述这个模型。这样我们就可以用程序来管理项目了。我们在开发过程中，最基本的做法就是将现实生活中的事物抽象为模型，然后封装模型相关的数据作为一个对象，这样就可以在程序中计算与现实事物相关的数据。</p>
<h5> ③对应的配置文件</h5>
<p>POM 理念集中体现在 Maven 工程根目录下 <strong>pom.xml</strong> 这个配置文件中。所以这个 pom.xml 配置文件就是 Maven 工程的核心配置文件。其实学习 Maven 就是学这个文件怎么配置，各个配置有什么用。</p>
<h4> 6、Maven核心概念：约定的目录结构</h4>
<h5> ①各个目录的作用</h5>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221220110722929.png" alt="image-20221220110722929" loading="lazy"></p>
<h5> ②约定目录结构的意义</h5>
<p>Maven 为了让构建过程能够尽可能自动化完成，所以必须约定目录结构的作用。例如：Maven 执行编译操作，必须先去 Java 源程序目录读取 Java 源代码，然后执行编译，最后把编译结果存放在 target 目录。</p>
<h5> ③约定大于配置</h5>
<p>Maven 对于目录结构这个问题，没有采用配置的方式，而是基于约定。这样会让我们在开发过程中非常方便。如果每次创建 Maven 工程后，还需要针对各个目录的位置进行详细的配置，那肯定非常麻烦。</p>
<p>目前开发领域的技术发展趋势就是：<strong>约定大于配置，配置大于编码</strong>。</p>
<h3> 2、在 Maven 工程中编写代码</h3>
<h4> 1、主体程序</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221223135339243.png" alt="image-20221223135339243" loading="lazy"></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2、测试程序</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221223140441200.png" alt="image-20221223140441200" loading="lazy"></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3、执行 Maven 的构建命令</h3>
<h4> 1、要求</h4>
<p>运行 Maven 中和构建操作相关的命令时，<strong>必须进入到 pom.xml 所在的目录</strong>。如果没有在 pom.xml 所在的目录运行 Maven 的构建命令，那么会看到下面的错误信息：</p>
<p>The goal you specified requires a project to execute but there is no POM in this directory</p>
<p>（<strong>mvn -v</strong> 命令和构建操作无关，只要正确配置了 PATH，在任何目录下执行都可以。而构建相关的命令要在 pom.xml 所在目录下运行——操作哪个工程，就进入这个工程的 pom.xml 目录。）</p>
<h4> 2、清理操作</h4>
<p><strong>mvn clean</strong><br>
效果：删除 target 目录</p>
<h4> 3、编译操作</h4>
<p>主程序编译：<strong>mvn compile</strong><br>
测试程序编译：<strong>mvn test-compile</strong><br>
主体程序编译结果存放的目录：target/classes<br>
测试程序编译结果存放的目录：target/test-classes</p>
<h4> 4、测试操作</h4>
<p><strong>mvn test</strong><br>
测试的报告存放的目录：target/surefire-reports</p>
<h4> 5、打包操作</h4>
<p><strong>mvn package</strong><br>
打包的结果——jar 包，存放的目录：target</p>
<h4> 6、安装操作</h4>
<p>安装的效果是将本地构建过程中生成的 jar 包存入 Maven 本地仓库。这个 jar 包在 Maven 仓库中的路径是根据它的坐标生成的。</p>
<p><strong>mvn install</strong></p>
<p>坐标信息如下：可以在项目中的pom.xml中查看到</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4、创建 Maven 版的 Web 工程</h3>
<h4> 1、说明</h4>
<p>使用 mvn archetype:generate 命令生成 Web 工程时，需要使用一个专门的 archetype。这个专门生成 Web 工程骨架的 archetype 可以参照官网看到它的用法：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221223142819791.png" alt="image-20221223142819791" loading="lazy"></p>
<h4> 2、操作</h4>
<p>注意：如果在上一个工程的目录下执行 mvn archetype:generate 命令，那么 Maven 会报错：不能在一个非 pom 的工程下再创建其他工程。<br>
所以不要再刚才创建的工程里再创建新的工程，<strong>请回到工作空间根目录</strong>来操作。</p>
<p>然后运行生成工程的命令：<br>
<strong>mvn archetype:generate -DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-webapp -DarchetypeVersion=1.4</strong></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221223143929570.png" alt="image-20221223143929570" loading="lazy"></p>
<h4> 3、生成的pom.xml</h4>
<p>确认打包的方式是war包形式</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 4、生成的Web工程的目录结构</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221223145233465.png" alt="image-20221223145233465" loading="lazy"></p>
<h4> 5、创建 Servlet</h4>
<h5> ①在 main 目录下创建 java 目录</h5>
<h5> ②在 java 目录下创建 Servlet 类所在的包的目录</h5>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221223145558932.png" alt="image-20221223145558932" loading="lazy"></p>
<h5> ③在包下创建 Servlet 类</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> ④在 web.xml 中注册 Servlet</h5>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 6、在 index.jsp 页面编写超链接</h4>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 7、编译</h4>
<p>此时直接执行 <strong>mvn compile</strong> 命令出错：</p>
<p>说明：我们的 Web 工程用到了 HttpServlet 这个类，而 HttpServlet 这个类属于 servlet-api.jar 这个 jar 包。此时我们说，<strong>Web 工程需要依赖 servlet-api.jar</strong> 包。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221223150029811.png" alt="image-20221223150029811" loading="lazy"></p>
<h4> 8、配置对 servlet-api.jar 包的依赖</h4>
<p>对于不知道详细信息的依赖可以到**<a href="https://mvnrepository.com/**%E7%BD%91%E7%AB%99%E6%9F%A5%E8%AF%A2%E3%80%82%E4%BD%BF%E7%94%A8%E5%85%B3%E9%94%AE%E8%AF%8D%E6%90%9C%E7%B4%A2%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9C%A8%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C%E5%88%97%E8%A1%A8%E4%B8%AD%E9%80%89%E6%8B%A9%E9%80%82%E5%90%88%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%82" target="_blank" rel="noopener noreferrer">https://mvnrepository.com/**网站查询。使用关键词搜索，然后在搜索结果列表中选择适合的使用。</a></p>
<p>比如，我们找到的 servlet-api 的依赖信息：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样就可以把上面的信息加入 pom.xml。重新执行 mvn compile 命令。</p>
<h4> 9、将 Web 工程打包为 war 包</h4>
<p>运行 <strong>mvn package</strong> 命令，生成 war 包的位置如下图所示：</p>
<h4> 10、将 war 包部署到 Tomcat 上运行</h4>
<p>将 war 包复制到 Tomcat/webapps 目录下<br>
启动 Tomcat<br>
通过浏览器尝试访问：<a href="http://localhost:8080/pro02-maven-web/index.jsp" target="_blank" rel="noopener noreferrer">http://localhost:8080/pro02-maven-web/index.jsp</a></p>
<h3> 5、让 Web 工程依赖 Java 工程</h3>
<h4> 1、观念</h4>
<p>明确一个意识：从来只有 Web 工程依赖 Java 工程，没有反过来 Java 工程依赖 Web 工程。<br>
本质上来说，Web 工程依赖的 Java 工程其实就是 <strong>Web 工程里导入的 jar 包</strong>。最终 <strong>Java 工程会变成 jar 包，放在 Web 工程的 WEB-INF/lib 目录下</strong>。</p>
<h4> 2、操作</h4>
<p>在 pro02-maven-web 工程的 pom.xml 中，找到 dependencies 标签，在 dependencies 标签中做如下配置：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3、在 Web 工程中，编写测试代码</h4>
<h5> ①补充创建目录</h5>
<p>pro02-maven-web**\src\test\java\com\atguigu\maven**</p>
<h5> ②确认 Web 工程依赖了 junit</h5>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> ③创建测试类</h5>
<p>把 Java 工程的 CalculatorTest.java 类复制到 pro02-maven-web**\src\test\java\com\atguigu\maven** 目录下</p>
<h4> 4、执行Maven命令</h4>
<h5> ①测试命令</h5>
<p><strong>mvn test</strong><br>
说明：测试操作中会提前自动执行编译操作，测试成功就说明编译也是成功的</p>
<h5> ②打包命令</h5>
<p><strong>mvn package</strong><br>
通过查看 war 包内的结构，我们看到被 Web 工程依赖的 Java 工程确实是会变成 Web 工程的 WEB-INF/lib 目录下的 jar 包。</p>
<h5> ③查看当前 Web 工程所依赖的 jar 包的列表</h5>
<p><strong>mvn dependency:list</strong></p>
<p>说明：javax.servlet:javax.servlet-api:jar:3.1.0:provided 格式显示的是一个 jar 包的坐标信息。<br>
格式是：<strong>groupId:artifactId:打包方式:version:依赖的范围</strong></p>
<p>这样的格式虽然和我们 XML 配置文件中坐标的格式不同，但是本质上还是坐标信息，大家需要能够认识这样的格式，将来从 Maven 命令的日志或错误信息中看到这样格式的信息，就<strong>能够识别出来这是坐标</strong>。进而<strong>根据坐标到Maven 仓库找到对应的jar包</strong>，用这样的方式解决我们遇到的报错的情况。</p>
<h5> ④以树形结构查看当前 Web 工程的依赖信息</h5>
<p><strong>mvn dependency:tree</strong></p>
<p>我们在 pom.xml 中并没有依赖 hamcrest-core，但是它却被加入了我们依赖的列表。原因是：junit 依赖了hamcrest-core，然后基于依赖的传递性，hamcrest-core 被传递到我们的工程了。</p>
<h3> 6、测试依赖的范围</h3>
<h4> 1、依赖范围</h4>
<p>标签的位置：<strong>dependencies/dependency/scope</strong><br>
标签的可选值：<strong>compile</strong>、<strong>test</strong>、<strong>provided</strong>、system、runtime、<strong>import</strong></p>
<h4> ①compile 和 test 对比</h4>
<table>
<thead>
<tr>
<th></th>
<th>main目录（空间）</th>
<th>test目录（空间）</th>
<th>开发过程（时间）</th>
<th>部署到服务器（时间）</th>
</tr>
</thead>
<tbody>
<tr>
<td>compile</td>
<td>有效</td>
<td>有效</td>
<td>有效</td>
<td>有效</td>
</tr>
<tr>
<td>test</td>
<td>无效</td>
<td>有效</td>
<td>有效</td>
<td>无效</td>
</tr>
</tbody>
</table>
<h4> ②compile 和 provided 对比</h4>
<table>
<thead>
<tr>
<th></th>
<th>main目录（空间）</th>
<th>test目录（空间）</th>
<th>开发过程（时间）</th>
<th>部署到服务器（时间）</th>
</tr>
</thead>
<tbody>
<tr>
<td>compile</td>
<td>有效</td>
<td>有效</td>
<td>有效</td>
<td>有效</td>
</tr>
<tr>
<td>provided</td>
<td>有效</td>
<td>有效</td>
<td>有效</td>
<td>无效</td>
</tr>
</tbody>
</table>
<h4> ③结论</h4>
<p><strong>compile</strong>：通常使用的第三方框架的 jar 包这样在项目实际运行时真正要用到的 jar 包都是以 compile 范围进行依赖的。比如 SSM 框架所需jar包。<br>
<strong>test</strong>：测试过程中使用的 jar 包，以 test 范围依赖进来。比如 junit。<br>
<strong>provided</strong>：在开发过程中需要用到的“服务器上的 jar 包”通常以 provided 范围依赖进来。比如 servlet-api、jsp-api。而这个范围的 jar 包之所以不参与部署、不放进 war 包，就是避免和服务器上已有的同类 jar 包产生冲突，同时减轻服务器的负担。说白了就是：“<strong>服务器上已经有了，你就别带啦！</strong>”</p>
<h3> 7、测试依赖的传递性</h3>
<h4> 1、依赖的传递性</h4>
<h5> ①概念</h5>
<p>A 依赖 B，B 依赖 C，那么在 A 没有配置对 C 的依赖的情况下，A 里面能不能直接使用 C？</p>
<h5> ②传递的原则</h5>
<p>在 A 依赖 B，B 依赖 C 的前提下，C 是否能够传递到 A，取决于 B 依赖 C 时使用的依赖范围。</p>
<ul>
<li><strong>B 依赖 C 时使用 compile 范围：可以传递</strong></li>
<li><strong>B 依赖 C 时使用 test 或 provided 范围：不能传递，所以需要这样的 jar 包时，就必须在需要的地方明确配置依赖才可以。</strong></li>
</ul>
<h4> 2、使用 compile 范围依赖 spring-core</h4>
<p>测试方式：让 pro01-maven-java 工程依赖 spring-core<br>
具体操作：编辑 pro01-maven-java 工程根目录下 pom.xml</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 mvn dependency:tree 命令查看效果：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221224141350567.png" alt="image-20221224141350567" loading="lazy"></p>
<p>还可以在 Web 工程中，使用 mvn dependency:tree 命令查看效果（需要重新将 pro01-maven-java 安装到仓库）：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221224141403153.png" alt="image-20221224141403153" loading="lazy"></p>
<h4> 3、验证 test 和 provided 范围不能传递</h4>
<p>从上面的例子已经能够看到，pro01-maven-java 依赖了 junit，但是在 pro02-maven-web 工程中查看依赖树的时候并没有看到 junit。<br>
要验证 provided 范围不能传递，可以在 pro01-maven-java 工程中加入 servlet-api 的依赖。</p>
<h3> 8、测试依赖的排除</h3>
<h4> 1、概念</h4>
<p>当 A 依赖 B，B 依赖 C 而且 C 可以传递到 A 的时候，A 不想要 C，需要在 A 里面把 C 排除掉。而往往这种情况都是为了避免 jar 包之间的冲突。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221224142134353.png" alt="image-20221224142134353" loading="lazy"></p>
<p>所以配置依赖的排除其实就是阻止某些 jar 包的传递。因为这样的 jar 包传递过来会和其他 jar 包冲突。</p>
<h4> 2、配置方式</h4>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3、测试</h4>
<p>测试的方式：在 pro02-maven-web 工程中配置对 commons-logging 的排除<br>
运行 mvn dependency:tree 命令查看效果，发现在 spring-core 下面就没有 commons-logging 了。<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221224150708267.png" alt="image-20221224150708267" loading="lazy"></p>
<h3> 9、继承</h3>
<h4> 1、概念</h4>
<p>Maven工程之间，A 工程继承 B 工程<br>
B 工程：父工程<br>
A 工程：子工程<br>
本质上是 A 工程的 pom.xml 中的配置继承了 B 工程中 pom.xml 的配置。</p>
<h4> 2、作用</h4>
<p>在父工程中统一管理项目中的依赖信息，具体来说是管理依赖信息的版本。</p>
<p>它的背景是：</p>
<ul>
<li>对一个比较大型的项目进行了模块拆分。</li>
<li>一个 project 下面，创建了很多个 module。</li>
<li><strong>每一个 module 都需要配置自己的依赖信息</strong>。</li>
</ul>
<p>它背后的需求是：</p>
<ul>
<li>在每一个 module 中各自维护各自的依赖信息很容易发生出入，不易统一管理。</li>
<li>使用同一个框架内的不同 jar 包，它们应该是同一个版本，所以<strong>整个项目中使用的框架版本需要统一</strong>。</li>
<li>使用框架时所需要的 jar 包组合（或者说依赖信息组合）需要经过长期摸索和反复调试，最终确定一个可用组合。这个耗费很大精力总结出来的方案不应该在新的项目中重新摸索。</li>
</ul>
<p>通过在父工程中为整个项目维护依赖信息的组合既<strong>保证了整个项目使用规范、准确的 jar 包</strong>；又能够将<strong>以往的经验沉淀</strong>下来，节约时间和精力。</p>
<h4> 3、举例</h4>
<p>在一个工程中依赖多个 Spring 的 jar 包</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221224151906558.png" alt="image-20221224151906558" loading="lazy"></p>
<p>使用 Spring 时要求所有 Spring 自己的 jar 包版本必须一致。为了能够对这些 jar 包的版本进行统一管理，我们使用继承这个机制，将所有版本信息统一在父工程中进行管理。</p>
<h4> 4、操作</h4>
<h5> ①创建父工程</h5>
<p>创建的过程和前面创建 pro01-maven-java 一样。<br>
工程名称：pro03-maven-parent<br>
工程创建好之后，要修改它的打包方式：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>只有打包方式为 pom 的 Maven 工程能够管理其他 Maven 工程。打包方式为 pom 的 Maven 工程中不写业务代码，它是专门管理其他 Maven 工程的工程。</strong></p>
<h5> ②创建模块工程</h5>
<p>模块工程类似于 IDEA 中的 module，所以需要<strong>进入 pro03-maven-parent 工程的根目录</strong>，然后运行 mvn archetype:generate 命令来创建模块工程。</p>
<p>假设，我们创建三个模块工程：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221224155634597.png" alt="image-20221224155634597" loading="lazy"></p>
<h5> ③查看被添加新内容的父工程 pom.xml</h5>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> ④解读子工程的pom.xml</h5>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> ⑤在父工程中配置依赖的统一管理</h5>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> ⑥子工程中引用那些被父工程管理的依赖</h5>
<p>关键点：省略版本号</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> ⑦在父工程中升级依赖信息的版本</h5>
<p><strong>一处修改，处处生效</strong></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在子工程中运行mvn dependency:list:<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221224160911927.png" alt="image-20221224160911927" loading="lazy"></p>
<h5> ⑧在父工程中声明自定义属性</h5>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在需要的地方使用${}的形式来引用自定义的属性名：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>真正实现“一处修改，处处生效”。</strong></p>
<h4> 5、实际意义</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221224160950881.png" alt="image-20221224160950881" loading="lazy"></p>
<p>编写一套符合要求、开发各种功能都能正常工作的依赖组合并不容易。如果公司里已经有人总结了成熟的组合方案，那么再开发新项目时，如果不使用原有的积累，而是重新摸索，会浪费大量的时间。为了提高效率，我们可以使用工程继承的机制，让成熟的依赖组合方案能够保留下来。</p>
<p>如上图所示，公司级的父工程中管理的就是成熟的依赖组合方案，各个新项目、子系统各取所需即可。</p>
<h3> 10、聚合</h3>
<h4> 1、聚合本身的含义</h4>
<p>部分组成整体动画片《战神金刚》中的经典台词：“我来组成头部！我来组成手臂！”就是聚合关系最生动的体现。</p>
<h4> 2、Maven 中的聚合</h4>
<p>使用一个“总工程”将各个“模块工程”汇集起来，作为一个整体对应完整的项目。</p>
<ul>
<li>项目：整体</li>
<li>模块：部分</li>
</ul>
<h4> 3、好处</h4>
<ul>
<li>
<p>一键执行 Maven 命令：很多构建命令都可以在“总工程”中一键执行。</p>
<p>以 mvn install 命令为例：Maven 要求有父工程时先安装父工程；有依赖的工程时，先安装被依赖的工程。我们自己考虑这些规则会很麻烦。但是工程聚合之后，在总工程执行 mvn install 可以一键完成安装，而且会自动按照正确的顺序执行。</p>
</li>
<li>
<p>配置聚合之后，各个模块工程会在总工程中展示一个列表，让项目中的各个模块一目了然。</p>
</li>
</ul>
<h4> 4、聚合的配置</h4>
<p>在总工程中配置 modules 即可：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 5、依赖循环问题</h4>
<p>如果 A 工程依赖 B 工程，B 工程依赖 C 工程，C 工程又反过来依赖 A 工程，那么在执行构建操作时会报下面的错误</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221224165432357.png" alt="image-20221224165432357" loading="lazy"></p>
<p>这个错误的含义是：循环引用。</p>
<h2> 4、使用Maven：IDEA环境</h2>
<h3> 1、创建父工程</h3>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225133658424.png" alt="image-20221225133658424" loading="lazy"></p>
<p>更改坐标位置</p>
<h3> 2、配置自己的Maven</h3>
<p><strong>每次创建 Project 后都需要设置 Maven 家目录位置</strong>，否则 IDEA 将使用内置的 Maven 核心程序（不稳定）并使用默认的本地仓库位置。这样一来，我们在命令行操作过程中已下载好的 jar 包就白下载了，默认的本地仓库通常在 C 盘，还影响系统运行。</p>
<p>配置之后，IDEA 会根据我们在这里指定的 Maven 家目录自动识别到我们在 settings.xml 配置文件中指定的本地仓库。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225133749426.png" alt="image-20221225133805324" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225133848797.png" alt="image-20221225133848797" loading="lazy"></p>
<h3> 3 、建Java模块工程</h3>
<p>选中项目，如上所述新建mavne模块</p>
<h3> 4、创建Web模块工程</h3>
<h4> 1、创建模块</h4>
<p>按照前面的同样操作创建模块，<strong>此时</strong>这个模块其实还是一个<strong>Java模块</strong>。</p>
<h4> 2、修改打包方式</h4>
<p>Web 模块将来打包当然应该是 <strong>war</strong> 包。</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 3、Web 设定</h4>
<p>首先打开项目结构菜单<br>
然后到 Facets 下查看 IDEA 是否已经帮我们自动生成了 Web 设定。没有就刷新一下右侧Maven</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225144820574.png" alt="image-20221225144820574" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225144830175.png" alt="image-20221225144830175" loading="lazy"></p>
<h4> 4、借助IDEA生成web.xml</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225145439907.png" alt="image-20221225145439907" loading="lazy"></p>
<h3> 5、其他操作</h3>
<h4> 1、在IDEA中执行Maven命令</h4>
<h5> ①直接执行</h5>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225140022531.png" alt="image-20221225140022531" loading="lazy"></p>
<h5> ②手动输入</h5>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225140043534.png" alt="image-20221225140043534" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225140057743.png" alt="image-20221225140057743" loading="lazy"></p>
<p>如果有需要，还可以给命令后面附加参数：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225140111847.png" alt="image-20221225140111847" loading="lazy"></p>
<h4> 2、在IDEA中查看某个模块的依赖信息</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225145515526.png" alt="image-20221225145515526" loading="lazy"></p>
<h4> 3、工程导入</h4>
<p>Maven工程除了自己创建的，还有很多情况是别人创建的。而为了参与开发或者是参考学习，我们都需要导入到 IDEA 中。下面我们分几种不同情况来说明：</p>
<h5> ①来自版本控制系统</h5>
<p>目前我们通常使用的都是 Git（本地库） + 码云（远程库）的版本控制系统，结合 IDEA 的相关操作方式请点<a href="http://heavy_code_industry.gitee.io/code_heavy_industry/pro008-Git/lecture/chapter05/verse03.html" target="_blank" rel="noopener noreferrer"><strong>这里</strong> (opens new window)</a>查看<strong>克隆远程库</strong>部分。</p>
<h5> ②来自工程目录</h5>
<p>直接使用 IDEA 打开工程目录即可。下面咱们举个例子：</p>
<h6> [1]工程压缩包</h6>
<p>假设别人发给我们一个 Maven 工程的 zip 压缩包：maven-rest-demo.zip。从码云或GitHub上也可以以 ZIP 压缩格式对项目代码打包下载。</p>
<h6> [2]解压</h6>
<p>如果你的所有 IDEA 工程有一个专门的目录来存放，而不是散落各处，那么首先我们就把 ZIP 包解压到这个指定目录中</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225145758877.png" alt="image-20221225145758877" loading="lazy"></p>
<h6> [3]打开</h6>
<p>只要我们确认在解压目录下可以直接看到 pom.xml，那就能证明这个解压目录就是我们的工程目录。那么接下来让 IDEA 打开这个目录就可以了。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225145843999.png" alt="image-20221225145843999" loading="lazy"></p>
<h6> [4]设置 Maven 核心程序位置</h6>
<p>打开一个新的 Maven 工程，和新创建一个 Maven 工程是一样的，此时 IDEA 的 settings 配置中关于 Maven 仍然是默认值：<br>
所以我们还是需要像新建 Maven 工程那样，指定一下 Maven 核心程序位置：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225145915064.png" alt="image-20221225145915064" loading="lazy"></p>
<h4> 4、模块导入</h4>
<h5> 1、导入 Java 类型模块</h5>
<p>复制我们想要导入的模块目录，粘贴到我们自己工程目录下</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225151023482.png" alt="image-20221225151023482" loading="lazy"></p>
<p>在 IDEA 中执行导入</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225151044681.png" alt="image-20221225151044681" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225151055554.png" alt="image-20221225151055554" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225151309080.png" alt="image-20221225151309080" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225151316718.png" alt="image-20221225151316718" loading="lazy"></p>
<p>修改 pom.xml<br>
刚刚导入的 module 的父工程坐标还是以前的，需要改成我们自己的 project。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225151337073.png" alt="image-20221225151337073" loading="lazy"></p>
<h5> 2、导入 Web 类型模块</h5>
<p>其它操作和上面演示的都一样，只是多一步：删除多余的、不正确的 web.xml 设置。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225151411493.png" alt="image-20221225151411493" loading="lazy"></p>
<h2> 5、其他核心概念</h2>
<h3> 1、生命周期</h3>
<h4> ①作用</h4>
<p>为了让构建过程自动化完成，Maven 设定了三个生命周期，生命周期中的每一个环节对应构建过程中的一个操作。</p>
<h4> ②三个生命周期</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225152742410.png" alt="image-20221225152742410" loading="lazy"></p>
<h4> ③特点</h4>
<ul>
<li>前面三个生命周期彼此是独立的。</li>
<li>在任何一个生命周期内部，执行任何一个具体环节的操作，都是<strong>从本周期最初的位置开始执行，直到指定的地方</strong>。（本节记住这句话就行了，其他的都不需要记）</li>
</ul>
<p>Maven 之所以这么设计其实就是为了提高构建过程的自动化程度：让使用者只关心最终要干的即可，过程中的各个环节是自动执行的。</p>
<h3> 2、插件和目标</h3>
<h4> ①插件</h4>
<p>Maven 的核心程序仅仅负责宏观调度，不做具体工作。<strong>具体工作都是由 Maven 插件完成的</strong>。例如：编译就是由 maven-compiler-plugin-3.1.jar 插件来执行的。</p>
<h4> ②目标</h4>
<p>一个插件可以对应多个目标，而每一个目标都和生命周期中的某一个环节对应。</p>
<p>Default 生命周期中有 compile 和 test-compile 两个和编译相关的环节，这两个环节对应 compile 和 test-compile 两个目标，而这两个目标都是由 maven-compiler-plugin-3.1.jar 插件来执行的。</p>
<h3> 3、仓库</h3>
<ul>
<li>本地仓库：在当前电脑上，为电脑上所有 Maven 工程服务</li>
<li>远程仓库：需要联网
<ul>
<li>局域网：我们自己搭建的 Maven 私服，例如使用 Nexus 技术。</li>
<li>Internet
<ul>
<li>中央仓库</li>
<li>镜像仓库：内容和中央仓库保持一致，但是能够分担中央仓库的负载，同时让用户能够就近访问提高下载速度，例如：Nexus aliyun</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>建议：不要中央仓库和阿里云镜像混用，否则 jar 包来源不纯，彼此冲突。</p>
<p>专门搜索 Maven 依赖信息的网站：<a href="https://mvnrepository.com/" target="_blank" rel="noopener noreferrer">https://mvnrepository.com/</a></p>
]]></content:encoded>
    </item>
  </channel>
</rss>