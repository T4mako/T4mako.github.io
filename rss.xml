<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://T4mako.github.io/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://T4mako.github.io/rss.xml" rel="self" type="application/rss+xml"/>
    <title>T4mako</title>
    <link>https://T4mako.github.io/</link>
    <description>T4mako</description>
    <language>zh-CN</language>
    <pubDate>Mon, 20 Nov 2023 15:26:52 GMT</pubDate>
    <lastBuildDate>Mon, 20 Nov 2023 15:26:52 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>算法</category>
    <category>多线程</category>
    <category>java</category>
    <category>MySQL</category>
    <category>SQL</category>
    <category>Vue</category>
    <category>部署</category>
    <category>MarkDown</category>
    <category>基础</category>
    <category>基础知识</category>
    <category>Docker</category>
    <category>Linux</category>
    <category>AE</category>
    <item>
      <title>160. 相交链表</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_160_%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_160_%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8.html</guid>
      <source url="https://T4mako.github.io/rss.xml">160. 相交链表</source>
      <description>160. 相交链表</description>
      <category>算法</category>
      <pubDate>Fri, 03 Nov 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 160. 相交链表</h1>
]]></content:encoded>
    </item>
    <item>
      <title>多线程练习</title>
      <link>https://T4mako.github.io/code/leetcode/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B.html</guid>
      <source url="https://T4mako.github.io/rss.xml">多线程练习</source>
      <description>多线程练习 leetcode 1114. 按序打印 题目：https://leetcode.cn/problems/print-in-order/description/ 方法一：使用 while 循环 class Foo { private AtomicInteger firstJobDone = new AtomicInteger(0); private AtomicInteger secondJobDone = new AtomicInteger(0); public Foo() {} public void first(Runnable printFirst) throws InterruptedException { // printFirst.run() outputs &amp;quot;first&amp;quot;. printFirst.run(); // mark the first job as done, by increasing its count. firstJobDone.incrementAndGet(); } public void second(Runnable printSecond) throws InterruptedException { while (firstJobDone.get() != 1) { // waiting for the first job to be done. } // printSecond.run() outputs &amp;quot;second&amp;quot;. printSecond.run(); // mark the second as done, by increasing its count. secondJobDone.incrementAndGet(); } public void third(Runnable printThird) throws InterruptedException { while (secondJobDone.get() != 1) { // waiting for the second job to be done. } // printThird.run() outputs &amp;quot;third&amp;quot;. printThird.run(); } }</description>
      <category>多线程</category>
      <pubDate>Thu, 02 Nov 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 多线程练习</h1>
<h3> leetcode 1114. 按序打印</h3>
<p>题目：<a href="https://leetcode.cn/problems/print-in-order/description/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/print-in-order/description/</a></p>
<h4> 方法一：使用 while 循环</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 方法二：使用锁 + wait</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 方法三：使用信号量</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>141. 环形链表</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_141_%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_141_%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8.html</guid>
      <source url="https://T4mako.github.io/rss.xml">141. 环形链表</source>
      <description>141. 环形链表 解法一：Set 存储 public class Solution { public boolean hasCycle(ListNode head) { HashSet&amp;lt;ListNode&amp;gt; set = new HashSet&amp;lt;&amp;gt;(); while (head != null){ if(!set.add(head)) return true; // add() 未添加成功返回 false head = head.next; } return false; } }</description>
      <category>算法</category>
      <pubDate>Sat, 28 Oct 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 141. 环形链表</h1>
<h2> 解法一：Set 存储</h2>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 解法二：快慢指针</h2>
<p>定义一个快指针一个慢指针，如果有环，快指针和满指正会相遇</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>234. 回文链表</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_234_%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_234_%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8.html</guid>
      <source url="https://T4mako.github.io/rss.xml">234. 回文链表</source>
      <description>234. 回文链表</description>
      <category>算法</category>
      <pubDate>Fri, 27 Oct 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 234. 回文链表</h1>
]]></content:encoded>
    </item>
    <item>
      <title>1318. 或运算的最小翻转次数</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1318_%E6%88%96%E8%BF%90%E7%AE%97%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BF%BB%E8%BD%AC%E6%AC%A1%E6%95%B0.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1318_%E6%88%96%E8%BF%90%E7%AE%97%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BF%BB%E8%BD%AC%E6%AC%A1%E6%95%B0.html</guid>
      <source url="https://T4mako.github.io/rss.xml">1318. 或运算的最小翻转次数</source>
      <description>1318. 或运算的最小翻转次数</description>
      <category>算法</category>
      <pubDate>Thu, 14 Sep 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 1318. 或运算的最小翻转次数</h1>
]]></content:encoded>
    </item>
    <item>
      <title>SpringBoot 常用注解总结</title>
      <link>https://T4mako.github.io/code/java/SpringBoot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%80%BB%E7%BB%93.html</link>
      <guid>https://T4mako.github.io/code/java/SpringBoot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%80%BB%E7%BB%93.html</guid>
      <source url="https://T4mako.github.io/rss.xml">SpringBoot 常用注解总结</source>
      <description>参考：https://javaguide.cn/system-design/framework/spring/spring-common-annotations.html 一、 @SpringBootApplication 这个注解是 Spring Boot 项目的基石，创建 SpringBoot 项目之后会默认在主类加上。</description>
      <category>java</category>
      <pubDate>Tue, 12 Sep 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>参考：<a href="https://javaguide.cn/system-design/framework/spring/spring-common-annotations.html" target="_blank" rel="noopener noreferrer">https://javaguide.cn/system-design/framework/spring/spring-common-annotations.html</a></p>
<h2> 一、 @SpringBootApplication</h2>
<p>这个注解是 Spring Boot 项目的基石，创建 SpringBoot 项目之后会默认在主类加上。</p>
<p>我们可以把 <code>@SpringBootApplication</code> 看作是 <code>@Configuration</code> + <code>@EnableAutoConfiguration</code> + <code>@ComponentScan</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>根据 SpringBoot 官网，这三个注解的作用分别是：</p>
<ul>
<li><code>@EnableAutoConfiguration</code>：启用 SpringBoot 的自动配置机制</li>
<li><code>@ComponentScan</code>：扫描被 @Component 注解的 bean，注解默认会扫描该类所在的<strong>包下所有的类</strong>。</li>
<li><code>@Configuration</code>：允许在 Spring 上下文中注册额外的 bean 或导入其他配置类</li>
</ul>
<h2> 二、Spring Bean 相关</h2>
<h3> 2.1 @Autowired</h3>
<p>一般使用<code> @Autowired</code> 注解让 Spring 容器帮我们自动装配 bean。</p>
<h3> 2.2 @Component 相关</h3>
<p>要想把类标识成可用于 @Autowired 注解自动装配的 bean 的类，可以采用以下注解：</p>
<ul>
<li><code>@Component</code>：通用的注解</li>
<li><code>@Repository</code>：持久层即 Dao 层，主要用于数据库相关操作</li>
<li><code>@Service</code>：服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层</li>
<li><code>@Controller</code>：控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面</li>
</ul>
<h3> 2.3 @RestController</h3>
<p><code>@RestController</code> = <code>@Controller</code> + <code>@ResponseBody</code><br>
表示这是个控制器 bean，并且是将函数的返回值直接填入 HTTP 响应体中，是 REST 风格的控制器。</p>
<h3> 2.4 @Scope</h3>
<p>声明 Spring Bean 的作用域，使用方法:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>四种常见的 Spring Bean 的作用域：</p>
<ul>
<li>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li>
<li>prototype : 每次请求都会创建一个新的 bean 实例。</li>
<li>request : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li>
<li>session : 每一个 HTTP Session 会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li>
</ul>
<h3> 2.5 @Configuration</h3>
<p>一般用来声明 <strong>配置类</strong> ，可以使用 @Component 注解替代，不过使用 @Configuration 注解声明配置类更加语义化。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 三、 处理常见的 HTTP 请求类型</h2>
<p>5 种常见的请求类型:</p>
<ul>
<li>GET：请求从服务器获取特定资源。</li>
<li>POST：在服务器上创建一个新的资源。</li>
<li>PUT：更新服务器上的资源（客户端提供更新后的整个资源）。</li>
<li>DELETE：从服务器删除特定的资源。</li>
<li>PATCH：更新服务器上的资源（客户端提供更改的属性，可以看做作是部分更新）。</li>
</ul>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p><code>@GetMapping("users")</code> 等价于 <code>@RequestMapping(value="/users",method=RequestMethod.GET)</code></p>
<p><code>@PostMapping("users")</code> 等价于 <code>@RequestMapping(value="/users",method=RequestMethod.POST)</code></p>
<p><code>@PutMapping("/users/{userId}")</code> 等价于 <code>@RequestMapping(value="/users/{userId}",method=RequestMethod.PUT)</code></p>
<p><code>@DeleteMapping("/users/{userId}")</code> 等价于 <code>@RequestMapping(value="/users/{userId}",method=RequestMethod.DELETE)</code></p>
<p>一般实际项目中，我们都是 PUT 不够用了之后才用 PATCH 请求去更新数据。<br>
<code>@PatchMapping("/profile")</code></p>
</div>
<h2> 四、 前后端传值</h2>
<h3> 4.1 @PathVariable 和 @RequestParam</h3>
<p><code>@PathVariable</code> 用于获取路径参数</p>
<p><code>@RequestParam</code> 用于获取查询参数。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>若请求的 url 是：/classes/123456/teachers?type=web<br>
则获取到的数据就是：classId=123456,type=web。</p>
<h3> 4.2 @RequestBody</h3>
<p>用于读取 Request 请求（可能是 POST,PUT,DELETE,GET 请求）的 body 部分并且 Content-Type 为 application/json 格式的数据<br>
接收到数据之后会自动将数据绑定到 Java 对象上去。系统会使用 <code>HttpMessageConverter</code> 或者自定义的 <code>HttpMessageConverter</code> 将请求的 body 中的 json 字符串转换为 java 对象。</p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>一个请求方法只可以有一个 @RequestBody，但是可以有多个 @RequestParam 和 @PathVariable。<br>
如果你的方法必须要用两个 @RequestBody 来接受数据的话，大概率是你的数据库设计或者系统设计出问题了！</p>
</div>
<h2> 五、 读取配置信息</h2>
<p>很多时候我们需要将一些常用的配置信息比如阿里云 oss、发送短信、微信认证的相关配置信息等等放到配置文件中。</p>
<p>Spring 为我们提供从配置文件中读取这些配置信息的方式如下。</p>
<p>假设数据源 <code>application.yml</code> 内容如下：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5.1 @Value（常用）</h3>
<p>使用 <code>@Value("${property}")</code> 读取比较简单的配置信息：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5.2 @ConfigurationProperties（常用）</h3>
<p>通过 <code>@ConfigurationProperties</code> 读取配置信息并与 bean 绑定。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以像使用普通的 Spring bean 一样，将其注入到类中使用</p>
<h3> 5.3 @PropertySource（不常用）</h3>
<p><code>@PropertySource</code> 读取指定 properties 文件</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 六、 参数校验</h2>
<p>JSR（Java Specification Requests） 是一套 JavaBean 参数校验的标准，它定义了很多常用的校验注解，我们可以直接将这些注解加在 JavaBean 的属性上面，这样就可以在需要校验的时候进行校验了</p>
<p>校验的时候我们实际用的是 Hibernate Validator 框架。<br>
SpringBoot 项目的 spring-boot-starter-web 依赖中已经有 hibernate-validator 包，不需要引用相关依赖。</p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>需要注意的是：<br>
所有的注解，推荐使用 JSR 注解，即 <code>javax.validation.constraints</code>，而不是 org.hibernate.validator.constraints</p>
</div>
<h3> 6.1 一些常用的字段验证的注解</h3>
<table>
<thead>
<tr>
<th>注解</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>@NotEmpty</td>
<td>被注释的字符串的不能为 null 也不能为空</td>
</tr>
<tr>
<td>@NotBlank</td>
<td>被注释的字符串非 null，并且必须包含一个非空白字符</td>
</tr>
<tr>
<td>@Null</td>
<td>被注释的元素必须为 null</td>
</tr>
<tr>
<td>@NotNull</td>
<td>被注释的元素必须不为 null</td>
</tr>
<tr>
<td>@AssertTrue</td>
<td>被注释的元素必须为 true</td>
</tr>
<tr>
<td>@AssertFalse</td>
<td>被注释的元素必须为 false</td>
</tr>
<tr>
<td>@Pattern(regex=,flag=)</td>
<td>被注释的元素必须符合指定的正则表达式</td>
</tr>
<tr>
<td>@Email</td>
<td>被注释的元素必须是 Email 格式</td>
</tr>
<tr>
<td>@Min(value)</td>
<td>被注释的元素必须是 &gt;= value 的数字</td>
</tr>
<tr>
<td>@Max(value)</td>
<td>被注释的元素必须是 &lt;= value 的数字</td>
</tr>
<tr>
<td>@DecimalMin(value)</td>
<td>被注释的元素必须是 &gt;= value 的数字</td>
</tr>
<tr>
<td>@DecimalMax(value)</td>
<td>被注释的元素必须是 &lt;= value 的数字</td>
</tr>
<tr>
<td>@Size(max=, min=)</td>
<td>被注释的元素的大小必须在指定的范围内</td>
</tr>
<tr>
<td>@Digits(integer, fraction)</td>
<td>被注释的元素必须是一个数字，其值必须在可接受的范围内</td>
</tr>
<tr>
<td>@Past</td>
<td>被注释的元素必须是一个过去的日期</td>
</tr>
<tr>
<td>@Future</td>
<td>被注释的元素必须是一个将来的日期</td>
</tr>
</tbody>
</table>
<h3> 6.2 验证请求体（RequestBody）</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在需要验证的参数上加上了 <code>@Valid</code> 注解，如果验证失败，它将抛出 <code>MethodArgumentNotValidException</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6.3 验证请求参数（Path Variables 和 Request Parameters）</h3>
<p>在类上加上 <code>@Validated</code> 注解，这个参数可以告诉 Spring 去校验方法参数</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 七、 全局处理 Controller 层异常</h2>
<p>Spring 项目必备全局处理 Controller 层异常</p>
<ul>
<li><code>@ControllerAdvice</code>：注解定义全局异常处理类</li>
<li><code>@ExceptionHandler</code>：注解声明异常处理方法</li>
</ul>
<p>以参数校验这块举例子。如果方法参数不对的话就会抛出 <code>MethodArgumentNotValidException</code>，我们来处理这个异常。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485568&amp;idx=2&amp;sn=c5ba880fd0c5d82e39531fa42cb036ac&amp;chksm=cea2474bf9d5ce5dcbc6a5f6580198fdce4bc92ef577579183a729cb5d1430e4994720d59b34&amp;token=2133161636&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">SpringBoot 处理异常的几种常见姿势</a><br>
<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247486379&amp;idx=2&amp;sn=48c29ae65b3ed874749f0803f0e4d90e&amp;chksm=cea24460f9d5cd769ed53ad7e17c97a7963a89f5350e370be633db0ae8d783c3a3dbd58c70f8&amp;token=1054498516&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">使用枚举简单封装一个优雅的 Spring Boot 全局异常处理</a></p>
<h2> 八、JPA 相关</h2>
<p>(Spring Data JPA)[<a href="https://spring.io/projects/spring-data-jpa#overview" target="_blank" rel="noopener noreferrer">https://spring.io/projects/spring-data-jpa#overview</a>]</p>
<h3> 8.1 创建表</h3>
<ul>
<li><code>@Entity</code> 声明一个类对应一个数据库实体</li>
<li><code>@Table</code> 设置表名</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8.2 创建主键</h3>
<ul>
<li><code>@Id</code>：声明一个字段为主键。声明后还需要定义主键的生成策略。</li>
</ul>
<h4> @GeneratedValue 生成</h4>
<p><code>@GeneratedValue</code> 直接使用 JPA 内置提供的四种主键生成策略来指定主键生成策略。<br>
<code>@GeneratedValue</code> 注解默认使用的策略是 <code>GenerationType.AUTO</code></p>
<p>一般使用 MySQL 数据库的话，使用 <code>GenerationType.IDENTITY</code> 策略比较普遍一点（分布式系统的话需要另外考虑使用分布式 ID）。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> @GenericGenerator</h4>
<p>通过 <code>@GenericGenerator</code> 声明一个主键策略，然后 <code>@GeneratedValue</code> 使用这个策略</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>jpa 提供的主键生成策略有如下几种：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8.3 设置字段类型</h3>
<p><code>@Column</code> 声明字段</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8.4 指定不持久化特定字段</h3>
<p><code>@Transient</code>：声明不需要与数据库映射的字段，在保存的时候不需要保存进数据库</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>还可以采用下面几种方法：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8.5 声明大字段</h3>
<p><code>@Lob</code>：声明某个字段为大字段。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8.6 创建枚举类型的字段</h3>
<p>可以使用枚举类型的字段，不过枚举字段要用 <code>@Enumerated</code> 注解修饰。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8.7 增加审计功能</h3>
<p>只要继承了 <code>@AbstractAuditBase</code> 的类都会默认加上下面四个字段。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们对应的审计功能对应地配置类可能是下面这样的（Spring Security 项目）:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><code>@CreatedDate</code>: 表示该字段为创建时间字段，在这个实体被 insert 的时候，会设置值</li>
<li><code>@CreatedBy</code> :表示该字段为创建人，在这个实体被 insert 的时候，会设置值<br>
<code>@LastModifiedDate</code>、<code>@LastModifiedBy</code> 同理。</li>
</ul>
<p><code>@EnableJpaAuditing</code>：开启 JPA 审计功能。</p>
<h3> 8.8 删除/修改数据</h3>
<p><code>@Modifying</code> 注解提示 JPA 该操作是修改操作，注意还要配合 · 注解使用。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8.9 关联关系</h3>
<ul>
<li><code>@OneToOne</code> 声明一对一关系</li>
<li><code>@OneToMany</code> 声明一对多关系</li>
<li><code>@ManyToOne</code> 声明多对一关系</li>
<li><code>@ManyToMany</code> 声明多对多关系</li>
</ul>
<h2> 九、事务 @Transactional</h2>
<p>在要开启事务的方法上使用 <code>@Transactional</code> 注解即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Exception 分为 运行时异常 和 非运行时异常。<br>
在 <code>@Transactional</code> 注解中如果不配置 <code>rollbackFor</code> 属性，那么事务只会在遇到 RuntimeException 的时候才会回滚<br>
加上 <code>rollbackFor=Exception.class</code> 可以让事务在遇到非运行时异常时也回滚。</p>
<p>@Transactional 注解一般可以作用在 <strong>类</strong> 或者 <strong>方法</strong> 上。</p>
<ul>
<li>作用于类：所有该类的 <code>public</code> 方法都配置相同的事务属性信息。</li>
<li>作用于方法：当类配置了 @Transactional，方法也配置了 @Transactional，方法的事务会覆盖类的事务配置信息。</li>
</ul>
<h2> 10、 json 数据处理</h2>
<h3> 10.1 过滤 json 数据</h3>
<p><code>@JsonIgnoreProperties</code> 作用在类上用于过滤掉特定字段不返回或者不解析。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>@JsonIgnore</code> 一般用于属性上，作用和 <code>@JsonIgnoreProperties</code> 一样。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 10.2 格式化 json 数据</h3>
<p><code>@JsonFormat</code> 一般用来格式化 json 数据。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 10.3 扁平化对象</h3>
<p>使用 <code>@JsonUnwrapped</code> 扁平对象，通常加在属性上</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 十一、测试相关</h2>
<p><code>@ActiveProfiles</code> 一般作用于测试类上， 用于声明生效的 Spring 配置文件。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>@Test</code>： 声明一个方法为测试方法<br>
<code>@Transactional</code>： 被声明的测试方法的数据会回滚，避免污染测试数据。<br>
<code>@WithMockUser</code>： Spring Security 提供的，用来模拟一个真实用户，并且可以赋予权限。</p>
]]></content:encoded>
    </item>
    <item>
      <title>136. 只出现一次的数字</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_136_%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_136_%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97.html</guid>
      <source url="https://T4mako.github.io/rss.xml">136. 只出现一次的数字</source>
      <description>136. 只出现一次的数字</description>
      <category>算法</category>
      <pubDate>Mon, 11 Sep 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 136. 只出现一次的数字</h1>
]]></content:encoded>
    </item>
    <item>
      <title>338. 比特位计数</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_338_%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_338_%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0.html</guid>
      <source url="https://T4mako.github.io/rss.xml">338. 比特位计数</source>
      <description>338. 比特位计数</description>
      <category>算法</category>
      <pubDate>Sun, 10 Sep 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 338. 比特位计数</h1>
]]></content:encoded>
    </item>
    <item>
      <title>208. 实现 Trie (前缀树)</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_208_%E5%AE%9E%E7%8E%B0%20Trie%20(%E5%89%8D%E7%BC%80%E6%A0%91).html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_208_%E5%AE%9E%E7%8E%B0%20Trie%20(%E5%89%8D%E7%BC%80%E6%A0%91).html</guid>
      <source url="https://T4mako.github.io/rss.xml">208. 实现 Trie (前缀树)</source>
      <description>208. 实现 Trie (前缀树)</description>
      <category>算法</category>
      <pubDate>Fri, 08 Sep 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 208. 实现 Trie (前缀树)</h1>
]]></content:encoded>
    </item>
    <item>
      <title>739. 每日温度</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_739_%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_739_%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.html</guid>
      <source url="https://T4mako.github.io/rss.xml">739. 每日温度</source>
      <description>739. 每日温度</description>
      <category>算法</category>
      <pubDate>Wed, 06 Sep 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 739. 每日温度</h1>
]]></content:encoded>
    </item>
    <item>
      <title>198. 打家劫舍</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_198_%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_198_%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.html</guid>
      <source url="https://T4mako.github.io/rss.xml">198. 打家劫舍</source>
      <description>198. 打家劫舍</description>
      <category>算法</category>
      <pubDate>Sun, 03 Sep 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 198. 打家劫舍</h1>
]]></content:encoded>
    </item>
    <item>
      <title>875. 爱吃香蕉的珂珂</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_875_%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_875_%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82.html</guid>
      <source url="https://T4mako.github.io/rss.xml">875. 爱吃香蕉的珂珂</source>
      <description>875. 爱吃香蕉的珂珂</description>
      <category>算法</category>
      <pubDate>Sat, 02 Sep 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 875. 爱吃香蕉的珂珂</h1>
]]></content:encoded>
    </item>
    <item>
      <title>162. 寻找峰值</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_162_%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_162_%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC.html</guid>
      <source url="https://T4mako.github.io/rss.xml">162. 寻找峰值</source>
      <description>162. 寻找峰值</description>
      <category>算法</category>
      <pubDate>Fri, 01 Sep 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 162. 寻找峰值</h1>
]]></content:encoded>
    </item>
    <item>
      <title>MySQL 索引</title>
      <link>https://T4mako.github.io/code/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%B4%A2%E5%BC%95.html</link>
      <guid>https://T4mako.github.io/code/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%B4%A2%E5%BC%95.html</guid>
      <source url="https://T4mako.github.io/rss.xml">MySQL 索引</source>
      <description>参考： https://javaguide.cn/database/mysql/mysql-index.html https://www.bilibili.com/video/BV1Wm4y147mS</description>
      <category>MySQL</category>
      <pubDate>Thu, 31 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>参考：<br>
<a href="https://javaguide.cn/database/mysql/mysql-index.html" target="_blank" rel="noopener noreferrer">https://javaguide.cn/database/mysql/mysql-index.html</a><br>
<a href="https://www.bilibili.com/video/BV1Wm4y147mS" target="_blank" rel="noopener noreferrer">https://www.bilibili.com/video/BV1Wm4y147mS</a></p>
</blockquote>
<p>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。</p>
<p>索引底层数据结构存在很多种类型，常见的索引结构有: B 树， B+树 和 Hash、红黑树。<br>
在 MySQL 中，无论是 Innodb 还是 MyIsam，都使用了 <strong>B+树</strong> 作为索引结构。</p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>存储引擎是数据库的核心，在MySQL中，存储引擎是以插件的形式运行的。支持的引擎有十几种之多，实战常用到的，大概只有 <code>InnoDB</code>、<code>MyISAM</code> 和 <code>Memory</code></p>
<p><a href="https://cloud.tencent.com/developer/article/1662516" target="_blank" rel="noopener noreferrer">https://cloud.tencent.com/developer/article/1662516</a></p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>216. 组合总和 III</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_216_%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20III.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_216_%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20III.html</guid>
      <source url="https://T4mako.github.io/rss.xml">216. 组合总和 III</source>
      <description>216. 组合总和 III</description>
      <category>算法</category>
      <pubDate>Thu, 31 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 216. 组合总和 III</h1>
]]></content:encoded>
    </item>
    <item>
      <title>2300. 咒语和药水的成功对数</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_2300.%20%E5%92%92%E8%AF%AD%E5%92%8C%E8%8D%AF%E6%B0%B4%E7%9A%84%E6%88%90%E5%8A%9F%E5%AF%B9%E6%95%B0.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_2300.%20%E5%92%92%E8%AF%AD%E5%92%8C%E8%8D%AF%E6%B0%B4%E7%9A%84%E6%88%90%E5%8A%9F%E5%AF%B9%E6%95%B0.html</guid>
      <source url="https://T4mako.github.io/rss.xml">2300. 咒语和药水的成功对数</source>
      <description>2300. 咒语和药水的成功对数</description>
      <category>算法</category>
      <pubDate>Wed, 30 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 2300. 咒语和药水的成功对数</h1>
]]></content:encoded>
    </item>
    <item>
      <title>215. 数组中的第K个最大元素</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_215_%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_215_%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0.html</guid>
      <source url="https://T4mako.github.io/rss.xml">215. 数组中的第K个最大元素</source>
      <description>215. 数组中的第K个最大元素</description>
      <category>算法</category>
      <pubDate>Mon, 28 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 215. 数组中的第K个最大元素</h1>
]]></content:encoded>
    </item>
    <item>
      <title>994. 腐烂的橘子</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_994_%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_994_%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90.html</guid>
      <source url="https://T4mako.github.io/rss.xml">994. 腐烂的橘子</source>
      <description>994. 腐烂的橘子</description>
      <category>算法</category>
      <pubDate>Sun, 27 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 994. 腐烂的橘子</h1>
]]></content:encoded>
    </item>
    <item>
      <title>1926. 迷宫中离入口最近的出口</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1926_%E8%BF%B7%E5%AE%AB%E4%B8%AD%E7%A6%BB%E5%85%A5%E5%8F%A3%E6%9C%80%E8%BF%91%E7%9A%84%E5%87%BA%E5%8F%A3.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1926_%E8%BF%B7%E5%AE%AB%E4%B8%AD%E7%A6%BB%E5%85%A5%E5%8F%A3%E6%9C%80%E8%BF%91%E7%9A%84%E5%87%BA%E5%8F%A3.html</guid>
      <source url="https://T4mako.github.io/rss.xml">1926. 迷宫中离入口最近的出口</source>
      <description>1926. 迷宫中离入口最近的出口</description>
      <category>算法</category>
      <pubDate>Sat, 26 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 1926. 迷宫中离入口最近的出口</h1>
]]></content:encoded>
    </item>
    <item>
      <title>746. 使用最小花费爬楼梯</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_746_%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_746_%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF.html</guid>
      <source url="https://T4mako.github.io/rss.xml">746. 使用最小花费爬楼梯</source>
      <description>746. 使用最小花费爬楼梯</description>
      <category>算法</category>
      <pubDate>Mon, 21 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 746. 使用最小花费爬楼梯</h1>
]]></content:encoded>
    </item>
    <item>
      <title>认识 JVM</title>
      <link>https://T4mako.github.io/code/java/JVM%E5%85%A5%E9%97%A8.html</link>
      <guid>https://T4mako.github.io/code/java/JVM%E5%85%A5%E9%97%A8.html</guid>
      <source url="https://T4mako.github.io/rss.xml">认识 JVM</source>
      <description>参考：https://javaguide.cn/java/jvm/jvm-intro.html JVM(Java Virtual Machine) 其实就类似于一台小电脑运行在 windows 或者 linux 这些操作系统环境下即可。 它直接和操作系统进行交互，与硬件不直接交互，而操作系统可以帮我们完成和硬件进行交互的工作。</description>
      <category>java</category>
      <pubDate>Sun, 20 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>参考：<a href="https://javaguide.cn/java/jvm/jvm-intro.html" target="_blank" rel="noopener noreferrer">https://javaguide.cn/java/jvm/jvm-intro.html</a></p>
</blockquote>
<p>JVM(Java Virtual Machine) 其实就类似于一台小电脑运行在 windows 或者 linux 这些操作系统环境下即可。<br>
它直接和操作系统进行交互，与硬件不直接交互，而操作系统可以帮我们完成和硬件进行交互的工作。</p>
<h2> 一、基础知识</h2>
<h3> JVM</h3>
<p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。</p>
<p>JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。</p>
<p>字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</p>
<p><strong>JVM 并不是只有一种！只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。</strong><br>
也就是说我们平时接触到的 HotSpot VM（Sun/Oracle JDK 和 OpenJDK 中所带的虚拟机） 仅仅是是 JVM 规范的一种实现而已</p>
<blockquote>
<p>Oracle JDK 是基于 OpenJDK 源代码构建的</p>
</blockquote>
<h3> JDK 和 JRE</h3>
<ul>
<li>JDK（Java Development Kit）= JRE + 开发工具集（javac.exe,java..exe,javadoc.exe...）</li>
<li>JRE（Java Runtime Environment Java运行环境）= JVM + Java SE 标准类库（Java Class Library）</li>
</ul>
<p>JDK（Java Development Kit），它是功能齐全的 Java SDK（软件开发套件 Software development kit），是提供给开发者使用的，能够创建和编译 Java 程序。</p>
<p>它包含了 JRE，同时还包含了编译 java 源码的编译器 javac 以及一些其他工具比如 javadoc（文档注释工具）、jdb（调试器）、jconsole（基于 JMX 的可视化监控⼯具）、javap（反编译工具）等等。</p>
<p>JRE（Java Runtime Environment） 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，主要包括 Java 虚拟机（JVM）、Java 基础类库（Class Library）。</p>
<p>JRE 是 Java 运行时环境，仅包含 Java 应用程序的运行时环境和必要的类库。</p>
<p>JDK 则包含了 JRE，同时还包括了 javac、javadoc、jdb、jconsole、javap 等工具，可以用于 Java 应用程序的开发和调试。</p>
<p>如果需要进行 Java 编程工作，比如编写和编译 Java 程序、使用 Java API 文档等，就需要安装 JDK。<br>
而对于某些需要使用 Java 特性的应用程序，如 JSP 转换为 Java Servlet、使用反射等，也需要 JDK 来编译和运行 Java 代码。<br>
因此，即使不打算进行 Java 应用程序的开发工作，也有可能需要安装 JDK。</p>
<h3> 字节码</h3>
<p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。</p>
<p>Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以， Java 程序运行时相对来说还是高效的（不过，和 C++，Rust，Go 等语言还是有一定差距的），而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>
<p><code>.class-&gt;机器码</code> 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器<strong>逐行解释执行</strong>，这种方式的执行速度会相对比较慢。</p>
<p>而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。</p>
<p>而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言</p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（<strong>热点代码</strong>），而这也就是 JIT 所需要编译的部分。</p>
<p>JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。</p>
<p>JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。</p>
</div>
<p>JVM 大致结构模型：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230821005244740.png" alt="image-20230821005244740" loading="lazy"></p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>为什么不全部使用 AOT 呢?</p>
<p>AOT 可以提前编译节省启动时间，那为什么不全部使用这种编译方式呢？</p>
<p>长话短说，这和 Java 语言的动态特性有千丝万缕的联系了。举个例子，CGLIB 动态代理使用的是 ASM 技术，而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 .class 文件，如果全部使用 AOT 提前编译，也就不能使用 ASM 技术了。为了支持类似的动态特性，所以选择使用 JIT 即时编译器。</p>
</div>
<h3> Java 语言“编译与解释并存”的原因</h3>
<p>高级编程语言按照程序的执行方式分为两种：</p>
<ul>
<li>编译型：编译型语言 会通过编译器将源代码 <strong>一次性翻译</strong> 成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。</li>
<li>解释型：解释型语言会通过解释器 <strong>一句一句的将代码解释</strong>（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。</li>
</ul>
<h3> Oracle JDK vs OpenJDK</h3>
<p>2006 年 SUN 公司将 Java 开源，也就有了 OpenJDK。<br>
2009 年 Oracle 收购了 Sun 公司，于是自己在 OpenJDK 的基础上搞了一个 Oracle JDK。  Oracle JDK 是不开源的，并且刚开始的几个版本（Java8 ~ Java11）还会相比于 OpenJDK 添加一些特有的功能和工具。</p>
<p>Oracle JDK 是基于 OpenJDK 7 构建的，只添加了一些小功能，由 Oracle 工程师参与维护。</p>
<p>Oracle JDK 和 OpenJDK 的区别：</p>
<ol>
<li>是否开源：OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是基于 OpenJDK 实现的，并不是完全开源的。<br>
OpenJDK 开源项目：<a href="https://github.com/openjdk/jdk" target="_blank" rel="noopener noreferrer">https://github.com/openjdk/jdk</a></li>
<li>是否免费：Oracle JDK 会提供免费版本，但一般有时间限制。<br>
JDK17 之后的版本可以免费分发和商用，但是仅有 3 年时间，3 年后无法免费商用<br>
不过，JDK8u221 之前只要不升级可以无限期免费。OpenJDK 是完全免费的。</li>
<li>功能性：Oracle JDK 在 OpenJDK 的基础上添加了一些特有的功能和工具，比如 Java Flight Recorder（JFR，一种监控工具）、Java Mission Control（JMC，一种监控工具）等工具。<br>
不过，在 Java 11 之后，OracleJDK 和 OpenJDK 的功能基本一致，之前 OracleJDK 中的私有组件大多数也已经被捐赠给开源组织。</li>
<li>稳定性：OpenJDK 不提供 LTS 服务，而 OracleJDK 大概每三年都会推出一个 LTS 版进行长期支持。<br>
不过，很多公司都基于 OpenJDK 提供了对应的和 OracleJDK 周期相同的 LTS 版。因此，两者稳定性其实也是差不多的。</li>
<li>协议：Oracle JDK 使用 <code>BCL/OTN</code> 协议获得许可，而 OpenJDK 根据 <code>GPL v2</code> 许可获得许可。</li>
</ol>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>既然 Oracle JDK 这么好，那为什么还要有 OpenJDK？</p>
<ul>
<li>OpenJDK 是开源的，开源意味着你可以对它根据你自己的需要进行修改、优化，比如 Alibaba 基于 OpenJDK 开发了 Dragonwell8：<a href="https://github.com/alibaba/dragonwell8" target="_blank" rel="noopener noreferrer">https://github.com/alibaba/dragonwell8</a></li>
<li>OpenJDK 是商业免费的（这也是为什么通过 yum 包管理器上默认安装的 JDK 是 OpenJDK 而不是 Oracle JDK）。虽然 Oracle JDK 也是商业免费（比如 JDK 8），但并不是所有版本都是免费的。</li>
<li>OpenJDK 更新频率更快。Oracle JDK 一般是每 6 个月发布一个新版本，而 OpenJDK 一般是每 3 个月发布一个新版本。（现在你知道为啥 Oracle JDK 更稳定了吧，先在 OpenJDK 试试水，把大部分问题都解决掉了才在 Oracle JDK 上发布）基于以上这些原因，OpenJDK 还是有存在的必要的！</li>
</ul>
</div>
<h3> Java 文件是如何被运行的</h3>
<p>假设编写了一个 <code>A.java</code> 文件，目前它只是一个文本文件且有一定的缩进<br>
JVM 是不认识文本文件的，所以它需要一个 <strong>编译</strong> ，让其成为一个它会读二进制文件的 <code>A.class</code></p>
<h4> ① 类加载器</h4>
<p>如果 JVM 想要执行这个 .class 文件，我们需要将其装进一个 <strong>类加载器</strong> 中，它就像一个搬运工一样，会把所有的 .class 文件全部搬进 JVM 里面来。</p>
<h4> ② 方法区</h4>
<p><strong>方法区</strong> 是用于存放类似于 <strong>元数据</strong> 信息方面的数据的<br>
比如类信息，常量，静态变量，编译后代码···等<br>
类加载器将 .class 文件搬过来就是先丢到这一块上</p>
<h4> ③ 堆</h4>
<p>堆 主要放了一些存储的数据，比如对象实例，数组···等，它和方法区都同属于 线程共享区域 。也就是说它们都是 <strong>线程不安全</strong> 的</p>
<h4> ④ 栈</h4>
<p>栈 这是我们的代码运行空间。我们编写的每一个方法都会放到 栈 里面运行。我们会听说过 本地方法栈 或者 本地方法接口 这两个名词，不过我们基本不会涉及这两块的内容，它俩底层是使用 C 来进行工作的，和 Java 没有太大的关系。</p>
<h4> ⑤ 程序计数器</h4>
<p>主要就是完成一个加载工作，类似于一个指针一样的，指向下一行我们需要执行的代码。和栈一样，都是 <strong>线程独享</strong> 的，就是说每一个线程都会有自己对应的一块区域而不会存在并发和多线程的问题。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230823001104289.png" alt="image-20230823001104289" loading="lazy"></p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<ul>
<li><code>.java</code> 文件经过编译后变成 <code>.class</code> 字节码文件</li>
<li>字节码文件通过 <code>类加载器</code> 被搬运到 JVM 虚拟机中</li>
<li>虚拟机主要的 5 大块：
<ul>
<li><code>方法区</code>，<code>堆</code> 都为<code>线程共享</code>区域，有线程安全问题</li>
<li><code>栈</code> 和 <code>本地方法栈</code> 和 <code>计数器</code> 都是 <code>独享区域</code>，不存在线程安全问题</li>
<li>而 JVM 的调优主要就是围绕 <code>堆</code>，<code>栈</code> 两大块进行</li>
</ul>
</li>
</ul>
</div>
<h3> 一个简单的示例</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol>
<li><code>App.java</code> 编译后得到 <code>App.class</code> ，执行 <code>App.class</code> ，系统会启动一个 <code>JVM 进程</code> ，从 <code>classpath</code> 路径中找到一个名为 <code>App.class</code> 的二进制文件，将 App 的类信息加载到运行时数据区的 <code>方法区</code> 内，这个过程叫做 App <code>类的加载</code></li>
<li>JVM 找到 App 的主程序入口，执行 main 方法</li>
<li>main 中的第一条语句为 <code>Stu stu = new Stu("T4mako");</code> ，就是让 JVM 创建一个 Stu 对象，但是这个时候方法区中是没有 Stu 类的信息的，所以 JVM 马上加载 Stu 类，把 Stu 类的信息放到 <code>方法区</code> 中</li>
<li>加载完 Stu 类后，JVM 在 <code>堆</code> 中为一个新的 stu 实例分配内存，然后调用构造函数初始化 stu 实例，这个 stu 实例持有 <strong>指向方法区中的 Stu 类的类型信息的引用</strong></li>
<li>执行 <code>stu.say();</code> 时，JVM 根据 stu 的引用找到 stu 对象，然后根据 stu 对象持有的引用定位到方法区中 Stu 类的类型信息的方法表，获得 say() 的字节码地址。</li>
<li>执行 say()</li>
</ol>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>只需要知道 <code>对象实例初始化</code> 时会去 <code>方法区中找类信息</code><br>
完成后再到 <code>栈</code> 那里去 <code>运行方法</code> 。<br>
找方法就在方法表中找</p>
</div>
<h2> 二、类加载器的介绍</h2>
<p>类的加载器：</p>
<ul>
<li>负责加载 .class 文件，.class 文件开头会有特定的文件标示</li>
<li><strong>将 class 文件字节码内容加载到内存中</strong>，并将这些内容转换成方法区中的运行时数据结构，并且 ClassLoader 只负责 class 文件的加载，而是否能够运行则由 Execution Engine 来决定</li>
</ul>
<h3> 2.1 类加载器的流程</h3>
<p>类被加载到虚拟机内存中开始，到释放内存总共有 7 个步骤：<br>
加载，连接（验证，准备，解析），初始化，使用，卸载。</p>
<h4> 2.1.1 加载</h4>
<ol>
<li>将 class 文件加载到内存</li>
<li>将 <strong>静态数据结构</strong> 转化成 <strong>方法区中运行时的数据结构</strong></li>
<li>在 <strong>堆</strong> 中生成一个代表这个类的 <code>java.lang.Class 对象</code> 作为数据访问的入口</li>
</ol>
<h4> 2.1.2 链接</h4>
<p>连接：为类的静态变量赋予正确的初始值</p>
<ol>
<li>验证：<br>
安全检查 （确保加载的类符合 JVM 规范和安全，保证被校验类的方法在运行时不会做出危害虚拟机的事件）</li>
<li>准备：<br>
为 <code>static</code> 变量在方法区中分配内存空间，设置变量的初始值<br>
（注意：准备阶段只设置类中的 <strong>静态</strong> 变量（ <strong>方法区</strong> 中），不包括 <strong>实例变量</strong>（ <strong>堆内存</strong> 中），实例变量是对象初始化时赋值的）</li>
<li>解析：<br>
虚拟机将常量池内的符号引用替换为直接引用的过程<br>
（符号引用比如我现在 <code>import java.util.ArrayList</code> 这就算符号引用<br>
直接引用就是指针或者对象地址，注意 <strong>引用对象</strong> 一定是在<strong>内存</strong>进行）</li>
</ol>
<h4> 2.1.3  初始化</h4>
<p>初始化：执行类构造器方法的 <code>&lt;clinit&gt;()</code> 的过程，且要保证父类的 <code>&lt;clinit&gt;()</code> 方法执行完毕<br>
这个方法由编译器收集，顺序执行所有 <strong>类变量（static）</strong> 显式初始化和 <strong>静态代码块</strong> 中语句。</p>
<p>初始化执行时机：</p>
<ul>
<li>new一个对象</li>
<li>访问某个类或接口的静态变量</li>
<li>调用类的静态方法，反射 <code>Class.forName</code></li>
<li>初始化一个类的子类</li>
<li>JVM启动时标明的启动类，即文件名和类名相同的那个类</li>
</ul>
<p>注：静态代码块 和 类变量初始化 顺序执行</p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>初始化顺序依次是：（静态变量、静态初始化块）–&gt;（变量、初始化块）–&gt; 构造器；如果有父类，则顺序是：父类 static 方法 –&gt; 子类 static 方法 –&gt; 父类构造方法- -&gt; 子类构造方法</p>
</div>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>字节码文件中初始化方法有两种，非静态资源初始化的 <code>&lt;init&gt;</code> 和静态资源初始化的 <code>&lt;clinit&gt;</code> ，类构造器方法 <code>&lt;clinit&gt;()</code> 不同于类的构造器，这些方法都是字节码文件中只能给 JVM 识别的特殊方法。</p>
</div>
<h4> 2.1.4 卸载</h4>
<p>GC 将无用对象从内存中卸载</p>
<h3> 2.2 类加载器加载顺序</h3>
<p>类加载器顺序：<br>
BootStrap ClassLoader：rt.jar<br>
Extension ClassLoader: 加载扩展的 jar 包<br>
App ClassLoader：指定的 classpath 下面的 jar 包<br>
Custom ClassLoader：自定义的类加载器</p>
<blockquote>
<p>第一步： 字底向上检查类是否已加载<br>
第二步： 自顶向下尝试加载类</p>
</blockquote>
<h3> 2.3 双亲委派机制</h3>
<p>当一个类收到了加载请求时，它是不会先自己去尝试加载的，而是委派给父类去完成，比如我现在要 new 一个 Person，这个 Person 是我们自定义的类，如果我们要加载它，就会先委派 App ClassLoader ，只有当父类加载器都反馈自己无法完成这个请求（也就是父类加载器都没有找到加载所需的 Class）时，子类加载器才会自行尝试加载。</p>
<p>这样做的好处是，加载位于 rt.jar 包中的类时不管是哪个加载器加载，最终都会委托到 BootStrap ClassLoader 进行加载，这样保证了使用不同的类加载器得到的都是同一个结果。</p>
<p>其实这个也是一个隔离的作用，避免了我们的代码影响了 JDK 的代码，比如我现在自己定义一个 java.lang.String：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>尝试运行当前类的 <code>main</code> 函数的时候，我们的代码肯定会报错。这是因为在加载的时候其实是找到了 <code>rt.jar</code> 中的 <code>java.lang.String</code>，然而发现这个里面并没有 <code>main</code> 方法。</p>
<h2> 三、运行时数据区</h2>
<h3> 3.1 本地方法栈和程序计数器</h3>
<ul>
<li>
<p>本地方法栈：<br>
<code>native</code> 修饰的方法就是本地方法，这是使用 C 来实现的（比如 Thread 类的 start0 方法）<br>
一般这些方法都会放到一个叫做本地方法栈的区域。</p>
</li>
<li>
<p>程序计数器其实就是一个指针，它指向了我们程序中下一句需要执行的指令<br>
它是内存区域中唯一一个不会出现 OutOfMemoryError 的区域，且占用很小的内存空间<br>
这个内存仅代表当前线程所执行的字节码的行号指示器，字节码解析器通过改变这个计数器的值选取下一条需要执行的字节码指令</p>
</li>
</ul>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>如果执行的是 native 方法，那这个指针就不工作了。</p>
</div>
<h3> 3.2 方法区</h3>
<p><strong>方法区</strong> 主要的作用是存放 <strong>类的元数据</strong> 信息，常量和静态变量···等。当它存储的信息过大时，会在无法满足内存分配时报错</p>
<h3> 3.3 虚拟机栈和虚拟机堆</h3>
<p>栈管运行，堆管存储。<br>
则虚拟机栈负责运行代码，而虚拟机堆负责存储数据</p>
<h4> 3.3.1、虚拟机栈</h4>
<p>它是 Java 方法执行的内存模型。<br>
里面会对局部变量，动态链表，方法出口，栈的操作（入栈和出栈）进行存储，且线程独享。<br>
同时如果我们听到 <strong>局部变量表</strong>，那也是在说 <strong>虚拟机栈</strong></p>
<h4> 3.3.2、虚拟机栈的异常</h4>
<p>线程请求的栈的深度大于虚拟机栈的最大深度，就会报 <code>StackOverflowError </code>（这种错误经常出现在递归中）<br>
Java 虚拟机也可以动态扩展，但随着扩展会不断地申请内存，当无法申请足够内存时就会报错 <code>OutOfMemoryError</code></p>
<h4> 3.3.3、虚拟机栈的生命周期</h4>
<p>对于栈来说，不存在垃圾回收。<br>
只要程序运行结束，栈的空间自然就会释放了。<br>
<strong>栈的生命周期</strong> 和 <strong>所处的线</strong>程是一致的。</p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>8 种基本类型的变量+对象的引用变量+实例方法都是在栈里面分配内存</p>
</div>
<h4> 3.3.4、虚拟机栈的执行</h4>
<p>我们经常说的栈帧数据（说白了在 JVM 中叫栈帧，放到 Java 中其实就是 <strong>方法</strong>）它也是存放在栈中的。</p>
<p>栈中的数据都是以栈帧的格式存在，它是一个关于方法和运行期数据的数据集。</p>
<p>比如我们执行一个方法 a，就会对应产生一个栈帧 A1，然后 A1 会被压入栈中。<br>
同理方法 b 会有一个 B1<br>
方法 c 会有一个 C1<br>
等到这个线程执行完毕后，栈弹出 C1，B1，A1。（<strong>先进后出</strong>）</p>
<h4> 3.3.5、局部变量的复用</h4>
<p>局部变量表用于存放方法参数和方法内部所定义的局部变量。<br>
它的容量是以 Slot 为最小单位，一个 slot 可以存放 32 位以内的数据类型。</p>
<p>为了节省栈帧空间，这些 slot 是可以复用的，当方法执行位置超过了某个变量，那么这个变量的 slot 可以被其它变量复用。当然如果需要复用，那我们的垃圾回收自然就不会去动这些内存</p>
<h4> 3.3.6、虚拟机堆的概念</h4>
<p>JVM 内存会划分为堆内存和非堆内存，堆内存中也会划分为 <strong>年轻代</strong> 和 <strong>老年代</strong>，而非堆内存则为 <strong>永久代</strong></p>
<p>Eden，FromPlace 和 ToPlace 的默认占比为 8:1:1。<br>
可以通过一个 <code>-XX:+UsePSAdaptiveSurvivorSizePolicy</code> 参数来根据生成对象的速率动态调整</p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p><strong>堆内存</strong> 中存放的是 <strong>对象</strong><br>
垃圾收集就是收集这些对象然后交给 GC 算法进行回收</p>
<p><strong>非堆内存</strong> 就是 <strong>方法区</strong></p>
<p>在 1.8 中已经移除永久代，替代品是 <strong>元空间（MetaSpace）</strong><br>
最大区别是 metaSpace 是不存在于 JVM 中的，它使用的是本地内存。并有两个参数：<br>
<code>MetaspaceSize</code>：初始化元空间大小，控制发生 GC<br>
<code>MaxMetaspaceSize</code>：限制元空间大小上限，防止占用过多物理内存。</p>
<p>移除的大致原因：融合 HotSpot JVM 和 JRockit VM 而做出的改变，因为 JRockit 是没有永久代的，不过这也间接性地解决了永久代的 OOM 问题。</p>
</div>
<h4> 3.3.7、Eden 年轻代</h4>
<p>对象放入 Eden：</p>
<ul>
<li>new 一个对象后，会先放到 Eden 划分出来的一块作为存储空间的内存</li>
<li>由于堆内存是线程共享的，所以有可能会出现两个对象共用一个内存的情况</li>
<li>JVM 的处理是为每个线程都预先申请好一块连续的内存空间并规定了对象存放的位置，而如果空间不足会再申请多块内存空间。这个操作我们会称作 TLAB</li>
</ul>
<p>Eden 空间满了后，会触发 <code>Minor GC</code>（一个发生在年轻代的 GC）<br>
存活下来的对象移动到 Survivor0 区，并把 from 和 to 两个指针交换，保证了一段时间内总有一个 survivor 区为空且 to 所指向的 survivor 区为空<br>
经过多次的 Minor GC 后仍然存活的对象（这里的存活判断是 15 次，对应到虚拟机参数为 <code>-XX:MaxTenuringThreshold</code> 。为什么是 15？，因为 HotSpot 会在对象头中的标记字段里记录年龄，分配到的空间仅有 4 位，所以最多只能记录到 15）会移动到 <strong>老年代</strong></p>
<p>当 Eden 区内存空间满了的时候，就会触发 Minor GC，Survivor0 区满不会触发 Minor GC<br>
Survivor0 区 的对象什么时候垃圾回收呢？<br>
假设 Survivor0 区现在是满的，此时又触发了 Minor GC ，发现 Survivor0 区依旧是满的，存不下，此时会将 S0 区与 Eden 区的对象一起进行可达性分析，找出活跃的对象，将它复制到 S1 区并且将 S0 区域和 Eden 区的对象给清空，这样那些不可达的对象进行清除，并且将 S0 区 和 S1 区交换。</p>
<p>老年代是存储长期存活的对象的，占满时就会触发我们最常听说的 Full GC，期间会停止所有线程等待 GC 的完成。<br>
所以对于响应要求高的应用应该尽量去减少发生 Full GC 从而避免响应超时的问题。</p>
<p>老年区执行了 full gc 之后仍然无法进行对象保存的操作，就会产生 <code>Out of Memory</code>，这时候就是虚拟机中的堆内存不足，原因可能会是堆内存设置的大小过小，这个可以通过参数 -Xms、-Xmx 来调整。也可能是代码中创建的对象大且多，而且它们一直在被引用从而长时间垃圾收集无法收集它们。</p>
<p>补充说明：关于 <code>-XX:TargetSurvivorRatio</code> 参数的问题。<br>
其实也不一定是要满足 <code>-XX:MaxTenuringThreshold</code> 才移动到老年代。<br>
举例：如对象年龄 5 的占 30%，年龄 6 的占 36%，年龄 7 的占 34%，加入某个年龄段后，当总占用超过 Survivor 空间  *TargetSurvivorRatio 的时候，从该年龄段开始及大于的年龄对象就要进入老年代，这时候无需等到 MaxTenuringThreshold 中要求的 15</p>
<h4> 3.3.8、判断一个对象需要被干掉</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230828223704998.png" alt="image-20230828223704998" loading="lazy"></p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>程序计数器、虚拟机栈、本地方法栈，3 个区域随着线程的生存而生存的。内存分配和回收都是确定的。<br>
随着线程的结束内存自然就被回收了，因此不需要考虑垃圾回收的问题</p>
<p>Java 堆和方法区，各线程共享，内存的分配和回收都是动态的。因此垃圾收集器所关注的都是堆和方法区这部分内存</p>
</div>
<p>判断哪些对象还存活，哪些已经死去:</p>
<ol>
<li>引用计数器计算：给对象添加一个引用计数器，每次引用这个对象时计数器加一，引用失效时减一，计数器等于 0 时就是不会再次使用的。不过这个方法有一种情况就是出现对象的循环引用时 GC 没法回收。</li>
<li>可达性分析计算：这是一种类似于二叉树的实现，将一系列的 GC ROOTS 作为起始的存活对象集，从这个节点往下搜索，搜索所走过的路径成为引用链，把能被该集合引用到的对象加入到集合中。搜索当一个对象到 GC Roots 没有使用任何引用链时，则说明该对象是不可用的。主流的商用程序语言，例如 Java，C#等都是靠这招去判定对象是否存活的。</li>
</ol>
<h4> 3.3.9、宣告一个对象的真正死亡</h4>
<p>判断一个对象的死亡至少需要两次标记</p>
<p><code>finalize()</code> 方法：<br>
<code>finalize()</code> 是 Object 类的一个方法、一个对象的 <code>finalize()</code> 方法只会被系统自动调用一次，经过 finalize()方法逃脱死亡的对象，第二次不会再调用。<br>
注：并不提倡在程序中调用 finalize()来进行自救</p>
<ol>
<li>如果对象进行可达性分析之后没发现与 GC Roots 相连的引用链，那它将会第一次标记并且进行一次筛选。判断的条件是决定这个对象是否有必要执行 <code>finalize()</code> 方法。如果对象有必要执行 <code>finalize()</code> 方法，则被放入 F-Queue 队列中。</li>
<li>GC 对 F-Queue 队列中的对象进行二次标记。如果对象在 <code>finalize()</code> 方法中重新与引用链上的任何一个对象建立了关联，那么二次标记时则会将它移出“即将回收”集合。如果此时对象还没成功逃脱，那么只能被回收了。</li>
</ol>
<p>对象宣告死亡后，下一步就是垃圾回收</p>
<h3> 3.4 垃圾回收算法</h3>
<p>常用的有标记清除，复制，标记整理和分代收集算法</p>
<h3> 3.5 各种垃圾回收器与 JVM 常用参数</h3>
<p><a href="https://javaguide.cn/java/jvm/jvm-intro.html#_3-5-%E4%BA%86%E8%A7%A3-%E5%90%84%E7%A7%8D%E5%90%84%E6%A0%B7%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8" target="_blank" rel="noopener noreferrer">各种各样的垃圾回收器</a><br>
<a href="https://javaguide.cn/java/jvm/jvm-intro.html#_3-6-%E4%BA%86%E8%A7%A3-jvm-%E7%9A%84%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0" target="_blank" rel="noopener noreferrer">JVM 的常用参数</a></p>
<h2> 四、JVM 调优</h2>
<p>JVM 调优，主要就是堆内存那块</p>
<p>所有线程共享数据区大小 = 新生代大小 + 年老代大小 + 持久代大小。<br>
持久代一般固定大小为 64m。所以 java 堆中增大年轻代后，将会减小年老代大小（因为老年代的清理是使用 fullgc，所以老年代过小的话反而是会增多 fullgc 的）。此值对系统性能影响较大，Sun 官方推荐配置为 java 堆的 3/8。</p>
<h3> 4.1 调整最大堆内存和最小堆内存</h3>
<ol>
<li><code>-Xmx</code><br>
指定 java 堆最大值（默认值是物理内存的 1/4(&lt;1GB)）<br>
如 <code>- Xmx3550m</code> 设置 JVM 堆最大值为 3550M。</li>
<li><code>–Xms</code>：初始 java 堆最小值（默认值是物理内存的 1/64(&lt;1GB)）<br>
如 <code>-Xms200m</code>，表示分配 200M</li>
<li><code>-Xss</code><br>
为 jvm 启动的每个线程分配的内存大小，默认 JDK1.4 中是256K，JDK1.5+ 中是 1M</li>
<li><code>-Xmn</code><br>
年轻代大小<br>
如 <code>-Xmn2g</code>：设置年轻代大小为 2G。整个堆大小 = 年轻代大小 + 年老代大小 + 持久代大小</li>
</ol>
<p>默认空余堆内存小于 40% 时，JVM 就会增大堆直到 -Xmx 的最大限制 （MinHeapFreeRatio 参数可以调整）<br>
默认空余堆内存大于 70% 时，JVM 会减少堆直到 -Xms 的最小限制（MaxHeapFreeRatio 参数可以调整）</p>
<p>简单来说，不停往堆内存里丢数据，等它剩余大小 &lt;40%，JVM 就会动态申请内存空间且 &lt;-Xmx<br>
如果剩余大小 &gt;70%，又会动态缩小 且 &gt;–Xms。</p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>开发过程中，通常会将 -Xms 与 -Xmx 两个参数配置成相同的值，其目的是为了能够在 java 垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小而浪费资源。</p>
</div>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>运行结果：<br>
Xmx=3621.5M<br>
free mem=240.37600708007812M<br>
total mem=245.5M</p>
</blockquote>
<p>可以设置 VM options 的参数：<code>-Xmx20m -Xms5m -XX:+PrintGCDetails</code></p>
<p>Java 会尽可能将 total mem 的值维持在最小堆内存大小<br>
当最小堆内存顶不住时。total memory 就会申请内存。</p>
<p>当手动执行 <code>System.gc();</code>（full gc）， total memory 会把申请的内存释放掉</p>
<h3> 4.2、调整新生代和老年代的比值</h3>
<p><code>-XX:NewRatio</code> ：新生代（eden + 2*Survivor）和老年代（不包含永久区）的比值</p>
<p>例如：<code>-XX:NewRatio=4</code>，表示 <code>新生代:老年代=1:4</code> ，即新生代占整个堆的 1/5。</p>
<p>在 Xms = Xmx 并且设置了 Xmn 的情况下，该参数不需要进行设置。</p>
<h3> 4.3、调整 Survivor 区和 Eden 区的比值</h3>
<p><code>-XX:SurvivorRatio</code>（幸存代）：设置两个 Survivor 区和 eden 的比值</p>
<p>如：<code>-XX:SurvivorRatio=8</code>，表示两个 <code>Survivor:eden=2:8</code>，即一个 Survivor 占年轻代的 1/10</p>
<h3> 4.4、设置年轻代和老年代的大小</h3>
<ul>
<li><code>-XX:NewSize</code> --- 设置年轻代大小</li>
<li><code>-XX:MaxNewSize</code> --- 设置年轻代最大值</li>
</ul>
<p>可以通过设置不同参数来测试不同的情况，反正最优解当然就是官方的 Eden 和 Survivor 的占比为 8:1:1</p>
<p>最大堆内存和最小堆内存如果数值不同会导致多次的 gc，需要注意。</p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>根据实际事情调整新生代和幸存代的大小，官方推荐新生代占 java 堆的 3/8，幸存代占新生代的 1/10<br>
在 OOM 时，记得 Dump 出堆，确保可以排查现场问题，通过下面命令你可以输出一个.dump 文件，这个文件可以使用 VisualVM 或者 Java 自带的 Java VisualVM 工具。</p>
<p><code>-Xmx20m -Xms5m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=你要输出的日志路径</code></p>
<p>一般我们也可以通过编写脚本的方式来让 OOM 出现时给我们报个信，可以通过发送邮件或者重启程序等来解决。</p>
</div>
<h3> 4.5、永久区的设置</h3>
<p><code>-XX:PermSize -XX:MaxPermSize</code></p>
<p>初始空间（默认为物理内存的 1/64）和最大空间（默认为物理内存的 1/4）。<br>
也就是说，jvm 启动时，永久区一开始就占用了 PermSize 大小的空间，如果空间还不够，可以继续扩展，但是不能超过 MaxPermSize，否则会 OOM。<br>
tips：如果堆空间没有用完也抛出了 OOM，有可能是永久区导致的。堆空间实际占用非常少，但是永久区溢出 一样抛出 OOM。</p>
<h3> 4.6、JVM 的栈参数调优</h3>
<h4> 调整每个线程栈空间的大小</h4>
<p>可以通过 <code>-Xss</code> ：调整每个线程栈空间的大小<br>
JDK5.0 以后每个线程堆栈大小为 1M，以前每个线程堆栈大小为 256K。<br>
在相同物理内存下，减小这个值能生成更多的线程。<br>
但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在 <code>3000~5000</code> 左右</p>
<h4> 设置线程栈的大小</h4>
<p><code>-XXThreadStackSize</code>：设置线程栈的大小(0 means use default stack size)</p>
<h3> 4.7、其他参数介绍</h3>
<ul>
<li><code>-XXThreadStackSize</code>：设置内存页的大小，不可设置过大，会影响Perm的大小</li>
<li><code>-XX:+UseFastAccessorMethods</code>：设置原始类型的快速优化</li>
<li><code>-XX:+DisableExplicitGC</code>：设置关闭 <code>System.gc()</code> (这个参数需要严格的测试)</li>
<li><code>-XX:MaxTenuringThreshold</code><br>
设置垃圾最大年龄。如果设置为0的话,则年轻代对象不经过 Survivor 区,直接进入年老代<br>
对于年老代比较多的应用,可以提高效率。如果将此值设置为一个较大值,<br>
则年轻代对象会在 Survivor 区进行多次复制,这样可以增加对象再年轻代的存活时间,<br>
增加在年轻代即被回收的概率。该参数只有在串行GC时才有效</li>
<li><code>-XX:+AggressiveOpts</code>：加快编译速度</li>
<li><code>-XX:+UseBiasedLocking</code>：改善锁机制性能</li>
<li><code>-Xnoclassgc</code>：禁用垃圾回收</li>
<li><code>-XX:SoftRefLRUPolicyMSPerMB</code>：设置每兆堆空闲空间中 SoftReference 的存活时间，默认值是 1s。</li>
<li><code>-XX:PretenureSizeThreshold</code>：设置对象超过多大时直接在老年代分配，默认值是 0。</li>
<li><code>-XX:TLABWasteTargetPercent</code>：设置 TLAB 占 eden 区的百分比，默认值是 1%</li>
<li><code>-XX:+CollectGen0First</code>：设置 FullGC 时是否先 YGC，默认值是 false</li>
</ul>
]]></content:encoded>
      <enclosure url="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230821005244740.png" type="image/png"/>
    </item>
    <item>
      <title>2130. 链表最大孪生和</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_2130_%E9%93%BE%E8%A1%A8%E6%9C%80%E5%A4%A7%E5%AD%AA%E7%94%9F%E5%92%8C.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_2130_%E9%93%BE%E8%A1%A8%E6%9C%80%E5%A4%A7%E5%AD%AA%E7%94%9F%E5%92%8C.html</guid>
      <source url="https://T4mako.github.io/rss.xml">2130. 链表最大孪生和</source>
      <description>2130. 链表最大孪生和</description>
      <category>算法</category>
      <pubDate>Wed, 16 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 2130. 链表最大孪生和</h1>
]]></content:encoded>
    </item>
    <item>
      <title>SpringBoot 自动装配原理</title>
      <link>https://T4mako.github.io/code/java/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86.html</link>
      <guid>https://T4mako.github.io/code/java/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86.html</guid>
      <source url="https://T4mako.github.io/rss.xml">SpringBoot 自动装配原理</source>
      <description>早期的Spring项目需要添加需要配置繁琐的xml,比如MVC、事务、数据库连接等繁琐的配置。SpringBoot的出现就无需这些繁琐的配置，因为SpringBoot基于约定大于配置的理念，在项目启动时候，将约定的配置类自动配置到IOC容器里。这些都因为SpringBoot有自动配置的特性。 Sping Boot 如何实现自动配置 Spring Boot都需要创建一个mian启动类，而启动类都含有@SpringBootApplication注解，从启动类，一步步探索源码。</description>
      <category>java</category>
      <pubDate>Tue, 15 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>早期的<code>Spring</code>项目需要添加需要配置繁琐的xml,比如<code>MVC</code>、事务、数据库连接等繁琐的配置。<code>SpringBoot</code>的出现就无需这些繁琐的配置，因为<code>SpringBoot</code>基于<strong>约定大于配置</strong>的理念，在项目启动时候，将约定的配置类自动配置到<code>IOC</code>容器里。这些都因为<code>SpringBoot</code>有自动配置的特性。</p>
<h2> Sping Boot 如何实现自动配置</h2>
<p><code>Spring Boot</code>都需要创建一个<code>mian</code>启动类，而启动类都含有<code>@SpringBootApplication</code>注解，从启动类，一步步探索源码。</p>
<h3> @SpringBootApplication注解</h3>
<p><code>Spring Boot</code> 启动类上都有一个 <code>@SpringBootApplication</code>注解：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> @EnableAutoConfiguration注解</h3>
<p><code>@SpringBootApplication</code> 里面有 <code>@EnableAutoConfiguration</code> 的注解：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> AutoConfigurationImportSelector类</h3>
<p><code>@EnableAutoConfiguration</code>注解导入<code>AutoConfigurationImportSelector</code>类：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> selectImports()方法</h3>
<p><code>AutoConfigurationImportSelector</code>类找到 <code>selectImports</code> 方法，里面有<code>getAutoConfigurationEntry</code>方法：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> SpringFactoriesLoader.loadFactoryNames() 方法</h3>
<p><code>getAutoConfigurationEntry</code>方法通过<code>SpringFactoriesLoader.loadFactoryNames()</code> 扫描所有含有<code>META-INF/spring.factories</code>的<code>jar</code>包：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>spring-boot-autoconfigure-xxx.jar</code>项目包含<code>META-INF/spring.factories</code>文件，<code>spring.factories</code>是一个键值对的形式，扫描该文件下<code>@EnableAutoConfiguration</code>对应类：</p>
<div class="hint-container info">
<p class="hint-container-title">总结</p>
<ul>
<li>自动配置主要由<code>@EnableAutoConfiguration</code>实现</li>
<li>添加了<code>@EnableAutoConfiguration</code>注解，会导入<code>AutoConfigurationImportSelector</code>类</li>
<li>里面的<code>selectImports</code>方法通过<code>SpringFactoriesLoader.loadFactoryNames()</code>扫描所有含有<code>META-INF/spring.factories</code>的<code>jar</code>包</li>
<li><code>spring.factories</code>是一个键值对的形式，扫描该文件下<code>@EnableAutoConfiguration</code>对应类：</li>
<li>将对应<code>key</code>为<code>@EnableAutoConfiguration</code>注解全名对应的<code>value</code>类全部装配到<code>IOC</code>容器中。</li>
</ul>
</div>
<p>这些属性自动配置到<code>IOC</code>之后就无需自己手动配置<code>bean</code>了，<code>Spring Boot</code>中的<code>约定大于配置</code>理念，约定是将需要的配置以约定的方式添加到<code>IOC</code>容器中。</p>
<h2> 自动配置生效条件</h2>
<p>那是不是<code>spring.factories</code>文件对应的配置都会加载到<code>IOC</code>容器中？</p>
<p>其中有几个注解：  <code>@ConditionalOnClass</code>, <code>@ConditionalOnMissingBean</code></p>
<ul>
<li><code>@ConditionalOnClass</code>表示在类路径中存在类才会配置该配置类。只有引入相关依赖才会自动配置该配置类。</li>
<li><code>@ConditionalOnMissingBean</code>表示只有不存在对应的类的<code>bean</code>才会自动配置该类。</li>
</ul>
<p>所以<code>spring.factories</code>里面并不是所有的<code>bean</code>都会装配到<code>IOC</code>容器中，只会按需配置对应的<code>bean</code>。</p>
]]></content:encoded>
    </item>
    <item>
      <title>2215. 找出两数组的不同</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_2095_%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_2095_%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9.html</guid>
      <source url="https://T4mako.github.io/rss.xml">2215. 找出两数组的不同</source>
      <description>2215. 找出两数组的不同</description>
      <category>算法</category>
      <pubDate>Tue, 15 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 2215. 找出两数组的不同</h1>
]]></content:encoded>
    </item>
    <item>
      <title>735. 行星碰撞</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_328_%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_328_%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8.html</guid>
      <source url="https://T4mako.github.io/rss.xml">735. 行星碰撞</source>
      <description>735. 行星碰撞</description>
      <category>算法</category>
      <pubDate>Tue, 15 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 735. 行星碰撞</h1>
]]></content:encoded>
    </item>
    <item>
      <title>206. 反转链表</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_206_%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_206_%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.html</guid>
      <source url="https://T4mako.github.io/rss.xml">206. 反转链表</source>
      <description>206. 反转链表</description>
      <category>算法</category>
      <pubDate>Sat, 12 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 206. 反转链表</h1>
]]></content:encoded>
    </item>
    <item>
      <title>735. 行星碰撞</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_735_%E8%A1%8C%E6%98%9F%E7%A2%B0%E6%92%9E.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_735_%E8%A1%8C%E6%98%9F%E7%A2%B0%E6%92%9E.html</guid>
      <source url="https://T4mako.github.io/rss.xml">735. 行星碰撞</source>
      <description>735. 行星碰撞</description>
      <category>算法</category>
      <pubDate>Fri, 11 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 735. 行星碰撞</h1>
]]></content:encoded>
    </item>
    <item>
      <title>高频 SQL 50题</title>
      <link>https://T4mako.github.io/code/leetcode/SQL/%E9%AB%98%E9%A2%91%20SQL%2050%20%E9%A2%98%EF%BC%88%E5%9F%BA%E7%A1%80%E7%89%88%EF%BC%89.html</link>
      <guid>https://T4mako.github.io/code/leetcode/SQL/%E9%AB%98%E9%A2%91%20SQL%2050%20%E9%A2%98%EF%BC%88%E5%9F%BA%E7%A1%80%E7%89%88%EF%BC%89.html</guid>
      <source url="https://T4mako.github.io/rss.xml">高频 SQL 50题</source>
      <description>高频 SQL 50题 题目集合 查询 1757. 可回收且低脂的产品</description>
      <category>SQL</category>
      <pubDate>Thu, 10 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 高频 SQL 50题</h1>
<p><a href="https://leetcode.cn/studyplan/sql-free-50/" target="_blank" rel="noopener noreferrer">题目集合</a></p>
<h2> 查询</h2>
<h3> 1757. 可回收且低脂的产品</h3>
]]></content:encoded>
    </item>
    <item>
      <title>1207. 独一无二的出现次数</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1207_%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1207_%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0.html</guid>
      <source url="https://T4mako.github.io/rss.xml">1207. 独一无二的出现次数</source>
      <description>1207. 独一无二的出现次数</description>
      <category>算法</category>
      <pubDate>Wed, 09 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 1207. 独一无二的出现次数</h1>
]]></content:encoded>
    </item>
    <item>
      <title>2352. 相等行列对</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_2352_%E7%9B%B8%E7%AD%89%E8%A1%8C%E5%88%97%E5%AF%B9.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_2352_%E7%9B%B8%E7%AD%89%E8%A1%8C%E5%88%97%E5%AF%B9.html</guid>
      <source url="https://T4mako.github.io/rss.xml">2352. 相等行列对</source>
      <description>2352. 相等行列对</description>
      <category>算法</category>
      <pubDate>Wed, 09 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 2352. 相等行列对</h1>
]]></content:encoded>
    </item>
    <item>
      <title>2215. 找出两数组的不同</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_2215_%E6%89%BE%E5%87%BA%E4%B8%A4%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%8D%E5%90%8C.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_2215_%E6%89%BE%E5%87%BA%E4%B8%A4%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%8D%E5%90%8C.html</guid>
      <source url="https://T4mako.github.io/rss.xml">2215. 找出两数组的不同</source>
      <description>2215. 找出两数组的不同</description>
      <category>算法</category>
      <pubDate>Tue, 08 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 2215. 找出两数组的不同</h1>
]]></content:encoded>
    </item>
    <item>
      <title>1004. 最大连续1的个数 III</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1004_%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%20III.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1004_%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%20III.html</guid>
      <source url="https://T4mako.github.io/rss.xml">1004. 最大连续1的个数 III</source>
      <description>1004. 最大连续1的个数 III</description>
      <category>算法</category>
      <pubDate>Mon, 07 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 1004. 最大连续1的个数 III</h1>
]]></content:encoded>
    </item>
    <item>
      <title>1732. 找到最高海拔</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1732_%E6%89%BE%E5%88%B0%E6%9C%80%E9%AB%98%E6%B5%B7%E6%8B%94.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1732_%E6%89%BE%E5%88%B0%E6%9C%80%E9%AB%98%E6%B5%B7%E6%8B%94.html</guid>
      <source url="https://T4mako.github.io/rss.xml">1732. 找到最高海拔</source>
      <description>1732. 找到最高海拔</description>
      <category>算法</category>
      <pubDate>Mon, 07 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 1732. 找到最高海拔</h1>
]]></content:encoded>
    </item>
    <item>
      <title>643_子数组最大平均数 I</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_643_%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B0%20I.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_643_%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B0%20I.html</guid>
      <source url="https://T4mako.github.io/rss.xml">643_子数组最大平均数 I</source>
      <description>643_子数组最大平均数 I</description>
      <category>算法</category>
      <pubDate>Mon, 07 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 643_子数组最大平均数 I</h1>
]]></content:encoded>
    </item>
    <item>
      <title>283_移动0</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_283_%E7%A7%BB%E5%8A%A80.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_283_%E7%A7%BB%E5%8A%A80.html</guid>
      <source url="https://T4mako.github.io/rss.xml">283_移动0</source>
      <description>283_移动0</description>
      <category>算法</category>
      <pubDate>Sun, 06 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 283_移动0</h1>
]]></content:encoded>
    </item>
    <item>
      <title>1679_K 和数对的最大数目</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1679_K%20%E5%92%8C%E6%95%B0%E5%AF%B9%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1679_K%20%E5%92%8C%E6%95%B0%E5%AF%B9%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE.html</guid>
      <source url="https://T4mako.github.io/rss.xml">1679_K 和数对的最大数目</source>
      <description>1679_K 和数对的最大数目</description>
      <category>算法</category>
      <pubDate>Sat, 05 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 1679_K 和数对的最大数目</h1>
]]></content:encoded>
    </item>
    <item>
      <title>1071_字符串的最大公因子</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1071_%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1071_%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90.html</guid>
      <source url="https://T4mako.github.io/rss.xml">1071_字符串的最大公因子</source>
      <description>1071_字符串的最大公因子</description>
      <category>算法</category>
      <pubDate>Fri, 04 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 1071_字符串的最大公因子</h1>
]]></content:encoded>
    </item>
    <item>
      <title>Stream API 的理解与使用</title>
      <link>https://T4mako.github.io/code/java/Java%20%E5%9F%BA%E7%A1%80/%E5%B8%B8%E7%94%A8%E7%B1%BB/Stream%20API.html</link>
      <guid>https://T4mako.github.io/code/java/Java%20%E5%9F%BA%E7%A1%80/%E5%B8%B8%E7%94%A8%E7%B1%BB/Stream%20API.html</guid>
      <source url="https://T4mako.github.io/rss.xml">Stream API 的理解与使用</source>
      <description>Stream API 的理解与使用 流表示包含着一系列元素的集合，可以对其做不同类型的操作，用来对这些元素执行计算 Stream执行流程 Stream的实例化 一系列中间操作（过滤，映射、......） 终止操作 中间操作与终端操作: 中间操作会再次返回一个流，所以可以链接多个中间操作，上述代码中的 filter 过滤，map 对象转换，sorted 排序，就属于中间操作。 终端操作是对流操作的一个结束动作，一般返回 void 或者一个非流的结果。上述代码中的 forEach循环 就是一个终止操作。</description>
      <category>java</category>
      <pubDate>Fri, 04 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Stream API 的理解与使用</h1>
<p>流表示包含着一系列<code>元素的集合</code>，可以对其做不同类型的操作，用来对这些元素执行计算</p>
<p>Stream执行流程</p>
<ul>
<li>Stream的实例化</li>
<li>一系列中间操作（过滤，映射、......）</li>
<li>终止操作</li>
</ul>
<!-- more    -->
<p>中间操作与终端操作:</p>
<ol>
<li>中间操作会再次返回一个流，所以可以链接多个中间操作，上述代码中的 filter 过滤，map 对象转换，sorted 排序，就属于中间操作。</li>
<li>终端操作是对流操作的一个结束动作，一般返回 <code>void</code> 或者一个<code>非流的结果</code>。上述代码中的 forEach循环 就是一个终止操作。</li>
</ol>
<p>大部分流操作都支持 <code>lambda</code> 表达式作为参数，应该说是接受一个函数式接口的实现作为参数。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 1、一些 Stream API</h2>
<h3> 创建流</h3>
<ul>
<li><code>stream()</code> 方法 通过集合获取 Stream 流</li>
<li><code>Stream.of()</code> 从一堆对象中创建 Stream 流。</li>
<li><code>IntStream</code>，<code>LongStream</code>，<code>DoubleStream</code>：特殊类型的流，用于处理原始数据类型int，long以及double</li>
</ul>
<h3> 中间操作</h3>
<h4> 1、筛选与切片</h4>
<table>
<thead>
<tr>
<th>方 法</th>
<th>描 述</th>
</tr>
</thead>
<tbody>
<tr>
<td>filter(Predicate p)</td>
<td>接收 Lambda ， 从流中排除某些元素</td>
</tr>
<tr>
<td>distinct()</td>
<td>筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素</td>
</tr>
<tr>
<td>limit(long maxSize)</td>
<td>截断流，使其元素不超过给定数量</td>
</tr>
<tr>
<td>skip(long n)</td>
<td>跳过元素，返回一个扔掉了前 个空流。与 limit(n) 互补 n 个元素的流。若流中元素不足 n 个，则返回一</td>
</tr>
</tbody>
</table>
<h4> 2、映射</h4>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>map(Function f)</td>
<td>接收一个函数作为参数，该函数会被应用到每个元 素上，并将其映射成一个新的元素。</td>
</tr>
<tr>
<td>mapToDouble(ToDoubleFunction f)</td>
<td>接收一个函数作为参数，该函数会被应用到每个元 素上，产生一个新的 DoubleStream。</td>
</tr>
<tr>
<td>mapToInt(ToIntFunction f)</td>
<td>接收一个函数作为参数，该函数会被应用到每个元 素上，产生一个新的 IntStream。</td>
</tr>
<tr>
<td>mapToLong(ToLongFunction f)</td>
<td>接收一个函数作为参数，该函数会被应用到每个元 素上，产生一个新的 LongStream。</td>
</tr>
<tr>
<td>flatMap(Function f)</td>
<td>接收一个函数作为参数，将流中的每个值都换成另 一个流，然后把所有流连接成一个流</td>
</tr>
</tbody>
</table>
<h4> 3、排序</h4>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>sorted()</td>
<td>产生一个新流，其中按自然顺序排序</td>
</tr>
<tr>
<td>sorted(Comparator com)</td>
<td>产生一个新流，其中按比较器顺序排序</td>
</tr>
</tbody>
</table>
<h3> 终止操作</h3>
<p>1、匹配与查找</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>allMatch(Predicate p)</td>
<td>检查是否匹配所有元素</td>
</tr>
<tr>
<td>anyMatch(Predicate p)</td>
<td>检查是否至少匹配一个元素</td>
</tr>
<tr>
<td>noneMatch(Predicate p)</td>
<td>检查是否没有匹配所有元素</td>
</tr>
<tr>
<td>findFirst()</td>
<td>返回第一个元素</td>
</tr>
<tr>
<td>findAny()</td>
<td>返回当前流中的任意元素</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>count()</td>
<td>返回流中元素总数</td>
</tr>
<tr>
<td>max(Comparator c)</td>
<td>返回流中最大值</td>
</tr>
<tr>
<td>min(Comparator c)</td>
<td>返回流中最小值</td>
</tr>
<tr>
<td>forEach(Consumer c)</td>
<td>内部迭代(使用 Collection 接口需要用户去做迭代， 称为外部迭代。相反， Stream API 使用内部迭 代——它帮你把迭代做了)</td>
</tr>
</tbody>
</table>
<h3> collect(),reduce(),flatMap()</h3>
<h2> 2、不同类型的 Stream 流</h2>
<p>流按对象类型可分为 <code>原始流</code> 和 <code>对象流</code></p>
<p>可以从各种数据源中创建 Stream 流，其中以 <code>Collection</code> 集合最为常见。如 <code>List</code> 和 <code>Set</code> 均支持 <code>stream()</code> 方法来创建顺序流或者是并行流。</p>
<blockquote>
<p>并行流与顺序流：并行流是通过多线程的方式来执行的，本文先讨论顺序流</p>
</blockquote>
<h3> 创建流的方式</h3>
<ul>
<li><code>stream()</code> 方法 通过集合获取 Stream 流</li>
<li><code>Stream.of()</code> 从一堆对象中创建 Stream 流。</li>
<li><code>IntStream</code>，<code>LongStream</code>，<code>DoubleStream</code>：特殊类型的流，用于处理原始数据类型int，long以及double</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>IntStreams.range()</code>方法还可以被用来取代常规的 for 循环</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>原始类型流使用其独有的函数式接口，例如IntFunction代替Function，IntPredicate代替Predicate。</li>
<li>原始类型流支持额外的终端聚合操作，<code>sum()</code> 以及 <code>average()</code></li>
</ul>
<h3> 原始流和对象流的转换</h3>
<ol>
<li>
<p>将常规对象流转换为原始类型流：<br>
<code>mapToInt()</code>，<code>mapToLong()</code>，<code>mapToDouble</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>原始类型流装换成对象流<br>
<code>mapToObj()</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<h2> 3、Stream 流的处理顺序</h2>
<h3> 垂直执行</h3>
<p>垂直执行：输出的结果是随着链条垂直移动的。<br>
上一个中间操作的结果顺势往下执行直到终端操作。</p>
<p>典型的方法如：<code>filter</code>，<code>map</code>，<code>forEach</code>，<code>anyMatch</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>中间操作顺序的不同会影响性能</p>
</div>
<h3> 水平执行</h3>
<p>所有元素都要完成这个操作<br>
比如 <code>sorted</code> 排序方法是水平执行的<br>
如果 元素只有一个，<code>sorted</code> 方法不执行</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 4、数据流复用</h2>
<p>Java8 Stream 流是不能被复用的，调用任何终端操作，流就会关闭<br>
为了克服这个限制，可以为想要执行的每个终端操作创建一个新的流链，例如，可以通过 Supplier 来包装一下流，通过 <code>get()</code> 方法来构建一个新的 <code>Stream</code> 流：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 5、常用操作</h2>
<h3> collect()收集器</h3>
<p><code>collect</code> 是终端操作,将流中的元素转变成另外一个不同的对象，例如一个<code>List</code>，<code>Set</code>或<code>Map</code>。<code>collect</code> 接受入参为<code>Collector</code>（收集器），它由四个不同的操作组成：供应器（supplier）、累加器（accumulator）、组合器（combiner）和终止器（finisher）。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 自定义收集器</h3>
<p>比如将流中的所有人转换成一个字符串，包含所有大写的名称，并以|分割。为了达到这种效果，可以通过<code>Collector.of()</code>创建一个新的收集器。同时，我们还需要传入收集器的四个组成部分：<code>供应器</code>、<code>累加器</code>、<code>组合器</code>和<code>终止器</code>。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于Java 中的字符串是 <code>final</code> 类型的，我们需要借助辅助类<code>StringJoiner</code>，来帮我们构造字符串。<br>
最开始供应器使用分隔符构造了一个<code>StringJointer</code>。<br>
累加器用于将每个人的人名转大写，然后加到<code>StringJointer</code>中。<br>
组合器将两个<code>StringJointer</code>合并为一个。<br>
最终，终结器从<code>StringJointer</code>构造出预期的字符串。</p>
<h3> FlatMap()</h3>
<p><code>FlatMap</code> 能够将流的每个元素, 转换为其他对象的流。<br>
因此，每个对象可以被转换为零个，一个或多个其他对象，并以流的方式返回。<br>
之后，这些流的内容会被放入<code>flatMap</code>返回的流中。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简化上述操作</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>flatMap</code>也可用于Java8引入的<code>Optional</code>类。<code>Optional</code>的<code>flatMap</code>操作返回一个<code>Optional</code>或其他类型的对象。所以它可以用于避免繁琐的null检查。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果不为空的话，每个<code>flatMap</code>的调用都会返回预期对象的<code>Optional</code>包装，否则返回为<code>null</code>的<code>Optional</code>包装类。</p>
<h3> Reduce()</h3>
<p>Java8 三种不同的Reduce方法</p>
<ol>
<li>
<p>第一种将流中的元素规约成流中的一个元素。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>第二种<code>reduce</code>方法接受标识值和BinaryOperator累加器。此方法可用于构造一个新的 <code>Person</code>，其中包含来自流中所有其他人的聚合名称和年龄：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>第三种reduce方法接受三个参数：标识值，BiFunction累加器和类型的组合器函数BinaryOperator。由于初始值的类型不一定为Person，我们可以使用这个归约函数来计算所有人的年龄总和：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<h2> 6、并行流</h2>
<p>流是可以并行执行的，当流中存在<strong>大量元素</strong>时，可以<strong>显著提升性能</strong>。<br>
并行流底层使用的<code>ForkJoinPool</code>, 它由<code>ForkJoinPool.commonPool()</code>方法提供。底层线程池的大小<strong>最多为五个</strong> - 默认值取决于 CPU 可用核心数</p>
<h3> 创建并行流</h3>
<p>集合支持<code>parallelStream()</code>方法来创建元素的并行流。<br>
或者在已存在的数据流上调用中间方法<code>parallel()</code>，将串行流转换为并行流</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码输出：</p>
<div class="language-apache line-numbers-mode" data-ext="apache"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>238_除自身以外数组的乘积</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_238_%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_238_%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF.html</guid>
      <source url="https://T4mako.github.io/rss.xml">238_除自身以外数组的乘积</source>
      <description>238_除自身以外数组的乘积</description>
      <category>算法</category>
      <pubDate>Thu, 03 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 238_除自身以外数组的乘积</h1>
]]></content:encoded>
    </item>
    <item>
      <title>334_递增的三元子序列</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_334_%E9%80%92%E5%A2%9E%E7%9A%84%E4%B8%89%E5%85%83%E5%AD%90%E5%BA%8F%E5%88%97.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_334_%E9%80%92%E5%A2%9E%E7%9A%84%E4%B8%89%E5%85%83%E5%AD%90%E5%BA%8F%E5%88%97.html</guid>
      <source url="https://T4mako.github.io/rss.xml">334_递增的三元子序列</source>
      <description>334_递增的三元子序列</description>
      <category>算法</category>
      <pubDate>Thu, 03 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 334_递增的三元子序列</h1>
]]></content:encoded>
    </item>
    <item>
      <title>1431_拥有最多糖果的孩子</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1431_%E6%8B%A5%E6%9C%89%E6%9C%80%E5%A4%9A%E7%B3%96%E6%9E%9C%E7%9A%84%E5%AD%A9%E5%AD%90.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1431_%E6%8B%A5%E6%9C%89%E6%9C%80%E5%A4%9A%E7%B3%96%E6%9E%9C%E7%9A%84%E5%AD%A9%E5%AD%90.html</guid>
      <source url="https://T4mako.github.io/rss.xml">1431_拥有最多糖果的孩子</source>
      <description>1431_拥有最多糖果的孩子</description>
      <category>算法</category>
      <pubDate>Wed, 02 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 1431_拥有最多糖果的孩子</h1>
]]></content:encoded>
    </item>
    <item>
      <title>1768_交替合并字符串</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1768_%E4%BA%A4%E6%9B%BF%E5%90%88%E5%B9%B6%E5%AD%97%E7%AC%A6%E4%B8%B2.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_1768_%E4%BA%A4%E6%9B%BF%E5%90%88%E5%B9%B6%E5%AD%97%E7%AC%A6%E4%B8%B2.html</guid>
      <source url="https://T4mako.github.io/rss.xml">1768_交替合并字符串</source>
      <description>1768_交替合并字符串</description>
      <category>算法</category>
      <pubDate>Wed, 02 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 1768_交替合并字符串</h1>
]]></content:encoded>
    </item>
    <item>
      <title>605_种花问题</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_605_%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_605_%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98.html</guid>
      <source url="https://T4mako.github.io/rss.xml">605_种花问题</source>
      <description>605_种花问题</description>
      <category>算法</category>
      <pubDate>Tue, 01 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 605_种花问题</h1>
]]></content:encoded>
    </item>
    <item>
      <title>056. 合并区间</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_056_%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_056_%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.html</guid>
      <source url="https://T4mako.github.io/rss.xml">056. 合并区间</source>
      <description>056. 合并区间</description>
      <category>算法</category>
      <pubDate>Mon, 31 Jul 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 056. 合并区间</h1>
<!-- more -->
<p><a href="https://leetcode.cn/problems/merge-intervals/description/" target="_blank" rel="noopener noreferrer">题目描述</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>724_寻找数组的中心下标</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_724_%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E4%B8%8B%E6%A0%87.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_724_%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E4%B8%8B%E6%A0%87.html</guid>
      <source url="https://T4mako.github.io/rss.xml">724_寻找数组的中心下标</source>
      <description>724_寻找数组的中心下标</description>
      <category>算法</category>
      <pubDate>Mon, 31 Jul 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 724_寻找数组的中心下标</h1>
]]></content:encoded>
    </item>
    <item>
      <title>个人介绍 / 留言板</title>
      <link>https://T4mako.github.io/intro.html</link>
      <guid>https://T4mako.github.io/intro.html</guid>
      <source url="https://T4mako.github.io/rss.xml">个人介绍 / 留言板</source>
      <description>个人介绍 / 留言板</description>
      <pubDate>Thu, 27 Jul 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 个人介绍 / 留言板</h1>
<!-- more -->
<h2> 我是谁？</h2>
<ul>
<li>T4mako</li>
<li>经典社恐</li>
<li>性别：男</li>
<li>年龄：22</li>
<li>婚姻情况: 未婚</li>
<li>单身: 是</li>
<li>学历：苏州科技大学 CS在读</li>
</ul>
<p>T4mako名字的由来：Tamako来自于<a href="https://www.kyotoanimation.co.jp/" target="_blank" rel="noopener noreferrer">京都动画</a>公司第二部原创动画<a href="http://tamakomarket.com/" target="_blank" rel="noopener noreferrer">《玉子市场》</a>的女主人公北白川たまこ（Kitashirakawa Tamako）。<br>
同时作为一名CSGO玩家，受职业选手启发，有着数字代表字母的‘美德’<code>1-&gt;i/l,3-&gt;e,4-&gt;a···</code>。<s>CSGO？赚钱工具！</s><br>
因此T4mako从宇宙诞生了。</p>
<h2> 兴趣爱好</h2>
<ul>
<li>编程 <s>解决吃饭</s></li>
<li>打游戏 <s>电子阳痿</s></li>
<li>MAD/摸鱼 <s>计算机图形学实验员</s></li>
<li>看番 <s>婆罗门</s></li>
<li>厨艺 <s>吃饭糊弄学研究方向</s></li>
<li>more and more <s>感兴趣但不会</s></li>
</ul>
<h2> 社交媒体与联系方式</h2>
<p>联系方式：</p>
<ul>
<li>你可以在下方留言</li>
<li>或通过QQ号查找到我：1536954632</li>
</ul>
<p>社交媒体：</p>
<ul>
<li><a href="https://space.bilibili.com/313309138" target="_blank" rel="noopener noreferrer">Bilibili</a> <s>（home）</s></li>
<li><a href="https://github.com/T4mako" target="_blank" rel="noopener noreferrer">GitHub</a> <s>（学习与整活）</s></li>
<li><a href="https://bgm.tv/user/t4mako" target="_blank" rel="noopener noreferrer">Bangumi</a> <s>（速来看番）</s></li>
<li><a href="https://steamcommunity.com/profiles/76561199025694576/" target="_blank" rel="noopener noreferrer">Steam</a> <s>（Van♂游戏）</s></li>
<li><a href="https://music.163.com/#/user/home?id=559686132" target="_blank" rel="noopener noreferrer">网易云</a> <s>（没有音乐会死）</s></li>
<li><a href="https://m.weibo.cn/u/6321875003" target="_blank" rel="noopener noreferrer">微博</a> <s>（理发店）</s></li>
<li><a href="https://www.douyin.com/user/MS4wLjABAAAA32mwXDHtuWrwk5MD48IWbQCxLEzl1K-wBpUKNiH6NdA" target="_blank" rel="noopener noreferrer">抖音</a> <s>（随心发）</s></li>
</ul>
<h2> 日常</h2>
<p>学习、睡觉、吃饭、玩</p>
<h2> 关于博客</h2>
<p>本博客基于<a href="https://theme-hope.vuejs.press/zh/" target="_blank" rel="noopener noreferrer">vuepress-theme-hope</a>主题搭建的<a href="https://vuejs.press/zh/" target="_blank" rel="noopener noreferrer">vuepress</a>博客。<br>
该博客存储我的大部分笔记，并提供搜索、评论服务<s>我真会来搜吗</s></p>
<h2> 请我喝一杯</h2>
<p><s>我看看会不会真有人Vme</s></p>
<table>
<thead>
<tr>
<th style="text-align:center">微信</th>
<th style="text-align:center">支付宝</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h2> 博客待完善的内容</h2>
<ul>
<li>文章格式整理</li>
<li>RSS订阅</li>
<li>背景图更换</li>
<li>更多玩法</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>基于 vue-theme-hope 的博客搭建指南</title>
      <link>https://T4mako.github.io/code/%E5%85%B6%E4%BB%96/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA.html</link>
      <guid>https://T4mako.github.io/code/%E5%85%B6%E4%BB%96/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA.html</guid>
      <source url="https://T4mako.github.io/rss.xml">基于 vue-theme-hope 的博客搭建指南</source>
      <description>基于 vue-theme-hope 的博客搭建指南 在构建博客时，推荐参照官方文档进行构建，本文知识大致介绍与提出基本概念，帮助大家快速构建博客。</description>
      <category>Vue</category>
      <pubDate>Thu, 27 Jul 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 基于 vue-theme-hope 的博客搭建指南</h1>
<p>在构建博客时，推荐参照<a href="https://theme-hope.vuejs.press/zh/" target="_blank" rel="noopener noreferrer">官方文档</a>进行构建，本文知识大致介绍与提出基本概念，帮助大家快速构建博客。</p>
<!-- more -->
<p>搭建个人博客的好处有很多，包括笔记管理，快速定位搜索，知识点复习，激发创作欲等，每个程序员都应有一个个人博客。<s>什么暴论</s><br>
目前搭建个人博客、资料库的手段很多。例如hexo，wordpress，VuePress，自行搭建······。<br>
<a href="https://v2.vuepress.vuejs.org/zh/" target="_blank" rel="noopener noreferrer">VuePress</a>是Vue 驱动的静态网站生成器，VuePress的核心是以Markdown文件为中心，由 Vue、Vue Router 和 webpack驱动的单页应用，它功能强大并支持诸多插件。<br>
<a href="https://theme-hope.vuejs.press/zh/" target="_blank" rel="noopener noreferrer">VuePress Theme Hope</a>是一个具有强大功能的 vuepress 主题，它基于VuePress2.x并提供了更强大的功能。</p>
<h2> 构建项目</h2>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>在搭建blog之前，你需要准备：</p>
<ul>
<li><a href="https://nodejs.org/zh-cn" target="_blank" rel="noopener noreferrer">Node.js</a> 16+</li>
<li>推荐使用<a href="https://pnpm.io/" target="_blank" rel="noopener noreferrer">pnpm</a> 7+作为包管理工具</li>
</ul>
</div>
<p>初始化项目：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的<code>my-docs</code>代表当前目录下的项目文件夹名称<br>
构建项目时，可以选择<code>简体中文</code>并回车来在后续流程中使用中文进行显示。<br>
在模板初始化成功后选择立即启动开发服务器，你就可以在浏览器地址栏输入 <code>localhost:8080/</code> 访问你的博客。</p>
<h2> 基本概念</h2>
<p>在构建项目后，开发项目前，你需要了解的<strong>基础知识</strong>：</p>
<ol>
<li>VuePress 是以<a href="https://theme-hope.vuejs.press/zh/cookbook/markdown/" target="_blank" rel="noopener noreferrer">Markdown</a> 为中心的。你项目中的每一个 Markdown 文件都是一个单独的页面。</li>
<li>主要配置文件：
<ul>
<li><code>.vuepress/config.ts</code>：<strong>VuePress的配置文件</strong>，用于配置主题，插件，站点等，<a href="https://vuejs.press/zh/reference/config.html" target="_blank" rel="noopener noreferrer">相关配置</a></li>
<li><code>.vuepress/theme.ts</code>：<strong>主题配置</strong>，用于配置主题的功能、布局、外观等，<a href="https://theme-hope.vuejs.press/zh/config/theme/layout.html" target="_blank" rel="noopener noreferrer">相关配置</a></li>
<li><code>narbar.ts</code>：用于配置<strong>导航栏</strong>布局，<a href="https://theme-hope.vuejs.press/zh/guide/layout/navbar.html" target="_blank" rel="noopener noreferrer">相关配置</a></li>
<li><code>sidebat.ts</code>：用于配置<strong>侧边栏</strong>布局，<a href="https://theme-hope.vuejs.press/zh/guide/layout/sidebar.html" target="_blank" rel="noopener noreferrer">相关配置</a></li>
</ul>
</li>
<li><code>frontmatter</code>：必须放在.md文件的<strong>开头</strong>，可以配置Markdown文件的相关信息，这些信息用于显示在博客上的标题，图标，时间，分类等，<a href="https://theme-hope.vuejs.press/zh/config/frontmatter/" target="_blank" rel="noopener noreferrer">相关配置</a></li>
<li>博客首页（<code>.vuepress/README.md</code>）：如果你创建的是博客项目，那么你打开博客后的初始页面为首页，你可以对其进行配置，也可以更改首页。<a href="https://theme-hope.vuejs.press/zh/guide/blog/" target="_blank" rel="noopener noreferrer">相关配置</a></li>
<li>个人介绍页（<code>.vuepress/intro.md</code>）</li>
<li>.vuepress/styles：样式配置，用于配置主题样式，添加自己的样式等，<a href="https://theme-hope.vuejs.press/zh/config/style.html" target="_blank" rel="noopener noreferrer">相关配置</a></li>
<li><a href="https://theme-hope.vuejs.press/zh/cookbook/tutorial/content.html#%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%94%9F%E6%88%90" target="_blank" rel="noopener noreferrer">Markdown 文件路由路径</a></li>
</ol>
<p><strong>你可以在vueprress-theme-hope<a href="https://theme-hope.vuejs.press/zh/" target="_blank" rel="noopener noreferrer">官方文档</a>中查询所有的配置与功能</strong></p>
<h2> MarkDown增强</h2>
<p>有了MarkDown增强即可在编写文章时使用更多的语法来实现更丰富的效果。</p>
<ul>
<li><a href="https://v2.vuepress.vuejs.org/zh/guide/markdown.html#%E8%AF%AD%E6%B3%95%E6%89%A9%E5%B1%95" target="_blank" rel="noopener noreferrer">VuePress 本身新增了一些 Markdown 语法</a></li>
<li>vuepress-theme-hope 通过 <a href="https://plugin-md-enhance.vuejs.press/zh/" target="_blank" rel="noopener noreferrer">vuepress-plugin-md-enhance</a> 在 Markdown 中启用了更多的语法与新功能。</li>
</ul>
<h2> 在MarkDown中使用Vue</h2>
<p>在MarkDown文件中可以使用Vue语法和Vue组件<br>
建议在<code>.vuepress/components</code>文件夹下创建组件<br>
通过<code>@vuepress/plugin-register-components</code>插件可以进行组件的注册</p>
<p><a href="https://vuejs.press/zh/reference/plugin/register-components.html" target="_blank" rel="noopener noreferrer">安装插件与配置项</a></p>
<p><a href="https://theme-hope.vuejs.press/zh/cookbook/customize/component.html#%E5%9C%A8-markdown-%E4%B8%AD%E4%BD%BF%E7%94%A8-vue-%E8%AF%AD%E6%B3%95%E4%B8%8E%E7%BB%84%E4%BB%B6" target="_blank" rel="noopener noreferrer">在vuepress-theme-hope中使用</a>：<br>
为了正确导入自己的组件，你需要为它们创建别名，你可以通过 alias 选项实现这一点:</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在MarkDown中引入：</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 插件</h2>
<p>vuepress的官方<a href="https://vuejs.press/zh/reference/plugin/" target="_blank" rel="noopener noreferrer">插件</a><br>
vuepress-theme-hope内置的<a href="https://theme-hope.vuejs.press/zh/config/plugins/" target="_blank" rel="noopener noreferrer">插件</a><br>
<a href="https://marketplace.vuejs.press/zh/" target="_blank" rel="noopener noreferrer">插件市场</a>包括更强的搜索，博客，live-2d等功能</p>
<h2> 常见问题</h2>
<p>在构建过程中，难免会发生问题，大部分问题你可以在<a href="https://theme-hope.vuejs.press/zh/faq/" target="_blank" rel="noopener noreferrer">常见问题</a>和<a href="https://github.com/vuepress-theme-hope/vuepress-theme-hope/issues" target="_blank" rel="noopener noreferrer">GitHub issues</a>上找到</p>
<h2> 项目的部署</h2>
<p><a href="https://t4mako.github.io/code/%E8%BF%90%E7%BB%B4%E4%B8%8E%E9%83%A8%E7%BD%B2/GitHub%20Actions.html" target="_blank" rel="noopener noreferrer">推荐使用 GitHub Actions 部署到 GitHub Pages</a><br>
<a href="https://vuejs.press/zh/guide/deployment.html" target="_blank" rel="noopener noreferrer">其他方式部署</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>GitHub Actions 部署</title>
      <link>https://T4mako.github.io/code/%E8%BF%90%E7%BB%B4%E4%B8%8E%E9%83%A8%E7%BD%B2/GitHub%20Actions.html</link>
      <guid>https://T4mako.github.io/code/%E8%BF%90%E7%BB%B4%E4%B8%8E%E9%83%A8%E7%BD%B2/GitHub%20Actions.html</guid>
      <source url="https://T4mako.github.io/rss.xml">GitHub Actions 部署</source>
      <description>使用 GitHub Actions 部署，以 vuepress-theme-hope Blog 为例</description>
      <category>部署</category>
      <pubDate>Mon, 24 Jul 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>使用 GitHub Actions 部署，以 vuepress-theme-hope Blog 为例</p>
<!-- more -->
<p>关于 git  相关使用  <a href="/code/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Git">GIt基础</a></p>
<p><a href="https://github.com/features/actions" target="_blank" rel="noopener noreferrer">GitHub Actions</a> 是 GitHub 的 <a href="https://www.ruanyifeng.com/blog/2015/09/continuous-integration.html" target="_blank" rel="noopener noreferrer">持续集成服务(CI/CD)</a></p>
<h3> GitHub Actions 术语：</h3>
<ul>
<li><strong>workflow</strong> （工作流程）：持续集成一次运行的过程，就是一个 wor	kflow。</li>
<li><strong>job</strong> （任务）：一个 workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务。</li>
<li><strong>step</strong>（步骤）：每个 job 由多个 step 构成，一步步完成。</li>
<li><strong>action</strong> （动作）：每个 step 可以依次执行一个或多个命令（action）。</li>
</ul>
<h3> workflow 文件</h3>
<p>GitHub Actions 的配置文件叫做 workflow 文件，存放在代码仓库的<code>.github/workflows</code>目录。</p>
<p>workflow 文件采用 YAML 格式，文件名可以任意取<br>
一个库可以有多个 workflow 文件<br>
GitHub 只要发现<code>.github/workflows</code>目录里面有<code>.yml</code>文件，就会自动运行该文件。</p>
<p>workflow 文件配置规则：<a href="https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions" target="_blank" rel="noopener noreferrer">https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions</a></p>
<h3> 部署 vuepress-theme-hope Blog 到 GitHub pages</h3>
<p>当 commit 到 main 分支后，GitHub Actions 就会执行 jobs 下的步骤</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后，提交到 main 分支下的内容通过自动构建并将 dist 目录部署到 GitHub Pages 上（注意设置GitHub Pages的依赖分支）</p>
]]></content:encoded>
    </item>
    <item>
      <title>VuePress 中的 Markdown 扩展</title>
      <link>https://T4mako.github.io/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/vue/vuepress/markdown%E6%89%A9%E5%B1%95.html</link>
      <guid>https://T4mako.github.io/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/vue/vuepress/markdown%E6%89%A9%E5%B1%95.html</guid>
      <source url="https://T4mako.github.io/rss.xml">VuePress 中的 Markdown 扩展</source>
      <description>VuePress 中的 Markdown 扩展 https://theme-hope.vuejs.press/zh/guide/markdown/intro.html VuePress 会使用 markdown-it 来解析 Markdown 内容，因此可以借助于 markdown-it 插件来实现 语法扩展</description>
      <category>MarkDown</category>
      <pubDate>Thu, 20 Jul 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> VuePress 中的 Markdown 扩展</h1>
<p><a href="https://theme-hope.vuejs.press/zh/guide/markdown/intro.html" target="_blank" rel="noopener noreferrer">https://theme-hope.vuejs.press/zh/guide/markdown/intro.html</a></p>
<p>VuePress 会使用 <a href="https://github.com/markdown-it/markdown-it" target="_blank" rel="noopener noreferrer">markdown-it</a> 来解析 Markdown 内容，因此可以借助于 markdown-it 插件来实现 <a href="https://github.com/markdown-it/markdown-it#syntax-extensions" target="_blank" rel="noopener noreferrer">语法扩展</a></p>
<h2> 链接</h2>
<p>VuePress 中的 链接语法 转换：</p>
<p>原始Markdown：</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>转换为：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>内部链接会被转换为 <code>&lt;RouterLink&gt;</code> 以便进行 SPA 导航。</li>
<li>指向 <code>.md</code> 文件的内部链接会被转换为目标页面的 <a href="https://theme-hope.vuejs.press/zh/cookbook/vuepress/page.html#%E8%B7%AF%E7%94%B1" target="_blank" rel="noopener noreferrer">路由路径</a>，并且支持绝对路径和相对路径。</li>
<li>外部链接会被添加 <code>target="_blank" rel="noopener noreferrer"</code> 属性。</li>
</ul>
<h3> 建议</h3>
<p>对于 <strong>内部链接</strong>，尽可能使用 <strong>相对路径</strong> 而不是绝对路径。</p>
<p>在使用绝对路径时，如果你站点的 base 不是 <code>"/"</code>，你需要手动添加 <code>base</code> 或者使用  base helper 。</p>
<h3> 引入目录</h3>
<p>如果你想要把当前页面的目录添加到 Markdown 内容中，你可以使用 <code>[[toc]]</code> 语法。</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 代码块</h2>
<p>代码块在 Node 端处理</p>
<h3> 行高亮</h3>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>行数范围标记的例子:</p>
<ul>
<li>行数范围: <code>{5-8}</code></li>
<li>多个单行: <code>{4,7,9}</code></li>
<li>组合: <code>{4,7-13,16,23-27,40}</code></li>
</ul>
<h3> 行号</h3>
<p>行号默认启用</p>
<p>局部禁用方式：</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> :no-v-pre</h3>
<p>为了避免你的代码块被 Vue 编译<br>
可以在代码块添加 <code>:v-pre</code> / <code>:no-v-pre</code> 标记来覆盖配置项中的设置。</p>
<h3> 导入代码块</h3>
<p>从文件中导入代码块: <a href="https://theme-hope.vuejs.press/zh/cookbook/vuepress/markdown.html#%E5%AF%BC%E5%85%A5%E4%BB%A3%E7%A0%81%E5%9D%97" target="_blank" rel="noopener noreferrer">https://theme-hope.vuejs.press/zh/cookbook/vuepress/markdown.html#导入代码块</a></p>
<h2> 在 Markdown中使用 Vue</h2>
<ul>
<li>Markdown 中允许使用 HTML。</li>
<li>Vue 模板语法是和 HTML 兼容的。</li>
</ul>
<p>Markdown 中允许直接使用 <a href="https://v3.vuejs.org/guide/template-syntax.html" target="_blank" rel="noopener noreferrer">Vue 模板语法</a></p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：不要在 VuePress 的 Markdown 中使用已废弃的 html 标签</p>
<h3> 使用Vue组件</h3>
<p>在MarkDown文件中可以使用Vue语法和Vue组件<br>
建议在<code>.vuepress/components</code>文件夹下创建组件<br>
通过<code>@vuepress/plugin-register-components</code>插件可以进行组件的注册</p>
<p><a href="https://vuejs.press/zh/reference/plugin/register-components.html" target="_blank" rel="noopener noreferrer">安装插件与配置项</a></p>
<p><a href="https://theme-hope.vuejs.press/zh/cookbook/customize/component.html#%E5%9C%A8-markdown-%E4%B8%AD%E4%BD%BF%E7%94%A8-vue-%E8%AF%AD%E6%B3%95%E4%B8%8E%E7%BB%84%E4%BB%B6" target="_blank" rel="noopener noreferrer">在vuepress-theme-hope中使用</a>：<br>
为了正确导入自己的组件，你需要为它们创建别名，你可以通过 alias 选项实现这一点:</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在MarkDown中引入：</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>JWT 教程</title>
      <link>https://T4mako.github.io/code/java/JWT.html</link>
      <guid>https://T4mako.github.io/code/java/JWT.html</guid>
      <source url="https://T4mako.github.io/rss.xml">JWT 教程</source>
      <description>JSON Web Token (JWT) 是一个开放标准（rfc7519），它定义了一种紧凑的、自包含的方式，用于在各方之间以 JSON对象 安全地传输信息。此信息可以验证和信任，因为它是数字签名的。JWT 可以使用 HMAC算法 或 使用 RSA 或 ECDSA 的公钥/私钥对进行签名</description>
      <category>java</category>
      <pubDate>Fri, 09 Jun 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>JSON Web Token (<a href="https://jwt.io/introduction/" target="_blank" rel="noopener noreferrer">JWT</a>) 是一个开放标准（rfc7519），它定义了一种紧凑的、自包含的方式，用于在各方之间以 <strong>JSON对象</strong> 安全地传输信息。此信息可以验证和信任，因为它是数字签名的。JWT 可以使用 HMAC算法 或 使用 RSA 或 ECDSA 的公钥/私钥对进行签名</p>
<!-- more -->
<p>JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案</p>
<h3> 1、JWT 作用</h3>
<p>1、<strong>登录授权</strong></p>
<ul>
<li>用户登录，后续每个请求将包括 JWT，从而允许用户访问该令牌允许的路由，服务和资源。|<br>
<strong>单点登录</strong> 是当今广泛使用JWT的一项功能，因为它的开销小且能在不同的域中使用。</li>
</ul>
<p>2、<strong>信息交换</strong></p>
<ul>
<li>JSON Web Token 可以在各方之间安全传输信息<br>
通过对 JWT 进行签名（例如，使用公钥/私钥对），可以确保发件人是他们所说的人。<br>
此外，由于签名是使用标头和有效负载计算的，因此您还可以验证内容是否遭到篡改。</li>
</ul>
<h3> 2、session 与 JWT 对比</h3>
<h4> 传统的Session认证</h4>
<p>认证方式：</p>
<ol>
<li>用户向服务器发送用户名和密码。</li>
<li>服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</li>
<li>服务器向用户返回一个 session_id，写入用户的 Cookie。</li>
<li>用户 <strong>随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器</strong>。</li>
<li>服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</li>
</ol>
<blockquote>
<p>这种模式的问题在于，扩展性（scaling）不好。<br>
单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，<strong>每台服务器都能够读取 session</strong></p>
<p>http 协议本身是一种 无状态 的协议，我们并不能知道是哪个用户发出的请求</p>
<p>所以为了让我们的应用能识别是哪个用户发出的请求，我们只能在 <strong>服务器存储</strong> 一份用户登录的信息，这份登录信息会在响应时传递给浏览器，告诉其保存为cookie,以便下次请求时发送给我们的应用，这样我们的应用就能识别请求来自哪个用户了,这就是传统的基于session认证。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20200726103959013.png" alt="image-20200726103959013" loading="lazy"></p>
<p>暴露问题：</p>
<ol>
<li>每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，通常而言 session 都是保存在 <strong>内存</strong> 中，而随着认证用户的增多，服务端的开销会明显增大</li>
<li>用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上，这样在分布式的应用上，相应的限制了 <strong>负载均衡</strong> 器的能力。这也意味着限制了应用的扩展能力。</li>
<li>因为是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。</li>
<li>在前后端分离系统中：<br>
① 通常用户一次请求就要转发多次。如果每次携带 sessionid 到服务器，服务器还要查询用户信息。<br>
② 如果用户很多。这些信息存储在服务器内存中，给 <strong>服务器增加负担</strong>。<br>
③ <strong>CSRF</strong> 攻击：session 是基于cookie 进行用户识别的, cookie 如果被截获，用户就会很容易受到 跨站请求伪造 的攻击。<br>
④ sessionid 就是一个特征值，<strong>表达的信息不够丰富</strong>。不容易扩展。而且如果你后端应用是多节点部署。那么就需要实现session共享机制。不方便集群应用。</li>
</ol>
<blockquote>
<p>一种解决方案是 <strong>session 数据持久化</strong>，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。</p>
<p>另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。</p>
</blockquote>
<h4> JWT认证</h4>
<p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20200726183248298.png" alt="" loading="lazy"></p>
<p><strong>认证流程</strong></p>
<ul>
<li>
<p>前端通过表单将用户名、密码发送到后端。</p>
</li>
<li>
<p>后端核对用户名和密码成功后，将用户的 <strong>id等信息</strong> 作为 <strong>JWT Payload（负载）</strong>，将其与头部分别进行Base64编码拼接后签名，形成一个JWT(Token)。</p>
</li>
<li>
<p>后端将 JWT字符串 作为登录成功的返回结果返回给前端。前端可以将返回的结果保存在 <strong>localStorage</strong> 或 <strong>sessionStorage</strong>上，退出登录时前端删除保存的JWT即可。</p>
</li>
<li>
<p>前端在每次请求时将 JWT 放入 HTTP Header 中的 <strong>Authorization</strong> 位。(解决XSS和XSRF问题)</p>
</li>
<li>
<p>后端验证 JWT 的有效性。例如，检查签名是否正确、Token是否过期、Token的接收方是否是自己等。</p>
</li>
<li>
<p>验证通过后后端使用 JWT 中包含的用户信息进行其他逻辑操作，返回相应结果。</p>
</li>
</ul>
<p><strong>JWT优势</strong></p>
<ul>
<li>
<p>简洁(Compact): 可以通过URL，POST参数或者在HTTP header发送，因为数据量小，传输速度也很快</p>
</li>
<li>
<p>自包含(Self-contained)：负载中包含了所有用户所需要的信息，避免了多次查询数据库</p>
</li>
<li>
<p>因为 Token 是以 JSON 加密的形式保存在客户端的，所以 JWT 是跨语言的，原则上任何web形式都支持。</p>
</li>
<li>
<p>不需要在服务端保存会话信息，特别适用于分布式微服务。</p>
</li>
</ul>
<h3> 3、JWT 结构</h3>
<p><strong>header.payload.singnature</strong></p>
<ul>
<li>1.标头(Header)</li>
<li>2.有效载荷(Payload)</li>
<li>3.签名(Signature)</li>
</ul>
<h4> Header</h4>
<p>标头通常由两部分组成：<br>
① 令牌的类型（即JWT）<br>
② 所使用的签名算法，例如HMAC SHA256或RSA。<br>
它会使用 Base64 编码组成 JWT 结构的第一部分。</p>
<blockquote>
<p>注：Base64是一种编码，并不是一种加密过程，它可以被翻译回原来的样子。</p>
</blockquote>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> Payload</h4>
<p>令牌第二部分是 有效负载，其中包含声明。<br>
声明是有关实体（通常是用户）和其他数据的声明。<br>
同样，它会使用 Base64 编码组成 JWT 结构的第二部分</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>注：JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。</p>
</blockquote>
<h4> Signature</h4>
<ul>
<li>
<p>Signature 需要使用编码后的 header 和 payload 以及我们提供的一个密钥（<strong>盐</strong>），然后使用 header 中指定的签名算法（HS256）进行签名。签名的作用是保证 JWT 没有被篡改过</p>
<p>Signature = HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload),secret);</p>
</li>
</ul>
<p>签名目的</p>
<ul>
<li>最后一步签名的过程，实际上是对头部以及负载内容进行签名，防止内容被窜改。</li>
<li>如果有人对头部以及负载的内容解码之后进行修改，再进行编码，最后加上之前的签名组合形成新的JWT的话，那么服务器端会判断出新的头部和负载形成的签名和JWT附带上的签名是不一样的。</li>
<li>如果要对新的头部和负载进行签名，在不知道服务器加密时用的密钥的话，得出来的签名也是不一样的。</li>
</ul>
<p>信息安全问题</p>
<ul>
<li>
<p>Base64是一种编码，是可逆的，那么信息会暴露</p>
</li>
<li>
<p>因此在 JWT 中，所以不要把秘密信息放在这个部分。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20200726181136113.png" alt="image-20200726181136113" loading="lazy"></p>
<h4> 放在一起</h4>
<p><strong>header.payload.singnature</strong></p>
<ul>
<li>输出是三个由点分隔的Base64-URL字符串</li>
<li>可以通过URL, POST 参数或者在 HTTP header 发送，数据量小，传输速度快</li>
<li>自包含(Self-contained)<br>
负载中包含了所有用户所需要的信息，避免了多次查询数据库</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20200726124257203.png" alt="image-20200726124257203" loading="lazy"></p>
<h3> 4、JWT 使用</h3>
<p><a href="https://jwt.io/libraries" target="_blank" rel="noopener noreferrer">JWT官网提供的使用</a></p>
<p><a href="https://github.com/auth0/java-jwt" target="_blank" rel="noopener noreferrer">基于 Java 的使用</a>：</p>
<h4> 1、引入依赖</h4>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2、生成token</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3、根据令牌和签名解析数据</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4、常见异常信息</h4>
<ul>
<li>SignatureVerificationException:				签名不一致异常</li>
<li>TokenExpiredException:    						令牌过期异常</li>
<li>AlgorithmMismatchException:						算法不匹配异常</li>
<li>InvalidClaimException:								失效的payload异常</li>
</ul>
<h3> 6.封装工具类</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6.整合springboot</h3>
<h4> Controller 层开发</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 测试类编写</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过 Postman 携带 token 测试</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20200805215451442.png" alt="image-20200805215451442" loading="lazy"></p>
<h4> 优化</h4>
<ul>
<li>使用上述方式每次都要传递 token 数据,每个方法都需要 <strong>验证 token 代码冗余</strong></li>
<li>可以使用 <strong>拦截器</strong> 进行优化</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>参考：<br>
<a href="https://www.bilibili.com/video/BV1i54y1m7cP/" target="_blank" rel="noopener noreferrer">https://www.bilibili.com/video/BV1i54y1m7cP/</a><br>
<a href="https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener noreferrer">https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html</a></p>
</blockquote>
]]></content:encoded>
      <enclosure url="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20200726103959013.png" type="image/png"/>
    </item>
    <item>
      <title>LCP 68_美观的花束</title>
      <link>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_LCP68_%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E6%9D%9F.html</link>
      <guid>https://T4mako.github.io/code/leetcode/%E7%AE%97%E6%B3%95/leetcode_LCP68_%E7%BE%8E%E4%B8%BD%E7%9A%84%E8%8A%B1%E6%9D%9F.html</guid>
      <source url="https://T4mako.github.io/rss.xml">LCP 68_美观的花束</source>
      <description>LCP 68_美观的花束</description>
      <category>算法</category>
      <pubDate>Thu, 24 Nov 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> LCP 68_美观的花束</h1>
]]></content:encoded>
    </item>
    <item>
      <title>代码笔记</title>
      <link>https://T4mako.github.io/code/</link>
      <guid>https://T4mako.github.io/code/</guid>
      <source url="https://T4mako.github.io/rss.xml">代码笔记</source>
      <description>基础知识 (/code/基础知识) 前端开发 (/code/前端开发) Java后端 (/code/java) 数据库 (/code/数据库) 运维与部署 (/code/运维与部署) Python (/code/python) Leetcode (/code/Leetcode) 其他 (/code/其他)</description>
      <content:encoded><![CDATA[<h1> </h1>
<!-- more -->
<h3> <a href="/code/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">基础知识</a></h3>
<h3> <a href="/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91">前端开发</a></h3>
<h3> <a href="/code/java">Java后端</a></h3>
<h3> <a href="/code/%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a></h3>
<h3> <a href="/code/%E8%BF%90%E7%BB%B4%E4%B8%8E%E9%83%A8%E7%BD%B2">运维与部署</a></h3>
<h3> <a href="/code/python">Python</a></h3>
<h3> <a href="/code/Leetcode">Leetcode</a></h3>
<h3> <a href="/code/%E5%85%B6%E4%BB%96">其他</a></h3>
]]></content:encoded>
    </item>
    <item>
      <title>友链</title>
      <link>https://T4mako.github.io/friends/</link>
      <guid>https://T4mako.github.io/friends/</guid>
      <source url="https://T4mako.github.io/rss.xml">友链</source>
      <description>友链</description>
      <content:encoded><![CDATA[<h1> 友链</h1>
]]></content:encoded>
    </item>
    <item>
      <title>IDE 快捷键</title>
      <link>https://T4mako.github.io/code/java/IDEA%E3%80%81Eclipse%E5%BF%AB%E6%8D%B7%E9%94%AE.html</link>
      <guid>https://T4mako.github.io/code/java/IDEA%E3%80%81Eclipse%E5%BF%AB%E6%8D%B7%E9%94%AE.html</guid>
      <source url="https://T4mako.github.io/rss.xml">IDE 快捷键</source>
      <description># Eclipse 补全代码的声明： alt + /; 快速修复: ctrl + 1 *; 批量导包： ctrl + shift + o; 使用单行注释： ctrl + / ; 使用多行注释： ctrl + shift + /; 取消多行注释： ctrl + shift + \; 复制指定行的代码： ctrl + alt + down 或 ctrl +...</description>
      <category>java</category>
      <content:encoded><![CDATA[<h1> </h1>
<!-- more -->
<h2> Eclipse</h2>
<ul>
<li>补全代码的声明： alt + /</li>
<li>*快速修复: ctrl + 1 **</li>
<li>批量导包： ctrl + shift + o</li>
<li>使用单行注释： ctrl + /</li>
<li>使用多行注释： ctrl + shift + /</li>
<li>取消多行注释： ctrl + shift + \</li>
<li>复制指定行的代码： ctrl + alt + down 或 ctrl + alt + up</li>
<li>删除指定行的代码： ctrl + d</li>
<li>上下移动代码： alt + up 或 alt + down</li>
<li>切换到下一行代码空位： shift + enter</li>
<li>切换到上一行代码空位： ctrl + shift + enter</li>
<li>如何查看源码： ctrl + 选中指定的结构 或 ctrl + shift + t</li>
<li>退回到前一个编辑的页面： alt + left</li>
<li>进入到下一个编辑的页面(针对于上面那条来说的)： alt + right</li>
<li>光标选中指定的类，查看继承树结构： ctrl + t</li>
<li>复制代码： ctrl + c</li>
<li>撤销： ctrl + z</li>
<li>反撤销： ctrl + y</li>
<li>剪切： ctrl + x</li>
<li>粘贴： ctrl + v</li>
<li>保存： ctrl + s</li>
<li>全选： ctrl + a</li>
<li>格式化代码： ctrl + shift + f （整理代码）</li>
<li>选中数行，整体往后移动： tab</li>
<li>选中数行，整体往前移动： shift + tab</li>
<li>在当前类中，显示类结构，并支持搜索指定的方法、属性等： ctrl + o</li>
<li>批量修改指定的变量名、方法名、类名等： alt + shift + r</li>
<li>选中的结构的大小写的切换：变成大写： ctrl + shift + x</li>
<li>选中的结构的大小写的切换：变成小写： ctrl + shift + y</li>
<li>调出生成 getter/setter/构造器等结构： alt + shift + s</li>
<li>显示当前选择资源(工程 or 文件)的属性： alt + enter</li>
<li>快速查找：参照选中的 Word 快速定位到下一个 ： ctrl + k</li>
<li>关闭当前窗口： ctrl + w</li>
<li>关闭所有的窗口： ctrl + shift + w</li>
<li>查看指定的结构使用过的地方： ctrl + alt + g</li>
<li>查找与替换： ctrl + f</li>
<li>最大化当前的 View： ctrl + m</li>
<li>直接定位到当前行的首位： home</li>
<li>直接定位到当前行的末位： end</li>
</ul>
<p>提示显示的设置：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230718154551691.png" alt="image-20230718154551691" loading="lazy"></p>
<h2> IDEA</h2>
<ul>
<li>alt+insert		选择生成构造器，getter、setter方法......</li>
<li>ctrl+F12		快速找方法</li>
<li>alt+enter		快速声明对象名，提供解异常的方式</li>
<li>ctrl+alt+t		将选中的代码用...包围起来</li>
<li>ctrl+p		将光标放置在()中，显示需要的形参</li>
<li>ctrl+alt+shift+s	文件-项目结构</li>
<li>ctrl+shift+方向键	整体移动代码</li>
<li>alt+←/→		查看左右的文件</li>
<li>ctrl+h		选中类，查看类的继承树</li>
<li>ctrl+shift+z	取消撤销</li>
<li>ctrl+shift+t	(右键代码，GO to Test 选择方法单元测试)单元测试</li>
<li>shift+F6		重命名</li>
<li>ctrl+alt+l		快速整理代码</li>
<li>ctrl+shift+'-/+'	折叠或展开选中的代码</li>
<li>ctrl+shift+/	舒服的快速注释</li>
<li>ctrl+o		重写父类、接口的方法</li>
<li>sout</li>
<li>soutv</li>
</ul>
]]></content:encoded>
      <enclosure url="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230718154551691.png" type="image/png"/>
    </item>
    <item>
      <title>JDBC 基础</title>
      <link>https://T4mako.github.io/code/java/JDBC.html</link>
      <guid>https://T4mako.github.io/code/java/JDBC.html</guid>
      <source url="https://T4mako.github.io/rss.xml">JDBC 基础</source>
      <description>JDBC核心技术 第1章：JDBC概述 1.1 数据的持久化 持久化(persistence)：把数据保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企业级应用，数据持久化意味着将内存中的数据保存到硬盘上加以”固化”，而持久化的实现过程大多通过各种关系数据库来完成。</description>
      <category>java</category>
      <content:encoded><![CDATA[<h2> JDBC核心技术</h2>
<hr>
<h3> 第1章：JDBC概述</h3>
<h4> 1.1 数据的持久化</h4>
<ul>
<li>持久化(persistence)：<strong>把数据保存到可掉电式存储设备中以供之后使用</strong>。大多数情况下，特别是企业级应用，<strong>数据持久化意味着将内存中的数据保存到硬盘</strong>上加以”固化”<strong>，而持久化的实现过程大多通过各种关系数据库来完成</strong>。</li>
</ul>
<!-- more -->
<ul>
<li>
<p>持久化的主要应用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1566741430592.png" alt="1566741430592" loading="lazy"></p>
</li>
</ul>
<h4> 1.2 Java中的数据存储技术</h4>
<ul>
<li>
<p>在Java中，数据库存取技术可分为如下几类：</p>
<ul>
<li>
<p><strong>JDBC</strong>直接访问数据库</p>
</li>
<li>
<p>JDO (Java Data Object )技术</p>
</li>
<li>
<p><strong>第三方O/R工具</strong>，如Hibernate, Mybatis 等</p>
</li>
</ul>
</li>
<li>
<p>JDBC是 java 访问数据库的基石，JDO、Hibernate、MyBatis 等只是更好的封装了JDBC。</p>
</li>
</ul>
<h4> 1.3 JDBC介绍</h4>
<ul>
<li>JDBC(Java Database Connectivity)是一个<strong>独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口</strong>（一组API），定义了用来访问数据库的标准Java类库，（<strong>java.sql,javax.sql</strong>）使用这些类库可以以一种 <strong>标准</strong> 的方法、方便地访问数据库资源。</li>
<li>JDBC为访问不同的数据库提供了一种<strong>统一的途径</strong>，为开发者屏蔽了一些细节问题。</li>
<li>JDBC的目标是使Java程序员使用JDBC可以连接任何<strong>提供了JDBC驱动程序</strong>的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。</li>
<li><strong>简单理解为：JDBC是SUN公司提供的一套API，通过这套API实现具体的数据库操作(获取、关闭连接，CRUD)</strong></li>
<li>如果没有JDBC，那么Java程序访问数据库时是这样的：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1555575760234.png" alt="1555575760234" loading="lazy"></p>
<hr>
<ul>
<li>有了JDBC，Java程序访问数据库时是这样的：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1555575981203.png" alt="1555575981203" loading="lazy"></p>
<hr>
<ul>
<li>总结如下：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1566741692804.png" alt="1566741692804" loading="lazy"></p>
<h4> 1.4 JDBC体系结构</h4>
<ul>
<li>JDBC接口（API）包括两个层次：
<ul>
<li><strong>面向应用的API</strong>：Java API，抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果）。</li>
<li><strong>面向数据库的API</strong>：Java Driver API，供开发商开发数据库驱动程序用。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>JDBC是sun公司提供一套用于数据库操作的接口，java程序员只需要面向这套接口编程即可。</strong></p>
<p><strong>不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。																————面向接口编程</strong></p>
</blockquote>
<h4> 1.5 JDBC程序编写步骤</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1565969323908.png" alt="1565969323908" loading="lazy"></p>
<blockquote>
<p>补充：ODBC(Open Database Connectivity，开放式数据库连接)，是微软在Windows平台下推出的。使用者在程序中只需要调用ODBC API，由 ODBC 驱动程序将调用转换成为对特定的数据库的调用请求。</p>
</blockquote>
<h3> 第2章：获取数据库连接</h3>
<h4> 2.1 、① Driver接口实现类</h4>
<h5> 2.1.1 Driver接口介绍</h5>
<ul>
<li>
<p>java.sql.Driver 接口是所有 JDBC 驱动程序需要实现的。这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现。</p>
</li>
<li>
<p>在程序中不需要直接去访问实现了 Driver 接口的类，而是<em>由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver</em>实现。</p>
<ul>
<li>Oracle的驱动：<strong>oracle.jdbc.driver.OracleDriver</strong></li>
<li>mySql的驱动： <strong>com.mysql.jdbc.Driver</strong></li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1555576157618.png" alt="1555576157618" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1555576170074.png" alt="1555576170074" loading="lazy"></p>
<ul>
<li>将上述jar包拷贝到Java工程的一个目录中，习惯上新建一个lib文件夹。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1566134718955.png" alt="1566134718955" loading="lazy"></p>
<p>在驱动jar上右键--&gt;Build Path--&gt;Add to Build Path</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1566134781682.png" alt="1566134781682" loading="lazy"></p>
<p>注意：如果是Dynamic Web Project（动态的web项目）话，则是把驱动jar放到WebContent（有的开发工具叫WebRoot）目录中的WEB-INF目录中的lib目录下即可</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1566135290460.png" alt="1566135290460" loading="lazy"></p>
<h5> 2.1.2 加载与注册JDBC驱动</h5>
<ul>
<li>
<p>加载驱动：加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名</p>
<ul>
<li><strong>Class.forName(“com.mysql.jdbc.Driver”);</strong></li>
</ul>
</li>
<li>
<p>注册驱动：DriverManager 类是驱动程序管理器类，负责管理驱动程序</p>
<ul>
<li>
<p><strong>使用DriverManager.registerDriver(com.mysql.jdbc.Driver)来注册驱动</strong></p>
</li>
<li>
<p>通常不用显式调用 DriverManager 类的 registerDriver() 方法来注册驱动程序类的实例，因为 Driver 接口的驱动程序类 都包含了 <strong>静态代码块</strong>，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注册自身的一个实例。下图是MySQL的Driver实现类的源码：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1566136831283.png" alt="1566136831283" loading="lazy"></p>
</li>
</ul>
</li>
</ul>
<h4> 2.2 、② URL</h4>
<ul>
<li>
<p>JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。</p>
</li>
<li>
<p>JDBC URL的标准由三部分组成，各部分间用冒号分隔。</p>
<ul>
<li><strong>jdbc:子协议:子名称</strong></li>
<li><strong>协议</strong>：JDBC URL中的协议总是jdbc</li>
<li><strong>子协议</strong>：子协议用于标识一个数据库驱动程序</li>
<li><strong>子名称</strong>：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了<strong>定位数据库</strong>提供足够的信息。包含<strong>主机名</strong>(对应服务端的ip地址)<strong>，端口号，数据库名</strong></li>
</ul>
</li>
<li>
<p>举例：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1555576477107.png" alt="1555576477107" loading="lazy"></p>
</li>
<li>
<p><strong>几种常用数据库的 JDBC URL</strong></p>
<ul>
<li>
<p>MySQL的连接URL编写方式：</p>
<ul>
<li>jdbc:mysql://主机名称:mysql服务端口号/数据库名称?参数=值&amp;参数=值</li>
<li>jdbc:mysql://localhost:3306/atguigu</li>
<li>jdbc:mysql://localhost:3306/atguigu**?useUnicode=true&amp;characterEncoding=utf8**（如果JDBC程序与服务器端的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集）</li>
<li>jdbc:mysql://localhost:3306/atguigu?user=root&amp;password=123456</li>
</ul>
</li>
<li>
<p>Oracle 9i的连接URL编写方式：</p>
<ul>
<li>jdbc:oracle:thin:@主机名称:oracle服务端口号:数据库名称</li>
<li>jdbc:oracle:thin:@localhost:1521:atguigu</li>
</ul>
</li>
<li>
<p>SQLServer的连接URL编写方式：</p>
<ul>
<li>
<p>jdbc:sqlserver://主机名称:sqlserver服务端口号:DatabaseName=数据库名称</p>
</li>
<li>
<p>jdbc:sqlserver://localhost:1433:DatabaseName=atguigu</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4> 2.3、 ③ 用户名和密码</h4>
<ul>
<li>user,password可以用“属性名=属性值”方式告诉数据库</li>
<li>可以调用 DriverManager 类的 getConnection() 方法建立到数据库的连接</li>
</ul>
<h4> 2.4、 数据库连接方式举例</h4>
<h5> 2.4.1 连接方式一</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>说明：上述代码中显式出现了第三方数据库的API</p>
</blockquote>
<h5> 2.4.2 连接方式二</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>说明：相较于方式一，这里使用反射实例化Driver，不在代码中体现第三方数据库的API。体现了面向接口编程思想。</p>
</blockquote>
<h5> 2.4.3 连接方式三</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>说明：使用DriverManager实现数据库的连接。体会获取连接必要的4个基本要素。</p>
</blockquote>
<h5> 2.4.4 连接方式四</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>说明：不必显式的注册驱动了。因为在DriverManager的源码中已经存在静态代码块，实现了驱动的注册。</p>
</blockquote>
<h5> 2.4.5 连接方式五(最终版)</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中，配置文件声明在工程的src目录下：【jdbc.properties】</p>
<div class="language-properties line-numbers-mode" data-ext="properties"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>说明：使用配置文件的方式保存配置信息，在代码中加载配置文件</p>
<p><strong>使用配置文件的好处：</strong></p>
<p>①实现了代码和数据的分离，如果需要修改配置信息，直接在配置文件中修改，不需要深入代码<br>
②如果修改了配置信息，省去重新编译的过程。</p>
</blockquote>
<h3> 第3章：使用PreparedStatement实现CRUD操作</h3>
<h4> 3.1 操作和访问数据库</h4>
<ul>
<li>
<p>数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。其实一个数据库连接就是一个Socket连接。</p>
</li>
<li>
<p>在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式：</p>
<ul>
<li>Statement：用于执行 **静态 SQL **语句并返回.它所生成结果的对象。</li>
<li><strong>PrepatedStatement：SQL 语句被预编译并存储在此对象中，可以使用此对象多次高效地执行该语句。</strong></li>
<li>CallableStatement：用于执行 SQL 存储过程</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1566573842140.png" alt="1566573842140" loading="lazy"></p>
</li>
</ul>
<h4> 3.2 使用 Statement 操作数据表的弊端</h4>
<ul>
<li>
<p>通过调用 Connection 对象的 createStatement() 方法创建该对象。该对象用于执行静态的 SQL 语句，并且返回执行结果。</p>
</li>
<li>
<p>Statement 接口中定义了下列方法用于执行 SQL 语句：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>但是使用 Statement 操作数据表存在弊端：</p>
<ul>
<li><strong>问题一：存在拼串操作，繁琐</strong></li>
<li><strong>问题二：存在SQL注入问题</strong></li>
</ul>
</li>
<li>
<p>SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令(如：SELECT user, password FROM user_table WHERE user='a' OR 1 = ' AND password = ' OR '1' = '1') ，从而利用系统的 SQL 引擎完成恶意行为的做法。</p>
</li>
<li>
<p>对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement(从Statement扩展而来) 取代 Statement 就可以了。</p>
</li>
<li>
<p>代码演示：</p>
</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>综上：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1566569819744.png" alt="1566569819744" loading="lazy"></p>
<h4> 3.3 PreparedStatement的使用</h4>
<h5> 3.3.1 PreparedStatement介绍</h5>
<ul>
<li>
<p>可以通过调用 Connection 对象的 <strong>preparedStatement(String sql)</strong> 方法获取 PreparedStatement 对象</p>
</li>
<li>
<p><strong>PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句</strong></p>
</li>
<li>
<p>PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值</p>
</li>
</ul>
<h5> 3.3.2 PreparedStatement vs Statement</h5>
<ul>
<li>
<p>代码的可读性和可维护性。</p>
</li>
<li>
<p><strong>PreparedStatement 能最大可能提高性能：</strong></p>
<ul>
<li>DBServer会对<strong>预编译</strong>语句提供性能优化。因为预编译语句有可能被重复调用，所以<u>语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。</u></li>
<li>在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样<u>每执行一次都要对传入的语句编译一次。</u></li>
<li>(语法检查，语义检查，翻译成二进制命令，缓存)</li>
</ul>
</li>
<li>
<p>PreparedStatement 可以防止 SQL 注入</p>
</li>
</ul>
<h5> 3.3.3 Java与SQL对应数据类型转换表</h5>
<table>
<thead>
<tr>
<th>Java类型</th>
<th>SQL类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>BIT</td>
</tr>
<tr>
<td>byte</td>
<td>TINYINT</td>
</tr>
<tr>
<td>short</td>
<td>SMALLINT</td>
</tr>
<tr>
<td>int</td>
<td>INTEGER</td>
</tr>
<tr>
<td>long</td>
<td>BIGINT</td>
</tr>
<tr>
<td>String</td>
<td>CHAR,VARCHAR,LONGVARCHAR</td>
</tr>
<tr>
<td>byte   array</td>
<td>BINARY  ,    VAR BINARY</td>
</tr>
<tr>
<td>java.sql.Date</td>
<td>DATE</td>
</tr>
<tr>
<td>java.sql.Time</td>
<td>TIME</td>
</tr>
<tr>
<td>java.sql.Timestamp</td>
<td>TIMESTAMP</td>
</tr>
</tbody>
</table>
<h5> 3.3.4 使用PreparedStatement实现增、删、改操作</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 3.3.5 使用PreparedStatement实现查询操作</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>说明：使用PreparedStatement实现的查询操作可以替换Statement实现的查询操作，解决Statement拼串和SQL注入问题。</p>
</blockquote>
<h4> 3.4 ResultSet与ResultSetMetaData</h4>
<h5> 3.4.1 ResultSet</h5>
<ul>
<li>
<p>查询需要调用PreparedStatement 的 executeQuery() 方法，查询结果是一个ResultSet 对象</p>
</li>
<li>
<p>ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet 接口由数据库厂商提供实现</p>
</li>
<li>
<p>ResultSet 返回的实际上就是一张数据表。有一个指针指向数据表的第一条记录的前面。</p>
</li>
<li>
<p>ResultSet 对象维护了一个指向当前数据行的<strong>游标</strong>，初始的时候，游标在第一行之前，可以通过 ResultSet 对象的 next() 方法移动到下一行。调用 next()方法检测下一行是否有效。若有效，该方法返回 true，且指针下移。相当于Iterator对象的 hasNext() 和 next() 方法的结合体。</p>
</li>
<li>
<p>当指针指向一行时, 可以通过调用 getXxx(int index) 或 getXxx(int columnName) 获取每一列的值。</p>
<ul>
<li>例如: getInt(1), getString("name")</li>
<li><strong>注意：Java与数据库交互涉及到的相关Java API中的索引都从1开始。</strong></li>
</ul>
</li>
<li>
<p>ResultSet 接口的常用方法：</p>
<ul>
<li>
<p>boolean next()</p>
</li>
<li>
<p>getString()</p>
</li>
<li>
<p>…</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1555580152530.png" alt="1555580152530" loading="lazy"></p>
</li>
</ul>
<h5> 3.4.2 ResultSetMetaData</h5>
<ul>
<li>
<p>可用于获取关于 ResultSet 对象中列的类型和属性信息的对象</p>
</li>
<li>
<p>ResultSetMetaData meta = rs.getMetaData();</p>
<ul>
<li>
<p><strong>getColumnName</strong>(int column)：获取指定列的名称</p>
</li>
<li>
<p><strong>getColumnLabel</strong>(int column)：获取指定列的别名</p>
</li>
<li>
<p><strong>getColumnCount</strong>()：返回当前 ResultSet 对象中的列数。</p>
</li>
<li>
<p>getColumnTypeName(int column)：检索指定列的数据库特定的类型名称。</p>
</li>
<li>
<p>getColumnDisplaySize(int column)：指示指定列的最大标准宽度，以字符为单位。</p>
</li>
<li>
<p><strong>isNullable</strong>(int column)：指示指定列中的值是否可以为 null。</p>
</li>
<li>
<p>isAutoIncrement(int column)：指示是否自动为指定列进行编号，这样这些列仍然是只读的。</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1555579494691.png" alt="1555579494691" loading="lazy"></p>
<p><strong>问题1：得到结果集后, 如何知道该结果集中有哪些列 ？ 列名是什么？</strong></p>
<p>​     需要使用一个描述 ResultSet 的对象， 即 ResultSetMetaData</p>
<p><strong>问题2：关于ResultSetMetaData</strong></p>
<ol>
<li><strong>如何获取 ResultSetMetaData</strong>： 调用 ResultSet 的 getMetaData() 方法即可</li>
<li><strong>获取 ResultSet 中有多少列</strong>：调用 ResultSetMetaData 的 getColumnCount() 方法</li>
<li><strong>获取 ResultSet 每一列的列的别名是什么</strong>：调用 ResultSetMetaData 的getColumnLabel() 方法</li>
</ol>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1555579816884.png" alt="1555579816884" loading="lazy"></p>
<h4> 3.5 资源的释放</h4>
<ul>
<li>释放ResultSet, Statement,Connection。</li>
<li>数据库连接（Connection）是<em>非常稀有的资源</em>，用完后<em>必须马上释放</em>，如果Connection不能及时正确的关闭将导致系统宕机。Connection的使用原则是<strong>尽量晚创建，尽量早的释放。</strong></li>
<li>可以在finally中关闭，保证及时其他代码出现异常，资源也一定能被关闭。</li>
</ul>
<h4> 3.6 JDBC API小结</h4>
<ul>
<li>
<p>两种思想</p>
<ul>
<li>
<p>面向接口编程的思想</p>
</li>
<li>
<p>ORM思想(object relational mapping)</p>
<ul>
<li><strong>一个数据表对应一个java类</strong></li>
<li><strong>表中的一条记录对应java类的一个对象</strong></li>
<li><strong>表中的一个字段对应java类的一个属性</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p>sql是需要结合列名和表的属性名来写。注意起别名。</p>
</blockquote>
</li>
<li>
<p>两种技术</p>
<ul>
<li>JDBC结果集的元数据：ResultSetMetaData
<ul>
<li>获取列数：getColumnCount()</li>
<li>获取列的别名：getColumnLabel()</li>
</ul>
</li>
<li>通过反射，创建指定类的对象，获取指定的属性并赋值</li>
</ul>
</li>
</ul>
<hr>
<h3> 章节练习</h3>
<p><strong>练习题1：从控制台向数据库的表customers中插入一条数据，表结构如下：</strong></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1555580275036.png" alt="1555580275036" loading="lazy"></p>
<p><strong>练习题2：创立数据库表 examstudent，表结构如下：</strong></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1555580735377.png" alt="1555580735377" loading="lazy"></p>
<p>向数据表中添加如下数据：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1555580763636.png" alt="1555580763636" loading="lazy"></p>
<p><strong>代码实现1：插入一个新的student 信息</strong></p>
<p>请输入考生的详细信息</p>
<p>Type:<br>
IDCard:<br>
ExamCard:<br>
StudentName:<br>
Location:<br>
Grade:</p>
<p>信息录入成功!</p>
<p><strong>代码实现2：在 eclipse中建立 java 程序：输入身份证号或准考证号可以查询到学生的基本信息。结果如下：</strong></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1555580937490.png" alt="1555580937490" loading="lazy"></p>
<p><strong>代码实现3：完成学生信息的删除功能</strong></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1555580965019.png" alt="1555580965019" loading="lazy"></p>
<hr>
<h3> 第4章 操作BLOB类型字段</h3>
<h4> 4.1 MySQL BLOB类型</h4>
<ul>
<li>
<p>MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。</p>
</li>
<li>
<p>插入BLOB类型的数据必须使用PreparedStatement，因为BLOB类型的数据无法使用字符串拼接写的。</p>
</li>
<li>
<p>MySQL的四种BLOB类型(除了在存储的最大信息量上不同外，他们是等同的)</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1555581069798.png" alt="1555581069798" loading="lazy"></p>
<ul>
<li>实际使用中根据需要存入的数据大小定义不同的BLOB类型。</li>
<li>需要注意的是：如果存储的文件过大，数据库的性能会下降。</li>
<li>如果在指定了相关的Blob类型以后，还报错：xxx too large，那么在mysql的安装目录下，找my.ini文件加上如下的配置参数： <strong>max_allowed_packet=16M</strong>。同时注意：修改了my.ini文件之后，需要重新启动mysql服务。</li>
</ul>
<h4> 4.2 向数据表中插入大数据类型</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4.3 修改数据表中的Blob类型字段</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4.4 从数据表中读取大数据类型</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 第5章 批量插入</h3>
<h4> 5.1 批量执行SQL语句</h4>
<p>当需要成批插入或者更新记录时，可以采用Java的批量<strong>更新</strong>机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率</p>
<p>JDBC的批量处理语句包括下面三个方法：</p>
<ul>
<li><strong>addBatch(String)：添加需要批量处理的SQL语句或是参数；</strong></li>
<li><strong>executeBatch()：执行批量处理语句；</strong></li>
<li><strong>clearBatch():清空缓存的数据</strong></li>
</ul>
<p>通常我们会遇到两种批量执行SQL语句的情况：</p>
<ul>
<li>多条SQL语句的批量处理；</li>
<li>一个SQL语句的批量传参；</li>
</ul>
<h4> 5.2 高效的批量插入</h4>
<p>举例：向数据表中插入20000条数据</p>
<ul>
<li>数据库中提供一个goods表。创建如下：</li>
</ul>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 5.2.1 实现层次一：使用Statement</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 5.2.2 实现层次二：使用PreparedStatement</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 5.2.3 实现层次三</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 5.2.4 实现层次四</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 第6章： 数据库事务</h3>
<h4> 6.1 数据库事务介绍</h4>
<ul>
<li>
<p><strong>事务：一组逻辑操作单元,使数据从一种状态变换到另一种状态。</strong></p>
</li>
<li>
<p><strong>事务处理（事务操作）：<strong>保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都</strong>被提交(commit)</strong>，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务**回滚(rollback)**到最初状态。</p>
</li>
<li>
<p>为确保数据库中数据的<strong>一致性</strong>，数据的操纵应当是离散的成组的逻辑单元：当它全部完成时，数据的一致性可以保持，而当这个单元中的一部分操作失败，整个事务应全部视为错误，所有从起始点以后的操作应全部回退到开始状态。</p>
</li>
</ul>
<h4> 6.2 JDBC事务处理</h4>
<ul>
<li>
<p>数据一旦提交，就不可回滚。</p>
</li>
<li>
<p>数据什么时候意味着提交？</p>
<ul>
<li><strong>当一个连接对象被创建时，默认情况下是自动提交事务</strong>：每次执行一个 SQL 语句时，如果执行成功，就会向数据库自动提交，而不能回滚。</li>
<li>**关闭数据库连接，数据就会自动的提交。**如果多个操作，每个操作使用的是自己单独的连接，则无法保证事务。即同一个事务的多个操作必须在同一个连接下。</li>
</ul>
</li>
<li>
<p><strong>JDBC程序中为了让多个 SQL 语句作为一个事务执行：</strong></p>
<ul>
<li>调用 Connection 对象的 <strong>setAutoCommit(false);</strong> 以取消自动提交事务</li>
<li>在所有的 SQL 语句都成功执行后，调用 <strong>commit();</strong> 方法提交事务</li>
<li>在出现异常时，调用 <strong>rollback();</strong> 方法回滚事务</li>
</ul>
<blockquote>
<p>若此时 Connection 没有被关闭，还可能被重复使用，则需要恢复其自动提交状态 setAutoCommit(true)。尤其是在使用数据库连接池技术时，执行close()方法前，建议恢复自动提交状态。</p>
</blockquote>
</li>
</ul>
<p>【案例：用户AA向用户BB转账100】</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中，对数据库操作的方法为：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 6.3 事务的ACID属性</h4>
<ol>
<li>
<p><strong>原子性（Atomicity）</strong><br>
原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</p>
</li>
<li>
<p><strong>一致性（Consistency）</strong><br>
事务必须使数据库从一个一致性状态变换到另外一个一致性状态。</p>
</li>
<li>
<p><strong>隔离性（Isolation）</strong><br>
事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
</li>
<li>
<p><strong>持久性（Durability）</strong><br>
持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。</p>
</li>
</ol>
<h5> 6.3.1 数据库的并发问题</h5>
<ul>
<li>
<p>对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:</p>
<ul>
<li><strong>脏读</strong>: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还<strong>没有被提交</strong>的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。</li>
<li><strong>不可重复读</strong>: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 <strong>更新</strong>了该字段。之后, T1再次读取同一个字段, 值就不同了。</li>
<li><strong>幻读</strong>: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中<strong>插入</strong>了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。</li>
</ul>
</li>
<li>
<p><strong>数据库事务的隔离性</strong>: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。</p>
</li>
<li>
<p>一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, <strong>隔离级别越高, 数据一致性就越好, 但并发性越弱。</strong></p>
</li>
</ul>
<h5> 6.3.2 四种隔离级别</h5>
<ul>
<li>
<p>数据库提供的4种事务隔离级别：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1555586275271.png" alt="1555586275271" loading="lazy"></p>
</li>
<li>
<p>Oracle 支持的 2 种事务隔离级别：<strong>READ COMMITED</strong>, SERIALIZABLE。 Oracle 默认的事务隔离级别为: <strong>READ COMMITED</strong> 。</p>
</li>
<li>
<p>Mysql 支持 4 种事务隔离级别。Mysql 默认的事务隔离级别为: <strong>REPEATABLE READ。</strong></p>
</li>
</ul>
<h5> 6.3.3 在MySql中设置隔离级别</h5>
<ul>
<li>
<p>每启动一个 mysql 程序, 就会获得一个单独的数据库连接. 每个数据库连接都有一个全局变量 @@tx_isolation, 表示当前的事务隔离级别。</p>
</li>
<li>
<p>查看当前的隔离级别:</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>设置当前 mySQL 连接的隔离级别:</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>设置数据库系统的全局的隔离级别:</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>补充操作：</p>
<ul>
<li>
<p>创建mysql数据库用户：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>授予权限</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
</li>
</ul>
<h3> 第7章：DAO及相关实现类</h3>
<ul>
<li><strong>DAO：Data Access Object访问数据信息的类和接口</strong>，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息。有时也称作：BaseDAO</li>
<li>作用：为了实现功能的模块化，更有利于代码的维护和升级。</li>
<li>下面是尚硅谷JavaWeb阶段书城项目中DAO使用的体现：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1566726681515.png" alt="1566726681515" loading="lazy"></p>
<ul>
<li>层次结构：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1566745811244.png" alt="1566745811244" loading="lazy"></p>
<h4> 【BaseDAO.java】</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 【BookDAO.java】</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 【UserDAO.java】</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 【BookDaoImpl.java】</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 【UserDaoImpl.java】</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 【Book.java】</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 【Page.java】</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 【User.java】</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 第8章：数据库连接池</h3>
<h4> 8.1 JDBC数据库连接池的必要性</h4>
<ul>
<li>
<p>在使用开发基于数据库的web程序时，传统的模式基本是按以下步骤：</p>
<ul>
<li><strong>在主程序（如servlet、beans）中建立数据库连接</strong></li>
<li><strong>进行sql操作</strong></li>
<li><strong>断开数据库连接</strong></li>
</ul>
</li>
<li>
<p>这种模式开发，存在的问题:</p>
<ul>
<li>普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。**数据库的连接资源并没有得到很好的重复利用。**若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。</li>
<li>**对于每一次数据库连接，使用完后都得断开。**否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将导致重启数据库。（回忆：何为Java的内存泄漏？）</li>
<li><strong>这种开发不能控制被创建的连接对象数</strong>，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。</li>
</ul>
</li>
</ul>
<h4> 8.2 数据库连接池技术</h4>
<ul>
<li>
<p>为解决传统开发中的数据库连接问题，可以采用数据库连接池技术。</p>
</li>
<li>
<p><strong>数据库连接池的基本思想</strong>：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。</p>
</li>
<li>
<p><strong>数据库连接池</strong>负责分配、管理和释放数据库连接，它<strong>允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个</strong>。</p>
</li>
<li>
<p>数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由<strong>最小数据库连接数来设定</strong>的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的<strong>最大数据库连接数量</strong>限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1555593464033.png" alt="1555593464033" loading="lazy"></p>
<ul>
<li><strong>工作原理：</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1555593598606.png" alt="1555593598606" loading="lazy"></p>
<ul>
<li>
<p><strong>数据库连接池技术的优点</strong></p>
<p><strong>1. 资源重用</strong></p>
<p>由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。</p>
<p><strong>2. 更快的系统反应速度</strong></p>
<p>数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间</p>
<p><strong>3. 新的资源分配手段</strong></p>
<p>对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源</p>
<p><strong>4. 统一的连接管理，避免数据库连接泄漏</strong></p>
<p>在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露</p>
</li>
</ul>
<h4> 8.3 多种开源的数据库连接池</h4>
<ul>
<li>JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现：
<ul>
<li><strong>DBCP</strong> 是Apache提供的数据库连接池。tomcat 服务器自带dbcp数据库连接池。<strong>速度相对c3p0较快</strong>，但因自身存在BUG，Hibernate3已不再提供支持。</li>
<li><strong>C3P0</strong> 是一个开源组织提供的一个数据库连接池，**速度相对较慢，稳定性还可以。**hibernate官方推荐使用</li>
<li><strong>Proxool</strong> 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，<strong>稳定性较c3p0差一点</strong></li>
<li><strong>BoneCP</strong> 是一个开源组织提供的数据库连接池，速度快</li>
<li><strong>Druid</strong> 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，但是速度不确定是否有BoneCP快</li>
</ul>
</li>
<li>DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池</li>
<li><strong>DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库访问速度。</strong></li>
<li>特别注意：
<ul>
<li>数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此<strong>整个应用只需要一个数据源即可。</strong></li>
<li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。</li>
</ul>
</li>
</ul>
<h5> 8.3.1 C3P0数据库连接池</h5>
<ul>
<li>获取连接方式一</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>获取连接方式二</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中，src下的配置文件为：【c3p0-config.xml】</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 8.3.2 DBCP数据库连接池</h5>
<ul>
<li>DBCP 是 Apache 软件基金组织下的开源连接池实现，该连接池依赖该组织下的另一个开源系统：Common-pool。如需使用该连接池实现，应在系统中增加如下两个 jar 文件：
<ul>
<li>Commons-dbcp.jar：连接池的实现</li>
<li>Commons-pool.jar：连接池实现的依赖库</li>
</ul>
</li>
<li>**Tomcat 的连接池正是采用该连接池来实现的。**该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用。</li>
<li>数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。</li>
<li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但上面的代码并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。</li>
<li>配置属性说明</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>initialSize</td>
<td>0</td>
<td>连接池启动时创建的初始化连接数量</td>
</tr>
<tr>
<td>maxActive</td>
<td>8</td>
<td>连接池中可同时连接的最大的连接数</td>
</tr>
<tr>
<td>maxIdle</td>
<td>8</td>
<td>连接池中最大的空闲的连接数，超过的空闲连接将被释放，如果设置为负数表示不限制</td>
</tr>
<tr>
<td>minIdle</td>
<td>0</td>
<td>连接池中最小的空闲的连接数，低于这个数量会被创建新的连接。该参数越接近maxIdle，性能越好，因为连接的创建和销毁，都是需要消耗资源的；但是不能太大。</td>
</tr>
<tr>
<td>maxWait</td>
<td>无限制</td>
<td>最大等待时间，当没有可用连接时，连接池等待连接释放的最大时间，超过该时间限制会抛出异常，如果设置-1表示无限等待</td>
</tr>
<tr>
<td>poolPreparedStatements</td>
<td>false</td>
<td>开启池的Statement是否prepared</td>
</tr>
<tr>
<td>maxOpenPreparedStatements</td>
<td>无限制</td>
<td>开启池的prepared 后的同时最大连接数</td>
</tr>
<tr>
<td>minEvictableIdleTimeMillis</td>
<td></td>
<td>连接池中连接，在时间段内一直空闲， 被逐出连接池的时间</td>
</tr>
<tr>
<td>removeAbandonedTimeout</td>
<td>300</td>
<td>超过时间限制，回收没有用(废弃)的连接</td>
</tr>
<tr>
<td>removeAbandoned</td>
<td>false</td>
<td>超过removeAbandonedTimeout时间后，是否进 行没用连接（废弃）的回收</td>
</tr>
</tbody>
</table>
<ul>
<li>获取连接方式一：</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>获取连接方式二：</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中，src下的配置文件为：【dbcp.properties】</p>
<div class="language-properties line-numbers-mode" data-ext="properties"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 8.3.3 Druid（德鲁伊）数据库连接池</h5>
<p>Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，<strong>可以说是目前最好的连接池之一。</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中，src下的配置文件为：【druid.properties】</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>详细配置参数：</li>
</ul>
<table>
<thead>
<tr>
<th><strong>配置</strong></th>
<th><strong>缺省</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td></td>
<td>配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。   如果没有配置，将会生成一个名字，格式是：”DataSource-” +   System.identityHashCode(this)</td>
</tr>
<tr>
<td>url</td>
<td></td>
<td>连接数据库的url，不同数据库不一样。例如：mysql :   jdbc:mysql://10.20.153.104:3306/druid2      oracle :   jdbc:oracle:thin:@10.20.149.85:1521:ocnauto</td>
</tr>
<tr>
<td>username</td>
<td></td>
<td>连接数据库的用户名</td>
</tr>
<tr>
<td>password</td>
<td></td>
<td>连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：<a href="https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter" target="_blank" rel="noopener noreferrer">https://github.com/alibaba/druid/wiki/使用ConfigFilter</a></td>
</tr>
<tr>
<td>driverClassName</td>
<td></td>
<td>根据url自动识别   这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下)</td>
</tr>
<tr>
<td>initialSize</td>
<td>0</td>
<td>初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时</td>
</tr>
<tr>
<td>maxActive</td>
<td>8</td>
<td>最大连接池数量</td>
</tr>
<tr>
<td>maxIdle</td>
<td>8</td>
<td>已经不再使用，配置了也没效果</td>
</tr>
<tr>
<td>minIdle</td>
<td></td>
<td>最小连接池数量</td>
</tr>
<tr>
<td>maxWait</td>
<td></td>
<td>获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。</td>
</tr>
<tr>
<td>poolPreparedStatements</td>
<td>false</td>
<td>是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。</td>
</tr>
<tr>
<td>maxOpenPreparedStatements</td>
<td>-1</td>
<td>要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100</td>
</tr>
<tr>
<td>validationQuery</td>
<td></td>
<td>用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。</td>
</tr>
<tr>
<td>testOnBorrow</td>
<td>true</td>
<td>申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。</td>
</tr>
<tr>
<td>testOnReturn</td>
<td>false</td>
<td>归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能</td>
</tr>
<tr>
<td>testWhileIdle</td>
<td>false</td>
<td>建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。</td>
</tr>
<tr>
<td>timeBetweenEvictionRunsMillis</td>
<td></td>
<td>有两个含义： 1)Destroy线程会检测连接的间隔时间2)testWhileIdle的判断依据，详细看testWhileIdle属性的说明</td>
</tr>
<tr>
<td>numTestsPerEvictionRun</td>
<td></td>
<td>不再使用，一个DruidDataSource只支持一个EvictionRun</td>
</tr>
<tr>
<td>minEvictableIdleTimeMillis</td>
<td></td>
<td></td>
</tr>
<tr>
<td>connectionInitSqls</td>
<td></td>
<td>物理连接初始化的时候执行的sql</td>
</tr>
<tr>
<td>exceptionSorter</td>
<td></td>
<td>根据dbType自动识别   当数据库抛出一些不可恢复的异常时，抛弃连接</td>
</tr>
<tr>
<td>filters</td>
<td></td>
<td>属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：   监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall</td>
</tr>
<tr>
<td>proxyFilters</td>
<td></td>
<td>类型是List，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系</td>
</tr>
</tbody>
</table>
<h3> 第9章：Apache-DBUtils实现CRUD操作</h3>
<h4> 9.1 Apache-DBUtils简介</h4>
<ul>
<li>
<p>commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。</p>
</li>
<li>
<p>API介绍：</p>
<ul>
<li>org.apache.commons.dbutils.QueryRunner</li>
<li>org.apache.commons.dbutils.ResultSetHandler</li>
<li>工具类：org.apache.commons.dbutils.DbUtils</li>
</ul>
</li>
<li>
<p>API包说明：</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1555595163263.png" alt="1555595163263" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/1555595198644.png" alt="1555595198644" loading="lazy"></p>
<h4> 9.2 主要API的使用</h4>
<h5> 9.2.1 DbUtils</h5>
<ul>
<li>DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下：
<ul>
<li><strong>public static void close(…) throws java.sql.SQLException</strong>：　DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。</li>
<li>public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。</li>
<li>public static void commitAndClose(Connection conn)throws SQLException： 用来提交连接的事务，然后关闭连接</li>
<li>public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在关闭连接时不抛出SQL异常。</li>
<li>public static void rollback(Connection conn)throws SQLException：允许conn为null，因为方法内部做了判断</li>
<li>public static void rollbackAndClose(Connection conn)throws SQLException</li>
<li>rollbackAndCloseQuietly(Connection)</li>
<li>public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。</li>
</ul>
</li>
</ul>
<h5> 9.2.2 QueryRunner类</h5>
<ul>
<li>
<p><strong>该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。</strong></p>
</li>
<li>
<p>QueryRunner类提供了两个构造器：</p>
<ul>
<li>默认的构造器</li>
<li>需要一个 javax.sql.DataSource 来作参数的构造器</li>
</ul>
</li>
<li>
<p>QueryRunner类的主要方法：</p>
<ul>
<li><strong>更新</strong>
<ul>
<li>public int update(Connection conn, String sql, Object... params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。</li>
<li>......</li>
</ul>
</li>
<li><strong>插入</strong>
<ul>
<li><code>public &lt;T&gt; T insert(Connection conn,String sql,ResultSetHandler&lt;T&gt; rsh, Object... params) throws SQLException</code>：只支持INSERT语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys.  返回值: An object generated by the handler.即自动生成的键值</li>
<li>....</li>
</ul>
</li>
<li><strong>批处理</strong>
<ul>
<li><code>public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException</code>： INSERT, UPDATE, or DELETE语句</li>
<li><code>public &lt;T&gt; T insertBatch(Connection conn,String sql,ResultSetHandler&lt;T&gt;</code> rsh,Object[][] params)throws SQLException：只支持INSERT语句</li>
<li>.....</li>
</ul>
</li>
<li><strong>查询</strong>
<ul>
<li><code>public Object query(Connection conn, String sql, ResultSetHandler rsh,Object... params) throws SQLException</code>：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。</li>
<li>......</li>
</ul>
</li>
</ul>
</li>
<li>
<p>测试</p>
</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 9.2.3 ResultSetHandler接口及实现类</h5>
<ul>
<li>
<p>该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。</p>
</li>
<li>
<p>ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs)。</p>
</li>
<li>
<p>接口的主要实现类：</p>
<ul>
<li>ArrayHandler：把结果集中的第一行数据转成对象数组。</li>
<li>ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。</li>
<li>**BeanHandler：**将结果集中的第一行数据封装到一个对应的JavaBean实例中。</li>
<li>**BeanListHandler：**将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。</li>
<li>ColumnListHandler：将结果集中某一列的数据存放到List中。</li>
<li>KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。</li>
<li>**MapHandler：**将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。</li>
<li>**MapListHandler：**将结果集中的每一行数据都封装到一个Map里，然后再存放到List</li>
<li>**ScalarHandler：**查询单个值对象</li>
</ul>
</li>
<li>
<p>测试</p>
</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> JDBC总结</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://raw.githubusercontent.com/T4mako/ImageBed/main/1566741430592.png" type="image/png"/>
    </item>
    <item>
      <title>JVM</title>
      <link>https://T4mako.github.io/code/java/JVM.html</link>
      <guid>https://T4mako.github.io/code/java/JVM.html</guid>
      <source url="https://T4mako.github.io/rss.xml">JVM</source>
      <description>初识虚拟机 JVM 全称 Java Virtual Machine，即 Java 虚拟机 Java 虚拟机的职责是运行字节码文件 JVM 三大核心功能： JVM 包内存管理 自动为对象，方法等分配内存 自动垃圾回收机制，回收不再使用的对象 解释执行虚拟机指令 对字节码文件中的指令实时解释成机器码，让计算机执行 及时编译 对热点代码进行优化，提升执行效率</description>
      <category>java</category>
      <content:encoded><![CDATA[<h2> 初识虚拟机</h2>
<p>JVM 全称 Java Virtual Machine，即 Java 虚拟机<br>
Java 虚拟机的职责是运行字节码文件</p>
<p>JVM 三大核心功能：</p>
<ul>
<li>JVM 包内存管理
<ul>
<li>自动为对象，方法等分配内存</li>
<li>自动垃圾回收机制，回收不再使用的对象</li>
</ul>
</li>
<li>解释执行虚拟机指令
<ul>
<li>对字节码文件中的指令实时解释成机器码，让计算机执行</li>
</ul>
</li>
<li>及时编译
<ul>
<li>对热点代码进行优化，提升执行效率</li>
</ul>
</li>
</ul>
<p>常见的 Java 虚拟机：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20231114225258529.png" alt="image-20231114225258529" loading="lazy"></p>
<p>JVM 的组成：</p>
<ul>
<li>类加载器 ClassLoader</li>
<li>运行时数据区（JVM 管理的内存）</li>
<li>执行引擎（即使编译器、解释器、垃圾回收器）</li>
<li>本地接口（通常为 native 修饰）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20231116222801070.png" alt="image-20231116222801070" loading="lazy"></p>
<h2> 字节码文件的组成</h2>
<ul>
<li>基本信息：
<ul>
<li>魔数、字节码文件对应的 Java 版本号</li>
<li>访问标识（public final 等）</li>
<li>父类和接口</li>
</ul>
</li>
<li>常量池
<ul>
<li>保存字符串常量、类或接口名、字段名</li>
</ul>
</li>
<li>字段
<ul>
<li>当前类或接口声明的字段信息</li>
</ul>
</li>
<li>方法
<ul>
<li>当前类或接口声明的方法信息</li>
</ul>
</li>
<li>属性
<ul>
<li>类的属性、比如源码文件名、内部类的列表等</li>
</ul>
</li>
</ul>
<h2> 类的生命周期</h2>
<p>类的生命周期：<br>
加载、连接、初始化、使用、卸载</p>
<h3> 加载阶段</h3>
<ol>
<li>类加载器根据类的全限定名通过不同的渠道以二进制流的方式获取字节码信息</li>
<li>类加载器在加载完之后，Java 虚拟机会将字节码中的信息保存到方法区中</li>
<li>类加载器在加载完类之后，Java 虚拟机会将字节码中的信息保存到内存的方法区中<br>
生成一个 InstanceKlass 对象，保存类的所有信息，里面包含实现特定功能比如多态的信息</li>
<li>同时，Java 虚拟机还在堆中生成一份与方法区中数据类似的 Java.lang.Class 对象<br>
作用在 Java 代码中去获取类的信息以及存储静态字段的数据（JDK 8 以后）</li>
</ol>
<h3> 连接阶段</h3>
<ol>
<li>验证：验证验证内容是否满足《Java 虚拟机规范》</li>
<li>准备：给静态变量赋初值</li>
<li>解析：将常量池中的符号引用替换成指向内存的直接引用</li>
</ol>
<h3> 初始化阶段</h3>
<ul>
<li>初始化阶段会执行静态代码块中的代码，并为静态变量赋值</li>
<li>初始化阶段会执行字节码文件中的 clinit 部分的字节码指令</li>
</ul>
<h2> 类加载器</h2>
<p>类加载器是什么：<br>
类加载器（ClassLoader）是 Java 虚拟机提供给应用程序去实现获取类和接口字节码数据的技术<br>
类加载器只参与加载过程中的字节码获取并加载内存这一部分</p>
<p>类加载器的作用：<br>
类加载器（ClassLoader）负责在类加载过程中的字节码获取并加载到内存这一部分。通过加载字节码数据放入内存转换为 byte[]，接下来调用虚拟机底层将 byte[] 转换成方法区和堆中的数据</p>
<p>类加载器分为两类：一类是 Java 代码中实现，一类是 Java 虚拟机底层源码实现</p>
<ul>
<li>虚拟机底层源码实现：
<ul>
<li>源代码位于 Java 虚拟机源码中，实现语言与底层语言一致（如 C++）</li>
<li>用于加载程序运行时的基础类，如 java.lang.String</li>
</ul>
</li>
<li>Java 代码中实现：
<ul>
<li>JDK 中默认提供或自定义</li>
<li>所有 Java 中实现的类加载器都要继承 ClassLoader 这个抽象类</li>
</ul>
</li>
</ul>
<h3> JDK8 及以前的类加载器</h3>
<p>虚拟机底层实现（C++）：</p>
<ul>
<li>启动类加载器 BootStrap：加载 Java 中最核心的类<br>
Java 实现：</li>
<li>扩展类加载器 Extension：允许扩展 Java 中比较通用的类</li>
<li>应用程序类加载器 Application：加载应用使用的类</li>
</ul>
<h4> 启动类加载器 BootStrap</h4>
<p>什么是启动类加载器：启动类加载器（Bootstrap ClassLoader）时有 Hotspot 虚拟机提供的、使用 C++ 编写的类加载器<br>
启动类加载器的作用：默认加载 Java 「安装目录/jre/lib」 下的文件，比如 rt.jar（包含 java.lang 中的常用类），tools.jar，resource.jar 等</p>
<p>通过启动类加载器加载用户 jar 包：</p>
<ul>
<li>使用参数进行扩展：<br>
使用 <code>-Xbootclasspath/xxx:jar包目录/jar包名</code> 进行扩展</li>
</ul>
<h4> Java 实现</h4>
<ul>
<li>
<p>扩展类加载器 Extension<br>
什么是扩展类加载器、应用程序类加载器：扩展类加载器和应用程序类加载器都是 JDK 中提供的、使用 Java 编写的类加载器<br>
它们的源码位于 sun.misc.Launcher 中，是一个静态内部类，继承自 URLClassLoader<br>
继承 URLClassLoader 的作用：具备通过目录或指定 jar 包将字节码文件加载到内存中</p>
</li>
<li>
<p>扩展类加载器 Extension<br>
加载 Java 安装目录 /jre/lib/ext 下的文件<br>
通过扩展类加载器加载用户 jar 包：使用 <code>-Djava.ext.dirs=jar包目录</code> 扩展，这种方式会覆盖掉原始目录，可使用 <code>;</code> (windows) <code>:</code> (macos/linux) 追加原始目录</p>
</li>
<li>
<p>应用程序类加载器<br>
加载 classpath 下的类文件</p>
</li>
</ul>
<h3> 双亲委派机制</h3>
<p>由于 Java 虚拟机有多个类加载器，双亲委派机制的核心就是解决一个类到底由谁加载的问题</p>
<p>双亲委派机制的作用：</p>
<ul>
<li>保证类加载的安全性（避免恶意代码薙魂 JDK 中的核心类库）</li>
<li>避免重复加载（避免一个类被加载多次）</li>
</ul>
<p>类加载器的双亲委派机制：当一个类加载器接受到加载类的任务时，会自底向上查找是否加载过，再由顶向下进行加载</p>
<h3> 自定义类加载器</h3>
<p>自定义类加载器的父加载器是应用程序类加载器 Application</p>
<h3> JDK9 及以后的类加载器</h3>
<p>JDK 引入了 module 的概念，类加载器在设计上发生了好多变化</p>
<ol>
<li>启动类加载器使用 Java 编写，位于 jdk.internal.loader.ClassLoaders 类中<br>
Java 中的 BootClassLoader 继承自 BuiltinClassLoader 实现从模块中找到要加载的字节码资源文件<br>
启动类加载器依然无法获得通过 java 代码获取到，返回的仍然是 null，保持了统一</li>
<li>扩展类加载器被替换成了平台类加载器（Platform Class Loader）<br>
平台类加载器遵循模块化方法加载字节码文件，所以继承关系从 URLClassLoader 变成了 BuiltinClassLoader，BuiltinClassLoader 实现了从模块中加载字节码文件。平台类加载器的存在更过的是为了与老版本的设计方案兼容，自身没有特殊的逻辑</li>
</ol>
<h2> 运行时数据区（Jvm 管理的内存）</h2>
<p>Java 虚拟机在运行 java 程序过程中管理的内存其余，称为运行时数据区</p>
<p>分类：</p>
<ul>
<li>程序计数器（线程不共享）</li>
<li>Java 虚拟机栈（线程不共享）</li>
<li>本地方法栈（线程不共享）</li>
<li>方法区（线程共享）</li>
<li>堆（线程共享）</li>
</ul>
<h3> 程序计数器</h3>
<p>程序计数器（Program Counter Register）也叫 PC 寄存器，每个线程会通过程序计数器记录当前要执行的字节码指令的地址</p>
<h3> Java 虚拟机栈</h3>
<p>Java 虚拟机栈采用栈的数据结构管理「方法调用」中的基本数据（方法以先进后出的形式）每一个方法的调用使用一个「栈帧」（Stack Frame）来保存</p>
<p>栈帧的组成：局部变量表、操作数栈、帧数据</p>
<ul>
<li>局部变量表：局部变量表的作用是方法执行过程中存放所有的局部变量</li>
<li>操作数栈：操作数栈是栈帧中虚拟机在执行指令过程中用来存放临时数据的一块区域</li>
<li>帧数据：帧数据主要包含动态链接、方法出口、异常表的引用</li>
</ul>
<p>栈内存溢出：<br>
Java 虚拟机栈如果栈帧过多，占用内存超过栈内存分配的最大的大小就会出现内存溢出<br>
Java 虚拟机栈内存溢出时会出现 StackOverflowError 错误</p>
<p>修改 Java 虚拟机栈的大小，可以使用虚拟机参数 -Xss</p>
<ul>
<li><code>-Xss 栈大小</code></li>
<li>单位：字节（默认，必须是 1024 的倍数）、k/K、m/M、g/G</li>
</ul>
<h3> 本地方法栈</h3>
<ul>
<li>Java 虚拟机栈存储 Java 方法调用时的栈帧、本地方法栈存储 native 本地方法的栈帧</li>
<li>在 Hotsot 虚拟机中，Java 虚拟机栈和本地方法栈实现上使用同一个栈空间</li>
</ul>
<h3> 堆</h3>
<ul>
<li>Java 程序中堆内存是空间最大的一块内存区域，创建出来的对象都在堆上</li>
<li>栈中的局部变量表可以存放堆上对象的引用，静态变量也可以存放堆对象的引用，通过静态变量可以实现对象在线程之间的共享</li>
</ul>
<p>堆内存大小有上限，达到上限抛出 OutOfMermory 错误</p>
<p>堆空间的三个值：</p>
<ul>
<li>used：当前已使用的堆内存</li>
<li>total：java 虚拟机已分配的可用堆内存</li>
<li>max：java 虚拟机可分配的最大堆内存</li>
</ul>
<p>要修改堆的大小，可以使用虚拟机参数 -Xmx（max 最大值）和 -Xms（初始的 total）<br>
单位：字节（默认，必须是 1024 的倍数）、k/K、m/M、g/G<br>
限制：Xmx 必须大于 2 MB，Xms 必须大于 1 MB<br>
开发时，建议将 -Xmx 和 -Xms 设置为相同的值</p>
<h3> 方法区</h3>
<p>方法区是存放基础信息的位置，线程共享，主要包括：</p>
<ul>
<li>类的元信息</li>
<li>运行时常量池</li>
<li>字符串常量池</li>
</ul>
<p>详细描述：</p>
<ul>
<li>元信息：存储每个类的 「基本信息（元信息）」，一般称之为 InstanceKclass 对象，在类的「加载阶段」完成</li>
<li>运行时常量池：<br>
常量池中存放的是字节码中的常量池的内容<br>
字节码文件中通过编号表的方式找到常量，这种常量池称为「静态常量池」。当常量池加载到内存中后，可用过内存地址快速定位到常量池中的内容，这种常量池称为运行时常量池</li>
</ul>
<p>方法区是《Java 虚拟机规范》中设计的虚拟概念，每款 Java 虚拟机在实现上都各不相同。Hotspot 设计如下：</p>
<ul>
<li>JDK 7及之前的版本：将方法区在「堆区域中的永久代空间」，堆的大小由虚拟机参数来控制</li>
<li>JDK 8 及之后的版本：将方法区存放在「元空间」中，元空间位于 OS 的直接内存中，默认不超过 OS 承受上限，可以一直分配</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20231118224434253.png" alt="image-20231118224434253" loading="lazy"></p>
<p>JDK 7 堆大小虚拟机参数： -XX:MaxPermSize=值<br>
JDK 8 限制大小参数：-XX:MaxMetaspaceSize=值</p>
<p>字符串常量池：</p>
<p>字符串常量池用于存放字符串</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20231118230548338.png" alt="image-20231118230548338" loading="lazy"></p>
<p>JDK7 及之后的版本中，静态变量存放在堆中的 Class 对象中，脱离了永久代</p>
<h3> 直接内存</h3>
<p>如果需要手动调整直接内存大小，可以使用 <code>-XX:MaxDirectMemorySize=大小</code><br>
单位：k/K、m/M、g/G<br>
默认不设置该参数的情况下，JVM 自动选择最大分配的大小</p>
<h3> 不同 JDK 版本之间的运行时数据区：</h3>
<p>JDK 6：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20231118232011117.png" alt="image-20231118232011117" loading="lazy"></p>
<p>JDK 7：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20231118232113434.png" alt="image-20231118232113434" loading="lazy"></p>
<p>JDK 8：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20231118232125654.png" alt="image-20231118232125654" loading="lazy"></p>
<h2> 自动垃圾回收</h2>
<p>Java 引入了自动的垃圾回收（Garbage Collection / GC）机制，垃圾回收器主要负责对「堆」上的内存（不再使用的对象）进行回收</p>
<p>对于线程不共享的部分（程序计数器、java 虚拟机栈、本地方法栈）都伴随着线程的创建而创建、线程的销毁而销毁。即方法的栈帧在执行完方法后就会自动弹出栈并释放掉对应内存</p>
<h3> 方法区的回收</h3>
<p>方法区中能回收的主要内容是「不再使用的类」</p>
<p>判定一个类是否可被卸载，需同时满足下面三个条件：</p>
<ul>
<li>此类的所有实例对象都已经被回收，在堆中不存在任何该类的实例对象以及子类对象</li>
<li>加载该类的类的加载器已被回收</li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用</li>
</ul>
<h3> 堆内存回收</h3>
<p>如何判断堆上的对象可以回收：</p>
<ul>
<li>Java 中的对象是能否能被回收，是根据对象时否被引用来决定的。如果对象被引用了，说明该对象还在使用，不允许回收</li>
</ul>
<p>如何判断堆上的对象没有被引用：</p>
<ul>
<li>
<p>引用计数法</p>
<ul>
<li>为每个对象维护一个引用计数器，当对象被引用时 +1、取消引用时 -1（该方法会出现循环引用问题）</li>
</ul>
</li>
<li>
<p>可达性分析算法（java 使用的方法）</p>
</li>
</ul>
<h4> 可达性分析</h4>
<p>Java 使用可达性分析算法来判断对象是否可以被回收<br>
可达性分析将对象分为两类：垃圾回收的跟对象（GC Root）和普通对象<br>
GC Root 对象一般不被回收，如果普通对象可以通过引用链找到 GC Root 对象，则不可被回收</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20231119220514771.png" alt="image-20231119220514771" loading="lazy"></p>
<h4> GC Root 对象</h4>
<p>哪些对象被称之为 GC Root 对象：</p>
<ul>
<li>线程 Thread 对象</li>
<li>系统类加载器加载的 java.lang.Class 对象</li>
<li>监视器对象，用来保存 synchronized 关键字持有的对象</li>
<li>本地方法调用时使用的全局对象</li>
</ul>
<h4> 其他常见对象引用</h4>
<p>可达性算法描述的对象引用、一般指强引用，即 GCRoot 对象对普通对象的引用</p>
<p>Java 中其他引用方式：</p>
<ul>
<li>软引用：如果只有一个对象只有软引用关联到它，当程序内存不足时，就会将软引用中的数据进行回收</li>
<li>弱引用：弱引用包含的对象在垃圾回收时，不管内存够不够都不会直接被回收</li>
<li>虚引用</li>
<li>终结器引用</li>
</ul>
<h3> 垃圾回收算法</h3>
<p>垃圾回收算法流程：</p>
<ol>
<li>找到内存中欧存活的对象</li>
<li>释放不在存活对象的内存，使得程序能再次利用这部分空间</li>
</ol>
<p>四种垃圾回收算法：</p>
<ul>
<li>标记-清除算法</li>
<li>复制算法</li>
<li>标记-整理算法</li>
<li>分代 GC</li>
</ul>
<p>垃圾回收会通过单独的 GC 线程完成，GC 线程在执行时需要暂停所有用户线程，这个过程称为 Stop The World（STW），如果 STW 时间过长则会影响用户使用</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20231119225412229.png" alt="image-20231119225412229" loading="lazy"></p>
<p>垃圾回收算法评价指标</p>
<ul>
<li>吞吐量：吞吐量 = 执行用户代码时间 / （执行用户代码时间 + GC 时间）</li>
<li>最大暂停时间：STW 的最大值</li>
<li>堆使用效率：不同垃圾回收算法，堆内存使用方式不同</li>
</ul>
<h4> 标记清除算法</h4>
<p>算法描述</p>
<ol>
<li>标记阶段：通过可达性分析算法，从 GC Root 开始通过引用链遍历出所有存活对象</li>
<li>清除阶段：从内存中删除没有被标记的非存活对象</li>
</ol>
<p>标记清除算法的优缺点</p>
<ul>
<li>优点：实现简单，只需在第一阶段标记，第二阶段删除</li>
<li>缺点：
<ul>
<li>碎片化问题：对象被删除后，内存中会出现很多细小可用内存，无法分配给大内存对象</li>
<li>分配速度慢：由于内存碎片存在，需要维护一个空闲链表连接内存碎片，很可能需要遍历到链表最后才获得合适空间</li>
</ul>
</li>
</ul>
<h4> 复制算法</h4>
<p>算法描述：</p>
<ol>
<li>将内存分割成两块空间，From 和 To 空间，对象分配阶段，创建对象</li>
<li>GC 阶段开始时，将 GC Root 搬运到 To 空间</li>
<li>将 GC Root 关联的对象搬运到 To 空间</li>
<li>清理 From 空间，将 From 和 To 名字互换</li>
</ol>
<p>复制算法优缺点</p>
<ul>
<li>优点：
<ul>
<li>吞吐量高</li>
<li>不会发生碎片化</li>
</ul>
</li>
<li>缺点：内存使用效率低</li>
</ul>
<h4> 标记整理算法</h4>
<p>标记整理算法（标记压缩算法）是对清理算法容易产生内存碎片的一种解决方案</p>
<p>算法描述：</p>
<ol>
<li>标记阶段：通过可达性分析算法，从 GC Root 开始通过引用链遍历出所有存活对象</li>
<li>整理阶段：将存活对象移动到堆的一端清理掉存活对象的内存空间，这样便于清理出一整大块的内存空间</li>
</ol>
<p>标记整理算法优缺点</p>
<ul>
<li>优点
<ul>
<li>内存使用效率高</li>
<li>不会发生碎片化</li>
</ul>
</li>
<li>缺点：整理阶段的效率不高</li>
</ul>
<h4> 分代垃圾回收</h4>
<p>现代优秀垃圾回收算法将上述算法组合使用，其中应用最广的为分代垃圾回收算法（Generational GC）<br>
分代垃圾回收算法将整个内存区域划分为年轻代和老年代</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20231120205858862.png" alt="image-20231120205858862" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20231120205934031.png" alt="image-20231120205934031" loading="lazy"></p>
<p>分代回收执行流程：</p>
<ol>
<li>新创建的对象首先被放入 Eden 区</li>
<li>当 Eden 区满时，新创建的对象无法放入，此时触发年轻代 GC，称为 Minor GC 或 Young GC</li>
<li>Minor GC 会把 Eden 中和 From 中需要回收的对象回收（可达性分析法），把没有回收的对象放入 To 区</li>
<li>接下来 S0 变为 To 区，S1 变为 From 区。当 Eden 满时再往里放对象，依然进行 Minor GC，此时回收 Eden 和 S1(From) 的对象，并把 eden 和 From 中剩余对象放入 S0
<ul>
<li>注意：每次 Minor GC 中为存活对象记录年龄，初始为 0，每次 GC 完 +1</li>
</ul>
</li>
<li>如果 Minor GC 后对象的年龄达到阈值（最大 15，默认值和垃圾会回收器有关），对象就会晋升至老年代</li>
<li>当老年代空间不足，无法放入新的对象时，先尝试 Minor GC ，如果还不足就会触 Full GC，Full GC 会对整个堆进行垃圾回收</li>
<li>如果 Full GC 依然无法回收掉老年代的对象，那么当兑现继续放入老年代时，就会抛出 Out Of Menory 异常</li>
</ol>
<p>分代 GC 算法把堆分成年轻代和老年代的原因：</p>
<ul>
<li>可以通过调整年轻代和老年代的比例来适应不同类型的应用程序，提高内存的利用率和性能</li>
<li>新生代和老年代使用不同的垃圾回收算法，新生代一般选择复制算法，老年代可以选择标记 - 清除和标记 - 整理算法，由程序员来选择灵活度较高<br>
3、分代的设计中允许只回收新生代 (minor gc)，如果能满足对象分配的要求就不需要对整个堆进行回收 (full gc)，STW 时间就会减少。</li>
</ul>
<h4> 垃圾回收器的组合关系</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20231120213538476.png" alt="image-20231120213538476" loading="lazy"></p>
<p>G1 垃圾回收器：<br>
JDK9 之后默认的垃圾回收器是 G1 (Garbage First) 垃圾回收器<br>
Parallel Scavenge 关注吞吐量，允许用户设置最大暂停时间，但是会减少年轻代可用空间的大小<br>
CMS 关注暂停时间，但是吞吐量方面会下降。<br>
而 G1 设计目标就是将上述两种垃圾回收器的优点融合</p>
<ul>
<li>支持巨大的堆空间回收，并有较高的吞吐量。</li>
<li>支持多 CPU 并行垃圾回收。</li>
<li>允许用户设置最大暂停时间。</li>
</ul>
<p>JDK9 之后强烈建议使用 G1 垃圾回收器</p>
]]></content:encoded>
      <enclosure url="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20231114225258529.png" type="image/png"/>
    </item>
    <item>
      <title>Java Web 基础</title>
      <link>https://T4mako.github.io/code/java/JavaWeb%E5%9F%BA%E7%A1%80.html</link>
      <guid>https://T4mako.github.io/code/java/JavaWeb%E5%9F%BA%E7%A1%80.html</guid>
      <source url="https://T4mako.github.io/rss.xml">Java Web 基础</source>
      <description>一、配置文件 1、XML配置文件 1、名词解释 XML是eXtensible Markup Language的缩写，翻译过来就是可扩展标记语言。XML和HTML一样都是标记语言，也就是说它们的基本语法都是标签。</description>
      <category>java</category>
      <content:encoded><![CDATA[<h2> 一、配置文件</h2>
<h3> 1、XML配置文件</h3>
<h4> 1、名词解释</h4>
<p>XML是e<strong>X</strong>tensible <strong>M</strong>arkup <strong>L</strong>anguage的缩写，翻译过来就是<strong>可扩展标记语言</strong>。<strong>XML和HTML一样都是标记语言</strong>，也就是说它们的基本语法都是<strong>标签</strong>。</p>
<!-- more -->
<p><strong>可扩展</strong>意思是XML允许<strong>自定义格式</strong></p>
<p>在XML基本语法规范的基础上，第三方应用程序、框架通过设计**『XML约束』<strong>的方式</strong>『强制规定』**配置文件中可以写什么和怎么写</p>
<h4> 2、XML基本语法</h4>
<p>XML的基本语法和HTML的基本语法如出一辙，XML基本语法+HTML约束=HTML语法。在逻辑上HTML是XML的子集。</p>
<p>①根标签<br>
根标签有且只能有一个</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>②单双标签<br>
双标签：开始标签和结束标签必须成对出现。<br>
单标签：单标签在标签内关闭。</p>
<p>③属性<br>
属性必须有值<br>
属性值必须加引号，单双都行</p>
<h4> 3、XML约束</h4>
<p>我们主要就是根据XML约束中的规定来编写XML配置文件。而XML约束主要包括<strong>DTD和Schema</strong>两种。如果XML配置文件使用的是DTD，那么对我们几乎没有影响。如果是Schema约束，需要我们稍微参与一点点。</p>
<p>详情见https://heavy_code_industry.gitee.io/code_heavy_industry/pro001-javaweb/lecture/chapter05/verse01.html#_2%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6</p>
<h3> 2、属性文件</h3>
<p>以<strong>properties作为扩展名</strong>的文件<br>
由<strong>键值对</strong>组成<br>
键和值之间的符号是<strong>等号</strong><br>
每一行都必须顶格写，前面<strong>不能有空格之类的其他符号</strong></p>
<div class="language-properties line-numbers-mode" data-ext="properties"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3、其他形式</h3>
<p>①YAML语言的配置文件：在SpringBoot中使用。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>②JSON格式的配置文件：一般是前端使用。</p>
<h2> 二、Tomcat</h2>
<h3> 1、Tomcat扮演的角色</h3>
<p><strong>① 对外：Web服务器</strong></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220914194924351.png" alt="image-20220914194924351" loading="lazy"></p>
<p><strong>② 对内：Servlet容器</strong></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220914195004706.png" alt="image-20220914195004706" loading="lazy"></p>
<h3> 2、部署</h3>
<p><mark>Tomcat本身是一个Java程序</mark>，所以当前系统中必须正确配置了JAVA_HOME <strong>环境变量</strong>。<br>
将Tomcat压缩包解压到一个<strong>非中文无空格</strong>的目录下。<br>
Tomcat的目录结构：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220914204033528.png" alt="image-20220914204033528" loading="lazy"></p>
<p>启动Tomcat：运行Tomcat解压后根目录下\bin\startup.bat即可</p>
<h3> 3、在IDEA中关联Tomcat</h3>
<p>https://heavy_code_industry.gitee.io/code_heavy_industry/pro001-javaweb/lecture/chapter05/verse03.html</p>
<h3> 4、动态Web工程目录结构介绍</h3>
<table>
<thead>
<tr>
<th>目录或文件名</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>src目录</td>
<td>存放Java源文件</td>
</tr>
<tr>
<td>web目录</td>
<td>存放Web开发相关资源</td>
</tr>
<tr>
<td>web/WEB-INF目录</td>
<td>存放web.xml文件、classes目录、lib目录</td>
</tr>
<tr>
<td>web/WEB-INF/web.xml文件</td>
<td>别名：部署描述符，deployment descriptor 作用：Web工程的核心配置文件</td>
</tr>
<tr>
<td>web/WEB-INF/classes目录</td>
<td>存放编译得到的*.class字节码文件</td>
</tr>
<tr>
<td>web/WEB-INF/lib目录</td>
<td>存放第三方jar包</td>
</tr>
</tbody>
</table>
<p><mark>新建web项目并在Tomcat中部署，访问</mark></p>
<p><strong>context root 相当于 application context</strong>（Tomcat中application context Server中的url）</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/03.第一次使用Servlet.png" alt="03.第一次使用Servlet" loading="lazy"></p>
<p><mark>action为add，向服务器的add组件发请求，add对应AddServler这个类</mark>，将request这个对象传给服务器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><mark>request设置相应字符集</mark></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>打开网页URL设置可以直接设置为组件（Tomcat Server OpenBrowser URL）</p>
<h2> 三、HTTP协议</h2>
<p>HTTP：<strong>H</strong>yper <strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol超文本传输协议。HTTP最大的作用就是<strong>确定了请求和响应数据的格式</strong>。<br>
<strong>浏览器发送给服务器的数据：请求报文</strong><br>
<strong>服务器返回给浏览器的数据：响应报文。</strong></p>
<p>1） Http 称之为 超文本传输协议<br>
2） Http 是 无状态 的<br>
3） Http 请求响应包含两个部分：<mark>请求和响应</mark></p>

<h3> 1、请求报文</h3>
<p><mark>请求报文的三部分：请求行、请求消息头、请求体</mark></p>
<p><strong>浏览器→服务器</strong></p>
<h4> 1、请求行</h4>
<p>作用：展示当前请求的最基本信息</p>
<div class="language-http line-numbers-mode" data-ext="http"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>请求方式<br>
访问地址<br>
HTTP协议的版本</p>
<h4> 2、请求消息头</h4>
<p>作用：通过具体的参数<strong>对本次请求进行详细的说明</strong><br>
格式：键值对，键和值之间使用冒号隔开</p>
<p>相对比较重要的请求消息头：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Host</td>
<td>服务器的主机地址</td>
</tr>
<tr>
<td>Accept</td>
<td>声明当前请求能够接受的『媒体类型』</td>
</tr>
<tr>
<td>Referer</td>
<td>当前请求来源页面的地址</td>
</tr>
<tr>
<td>Content-Length</td>
<td>请求体内容的长度</td>
</tr>
<tr>
<td>Content-Type</td>
<td>请求体的内容类型，这一项的具体值是媒体类型中的某一种</td>
</tr>
<tr>
<td>Cookie</td>
<td><strong>浏览器访问服务器时携带的Cookie数据</strong></td>
</tr>
</tbody>
</table>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917150026204.png" alt="image-20220917150026204" loading="lazy"></p>
<h4> 3、请求体</h4>
<p>作用：作为请求的主体，发送数据给服务器。具体来说其实就是<strong>POST请求方式下的请求参数</strong>。</p>
<p>[1]form data<br>
含义：当前请求体是一个<strong>表单提交的请求参数</strong></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917150418728.png" alt="image-20220917150418728" loading="lazy"></p>
<p>[2]Request Payload<br>
含义：<strong>整个请求体</strong>以某种<strong>特定格式</strong>来组织数据，例如JSON格式。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917150459419.png" alt="image-20220917150459419" loading="lazy"></p>
<h3> 2、请求方式</h3>
<h4> ①HTTP协议已定义的请求方式</h4>
<p>HTTP1.1中共定义了八种请求方式：</p>
<p><strong>GET</strong>：<em>从服务器端获取</em>数据<br>
<strong>POST</strong>：将数据保存到服务器端<br>
<strong>PUT</strong>：命令服务器对数据执行更新<br>
<strong>DELETE</strong>：命令服务器删除数据*<br>
HEAD<br>
CONNECT<br>
OPTIONS<br>
TRACE</p>
<h4> ②GET请求</h4>
<p>特征1：<strong>没有请求体</strong><br>
特征2：<strong>请求参数</strong>附着在<strong>URL地址后面</strong><br>
特征3：请求参数在浏览器地址栏<strong>能够直接被看到</strong>，存在安全隐患<br>
特征4：在URL地址后面携带请求参数，<strong>数据容量非常有限</strong>。如果数据量大，那么超出容量的数据会丢失<br>
特征5：从报文角度分析，<strong>请求参数是在请求行中携带的</strong>，因为访问地址在请求行</p>
<h4> ③POST请求</h4>
<p>特征1：<strong>有请求体</strong><br>
特征2：<strong>请求参数放在请求体中</strong><br>
特征3：请求体发送<strong>数据的空间没有限制</strong><br>
特征4：可以<strong>发送各种不同类型</strong>的数据<br>
特征5：从报文角度分析，<strong>请求参数是在请求体中</strong>携带的<br>
特征6：由于<strong>请求参数是放在请求体</strong>中，所以<strong>浏览器地址栏看不到</strong></p>
<h3> 3、响应报文</h3>
<p><mark>响应报文的三部分：响应状态行、响应消息头、响应体</mark></p>
<p><strong>服务器→浏览器</strong></p>
<h4> ①响应状态行</h4>
<div class="language-http line-numbers-mode" data-ext="http"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>HTTP协议版本<br>
<strong>响应状态码</strong><br>
响应状态的说明文字</p>
<h4> ②响应消息头</h4>
<p>响应体的说明书。<br>
<strong>服务器端对浏览器端设置数据</strong>，例如：服务器端返回Cookie信息。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Content-Type</td>
<td>响应体的内容类型</td>
</tr>
<tr>
<td>Content-Length</td>
<td>响应体的内容长度</td>
</tr>
<tr>
<td>Set-Cookie</td>
<td><strong>服务器返回新的Cookie信息给浏览器</strong></td>
</tr>
<tr>
<td>location</td>
<td>在<strong>重定向</strong>的情况下，告诉<strong>浏览器访问下一个资源的地址</strong></td>
</tr>
</tbody>
</table>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917151743113.png" alt="image-20220917151743113" loading="lazy"></p>
<h4> ③响应体</h4>
<p>服务器返回的数据主体，有可能是各种数据类型。</p>
<p>HTML页面、图片、视频以下载形式返回的文件<br>
CSS文件、JavaScript文件</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917151835657.png" alt="image-20220917151835657" loading="lazy"></p>
<h4> ④响应状态码</h4>
<p>作用：以编码的形式告诉浏览器当前请求处理的结果</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>200</td>
<td>服务器成功处理了当前请求，成功返回响应</td>
</tr>
<tr>
<td>302</td>
<td>重定向</td>
</tr>
<tr>
<td>400</td>
<td>[SpringMVC特定环境]请求参数问题</td>
</tr>
<tr>
<td>403</td>
<td>没有权限</td>
</tr>
<tr>
<td><strong>404</strong></td>
<td><strong>找不到目标资源</strong></td>
</tr>
<tr>
<td><strong>405</strong></td>
<td>**请求方式和服务器端对应的处理方式不一致 **（请求为get而处理为post）</td>
</tr>
<tr>
<td>406</td>
<td>[SpringMVC特定环境]请求扩展名和实际返回的响应体类型不一致</td>
</tr>
<tr>
<td><strong>50X</strong></td>
<td><strong>服务器端内部错误，通常都是服务器端抛异常了</strong></td>
</tr>
</tbody>
</table>
<p><strong>404产生的具体原因：</strong><br>
访问地址写错了，确实是没有这个资源<br>
访问了WEB-INF目录下的资源<br>
Web应用启动的时候，控制台已经抛出异常，导致整个Web应用不可用，访问任何资源都是404<br>
服务器端缓存</p>
<h3> 4、会话</h3>
<p>1、http是 <strong>无状态</strong> 的<br>
无状态：服务器无法判断两次请求是否是同一个客户端还是不同客户端<br>
通过 <strong>会话跟踪技术</strong> 解决无状态的问题</p>
<p>2、会话跟踪技术：<br>
<strong>客户端第一次发请求给服务器，服务器获取session</strong>，<strong>获取不到，则创建新的</strong>，然后响应给客户端<br>
下一次客户端给服务器发请求时，会把sessionID带给服务器服务器判断这次和上次请求是否是同一个客户端，从而区分开客户端<br>
常用API：<br>
<strong>request.getSession() -&gt; 获取当前的会话，没有则创建一个新的会话<br>
request.getSession(true)-&gt; 效果和不带参数相同<br>
request.getSession(false) -&gt; 获取当前会话，没有则返回null，不会创建新的<br>
session.getId() -&gt; 获取sessionId<br>
session.isNew() -&gt; 判断当前session是否是新的<br>
session.getMaxInactiveInterval() -&gt; session的非激活间隔时长，默认1800秒 （session持续时间）<br>
session.setMaxInactiveInterval()<br>
session.invalidate() -&gt; 强制让会话立即失效</strong></p>
<p>3、session保存作用域<br>
sessioin保存作用域是和具体的某一个session对应的 <strong>（一次会话范围内有效 （<em>一个客户端一个session</em>））</strong><br>
常用的API：<br>
<strong>void session.setAttribute(k,v)  往session保存作用域中保存数据<br>
Object session.getAttribute(k)  往session保存作用域中获取数据<br>
void removeAttribute(k)</strong></p>
<h3> 5、服务器内部转发以及客户端重定向</h3>
<p>1） <strong>服务器内部转发 : request.getRequestDispatcher("...").forward(request,response);</strong></p>

<p>2）<strong>客户端重定向：response.sendRedirect("....");</strong></p>
<ul>
<li>两次请求响应的过程。客户端肯定知道请求URL有变化<br>
<strong>地址栏有变化</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/04.服务器内部转发.png" alt="04.服务器内部转发" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/05.客户端重定向.png" alt="05.客户端重定向" loading="lazy"></p>
<h2> 四、Servlet</h2>
<h3> 1、Servlet概述</h3>
<p><strong>Servlet=Server+applet</strong><br>
<em>Server：服务器、applet：小程序</em><br>
<strong>Servlet含义是服务器端的小程序</strong>*</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917152349188.png" alt="image-20220917152349188" loading="lazy"></p>
<p>在整个Web应用中，Servlet主要负责 <strong>处理请求、协调调度功能</strong>。我们可以把Servlet称为Web应用中的 <strong>控制器</strong></p>
<h3> 2、Servlet  HelloWorld</h3>
<p>在页面上点击超链接，由Servlet处理这个请求，并返回一个响应字符串：Hello,I am Servlet</p>
<p>①第一步：创建动态 Web module<br>
②第二步：创建超链接</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>③第三步：创建HelloServlet的Java类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>④第四步：配置HelloServlet<br>
配置文件位置：WEB-INF/web.xml</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917153143610.png" alt="image-20220917153143610" style="zoom:200%;">
<p><strong>虚拟路径</strong>：Servlet并<strong>不是</strong>文件系统中<strong>实际存在</strong>的<strong>目录或文件</strong>，所以为了方便浏览器访问，我们创建了<strong>虚拟</strong>出来的路径来访问它。</p>
<h4> Web工程中的资源：</h4>
<p>静态资源：HTML，CSS，JS，图片<br>
动态资源：Servlet</p>
<p>访问资源的地址：<br>
静态资源：/Web应用名称/静态资源本身的路径<br>
动态资源：/Web应用名称/虚拟路径</p>
<h4> 总体逻辑结构：</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917153538804.png" alt="image-20220917153538804" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917153638692.png" alt="image-20220917153638692" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917153645060.png" alt="image-20220917153645060" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917153654438.png" alt="image-20220917153654438" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917153702954.png" alt="image-20220917153702954" loading="lazy"></p>
<h3> 3、Servlet生命周期</h3>
<p>生命周期：从出生到死亡的过程就，对应Servlet的三个方法：<mark>init(),service(),destroy()</mark></p>
<p>默认情况下：Servlet在<strong>第一次接收到请求</strong>的时候才<strong>创建对象</strong>(调用<strong>构造器</strong>，实例化)，然后初始化（init方法）、然后服务（service方法）<br>
当容器关闭时，其中的所有servlet实例被销毁，调用销毁方法</p>
<p>创建对象后，所有的URL地址匹配的请求都由这同一个对象来处理<br>
Tomcat中，每一个请求会被分配一个线程来处理，所以可以说：Servlet是<strong>单实例，多线程</strong>方式运行的。<br>
既然Servlet是多线程方式运行，所以有线程安全方面的可能性，所以<strong>不能在处理请求的方法中修改公共属性</strong>。</p>
<p>在web.xml中修改Servlet配置，使得在Web应用启动的时候创建Servlet对象</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4、Servlet容器</h3>
<p>①容器<br>
在开发使用的各种技术中，经常会有<strong>很多对象会放在容器</strong>中。</p>
<p>②容器提供的功能<br>
容器会管理内部对象的整个生命周期。<strong>对象在容器中才能够正常的工作，得到来自容器的全方位的支持</strong>。</p>
<p>创建对象<br>
初始化<br>
工作<br>
清理</p>
<p>③容器本身也是对象<br>
特点1：往往是非常大的对象<br>
特点2：通常的单例的</p>
<p>④典型Servlet容器产品举例<br>
Tomcat、jetty、jboss、Weblogic、WebSphere、glassfish</p>
<h4> </h4>
<table>
<thead>
<tr>
<th>名称</th>
<th>时机</th>
<th>次数</th>
</tr>
</thead>
<tbody>
<tr>
<td>创建对象</td>
<td>默认情况：接收到第一次请求 修改启动顺序后：Web应用启动过程中</td>
<td>一次</td>
</tr>
<tr>
<td>初始化操作</td>
<td>创建对象之后</td>
<td>一次</td>
</tr>
<tr>
<td>处理请求</td>
<td>接收到请求</td>
<td>多次</td>
</tr>
<tr>
<td>销毁操作</td>
<td>Web应用卸载之前</td>
<td>一次</td>
</tr>
</tbody>
</table>
<h3> 5、ServletConfig和ServletContext</h3>
<h4> 1、ServletConfig接口</h4>
<p>接口方法：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>getServletName()</td>
<td>获取定义的Servlet名称</td>
</tr>
<tr>
<td><strong>getServletContext()</strong></td>
<td>获取ServletContext对象</td>
</tr>
<tr>
<td>getInitParameter()</td>
<td>获取配置Servlet时设置的『初始化参数』，根据名字获取值</td>
</tr>
<tr>
<td>getInitParameterNames()</td>
<td>获取所有初始化参数名组成的Enumeration对象</td>
</tr>
</tbody>
</table>
<p>使用举例：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Servlet标准和JDBC标准对比：</p>
<table>
<thead>
<tr>
<th>Servlet标准</th>
<th>JDBC标准</th>
</tr>
</thead>
<tbody>
<tr>
<td>javax.servlet包下的一系列接口</td>
<td>javax.sql包下的一系列接口</td>
</tr>
<tr>
<td>Servlet容器厂商提供的具体实现类</td>
<td>数据库厂商提供的实现类（数据库驱动）</td>
</tr>
</tbody>
</table>
<h4> 2、ServletContext接口</h4>
<p>功能：<br>
获取 <strong>某个资源的真实路径</strong>：getRealPath()<br>
<strong>获取</strong> 整个Web应用级别的 <strong>初始化参数</strong>：getInitParameter()<br>
作为Web应用范围的域对象<br>
<strong>存入数据：setAttribute()</strong><br>
<strong>取出数据：getAttribute()</strong></p>
<p>使用举例：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6、Servlet继承关系</h3>
<p>1、继承关系：<br>
javax.servlet.Servlet接口<br>
javax.servlet.GenericServlet抽象类<br>
javax.servlet.http.HttpServlet抽象子类</p>
<p>2、相关方法：<br>
<strong>javax.servlet.Servlet接口：</strong><br>
void init(config)	初始化方法<br>
void service(request,response)	服务方法<br>
void destory()	销毁方法</p>
<p><strong>对于service方法：</strong><br>
①在javax.servlet.GenericServlet抽象类中，void service(request,response)仍然是抽象的<br>
在java.servlet.HttpServlet抽象子类：void service(request,response)不是抽象的<br>
②<strong>当有请求过来时，service方法会自动响应</strong>（其实是tomcat容器调用的）<br>
③servlet方法所做的事：<br>
<strong>获取的请求方式</strong><br>
<strong>根据请求方式的不同，调用不同的doXXX方法</strong><br>
在HttpServlet中这些doXXX方法默认都是405实现风格-&gt;要子类实现对应方法，否则报405错误<br>
④因此，我们在新建Servlet时，我们才会去考虑请求方法，从而决定重写哪个do方法</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917160608144.png" alt="image-20220917160608144" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917160624439.png" alt="image-20220917160624439" loading="lazy"></p>
<h3> 7、动态web工程内编写路径</h3>
<p>整个系统要根据功能拆分成许许多多<strong>独立</strong>的<strong>资源</strong><br>
资源之间既要完成自身的功能又要和其他资源<strong>配合</strong><br>
写路径就是为了<strong>从一个资源跳转到下一个资源</strong></p>
<p><strong>工程目录</strong>：我们<strong>写代码的地方</strong>，但是在服务器上运行的不是这个。<br>
<strong>部署目录</strong>：经过Java源文件<strong>编译</strong>和<strong>目录重组</strong>后，IDEA就替我们准备好了可以在服务器上运行的部署目录。<br>
部署目录经过了目录重组，所以目录结构不一样<br>
用户通过浏览器访问服务器，而服务器上运行的是部署目录，<strong>所以写路径的时候参考部署目录而不是工程目录。</strong><br>
<strong>对应关系</strong>：<strong>工程目录下的web目录对应部署目录的根目录</strong>，同时部署目录的根目录也是路径中的<strong>Web应用根目录</strong>。</p>
<h4> <strong>①具体文件：</strong></h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917161721361.png" alt="image-20220917161721361" loading="lazy"></p>
<h4> ②<strong>Servlert路径</strong></h4>
<p>访问Servlet的路径是我们在web.xml中配置的，大家可能注意到了，url-pattern里面的路径我们也是<strong>斜杠开头</strong>的，但是这个开头的斜杠代表<strong>Web应用根目录</strong>。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917161801727.png" alt="image-20220917161801727" loading="lazy"></p>
<h4> 准则：</h4>
<p>一个路径由谁来解析(浏览器、服务器)，其实就是这个路径是谁来用。</p>
<table>
<thead>
<tr>
<th>路径类型</th>
<th>解析方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>由浏览器解析的路径</td>
<td>开头斜杠代表服务器根目录</td>
</tr>
<tr>
<td>由服务器解析的路径</td>
<td>开头斜杠代表Web应用根目录</td>
</tr>
</tbody>
</table>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917161926471.png" alt="image-20220917161926471" loading="lazy"></p>
<ul>
<li>浏览器解析的路径举例：
<ul>
<li>所有HTML标签中的路径</li>
<li>重定向过程中指定的路径</li>
</ul>
</li>
<li>服务器解析的路径举例：
<ul>
<li>所有web.xml中配置的路径</li>
<li>请求转发过程中指定的路径</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917162121772.png" alt="image-20220917162121772" loading="lazy"></p>
<h4> 动态获取上下文路径：</h4>
<p><strong>上下文路径（context path）=/Web应用名称</strong></p>
<p>由于项目部署的时候，上下文路径是可以变化的，所以写死有可能发生错误。此时我们通过<strong>request对象动态获取上下文路径</strong>就不用担心这个问题了。调用下面这个方法，每一次获取的都是当前环境下实际的上下文路径的值。</p>
<p><strong>request.getContextPath()</strong></p>
<h3> 8、请求转发和重定向</h3>
<h4> 1、服务器内部转发</h4>
<p>在请求的处理过程中，Servlet完成了自己的任务，需要把请求<strong>转交给下一个资源</strong>继续处理。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><table>
<thead>
<tr>
<th>代码</th>
<th>类比</th>
</tr>
</thead>
<tbody>
<tr>
<td>request</td>
<td>小货车</td>
</tr>
<tr>
<td>getRequestDispatcher("转发地址")</td>
<td>告诉司机要去哪</td>
</tr>
<tr>
<td>forward(request, response)</td>
<td>出发</td>
</tr>
</tbody>
</table>
<p>由于转发操作的核心部分是<strong>在服务器端完成</strong>的，所以<strong>浏览器感知不到</strong>，整个过程中<strong>浏览器只发送一次请求</strong>。</p>
<h4> 2、浏览器重定向</h4>
<p>在请求的处理过程中，Servlet完成了自己的任务，然后以一个<strong>响应</strong>的方式告诉浏览器：“要完成这个任务还需要你另外<strong>再访问下一个资源</strong>”。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>由于重定向操作的核心部分是<strong>在浏览器端完成</strong>的，所以整个过程中浏览器<strong>共发送两次请求</strong>。</p>
<table>
<thead>
<tr>
<th>转发</th>
<th>重定向</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>一次请求</strong></td>
<td><strong>两次请求</strong></td>
</tr>
<tr>
<td>浏览器<strong>地址栏显示</strong>的是<strong>第一个</strong>资源的地址</td>
<td>浏览器<strong>地址栏显示</strong>的是<strong>第二个</strong>资源的地址</td>
</tr>
<tr>
<td>全程使用的是<strong>同一个request对象</strong></td>
<td>全程使用的是<strong>不同的request对象</strong></td>
</tr>
<tr>
<td>在<strong>服务器端完成</strong></td>
<td>在<strong>浏览器端完成</strong></td>
</tr>
<tr>
<td>目标资源地址由服务器解析</td>
<td>目标资源地址由浏览器解析</td>
</tr>
<tr>
<td>目标资源可以在WEB-INF目录下</td>
<td>目标资源不能在WEB-INF目录下</td>
</tr>
<tr>
<td>目标资源仅限于本应用内部</td>
<td>目标资源可以是外部资源</td>
</tr>
</tbody>
</table>
<p>使用场景：<br>
能用转发的先用转发，如果转发不行，再使用重定向。</p>
<p>需要通过同一个request对象把数据携带到目标资源：只能用转发<br>
如果希望前往下一个资源之后，浏览器刷新访问的是第二个资源：只能用重定向</p>
<h3> 9、获取请求参数</h3>
<p>浏览器在给服务器发送请求的同时，携带的参数数据。<br>
请求参数的基本形式：<br>
URL地址后面附着的请求参数<br>
表单<br>
Ajax请求</p>
<p>总体上来说，服务器端将请求参数封装为<strong>Map&lt;String, String[]&gt;</strong>。<br>
<strong>键：请求参数的名字</strong><br>
<strong>值：请求参数的值组成的数组</strong></p>
<h4> 获取请求参数的方法(request.)</h4>
<table>
<thead>
<tr>
<th>方法名</th>
<th>返回值类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>request.getParameterMap()</td>
<td><code>Map&lt;String, String[]&gt;</code></td>
</tr>
<tr>
<td>request.getParameter("请求参数的名字")</td>
<td>String</td>
</tr>
<tr>
<td>request.getParameterValues("请求参数的名字")</td>
<td>String []</td>
</tr>
<tr>
<td>request.getParameterNames()</td>
<td><code>Enumeration&lt;String&gt;</code></td>
</tr>
</tbody>
</table>
<h3> 10、请求响应设置字符集</h3>
<h4> 1、请求</h4>
<h4> 1、GET</h4>
<p>设置方式</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917164406033.png" alt="image-20220917164406033" loading="lazy"></p>
<h4> 2、Post</h4>
<p>设置方式<br>
注：设置字符集必须在获取请求参数之前</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2、响应</h4>
<p>1、设置方式一：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>2、设置方式二：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>response.getWriter()不能出现在设置字符集操作的前面（两种方式都不行）</p>
<h2> 五、Thymeleaf</h2>
<p>1） 添加thymeleaf的jar包<br>
2） <mark>新建一个Servlet类<strong>ViewBaseServlet</strong></mark><br>
3） 在web.xml文件中添加配置</p>

<p>4） <mark>使得<strong>我们的Servlet继承ViewBaseServlet</strong></mark><br>
<strong>VIewBaseServlet继承了HttpServlet<br>
我们创建的Servlet继承了ViewServlet</strong></p>
<p>5） 根据逻辑视图名称 得到 物理视图名称<br>
//此处的视图名称是 index<br>
//那么thymeleaf会将这个 逻辑视图名称 对应到 物理视图 名称上去<br>
//逻辑视图名称 ：   index<br>
//物理视图名称 ： <strong>view-prefix + 逻辑视图名称 + view-suffix</strong><br>
//所以真实的视图名称是：      /       index       .html<br>
super.processTemplate("index",request,response);<br>
6） 使用thymeleaf的标签<br>
th:if   ,  th:unless   , th:each   ,   th:text</p>
<h3> ViewBaseServlet</h3>
<p>有关ViewBaseServlet</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1、Thymeleaf简介</h3>
<p>Thymeleaf、JSP、Freemarker、Velocity等等，它们有一个共同的名字：<strong>服务器端模板技术</strong></p>
<p><strong>thymeleaf帮助我们做视图渲染</strong><br>
<strong>渲染：在html页面上加载java内存中的数据</strong></p>
<p>Thymeleaf的优势：<br>
SpringBoot官方推荐使用的视图模板技术，和SpringBoot完美整合。<br>
不经过服务器运算仍然可以直接查看原始值，对前端工程师更友好。</p>
<p>物理视图和逻辑视图<br>
①物理视图<br>
在Servlet中，将请求转发到一个HTML页面文件时，使用的完整的转发路径就是<strong>物理视图</strong>。</p>
<p>如果我们把所有的HTML页面都放在某个统一的目录下，那么转发地址就会呈现出明显的规律：<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917185459523.png" alt="image-20220917185459523" loading="lazy"></p>
<p>所以，路径开头的部分我们称之为<strong>视图前缀</strong>，路径结尾的部分我们称之为<strong>视图后缀</strong>。</p>
<p>②逻辑视图<br>
物理视图=视图前缀+逻辑视图+视图后缀<br>
上面的例子中：</p>
<table>
<thead>
<tr>
<th>视图前缀</th>
<th>逻辑视图</th>
<th>视图后缀</th>
<th>物理视图</th>
</tr>
</thead>
<tbody>
<tr>
<td>/pages/user/</td>
<td>login</td>
<td>.html</td>
<td>/pages/user/login.html</td>
</tr>
<tr>
<td>/pages/user/</td>
<td>login_success</td>
<td>.html</td>
<td>/pages/user/login_success.html</td>
</tr>
</tbody>
</table>
<h3> 2、在服务器端引入Thymeleaf环境</h3>
<p>https://heavy_code_industry.gitee.io/code_heavy_industry/pro001-javaweb/lecture/chapter08/verse03.html</p>
<h3> 3、基本语法：th名称空间</h3>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917190228445.png" alt="image-20220917190228445" loading="lazy"></p>
<h3> 4、基本语法：表达式语法</h3>
<h4> 1、修改标签文本值</h4>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h5> ①th:text作用</h5>
<p>不经过服务器解析，直接用浏览器打开HTML文件，看到的是标签体原始值<br>
<strong>经过服务器解析</strong>，Thymeleaf引擎根<strong>据th:text属性指定</strong>的标签体新值去<strong>替换</strong>标签体原始值</p>
<h5> ②字面量</h5>
<p>字面量是一个经常会遇到的概念，我们可以对照变量来理解它的含义<br>
<strong>变量</strong>：变量名字符串本身不是它的值，<strong>它指向的才是它的值</strong><br>
<strong>字面量</strong>：它就是字面上的含义，我们<strong>从字面上看到的直接就是它的值</strong><br>
现在我们在th:text属性中使用的就是<strong>字面量</strong>，它<strong>不指代任何其他值</strong></p>
<h4> 2、修改指定属性值</h4>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>语法：任何HTML标签原有的属性，<strong>前面加上『th:』就都可以通过Thymeleaf来设定新值。</strong></p>
<h4> <mark>3、解析URL地址</mark></h4>
<h5> ①基本语法</h5>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>经过解析后得到：/view/aaa/bbb/ccc</p>
<p>所以==@{}==的作用是<strong>在字符串前附加『上下文路径』</strong></p>
<p>这个语法的好处是：实际开发过程中，项目在不同环境部署时，Web应用的名字有可能发生变化。所以上下文路径不能写死。而通过@{}动态获取上下文路径后，不管怎么变都不怕啦！</p>
<h5> ②首页使用URL地址解析</h5>
<p>如果我们直接访问index.html本身，那么<strong>index.html是不需要通过Servlet</strong>，<strong>当然也不经过模板引擎</strong>，所以<strong>index.html上的Thymeleaf的任何表达式都不会被解析</strong>。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917191612545.png" alt="image-20220917191612545" loading="lazy"></p>
<p>解决办法：通过Servlet访问index.html，这样就可以让模板引擎渲染页面了：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917191730539.png" alt="image-20220917191730539" loading="lazy"></p>
<h5> ③<mark>给URL地址后面附加请求参数</mark></h5>
<p><strong>一个变量对应一个value值</strong></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220923195523837.png" alt="image-20220923195523837" loading="lazy"></p>
<h4> 4、直接执行表达式</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220917191950294.png" alt="image-20220917191950294" loading="lazy"></p>
<h3> 5、基本语法：访问域对象（保存作用域）</h3>
<h4> 1、域对象</h4>
<h5> ①请求域：HttpServletRequest对象内部给我们提供的存储空间（requese 一次会话范围有效）</h5>
<h5> ②会话域（session 一次会话范围有效）</h5>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220923154339888.png" alt="image-20220923154339888" loading="lazy"></p>
<h5> ③应用域（application 一次应用程序范围有效）</h5>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220923154427454.png" alt="image-20220923154427454" loading="lazy"></p>
<h4> 2、在servlet中将数据存入域</h4>
<h5> ①操作请求域</h5>
<p><strong>Servlet中：</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>thymeleaf中：</strong></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h5> ②操作会话域</h5>
<p><strong>Servlet中代码：</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>thymeleaf中：</strong></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h5> ③操作应用域</h5>
<p><strong>Servlet中代码：</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Thymeleaf表达式：</strong></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 6、获取请求参数</h3>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220923161405776.png" alt="image-20220923161405776" loading="lazy"></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7、内置对象</h3>
<p>所谓内置对象其实就是在表达式中<strong>可以直接使用</strong>的对象</p>
<p><strong>基本内置对象：</strong></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220923162427773.png" alt="image-20220923162427773" loading="lazy"></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>基本思路：<br>
如果不清楚这个对象有哪些方法可以使用，那么就<strong>通过getClass().getName()获取全类名</strong>，再<strong>回到Java环境查看这个对象有哪些方法</strong><br>
内置对象的<strong>方法可以直接调用</strong><br>
<strong>调用方法</strong>时<strong>需要传参</strong>的也可以<strong>直接传入参数</strong></p>
<p><strong>公共内置对象：</strong></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220923162455736.png" alt="image-20220923162455736" loading="lazy"></p>
<p>Servlet中将List集合数据存入请求域：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>页面代码：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8、${ }中的表达式本质是OGNL</h3>
<p>OGNL：Object-Graph Navigation Language对象-图 导航语言</p>
<h3> 9、OGNL语法</h3>
<h4> ①起点</h4>
<p>在Thymeleaf环境下，${}中的表达式可以从下列元素开始：</p>
<p>访问属性域的起点:<br>
请求域属性名<br>
session<br>
application<br>
param<br>
内置对象<br>
#request<br>
#session<br>
#lists<br>
#strings</p>
<h4> ②属性访问语法</h4>
<p>访问对象属性：使用getXxx()、setXxx()方法定义的属性<br>
对象.属性名<br>
访问List集合或数组<br>
集合或数组[下标]<br>
访问Map集合<br>
Map集合.key<br>
Map集合['key']</p>
<h3> 10、分支与迭代</h3>
<h4> 1、分支</h4>
<p><strong>①if和unless</strong><br>
让标记了th:if、th:unless的标签根据条件决定是否显示。</p>
<p>示例的实体类：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>示例的Servlet代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>示例的HTML代码：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> ②switch</h4>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2、迭代</h4>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220923164310877.png" alt="image-20220923164310877" loading="lazy"></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 11、包含其他模板文件</h3>
<p>https://heavy_code_industry.gitee.io/code_heavy_industry/pro001-javaweb/lecture/chapter08/verse11.html</p>
<h2> CRUD练习</h2>
<p>https://heavy_code_industry.gitee.io/code_heavy_industry/pro001-javaweb/lecture/chapter08/verse12.html</p>
<h2> Fruit项目优化</h2>
<ol>
<li>一个请求对应一个Servlet，这样存在的问题是servlet太多了</li>
<li>把一些列的请求都对应一个Servlet, IndexServlet/AddServlet/EditServlet/DelServlet/UpdateServlet -&gt; 合并成FruitServlet<br>
通过一个operate的值来决定调用FruitServlet中的哪一个方法<br>
使用的是switch-case</li>
<li>在上一个版本中，Servlet中充斥着大量的switch-case，试想一下，随着我们的项目的业务规模扩大，那么会有很多的Servlet，也就意味着会有很多的switch-case，这是一种代码冗余<br>
因此，我们在servlet中使用了反射技术，我们规定operate的值和方法名一致，那么接收到operate的值是什么就表明我们需要调用对应的方法进行响应，如果找不到对应的方法，则抛异常</li>
<li>在上一个版本中我们使用了反射技术，但是其实还是存在一定的问题：每一个servlet中都有类似的反射技术的代码。因此继续抽取，设计了中央控制器类：<code>DispatcherServlet</code><br>
<code> DispatcherServlet</code>这个类的工作分为两大部分：</li>
<li>根据url定位到能够处理这个请求的controller组件：
<ul>
<li>从url中提取servletPath : /fruit.do -&gt; fruit</li>
<li>根据fruit找到对应的组件:FruitController ， 这个对应的依据我们存储在applicationContext.xml中<br>
<code>&lt;bean id="fruit" class="com.atguigu.fruit.controllers.FruitController/&gt;</code><br>
通过DOM技术我们去解析XML文件，在中央控制器中形成一个beanMap容器，用来存放所有的Controller组件</li>
<li>根据获取到的operate的值定位到我们FruitController中需要调用的方法</li>
</ul>
</li>
<li>调用Controller组件中的方法：
<ul>
<li>获取参数<br>
获取即将要调用的方法的参数签名信息: Parameter[] parameters = method.getParameters();<br>
通过parameter.getName()获取参数的名称；<br>
准备了Object[] parameterValues 这个数组用来存放对应参数的参数值<br>
另外，我们需要考虑参数的类型问题，需要做类型转化的工作。通过parameter.getType()获取参数的类型</li>
<li>执行方法<br>
Object returnObj = method.invoke(controllerBean , parameterValues);</li>
<li>视图处理</li>
</ul>
</li>
</ol>
<h2> 六、MVC</h2>
<h3> 1、servlet初始化回顾</h3>
<p>Servlet生命周期：实例化、初始化、服务、销毁</p>
<p>Servlet中的初始化方法有两个：init() , init(config)<br>
其中带参数的方法代码如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们想要在Servlet<strong>初始化时做一些准备工作，那么我们可以重写init方法</strong><br>
我们可以通过如下步骤去获取初始化设置的数据</p>
<p><strong>获取config对象：ServletConfig config = getServletConfig();<br>
获取初始化参数值： config.getInitParameter(key);</strong></p>
<p>在web.xml文件中配置Servlet</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也可以通过注解的方式进行配置：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2、学习Servlet中的ServletContext和&lt;context-param&gt;</h3>
<ol>
<li>获取ServletContext，有很多方法<br>
在初始化方法中： ServletContxt servletContext = getServletContext();<br>
在服务方法中也可以通过request对象获取，也可以通过session获取：<br>
request.getServletContext(); session.getServletContext()</li>
<li>获取初始化值：<br>
servletContext.getInitParameter();</li>
</ol>
<p>通过ServletContext获取配置的上下文参数</p>
<h3> 3业务层</h3>
<p>Model1和Model2<br>
<strong>MVC : Model（模型）、View（视图）、Controller（控制器）</strong><br>
视图层：用于做<strong>数据展示</strong>以及和<strong>用户交互的</strong>一个<strong>界面</strong><br>
控制层：能够<strong>接受客户端的请求</strong>，<strong>具体的业务功能还是需要借助于模型组件来完成</strong><br>
模型层：模型分为很多种：有比较简单的pojo/vo(value object)，有业务模型组件，有数据访问层组件<br>
pojo/vo : 值对象<br>
DAO ： 数据访问对象<br>
BO ： 业务对象</p>
<p>模型有很多种类：数据访问模型（DAO）；业务逻辑模型（BO）；值对象模型（POJO）；数据传输对象（DTO）</p>
<p><strong>DAO中的方法</strong>都是<strong>单精度</strong>方法或称<strong>细粒度</strong>方法。一个方法只考虑一个操作，比如添加，那就是insert操作、查询那就是select操作....(<strong>只是一种操作</strong>)<br>
<strong>BO</strong>中的方法属于<strong>业务方法</strong>，也实际的业务是<strong>比较复杂</strong>的，因此业务方法的<strong>粒度是比较粗</strong>的<br>
注册这个功能属于业务功能，也就是说注册这个方法属于业务方法。<br>
那么这个<strong>业务方法中包含了多个DAO方法</strong>。</p>
<h2> 七、IOC（控制反转）</h2>
<p><strong>IOC - 控制反转 / DI - 依赖注入</strong></p>
<p><strong>控制反转：</strong><br>
之前在Servlet中，我们创建service对象 ， FruitService fruitService = new FruitServiceImpl();<br>
这句话如果出现在servlet中的<strong>某个方法内部</strong>，那么这个fruitService的作用域（生命周期）应该就是<strong>这个方法级别</strong>；<br>
如果这句话出现在servlet的<strong>类中</strong>，也就是说fruitService是一个<strong>成员变量</strong>，那么这个fruitService的作用域（生命周期）应该就是这个<strong>servlet实例级别</strong></p>
<p>​	之后我们在<strong>applicationContext.xml中定义了这个fruitService</strong>。然后<strong>通过解析XML</strong>，<strong>产生fruitService实例</strong>，<strong>存放在beanMap中</strong>，这个<strong>beanMap在一个BeanFactory中 **<br>
​	因此，我们</strong>转移（改变）了之前的service实例、dao实例等等他们的生命周期**。控制权从程序员转移到<strong>BeanFactory(IOC容器)</strong>。这个现象我们称之为<strong>控制反转</strong></p>
<p><strong>依赖注入：</strong><br>
之前我们在控制层出现代码：FruitService fruitService = new FruitServiceImpl()；<br>
那么，控制层和service层存在耦合。<br>
之后，我们将代码修改成FruitService fruitService = null ;<br>
然后，在配置文件中配置:</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 配置监听器要读取的文件，目的是加载IOC容器的配置文件</h3>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>根据bean获取所有元素节点，添加到map中，对于每个节点的子节点，通过反射添加它们中的依赖</strong></p>
<h2> 八、过滤器Filter</h2>
<h3> 1、过滤器的三要素：</h3>
<p>①拦截：<br>
过滤器之所以能够对请求进行预处理，关键是对请求进行拦截，把请求拦截下来才能够做后续的操作。而且对于一个具体的过滤器，它<strong>必须明确它要拦截的请求</strong>，而不是所有请求都拦截。</p>
<p>②过滤：<br>
根据业务功能实际的需求，看看在把请求拦截到之后，需要<strong>做什么检查或什么操作，写对应的代码即可</strong>。</p>
<p>③放行：<br>
过滤器完成自己的任务或者是检测到当前请求符合过滤规则，那么可以将请求放行。所谓放行，就是<strong>让请求继续去访问它原本要访问的资源</strong>。</p>
<h3> 2、操作步骤</h3>
<ol>
<li>
<p>Filter也属于Servlet规范</p>
</li>
<li>
<p>Filter开发步骤：新建类<strong>实现javax.servlet.Filter接口</strong>，然后实现其中的三个方法：init、doFilter、destroy<br>
配置Filter，可以用注解@WebFilter，<code>也可以使用xml文件 &lt;filter&gt; &lt;filter-mapping&gt;</code></p>
<p><strong>在doFilter()方法中执行过滤</strong></p>
<p>如果<strong>满足过滤条件</strong>使用<strong>chain.doFilter(request, response);放行</strong></p>
<p>如果<strong>不满足过滤条件转发或重定向请求</strong></p>
</li>
<li>
<p>Filter在配置时，和servlet一样，也可以配置通配符，例如 @WebFilter("*.do")表示<strong>拦截所有以.do结尾的请求</strong></p>
</li>
<li>
<p>过滤器链<br>
1）如果采取的是<strong>注解的方式进行配置</strong>，那么过滤器链的拦截顺序是<strong>按照全类名的先后顺序</strong>排序的<br>
2）如果采取的是<strong>xml的方式</strong>进行配置，那么按照<strong>配置的先后顺序</strong>进行排序</p>
</li>
<li>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/01.Filter.png" alt="01.Filter" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/02.CharacterEncodingFilter.png" alt="02.CharacterEncodingFilter" loading="lazy"></p>
<h3> 3、过滤器生命周期</h3>
<p>和Servlet生命周期类比，Filter生命周期的关键区别是：<strong>在Web应用启动时创建对象</strong></p>
<table>
<thead>
<tr>
<th>生命周期阶段</th>
<th>执行时机</th>
<th>执行次数</th>
</tr>
</thead>
<tbody>
<tr>
<td>创建对象</td>
<td>Web应用启动时</td>
<td>一次</td>
</tr>
<tr>
<td>初始化</td>
<td>创建对象后</td>
<td>一次</td>
</tr>
<tr>
<td>拦截请求</td>
<td>接收到匹配的请求</td>
<td>多次</td>
</tr>
<tr>
<td>销毁</td>
<td>Web应用卸载前</td>
<td>一次</td>
</tr>
</tbody>
</table>
<h2> 九、事务管理</h2>
<ol>
<li>
<p>涉及到的组件：</p>
<ul>
<li>OpenSessionInViewFilter</li>
<li>TransactionManager</li>
<li>ThreadLocal</li>
<li>ConnUtil</li>
<li>BaseDAO</li>
</ul>
</li>
<li>
<p>ThreadLocal</p>
<p>get() , set(obj)方法（对于同一个线程中）</p>
<p>ThreadLocal称之为本地线程 。 我们可以<strong>通过set方法在当前线程上存储数据、通过get方法在当前线程上获取数据</strong></p>
<p>set方法源码分析：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>get方法源码分析：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/05.编程式事务管理03.png" alt="05.编程式事务管理03" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/06.ThreadLocal.png" alt="06.ThreadLocal" loading="lazy"></p>
<h2> 十、监听器</h2>
<h3> 1、观察者模式</h3>
<ul>
<li>观察者：监控『被观察者』的行为，一旦发现『被观察者』触发了事件，就会调用事先准备好的方法执行操作。</li>
<li>被观察者：『被观察者』一旦触发了被监控的事件，就会被『观察者』发现。</li>
</ul>
<h3> 2、监听器简介</h3>
<p>1、<strong>Servlet监听器</strong>：Servlet规范中定义的一种特殊类，它用于监听Web应用程序中的<strong>ServletContext，HttpSession 和HttpServletRequest等域对象的创建与销毁事件</strong>，以及监听这些<strong>域对象中的属性发生修改的事件</strong></p>
<p>2、监听器分类</p>
<ul>
<li>域对象监听器</li>
<li>域对象的属性域监听器</li>
<li>Session域中数据的监听器</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221003161917547.png" alt="image-20221003161917547" loading="lazy"></p>
<h3> 3、监听器列表</h3>
<h4> ①ServletContextListener</h4>
<p>作用：监听<strong>ServletContext对象</strong>的创建与销毁</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>contextInitialized(ServletContextEvent sce)</td>
<td>ServletContext创建时调用</td>
</tr>
<tr>
<td>contextDestroyed(ServletContextEvent sce)</td>
<td>ServletContext销毁时调用</td>
</tr>
</tbody>
</table>
<p>ServletContextEvent对象代表从ServletContext对象身上捕获到的事件，通过这个事件对象我们可以获取到ServletContext对象。</p>
<h4> ②HttpSessionListener</h4>
<p>作用：监听<strong>HttpSession对象</strong>的创建与销毁</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>sessionCreated(HttpSessionEvent hse)</td>
<td>HttpSession对象创建时调用</td>
</tr>
<tr>
<td>sessionDestroyed(HttpSessionEvent hse)</td>
<td>HttpSession对象销毁时调用</td>
</tr>
</tbody>
</table>
<p>HttpSessionEvent对象代表从HttpSession对象身上捕获到的事件，通过这个事件对象我们可以获取到触发事件的HttpSession对象。</p>
<h4> ③ServletRequestListener</h4>
<p>作用：监听<strong>ServletRequest对象</strong>的创建与销毁</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>requestInitialized(ServletRequestEvent sre)</td>
<td>ServletRequest对象创建时调用</td>
</tr>
<tr>
<td>requestDestroyed(ServletRequestEvent sre)</td>
<td>ServletRequest对象销毁时调用</td>
</tr>
</tbody>
</table>
<p>ServletRequestEvent对象代表从HttpServletRequest对象身上捕获到的事件，通过这个事件对象我们可以获取到触发事件的HttpServletRequest对象。另外还有一个方法可以获取到当前Web应用的ServletContext对象。</p>
<h4> ④ServletContextAttributeListener</h4>
<p>作用：监听<strong>ServletContext中属性</strong>的创建、修改和销毁</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>attributeAdded(ServletContextAttributeEvent scab)</td>
<td>向ServletContext中添加属性时调用</td>
</tr>
<tr>
<td>attributeRemoved(ServletContextAttributeEvent scab)</td>
<td>从ServletContext中移除属性时调用</td>
</tr>
<tr>
<td>attributeReplaced(ServletContextAttributeEvent scab)</td>
<td>当ServletContext中的属性被修改时调用</td>
</tr>
</tbody>
</table>
<p>ServletContextAttributeEvent对象代表属性变化事件，它包含的方法如下：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>getName()</td>
<td>获取<strong>修改或添加的属性名</strong></td>
</tr>
<tr>
<td>getValue()</td>
<td>获取<strong>被修改或添加的属性值</strong></td>
</tr>
<tr>
<td>getServletContext()</td>
<td>获取<strong>ServletContext对象</strong></td>
</tr>
</tbody>
</table>
<h4> ⑤HttpSessionAttributeListener</h4>
<p>作用：监听<strong>HttpSession中属性</strong>的创建、修改和销毁</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>attributeAdded(HttpSessionBindingEvent se)</td>
<td>向HttpSession中<strong>添加属性时</strong>调用</td>
</tr>
<tr>
<td>attributeRemoved(HttpSessionBindingEvent se)</td>
<td>从HttpSession中<strong>移除属性时</strong>调用</td>
</tr>
<tr>
<td>attributeReplaced(HttpSessionBindingEvent se)</td>
<td>当HttpSession中的<strong>属性被修改时</strong>调用</td>
</tr>
</tbody>
</table>
<p><strong>HttpSessionBindingEvent对象</strong>代表属性变化事件，它包含的方法如下：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>getName()</td>
<td>获取修改或添加的属性名</td>
</tr>
<tr>
<td>getValue()</td>
<td>获取被修改或添加的属性值</td>
</tr>
<tr>
<td>getSession()</td>
<td>获取触发事件的HttpSession对象</td>
</tr>
</tbody>
</table>
<h4> ⑥ServletRequestAttributeListener</h4>
<p>作用：监听<strong>ServletRequest中属性</strong>的创建、修改和销毁</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>attributeAdded(ServletRequestAttributeEvent srae)</td>
<td>向ServletRequest中添加属性时调用</td>
</tr>
<tr>
<td>attributeRemoved(ServletRequestAttributeEvent srae)</td>
<td>从ServletRequest中移除属性时调用</td>
</tr>
<tr>
<td>attributeReplaced(ServletRequestAttributeEvent srae)</td>
<td>当ServletRequest中的属性被修改时调用</td>
</tr>
</tbody>
</table>
<p>ServletRequestAttributeEvent对象代表属性变化事件，它包含的方法如下：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>getName()</td>
<td>获取修改或添加的属性名</td>
</tr>
<tr>
<td>getValue()</td>
<td>获取被修改或添加的属性值</td>
</tr>
<tr>
<td>getServletRequest ()</td>
<td>获取触发事件的ServletRequest对象</td>
</tr>
</tbody>
</table>
<h4> ⑦HttpSessionBindingListener</h4>
<p>作用：监听某个对象在Session域中的创建与移除</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>valueBound(HttpSessionBindingEvent event)</td>
<td>该类的实例被放到Session域中时调用</td>
</tr>
<tr>
<td>valueUnbound(HttpSessionBindingEvent event)</td>
<td>该类的实例从Session中移除时调用</td>
</tr>
</tbody>
</table>
<p>HttpSessionBindingEvent对象代表属性变化事件，它包含的方法如下：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>getName()</td>
<td>获取当前事件涉及的属性名</td>
</tr>
<tr>
<td>getValue()</td>
<td>获取当前事件涉及的属性值</td>
</tr>
<tr>
<td>getSession()</td>
<td>获取触发事件的HttpSession对象</td>
</tr>
</tbody>
</table>
<h4> ⑧HttpSessionActivationListener</h4>
<p>作用：监听某个对象在Session中的序列化与反序列化。</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>sessionWillPassivate(HttpSessionEvent se)</td>
<td>该类实例和Session一起钝化到硬盘时调用</td>
</tr>
<tr>
<td>sessionDidActivate(HttpSessionEvent se)</td>
<td>该类实例和Session一起活化到内存时调用</td>
</tr>
</tbody>
</table>
<p>HttpSessionEvent对象代表事件对象，通过getSession()方法获取事件涉及的HttpSession对象。</p>
<h3> 4、监听器的使用</h3>
<h4> ①创建监听器类</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> ②注册监听器</h4>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 目前我们进行javaweb项目开发的“套路”是这样的：</h2>
<ol>
<li>
<p>拷贝 myssm包</p>
</li>
<li>
<p>新建配置文件applicationContext.xml或者可以不叫这个名字，在web.xml中指定文件名</p>
</li>
<li>
<p>在web.xml文件中配置：</p>
<ol>
<li>配置前缀和后缀，这样thymeleaf引擎就可以根据我们返回的字符串进行拼接，再跳转</li>
</ol>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2">
<li>配置监听器要读取的参数，目的是加载IOC容器的配置文件（也就是applicationContext.xml）</li>
</ol>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>开发具体的业务模块：<br>
1） 一个具体的业务模块纵向上由几个部分组成：</p>
<ul>
<li>html页面</li>
<li>POJO类</li>
<li>DAO接口和实现类</li>
<li>Service接口和实现类</li>
<li>Controller 控制器组件<br>
2） 如果html页面有thymeleaf表达式，一定不能够直接访问，必须要经过PageController<br>
3） 在applicationContext.xml中配置 DAO、Service、Controller，以及三者之间的依赖关系<br>
4） DAO实现类中 ， 继承BaseDAO，然后实现具体的接口, 需要注意，BaseDAO后面的泛型不能写错。</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>5） Service是业务控制类，这一层我们只需要记住一点：<br>
- 业务逻辑我们都封装在service这一层，不要分散在Controller层。也不要出现在DAO层（我们需要保证DAO方法的单精度特性）<br>
- 当某一个业务功能需要使用其他模块的业务功能时，尽量的调用别人的service，而不是深入到其他模块的DAO细节<br>
6） Controller类的编写规则<br>
① 在applicationContext.xml中配置Controller<br>
&lt;bean id="user" class="com.atguigu.qqzone.controllers.UserController&gt;<br>
那么，用户在前端发请求时，对应的servletpath就是   /user.do   , 其中的“user”就是对应此处的bean的id值<br>
② 在Controller中设计的方法名需要和operate的值一致<br>
public String login(String loginId , String pwd , HttpSession session){<br>
return "index";<br>
}<br>
因此，我们的登录验证的表单如下：<br>
</p><form th:action="@{/user.do}" method="post"><br>
</form></li>
</ol>
<h2> 十一、其他知识</h2>
<h3> 1、cookie</h3>
<p>cookie时客户端保存的一些数据，比如sessioinID<br>
给服务器发请求时，服务器会产生cookie，响应时将cookie带给客户端，客户端将cookie文件保存在本地电脑下</p>
<ol>
<li>
<p>创建Cookie对象</p>
</li>
<li>
<p>在客户端保存Cookie</p>
</li>
<li>
<p>设置Cookie的有效时长</p>
<p>cookie.setMaxAge(60)  ， 设置cookie的有效时长是60秒<br>
cookie.setDomain(pattern);<br>
cookie.setPath(uri);</p>
</li>
<li>
<p>Cookie的应用：<br>
4-1: 记住用户名和密码十天 setMaxAge(60 * 60 * 24 * 10)<br>
4-2: 十天免登录</p>
</li>
</ol>
<p>创建cookie并返回：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>服务器端读取cookie信息</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>cookie的时效性</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2、Kaptcha</h3>
<p>1、验证码的作用：防止机器发送大量请求<br>
2、Kaptcha的使用：<br>
添加jar包<br>
在web.xml文件中注册KaptchaServlet，并设置验证码图片的相关属性<br>
在html页面上编写一个img标签，然后设置src等于KaptchaServlet对应的url-pattern<br>
3、kaptcha验证码图片的各个属性在常量接口：Constants中<br>
4、KaptchaServlet在生成验证码图片时，会同时将验证码信息保存到session中<br>
因此，我们在注册请求时，首先将用户文本框中输入的验证码值和session中保存的值进行比较，相等，则进行注册</p>
<h2> 十二、JavaWeb总结</h2>
<p>java实体类的不同名称</p>
<ul>
<li>POJO：Plain old Java Object，传统的普通的Java对象</li>
<li>entity：实体类</li>
<li>bean或Java bean</li>
<li>domain：领域模型</li>
</ul>
<p>DAO：dao中的方法都是单精度的</p>
<p>Servce：一个业务方法，它对应多个单精度方法，将其封装到service方法中</p>
<p>Controller：主要分为三个部分， 参数获取，服务，资源转发，将部分代码抽取到中央控制器中</p>
<p>IOC容器：层与层之间有耦合，降低耦合，依赖注入，管理对象的生命周期（对bean的组装，添加依赖关系）</p>
<p>filter：设置编码，开启事务，对事务的try-catch</p>
<p>listener：监听上下文启动，在上下文启动的时候去创建IOC容器,然后将其保存到application作用域，后面中央控制器再从application作用域中去获取IOC容器</p>
<p>threadLocal的引入</p>
<p>DispatcherServlet:中央控制器</p>
<h3> MVC各个层的设计</h3>
]]></content:encoded>
      <enclosure url="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220914194924351.png" type="image/png"/>
    </item>
    <item>
      <title>Maven 基础</title>
      <link>https://T4mako.github.io/code/java/Maven%E5%9F%BA%E7%A1%80.html</link>
      <guid>https://T4mako.github.io/code/java/Maven%E5%9F%BA%E7%A1%80.html</guid>
      <source url="https://T4mako.github.io/rss.xml">Maven 基础</source>
      <description>1、Maven概述 1、为什么要学习Maven？ 1、Maven 作为依赖管理工具 ①jar 包的规模 随着我们使用越来越多的框架，或者框架封装程度越来越高，项目中使用的jar包也越来越多。项目中，一个模块里面用到上百个jar包是非常正常的。</description>
      <category>java</category>
      <content:encoded><![CDATA[<h2> 1、Maven概述</h2>
<h3> 1、为什么要学习Maven？</h3>
<h4> 1、Maven 作为依赖管理工具</h4>
<h5> ①jar 包的规模</h5>
<p>随着我们使用越来越多的框架，或者框架封装程度越来越高，项目中使用的jar包也越来越多。项目中，一个模块里面用到上百个jar包是非常正常的。</p>
<!-- more -->
<p>比如下面的例子，我们只用到 SpringBoot、SpringCloud 框架中的三个功能：Nacos 服务注册发现、Web 框架环境、图模板技术 Thymeleaf<br>
最终却导入了 106 个 jar 包</p>
<p>而如果使用 Maven 来引入这些 jar 包只需要配置三个『<strong>依赖</strong>』：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> ②jar 包的来源</h5>
<p>使用 Maven 后，依赖对应的 jar 包能够<strong>自动下载</strong>，方便、快捷又规范</p>
<h5> ③jar 包之间的依赖关系</h5>
<p>框架中使用的 jar 包，不仅数量庞大，而且彼此之间存在错综复杂的依赖关系。依赖关系的复杂程度，已经上升到了完全不能靠人力手动解决的程度。另外，jar 包之间有可能产生冲突。进一步增加了我们在 jar 包使用过程中的难度。</p>
<p>而实际上 jar 包之间的依赖关系是普遍存在的，如果要由程序员手动梳理无疑会增加极高的学习成本，而这些工作又对实现业务功能毫无帮助。</p>
<p><strong>而使用 Maven 则几乎不需要管理这些关系，极个别的地方调整一下即可，极大的减轻了我们的工作量</strong>。</p>
<h4> 2、Maven 作为构建管理工具</h4>
<h5> ①你没有注意过的构建</h5>
<p>你可以不使用 Maven，但是构建必须要做。当我们使用 IDEA 进行开发时，构建是 IDEA 替我们做的。</p>
<h5> ②脱离 IDE 环境仍需构建</h5>
<h4> 结论</h4>
<ul>
<li><strong>管理规模庞大的 jar 包，需要专门工具。</strong></li>
<li><strong>脱离 IDE 环境执行构建操作，需要专门工具。</strong></li>
</ul>
<h3> 2、什么是 Maven？</h3>
<p>Maven 是 Apache 软件基金会组织维护的一款专门为 Java 项目提供<strong>构建</strong>和<strong>依赖</strong>管理支持的工具。</p>
<h4> 1、构建</h4>
<p>Java 项目开发过程中，构建指的是使用**『原材料生产产品』**的过程。<br>
原材料：Java 源代码、基于 HTML 的 Thymeleaf 文件、图片、配置文件等<br>
产品：一个可以在服务器上运行的项目</p>
<p><strong>构建过程</strong>包含的<strong>主要的环节</strong>：<br>
清理：删除上一次构建的结果，为下一次构建做好准备<br>
编译：Java 源程序编译成 *.class 字节码文件<br>
测试：运行提前准备好的测试程序<br>
报告：针对刚才测试的结果生成一个全面的信息<br>
打包：<br>
Java工程：jar包<br>
Web工程：war包<br>
安装：把一个 Maven 工程经过打包操作生成的 jar 包或 war 包存入 Maven 仓库<br>
部署：<br>
部署 jar 包：把一个 jar 包部署到 Nexus 私服服务器上<br>
部署 war 包：借助相关 Maven 插件（例如 cargo），将 war 包部署到 Tomcat 服务器上</p>
<h4> 2、依赖</h4>
<p>如果 A 工程里面用到了 B 工程的类、接口、配置文件等等这样的资源，那么我们就可以说 A 依赖 B。</p>
<p>例如：<br>
junit-4.12 依赖 hamcrest-core-1.3<br>
thymeleaf-3.0.12.RELEASE 依赖 ognl-3.1.26<br>
ognl-3.1.26 依赖 javassist-3.20.0-GA<br>
thymeleaf-3.0.12.RELEASE 依赖 attoparser-2.0.5.RELEASE<br>
thymeleaf-3.0.12.RELEASE 依赖 unbescape-1.1.6.RELEASE<br>
thymeleaf-3.0.12.RELEASE 依赖 slf4j-api-1.7.26</p>
<p>依赖管理中要解决的具体问题：</p>
<ul>
<li>jar 包的下载：使用 Maven 之后，jar 包会从规范的远程仓库下载到本地</li>
<li>jar 包之间的依赖：通过依赖的传递性自动完成</li>
<li>jar 包之间的冲突：通过对依赖的配置进行调整，让某些jar包不会被导入</li>
</ul>
<h4> 3、Maven 的工作机制（关键作战地图）</h4>
<p>核心程序：官网下载的Maven解压<br>
Maven仓库：conf/settings.xml中修改的地址为仓库地址</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221219164435561.png" alt="image-20221219164435561" loading="lazy"></p>
<h2> 2、Maven 核心程序解压和配置</h2>
<h3> 1、Maven核心程序解压与配置</h3>
<h4> 1、Maven 官网地址</h4>
<p>首页：<br>
<a href="https://maven.apache.org/" target="_blank" rel="noopener noreferrer">https://maven.apache.org/</a></p>
<p>下载页面：<br>
<a href="https://maven.apache.org/download.cgi" target="_blank" rel="noopener noreferrer">https://maven.apache.org/download.cgi</a></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221219170219783.png" alt="image-20221219170311882" loading="lazy"></p>
<h4> 2、解压Maven核心程序</h4>
<p>解压到<strong>非中文、没有空格</strong>的目录，在解压目录中，我们需要着重关注 Maven 的核心配置文件：<strong>conf/settings.xml</strong></p>
<h4> 3、指定本地仓库</h4>
<p>本地仓库默认值：用户home目录/.m2/repository。由于本地仓库的默认位置是在用户的家目录下，而家目录往往是在 C 盘，也就是系统盘。将来 Maven 仓库中jar 包越来越多，仓库体积越来越大，可能会拖慢 C 盘运行速度，影响系统性能。所以建议将 Maven 的本地仓库放在其他盘符下。配置方式如下：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>本地仓库这个目录，我们手动创建一个空的目录即可。<br>
<strong>记住</strong>：一定要把 localRepository 标签<strong>从注释中拿出来</strong>。<br>
<strong>注意</strong>：本地仓库本身也需要使用一个<strong>非中文、没有空格</strong>的目录。</p>
<h4> 4、配置阿里云提供的镜像仓库</h4>
<p>Maven 下载 jar 包默认访问境外的中央仓库，而国外网站速度很慢。改成阿里云提供的镜像仓库，<strong>访问国内网站</strong>，可以让 Maven 下载 jar 包的时候速度更快。配置的方式是：</p>
<h6> ①将原有的例子配置注释掉</h6>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h6> ②加入我们的配置</h6>
<p>将下面 mirror 标签整体复制到 settings.xml 文件的 mirrors 标签的内部。</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 5、配置 Maven 工程的基础 JDK 版本</h4>
<p>如果按照默认配置运行，Java 工程使用的默认 JDK 版本是 1.5，而我们熟悉和常用的是 JDK 1.8 版本。修改配置的方式是：将 profile 标签整个复制到 settings.xml 文件的 profiles 标签内。</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2、配置环境变量</h3>
<h4> 1、检查 JAVA_HOME 配置是否正确</h4>
<h4> 2、配置 MAVEN_HOME、PATH</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221219175732833.png" alt="image-20221219175732833" loading="lazy"><br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221219175744782.png" alt="image-20221219175744782" loading="lazy"></p>
<h4> 3、验证</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221219175812570.png" alt="image-20221219175812570" loading="lazy"></p>
<h2> 3、使用 Maven：命令行环境</h2>
<h3> 1、根据坐标创建 Maven 工程</h3>
<h4> 1、向量说明</h4>
<p>在数学中，使用 x、y、z 三个**『向量』<strong>作为空间的坐标系，可以在</strong>『空间』<strong>中唯一的定位到一个</strong>『点』**。</p>
<p><strong>在Maven中</strong>，使用三个**『向量』<strong>在</strong>『Maven的仓库』<strong>中</strong>唯一<strong>的定位到一个</strong>『jar』**包。</p>
<ul>
<li>​	<strong>groupId</strong>：公司或组织的 id</li>
<li>​	<strong>artifactId</strong>：一个项目或者是项目中的一个模块的 id</li>
<li>​	<strong>version</strong>：版本号</li>
</ul>
<h4> 2、三个向量的取值方式</h4>
<p><strong>groupId</strong>：公司或组织域名的倒序，通常也会加上项目名称s<br>
例如：com.atguigu.maven<br>
<strong>artifactId</strong>：模块的名称，将来作为 Maven 工程的工程名<br>
<strong>version</strong>：模块的版本号，根据自己的需要设定<br>
例如：SNAPSHOT 表示快照版本，正在迭代过程中，不稳定的版本<br>
例如：RELEASE 表示正式版本</p>
<p>举例：<br>
groupId：com.atguigu.maven<br>
artifactId：pro01-atguigu-maven<br>
version：1.0-SNAPSHOT</p>
<h4> 3、坐标和仓库中 jar 包的存储路径之间的对应关系</h4>
<p>坐标：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面坐标对应的 jar 包在 Maven 本地仓库中的位置：<br>
<strong>Maven本地仓库根目录</strong>\javax\servlet\servlet-api\2.5\servlet-api-2.5.jar<br>
要学会根据坐标到本地仓库中找到对应的 jar 包</p>
<h4> 4、实验操作</h4>
<h5> ①创建目录作为后面操作的工作空间</h5>
<p>例如：D:\maven-workspace\space201026</p>
<p>此时我们已经有了<strong>三个目录</strong>，分别是：<br>
<strong>Maven 核心程序：中军大帐<br>
Maven 本地仓库：兵营<br>
本地工作空间：战场</strong></p>
<h5> ②在工作空间目录下打开命令行窗口</h5>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221220102348639.png" alt="image-20221220102348639" loading="lazy"></p>
<h5> ③使用命令生成Maven工程</h5>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221220102412287.png" alt="image-20221220102412287" loading="lazy"></p>
<p>下面是运行提示操作：<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221220102451513.png" alt="image-20221220102451513" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221220104454725.png" alt="image-20221220104454725" loading="lazy"></p>
<h5> ④调整</h5>
<p>Maven 默认生成的工程，对 junit 依赖的是较低的 3.8.1 版本，我们可以改成较适合的 4.12 版本。<br>
自动生成的 App.java 和 AppTest.java 可以删除。<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221220104639499.png" alt="image-20221220104639499" loading="lazy"></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> ⑤自动生成的 pom.xml 解读</h5>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 5、Maven核心概念：POM</h4>
<h5> ①含义</h5>
<p>POM：<strong>P</strong>roject <strong>O</strong>bject <strong>M</strong>odel，**项目对象模型。和 POM 类似的是：DOM（Document Object Model），文档对象模型。它们都是模型化思想的具体体现。</p>
<h5> ②模型化思想</h5>
<p>POM 表示将工程抽象为一个模型，再用程序中的对象来描述这个模型。这样我们就可以用程序来管理项目了。我们在开发过程中，最基本的做法就是将现实生活中的事物抽象为模型，然后封装模型相关的数据作为一个对象，这样就可以在程序中计算与现实事物相关的数据。</p>
<h5> ③对应的配置文件</h5>
<p>POM 理念集中体现在 Maven 工程根目录下 <strong>pom.xml</strong> 这个配置文件中。所以这个 pom.xml 配置文件就是 Maven 工程的核心配置文件。其实学习 Maven 就是学这个文件怎么配置，各个配置有什么用。</p>
<h4> 6、Maven核心概念：约定的目录结构</h4>
<h5> ①各个目录的作用</h5>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221220110722929.png" alt="image-20221220110722929" loading="lazy"></p>
<h5> ②约定目录结构的意义</h5>
<p>Maven 为了让构建过程能够尽可能自动化完成，所以必须约定目录结构的作用。例如：Maven 执行编译操作，必须先去 Java 源程序目录读取 Java 源代码，然后执行编译，最后把编译结果存放在 target 目录。</p>
<h5> ③约定大于配置</h5>
<p>Maven 对于目录结构这个问题，没有采用配置的方式，而是基于约定。这样会让我们在开发过程中非常方便。如果每次创建 Maven 工程后，还需要针对各个目录的位置进行详细的配置，那肯定非常麻烦。</p>
<p>目前开发领域的技术发展趋势就是：<strong>约定大于配置，配置大于编码</strong>。</p>
<h3> 2、在 Maven 工程中编写代码</h3>
<h4> 1、主体程序</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221223135339243.png" alt="image-20221223135339243" loading="lazy"></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2、测试程序</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221223140441200.png" alt="image-20221223140441200" loading="lazy"></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3、执行 Maven 的构建命令</h3>
<h4> 1、要求</h4>
<p>运行 Maven 中和构建操作相关的命令时，<strong>必须进入到 pom.xml 所在的目录</strong>。如果没有在 pom.xml 所在的目录运行 Maven 的构建命令，那么会看到下面的错误信息：</p>
<p>The goal you specified requires a project to execute but there is no POM in this directory</p>
<p>（<strong>mvn -v</strong> 命令和构建操作无关，只要正确配置了 PATH，在任何目录下执行都可以。而构建相关的命令要在 pom.xml 所在目录下运行——操作哪个工程，就进入这个工程的 pom.xml 目录。）</p>
<h4> 2、清理操作</h4>
<p><strong>mvn clean</strong><br>
效果：删除 target 目录</p>
<h4> 3、编译操作</h4>
<p>主程序编译：<strong>mvn compile</strong><br>
测试程序编译：<strong>mvn test-compile</strong><br>
主体程序编译结果存放的目录：target/classes<br>
测试程序编译结果存放的目录：target/test-classes</p>
<h4> 4、测试操作</h4>
<p><strong>mvn test</strong><br>
测试的报告存放的目录：target/surefire-reports</p>
<h4> 5、打包操作</h4>
<p><strong>mvn package</strong><br>
打包的结果——jar 包，存放的目录：target</p>
<h4> 6、安装操作</h4>
<p>安装的效果是将本地构建过程中生成的 jar 包存入 Maven 本地仓库。这个 jar 包在 Maven 仓库中的路径是根据它的坐标生成的。</p>
<p><strong>mvn install</strong></p>
<p>坐标信息如下：可以在项目中的pom.xml中查看到</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4、创建 Maven 版的 Web 工程</h3>
<h4> 1、说明</h4>
<p>使用 mvn archetype:generate 命令生成 Web 工程时，需要使用一个专门的 archetype。这个专门生成 Web 工程骨架的 archetype 可以参照官网看到它的用法：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221223142819791.png" alt="image-20221223142819791" loading="lazy"></p>
<h4> 2、操作</h4>
<p>注意：如果在上一个工程的目录下执行 mvn archetype:generate 命令，那么 Maven 会报错：不能在一个非 pom 的工程下再创建其他工程。<br>
所以不要再刚才创建的工程里再创建新的工程，<strong>请回到工作空间根目录</strong>来操作。</p>
<p>然后运行生成工程的命令：<br>
<strong>mvn archetype:generate -DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-webapp -DarchetypeVersion=1.4</strong></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221223143929570.png" alt="image-20221223143929570" loading="lazy"></p>
<h4> 3、生成的pom.xml</h4>
<p>确认打包的方式是war包形式</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 4、生成的Web工程的目录结构</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221223145233465.png" alt="image-20221223145233465" loading="lazy"></p>
<h4> 5、创建 Servlet</h4>
<h5> ①在 main 目录下创建 java 目录</h5>
<h5> ②在 java 目录下创建 Servlet 类所在的包的目录</h5>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221223145558932.png" alt="image-20221223145558932" loading="lazy"></p>
<h5> ③在包下创建 Servlet 类</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> ④在 web.xml 中注册 Servlet</h5>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 6、在 index.jsp 页面编写超链接</h4>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 7、编译</h4>
<p>此时直接执行 <strong>mvn compile</strong> 命令出错：</p>
<p>说明：我们的 Web 工程用到了 HttpServlet 这个类，而 HttpServlet 这个类属于 servlet-api.jar 这个 jar 包。此时我们说，<strong>Web 工程需要依赖 servlet-api.jar</strong> 包。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221223150029811.png" alt="image-20221223150029811" loading="lazy"></p>
<h4> 8、配置对 servlet-api.jar 包的依赖</h4>
<p>对于不知道详细信息的依赖可以到**<a href="https://mvnrepository.com/**%E7%BD%91%E7%AB%99%E6%9F%A5%E8%AF%A2%E3%80%82%E4%BD%BF%E7%94%A8%E5%85%B3%E9%94%AE%E8%AF%8D%E6%90%9C%E7%B4%A2%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9C%A8%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C%E5%88%97%E8%A1%A8%E4%B8%AD%E9%80%89%E6%8B%A9%E9%80%82%E5%90%88%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%82" target="_blank" rel="noopener noreferrer">https://mvnrepository.com/**网站查询。使用关键词搜索，然后在搜索结果列表中选择适合的使用。</a></p>
<p>比如，我们找到的 servlet-api 的依赖信息：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样就可以把上面的信息加入 pom.xml。重新执行 mvn compile 命令。</p>
<h4> 9、将 Web 工程打包为 war 包</h4>
<p>运行 <strong>mvn package</strong> 命令，生成 war 包的位置如下图所示：</p>
<h4> 10、将 war 包部署到 Tomcat 上运行</h4>
<p>将 war 包复制到 Tomcat/webapps 目录下<br>
启动 Tomcat<br>
通过浏览器尝试访问：<a href="http://localhost:8080/pro02-maven-web/index.jsp" target="_blank" rel="noopener noreferrer">http://localhost:8080/pro02-maven-web/index.jsp</a></p>
<h3> 5、让 Web 工程依赖 Java 工程</h3>
<h4> 1、观念</h4>
<p>明确一个意识：从来只有 Web 工程依赖 Java 工程，没有反过来 Java 工程依赖 Web 工程。<br>
本质上来说，Web 工程依赖的 Java 工程其实就是 <strong>Web 工程里导入的 jar 包</strong>。最终 <strong>Java 工程会变成 jar 包，放在 Web 工程的 WEB-INF/lib 目录下</strong>。</p>
<h4> 2、操作</h4>
<p>在 pro02-maven-web 工程的 pom.xml 中，找到 dependencies 标签，在 dependencies 标签中做如下配置：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3、在 Web 工程中，编写测试代码</h4>
<h5> ①补充创建目录</h5>
<p>pro02-maven-web**\src\test\java\com\atguigu\maven**</p>
<h5> ②确认 Web 工程依赖了 junit</h5>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> ③创建测试类</h5>
<p>把 Java 工程的 CalculatorTest.java 类复制到 pro02-maven-web**\src\test\java\com\atguigu\maven** 目录下</p>
<h4> 4、执行Maven命令</h4>
<h5> ①测试命令</h5>
<p><strong>mvn test</strong><br>
说明：测试操作中会提前自动执行编译操作，测试成功就说明编译也是成功的</p>
<h5> ②打包命令</h5>
<p><strong>mvn package</strong><br>
通过查看 war 包内的结构，我们看到被 Web 工程依赖的 Java 工程确实是会变成 Web 工程的 WEB-INF/lib 目录下的 jar 包。</p>
<h5> ③查看当前 Web 工程所依赖的 jar 包的列表</h5>
<p><strong>mvn dependency:list</strong></p>
<p>说明：javax.servlet:javax.servlet-api:jar:3.1.0:provided 格式显示的是一个 jar 包的坐标信息。<br>
格式是：<strong>groupId:artifactId:打包方式:version:依赖的范围</strong></p>
<p>这样的格式虽然和我们 XML 配置文件中坐标的格式不同，但是本质上还是坐标信息，大家需要能够认识这样的格式，将来从 Maven 命令的日志或错误信息中看到这样格式的信息，就<strong>能够识别出来这是坐标</strong>。进而<strong>根据坐标到Maven 仓库找到对应的jar包</strong>，用这样的方式解决我们遇到的报错的情况。</p>
<h5> ④以树形结构查看当前 Web 工程的依赖信息</h5>
<p><strong>mvn dependency:tree</strong></p>
<p>我们在 pom.xml 中并没有依赖 hamcrest-core，但是它却被加入了我们依赖的列表。原因是：junit 依赖了hamcrest-core，然后基于依赖的传递性，hamcrest-core 被传递到我们的工程了。</p>
<h3> 6、测试依赖的范围</h3>
<h4> 1、依赖范围</h4>
<p>标签的位置：<strong>dependencies/dependency/scope</strong><br>
标签的可选值：<strong>compile</strong>、<strong>test</strong>、<strong>provided</strong>、system、runtime、<strong>import</strong></p>
<h4> ①compile 和 test 对比</h4>
<table>
<thead>
<tr>
<th></th>
<th>main目录（空间）</th>
<th>test目录（空间）</th>
<th>开发过程（时间）</th>
<th>部署到服务器（时间）</th>
</tr>
</thead>
<tbody>
<tr>
<td>compile</td>
<td>有效</td>
<td>有效</td>
<td>有效</td>
<td>有效</td>
</tr>
<tr>
<td>test</td>
<td>无效</td>
<td>有效</td>
<td>有效</td>
<td>无效</td>
</tr>
</tbody>
</table>
<h4> ②compile 和 provided 对比</h4>
<table>
<thead>
<tr>
<th></th>
<th>main目录（空间）</th>
<th>test目录（空间）</th>
<th>开发过程（时间）</th>
<th>部署到服务器（时间）</th>
</tr>
</thead>
<tbody>
<tr>
<td>compile</td>
<td>有效</td>
<td>有效</td>
<td>有效</td>
<td>有效</td>
</tr>
<tr>
<td>provided</td>
<td>有效</td>
<td>有效</td>
<td>有效</td>
<td>无效</td>
</tr>
</tbody>
</table>
<h4> ③结论</h4>
<p><strong>compile</strong>：通常使用的第三方框架的 jar 包这样在项目实际运行时真正要用到的 jar 包都是以 compile 范围进行依赖的。比如 SSM 框架所需jar包。<br>
<strong>test</strong>：测试过程中使用的 jar 包，以 test 范围依赖进来。比如 junit。<br>
<strong>provided</strong>：在开发过程中需要用到的“服务器上的 jar 包”通常以 provided 范围依赖进来。比如 servlet-api、jsp-api。而这个范围的 jar 包之所以不参与部署、不放进 war 包，就是避免和服务器上已有的同类 jar 包产生冲突，同时减轻服务器的负担。说白了就是：“<strong>服务器上已经有了，你就别带啦！</strong>”</p>
<h3> 7、测试依赖的传递性</h3>
<h4> 1、依赖的传递性</h4>
<h5> ①概念</h5>
<p>A 依赖 B，B 依赖 C，那么在 A 没有配置对 C 的依赖的情况下，A 里面能不能直接使用 C？</p>
<h5> ②传递的原则</h5>
<p>在 A 依赖 B，B 依赖 C 的前提下，C 是否能够传递到 A，取决于 B 依赖 C 时使用的依赖范围。</p>
<ul>
<li><strong>B 依赖 C 时使用 compile 范围：可以传递</strong></li>
<li><strong>B 依赖 C 时使用 test 或 provided 范围：不能传递，所以需要这样的 jar 包时，就必须在需要的地方明确配置依赖才可以。</strong></li>
</ul>
<h4> 2、使用 compile 范围依赖 spring-core</h4>
<p>测试方式：让 pro01-maven-java 工程依赖 spring-core<br>
具体操作：编辑 pro01-maven-java 工程根目录下 pom.xml</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 mvn dependency:tree 命令查看效果：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221224141350567.png" alt="image-20221224141350567" loading="lazy"></p>
<p>还可以在 Web 工程中，使用 mvn dependency:tree 命令查看效果（需要重新将 pro01-maven-java 安装到仓库）：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221224141403153.png" alt="image-20221224141403153" loading="lazy"></p>
<h4> 3、验证 test 和 provided 范围不能传递</h4>
<p>从上面的例子已经能够看到，pro01-maven-java 依赖了 junit，但是在 pro02-maven-web 工程中查看依赖树的时候并没有看到 junit。<br>
要验证 provided 范围不能传递，可以在 pro01-maven-java 工程中加入 servlet-api 的依赖。</p>
<h3> 8、测试依赖的排除</h3>
<h4> 1、概念</h4>
<p>当 A 依赖 B，B 依赖 C 而且 C 可以传递到 A 的时候，A 不想要 C，需要在 A 里面把 C 排除掉。而往往这种情况都是为了避免 jar 包之间的冲突。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221224142134353.png" alt="image-20221224142134353" loading="lazy"></p>
<p>所以配置依赖的排除其实就是阻止某些 jar 包的传递。因为这样的 jar 包传递过来会和其他 jar 包冲突。</p>
<h4> 2、配置方式</h4>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3、测试</h4>
<p>测试的方式：在 pro02-maven-web 工程中配置对 commons-logging 的排除<br>
运行 mvn dependency:tree 命令查看效果，发现在 spring-core 下面就没有 commons-logging 了。<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221224150708267.png" alt="image-20221224150708267" loading="lazy"></p>
<h3> 9、继承</h3>
<h4> 1、概念</h4>
<p>Maven工程之间，A 工程继承 B 工程<br>
B 工程：父工程<br>
A 工程：子工程<br>
本质上是 A 工程的 pom.xml 中的配置继承了 B 工程中 pom.xml 的配置。</p>
<h4> 2、作用</h4>
<p>在父工程中统一管理项目中的依赖信息，具体来说是管理依赖信息的版本。</p>
<p>它的背景是：</p>
<ul>
<li>对一个比较大型的项目进行了模块拆分。</li>
<li>一个 project 下面，创建了很多个 module。</li>
<li><strong>每一个 module 都需要配置自己的依赖信息</strong>。</li>
</ul>
<p>它背后的需求是：</p>
<ul>
<li>在每一个 module 中各自维护各自的依赖信息很容易发生出入，不易统一管理。</li>
<li>使用同一个框架内的不同 jar 包，它们应该是同一个版本，所以<strong>整个项目中使用的框架版本需要统一</strong>。</li>
<li>使用框架时所需要的 jar 包组合（或者说依赖信息组合）需要经过长期摸索和反复调试，最终确定一个可用组合。这个耗费很大精力总结出来的方案不应该在新的项目中重新摸索。</li>
</ul>
<p>通过在父工程中为整个项目维护依赖信息的组合既<strong>保证了整个项目使用规范、准确的 jar 包</strong>；又能够将<strong>以往的经验沉淀</strong>下来，节约时间和精力。</p>
<h4> 3、举例</h4>
<p>在一个工程中依赖多个 Spring 的 jar 包</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221224151906558.png" alt="image-20221224151906558" loading="lazy"></p>
<p>使用 Spring 时要求所有 Spring 自己的 jar 包版本必须一致。为了能够对这些 jar 包的版本进行统一管理，我们使用继承这个机制，将所有版本信息统一在父工程中进行管理。</p>
<h4> 4、操作</h4>
<h5> ①创建父工程</h5>
<p>创建的过程和前面创建 pro01-maven-java 一样。<br>
工程名称：pro03-maven-parent<br>
工程创建好之后，要修改它的打包方式：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>只有打包方式为 pom 的 Maven 工程能够管理其他 Maven 工程。打包方式为 pom 的 Maven 工程中不写业务代码，它是专门管理其他 Maven 工程的工程。</strong></p>
<h5> ②创建模块工程</h5>
<p>模块工程类似于 IDEA 中的 module，所以需要<strong>进入 pro03-maven-parent 工程的根目录</strong>，然后运行 mvn archetype:generate 命令来创建模块工程。</p>
<p>假设，我们创建三个模块工程：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221224155634597.png" alt="image-20221224155634597" loading="lazy"></p>
<h5> ③查看被添加新内容的父工程 pom.xml</h5>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> ④解读子工程的pom.xml</h5>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> ⑤在父工程中配置依赖的统一管理</h5>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> ⑥子工程中引用那些被父工程管理的依赖</h5>
<p>关键点：省略版本号</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> ⑦在父工程中升级依赖信息的版本</h5>
<p><strong>一处修改，处处生效</strong></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在子工程中运行mvn dependency:list:<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221224160911927.png" alt="image-20221224160911927" loading="lazy"></p>
<h5> ⑧在父工程中声明自定义属性</h5>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在需要的地方使用${}的形式来引用自定义的属性名：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>真正实现“一处修改，处处生效”。</strong></p>
<h4> 5、实际意义</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221224160950881.png" alt="image-20221224160950881" loading="lazy"></p>
<p>编写一套符合要求、开发各种功能都能正常工作的依赖组合并不容易。如果公司里已经有人总结了成熟的组合方案，那么再开发新项目时，如果不使用原有的积累，而是重新摸索，会浪费大量的时间。为了提高效率，我们可以使用工程继承的机制，让成熟的依赖组合方案能够保留下来。</p>
<p>如上图所示，公司级的父工程中管理的就是成熟的依赖组合方案，各个新项目、子系统各取所需即可。</p>
<h3> 10、聚合</h3>
<h4> 1、聚合本身的含义</h4>
<p>部分组成整体动画片《战神金刚》中的经典台词：“我来组成头部！我来组成手臂！”就是聚合关系最生动的体现。</p>
<h4> 2、Maven 中的聚合</h4>
<p>使用一个“总工程”将各个“模块工程”汇集起来，作为一个整体对应完整的项目。</p>
<ul>
<li>项目：整体</li>
<li>模块：部分</li>
</ul>
<h4> 3、好处</h4>
<ul>
<li>
<p>一键执行 Maven 命令：很多构建命令都可以在“总工程”中一键执行。</p>
<p>以 mvn install 命令为例：Maven 要求有父工程时先安装父工程；有依赖的工程时，先安装被依赖的工程。我们自己考虑这些规则会很麻烦。但是工程聚合之后，在总工程执行 mvn install 可以一键完成安装，而且会自动按照正确的顺序执行。</p>
</li>
<li>
<p>配置聚合之后，各个模块工程会在总工程中展示一个列表，让项目中的各个模块一目了然。</p>
</li>
</ul>
<h4> 4、聚合的配置</h4>
<p>在总工程中配置 modules 即可：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 5、依赖循环问题</h4>
<p>如果 A 工程依赖 B 工程，B 工程依赖 C 工程，C 工程又反过来依赖 A 工程，那么在执行构建操作时会报下面的错误</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221224165432357.png" alt="image-20221224165432357" loading="lazy"></p>
<p>这个错误的含义是：循环引用。</p>
<h2> 4、使用Maven：IDEA环境</h2>
<h3> 1、创建父工程</h3>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225133658424.png" alt="image-20221225133658424" loading="lazy"></p>
<p>更改坐标位置</p>
<h3> 2、配置自己的Maven</h3>
<p><strong>每次创建 Project 后都需要设置 Maven 家目录位置</strong>，否则 IDEA 将使用内置的 Maven 核心程序（不稳定）并使用默认的本地仓库位置。这样一来，我们在命令行操作过程中已下载好的 jar 包就白下载了，默认的本地仓库通常在 C 盘，还影响系统运行。</p>
<p>配置之后，IDEA 会根据我们在这里指定的 Maven 家目录自动识别到我们在 settings.xml 配置文件中指定的本地仓库。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225133749426.png" alt="image-20221225133805324" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225133848797.png" alt="image-20221225133848797" loading="lazy"></p>
<h3> 3 、建Java模块工程</h3>
<p>选中项目，如上所述新建mavne模块</p>
<h3> 4、创建Web模块工程</h3>
<h4> 1、创建模块</h4>
<p>按照前面的同样操作创建模块，<strong>此时</strong>这个模块其实还是一个<strong>Java模块</strong>。</p>
<h4> 2、修改打包方式</h4>
<p>Web 模块将来打包当然应该是 <strong>war</strong> 包。</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 3、Web 设定</h4>
<p>首先打开项目结构菜单<br>
然后到 Facets 下查看 IDEA 是否已经帮我们自动生成了 Web 设定。没有就刷新一下右侧Maven</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225144820574.png" alt="image-20221225144820574" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225144830175.png" alt="image-20221225144830175" loading="lazy"></p>
<h4> 4、借助IDEA生成web.xml</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225145439907.png" alt="image-20221225145439907" loading="lazy"></p>
<h3> 5、其他操作</h3>
<h4> 1、在IDEA中执行Maven命令</h4>
<h5> ①直接执行</h5>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225140022531.png" alt="image-20221225140022531" loading="lazy"></p>
<h5> ②手动输入</h5>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225140043534.png" alt="image-20221225140043534" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225140057743.png" alt="image-20221225140057743" loading="lazy"></p>
<p>如果有需要，还可以给命令后面附加参数：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225140111847.png" alt="image-20221225140111847" loading="lazy"></p>
<h4> 2、在IDEA中查看某个模块的依赖信息</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225145515526.png" alt="image-20221225145515526" loading="lazy"></p>
<h4> 3、工程导入</h4>
<p>Maven工程除了自己创建的，还有很多情况是别人创建的。而为了参与开发或者是参考学习，我们都需要导入到 IDEA 中。下面我们分几种不同情况来说明：</p>
<h5> ①来自版本控制系统</h5>
<p>目前我们通常使用的都是 Git（本地库） + 码云（远程库）的版本控制系统，结合 IDEA 的相关操作方式请点<a href="http://heavy_code_industry.gitee.io/code_heavy_industry/pro008-Git/lecture/chapter05/verse03.html" target="_blank" rel="noopener noreferrer"><strong>这里</strong> (opens new window)</a>查看<strong>克隆远程库</strong>部分。</p>
<h5> ②来自工程目录</h5>
<p>直接使用 IDEA 打开工程目录即可。下面咱们举个例子：</p>
<h6> [1]工程压缩包</h6>
<p>假设别人发给我们一个 Maven 工程的 zip 压缩包：maven-rest-demo.zip。从码云或GitHub上也可以以 ZIP 压缩格式对项目代码打包下载。</p>
<h6> [2]解压</h6>
<p>如果你的所有 IDEA 工程有一个专门的目录来存放，而不是散落各处，那么首先我们就把 ZIP 包解压到这个指定目录中</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225145758877.png" alt="image-20221225145758877" loading="lazy"></p>
<h6> [3]打开</h6>
<p>只要我们确认在解压目录下可以直接看到 pom.xml，那就能证明这个解压目录就是我们的工程目录。那么接下来让 IDEA 打开这个目录就可以了。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225145843999.png" alt="image-20221225145843999" loading="lazy"></p>
<h6> [4]设置 Maven 核心程序位置</h6>
<p>打开一个新的 Maven 工程，和新创建一个 Maven 工程是一样的，此时 IDEA 的 settings 配置中关于 Maven 仍然是默认值：<br>
所以我们还是需要像新建 Maven 工程那样，指定一下 Maven 核心程序位置：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225145915064.png" alt="image-20221225145915064" loading="lazy"></p>
<h4> 4、模块导入</h4>
<h5> 1、导入 Java 类型模块</h5>
<p>复制我们想要导入的模块目录，粘贴到我们自己工程目录下</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225151023482.png" alt="image-20221225151023482" loading="lazy"></p>
<p>在 IDEA 中执行导入</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225151044681.png" alt="image-20221225151044681" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225151055554.png" alt="image-20221225151055554" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225151309080.png" alt="image-20221225151309080" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225151316718.png" alt="image-20221225151316718" loading="lazy"></p>
<p>修改 pom.xml<br>
刚刚导入的 module 的父工程坐标还是以前的，需要改成我们自己的 project。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225151337073.png" alt="image-20221225151337073" loading="lazy"></p>
<h5> 2、导入 Web 类型模块</h5>
<p>其它操作和上面演示的都一样，只是多一步：删除多余的、不正确的 web.xml 设置。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225151411493.png" alt="image-20221225151411493" loading="lazy"></p>
<h2> 5、其他核心概念</h2>
<h3> 1、生命周期</h3>
<h4> ①作用</h4>
<p>为了让构建过程自动化完成，Maven 设定了三个生命周期，生命周期中的每一个环节对应构建过程中的一个操作。</p>
<h4> ②三个生命周期</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221225152742410.png" alt="image-20221225152742410" loading="lazy"></p>
<h4> ③特点</h4>
<ul>
<li>前面三个生命周期彼此是独立的。</li>
<li>在任何一个生命周期内部，执行任何一个具体环节的操作，都是<strong>从本周期最初的位置开始执行，直到指定的地方</strong>。（本节记住这句话就行了，其他的都不需要记）</li>
</ul>
<p>Maven 之所以这么设计其实就是为了提高构建过程的自动化程度：让使用者只关心最终要干的即可，过程中的各个环节是自动执行的。</p>
<h3> 2、插件和目标</h3>
<h4> ①插件</h4>
<p>Maven 的核心程序仅仅负责宏观调度，不做具体工作。<strong>具体工作都是由 Maven 插件完成的</strong>。例如：编译就是由 maven-compiler-plugin-3.1.jar 插件来执行的。</p>
<h4> ②目标</h4>
<p>一个插件可以对应多个目标，而每一个目标都和生命周期中的某一个环节对应。</p>
<p>Default 生命周期中有 compile 和 test-compile 两个和编译相关的环节，这两个环节对应 compile 和 test-compile 两个目标，而这两个目标都是由 maven-compiler-plugin-3.1.jar 插件来执行的。</p>
<h3> 3、仓库</h3>
<ul>
<li>本地仓库：在当前电脑上，为电脑上所有 Maven 工程服务</li>
<li>远程仓库：需要联网
<ul>
<li>局域网：我们自己搭建的 Maven 私服，例如使用 Nexus 技术。</li>
<li>Internet
<ul>
<li>中央仓库</li>
<li>镜像仓库：内容和中央仓库保持一致，但是能够分担中央仓库的负载，同时让用户能够就近访问提高下载速度，例如：Nexus aliyun</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>建议：不要中央仓库和阿里云镜像混用，否则 jar 包来源不纯，彼此冲突。</p>
<p>专门搜索 Maven 依赖信息的网站：<a href="https://mvnrepository.com/" target="_blank" rel="noopener noreferrer">https://mvnrepository.com/</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>Mybatis 基础</title>
      <link>https://T4mako.github.io/code/java/MyBatis.html</link>
      <guid>https://T4mako.github.io/code/java/MyBatis.html</guid>
      <source url="https://T4mako.github.io/rss.xml">Mybatis 基础</source>
      <description>1、MyBatis简介 MyBatis最初是Apache的一个开源项目iBatis, 2010年6月这个项目由Apache Software Foundation迁移到了Google Code。随着开发团队转投Google Code旗下， iBatis3.x正式更名为MyBatis。代码于2013年11月迁移到Github。iBatis一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。 iBatis提供的持久层框架包括SQL Maps和Data Access Objects（DAO）。</description>
      <category>java</category>
      <content:encoded><![CDATA[<h2> 1、MyBatis简介</h2>
<p>MyBatis最初是Apache的一个开源项目iBatis, 2010年6月这个项目由Apache Software Foundation迁移到了Google Code。随着开发团队转投Google Code旗下， iBatis3.x正式更名为MyBatis。代码于2013年11月迁移到Github。iBatis一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。 iBatis提供的持久层框架包括SQL Maps和Data Access Objects（DAO）。</p>
<!-- more -->
<h3> 1.1MyBatis特性</h3>
<p>1） MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架<br>
2） MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集<br>
3） MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old JavaObjects，普通的Java对象）映射成数据库中的记录<br>
4） MyBatis 是一个 半自动的ORM（Object Relation Mapping）框架</p>
<h3> 1.2、MyBatis下载</h3>
<p>MyBatis下载地址：<a href="https://github.com/mybatis/mybatis-3" target="_blank" rel="noopener noreferrer">https://github.com/mybatis/mybatis-3</a></p>
<h3> 1.3、和其它持久化层技术对比</h3>
<p>JDBC<br>
SQL 夹杂在Java代码中耦合度高，导致<strong>硬编码内伤</strong>（要修改java中的代码）<br>
维护不易且实际开发需求中 SQL 有变化，频繁修改的情况多见<br>
代码冗长，开发效率低</p>
<p>Hibernate 和 JPA<br>
操作简便，开发效率高<br>
程序中的长难复杂 SQL 需要绕过框架<br>
内部自动生产的 SQL，不容易做特殊优化<br>
基于全映射的全自动框架，大量字段的 POJO 进行部分映射时比较困难。<br>
反射操作太多，导致数据库性能下降</p>
<p>MyBatis<br>
轻量级，性能出色<br>
SQL 和 Java 编码分开，功能边界清晰。Java代码专注业务、SQL语句专注数据<br>
开发效率稍逊于HIbernate，但是完全能够接受</p>
<h2> 2、搭建MyBatis</h2>
<h3> 2.1、开发环境</h3>
<p>IDE：idea2022.1.3<br>
构建工具：maven 3.8.6<br>
MySQL版本：MySQL 8<br>
MyBatis版本：MyBatis 3.5.11</p>
<h3> 2.2、创建maven工程</h3>
<h4> ①新建项目，更改settings</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221226160430380.png" alt="image-20221226160430380" loading="lazy"></p>
<h4> ②新建模块</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221226160638023.png" alt="image-20221226160638023" loading="lazy"></p>
<h4> ③修改打包方式</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221226160928407.png" alt="image-20221226160928407" loading="lazy"></p>
<h4> ④引入依赖</h4>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>若代码报红，右上角的m点击下载</p>
<h3> 2.3、创建MyBatis的核心配置文件</h3>
<p>习惯上命名为<strong>mybatis-config.xml</strong>，这个文件名仅仅只是建议，并非强制要求。将来<strong>整合Spring之后，这个配置文件可以省略</strong>，所以大家操作时可以直接复制、粘贴。<br>
核心配置文件主要用于<strong>配置连接数据库的环境以及MyBatis的全局配置信息</strong><br>
核心配置文件存放的位置是<strong>src/main/resources</strong>目录下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.4、创建mapper接口</h3>
<p>MyBatis中的mapper接口相当于以前的dao。但是区别在于，mapper仅仅是接口，我们不需要提供实现类。  Mybatis可以帮你实现</p>
<p>例如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.5、创建MyBatis的映射文件</h3>
<p>相关概念：<strong>ORM</strong>（Object Relationship Mapping）对象关系映射<br>
<strong>对象：Java的实体类对象<br>
关系：关系型数据库<br>
映射：二者之间的对应关系</strong></p>
<table>
<thead>
<tr>
<th>Java概念</th>
<th>数据库概念</th>
</tr>
</thead>
<tbody>
<tr>
<td>类</td>
<td>表</td>
</tr>
<tr>
<td>属性</td>
<td>字段/列</td>
</tr>
<tr>
<td>对象</td>
<td>记录/行</td>
</tr>
</tbody>
</table>
<p>1、映射文件的命名规则：<br>
表所对应的实体类的类名+Mapper.xml<br>
例如：<strong>表t_user，映射的实体类为User，所对应的映射文件为UserMapper.xml</strong><br>
因此<strong>一个映射文件对应一个实体类</strong>，对应一张表的操作<br>
MyBatis<strong>映射文件用于编写SQL</strong>，访问以及操作表中的数据<br>
MyBatis映射文件存放的位置是<strong>src/main/resources/mappers</strong>目录下<br>
2、 MyBatis中可以<strong>面向接口操作数据</strong>，要保证两个一致：<br>
<mark><strong>mapper接口</strong>的全类名和<strong>映射文件</strong>的<strong>命名空间（namespace）保持一致</strong><br>
<strong>mapper接口</strong>中<strong>方法的方法名</strong>和映射文件中编写<strong>SQL的标签的id</strong>属性保持一致</mark></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><mark>在核心配置文件中引入映射</mark></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.6、通过junit测试功能</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>SqlSession</strong>：代表<strong>Java程序和数据库之间的会话</strong>。（HttpSession是Java程序和浏览器之间的会话）<br>
SqlSessionFactory：是“生产”SqlSession的“工厂”。<br>
工厂模式：如果创建某一个对象，使用的过程基本固定，那么我们就可以把创建这个对象的相关代码封装到一个“工厂类”中，以后都使用这个工厂类来“生产”我们需要的对象。</p>
<h3> 2.7、加入log4j日志功能</h3>
<h4> ①加入依赖</h4>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> ②加入log4j的配置文件</h4>
<p>log4j的配置文件名为log4j.xml，存放的位置是src/main/resources目录下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>日志的级别：<br>
<strong>FATAL(致命) &gt; ERROR(错误) &gt; WARN(警告) &gt; INFO(信息) &gt; DEBUG(调试)<br>
从左到右打印的内容越来越详细</strong></p>
<h2> 3、核心配置文件详解</h2>
<p>核心配置文件中的标签必须按照固定的顺序：<br>
properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,reflectorFactory?,plugins?,environments?,databaseIdProvider?,mappers?</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> tips：创建文件模板</h3>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221228145920237.png" alt="image-20221228145920237" loading="lazy"></p>
<p>创建模板名为mybatis-config和mybatis-mapper的模板，下次创建核心配置文件时只需要通过模板创建</p>
<h2> 4、MyBatis的增删改查</h2>
<p>4.1、新增</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>4.2、删除</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>4.3、修改</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>4.4、查询一个实体类对象</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>4.5、查询list集合</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意<br>
1、查询的标签select必须设置属性resultType或resultMap，用于设置实体类和数据库表的映射关系<br>
resultType：自动映射，用于属性名和表中字段名一致的情况<br>
resultMap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况</p>
<h2> 5、MyBatis获取参数值的两种方式</h2>
<p>MyBatis<strong>获取参数值</strong>的两种方式：<code>${}</code>和<code>#{}</code> ，此时可以通过<code>#{}</code>和<code>${}</code>以任意的内容获取参数值<br>
<code>${}</code> 的本质就是<code>字符串拼接</code>，<code>#{}</code>的本质就是<code>占位符赋值</code><br>
<code>${}</code>使用字符串拼接的方式拼接sql，若为字符串类型或日期类型的字段进行赋值时，<strong>需要手动加单引号</strong><br>
但是<code>#{}</code>使用占位符赋值的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时，**可以自动添加单引号  **</p>
<h3> 5.1、单个字面量类型的参数</h3>
<p>若mapper接口中的方法参数为单个的字面量类型<br>
此时可以使用<code>${}</code>和<code>#{}</code>以任意的名称获取参数的值，注意<code>${}</code>需要手动加单引号</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5.2、多个字面量类型的参数</h3>
<p>若mapper接口中的方法<strong>参数为多个</strong>时，此时MyBatis会自动将这些参数存<strong>放在一个map集合中</strong>，有两种方式存储：<br>
<strong>以arg0,arg1...为键，以参数为值；<br>
以param1,param2...为键，以参数为值；</strong><br>
因此只需要通过<code>${}</code>和<code>#{}</code>访问map集合的键就可以获取相对应的值，注意<code>${}</code>需要手动加单引号</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5.3、map集合类型的参数</h3>
<p>若mapper接口中的方法需要的参数为多个时，此时可以<strong>手动创建map集合</strong>，将这些数据放在map中<br>
只需要通过<code>${}</code>和<code>#{}</code>访问map集合的键就可以获取相对应的值，注意<code>${}</code>需要手动加单引号</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5.4、实体类类型的参数</h3>
<p>若mapper接口中的方法参数为<strong>实体类对象</strong>时<br>
此时可以使用<code>${}</code>和<code>#{}</code>，通过访问实体类对象中的<strong>属性名获取属性值</strong>，注意${}需要手动加单引号</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5.5、使用@Param标识参数</h3>
<p>可以通过@Param注解标识mapper接口中的方法参数。此时，会将这些参数放在map集合中，有两种情况<br>
以**@Param注解的value属性名为键**，以参数为值；<br>
以param1,param2...为键，以参数为值；<br>
只需要通过<code>${}</code>和<code>#{}</code>访问map集合的键就可以获取相对应的值，<br>
注意<code>${}</code>需要手动加单引`号</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 6、MyBatis的各种查询功能</h2>
<h3> 6.1、查询一个实体类对象</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6.2、查询一个list集合</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当查询的数据为多条时，不能使用实体类作为返回值，否则会抛出异常TooManyResultsException；<br>
但是若查询的数据只有一条，可以使用实体类或集合作为返回值；</p>
<h3> 6.3、查询单个数据</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6.4、查询一条数据为map集合</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6.5、查询多条数据为map集合</h3>
<p>若查询的数据有多条时，并且要将每条数据转换为map集合<br>
此时有两种解决方案：</p>
<h4> ①方式一</h4>
<p>将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，此时可以将<strong>这些map放在一个list集合中</strong>获取</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> ②方式二</h4>
<p>将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，并且最终要以一个map的方式返回数据，此时需要通过**@MapKey注解设置map集合的键**，值是每条数据所对应的map集合</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 7、特殊SQL的执行</h2>
<h3> 7.1、模糊查询</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7.2、批量删除</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7.3、动态设置表名</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7.4、添加功能获取自增的主键</h3>
<p>场景模拟：<br>
t_clazz(clazz_id,clazz_name)<br>
t_student(student_id,student_name,clazz_id)<br>
1、添加班级信息<br>
2、获取新添加的班级的id<br>
3、为班级分配学生，即将某学的班级id修改为新添加的班级的id</p>
<p><strong>useGeneratedKeys:表示当前添加功能使用自增的主键<br>
keyProperty:将添加的数据的自增主键为实体类类型的参数属性赋值</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 8、自定义映射resultMap</h2>
<p>对于<strong>数据库中的字段名与java中实体类属性名不一致</strong>的情况的解决方法：<br>
①在mapper中的sql语句起别名</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>②在mybatis的核心配置文件mybatis-config.xml中设置下划线命名到驼峰命名的自动转换</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>③使用resultMap处理字段名和属性名不一致的情况</p>
<h3> 8.1、resultMap处理字段和属性的映射关系</h3>
<p><strong>若字段名和实体类中的属性名不一致，则可以通过resultMap设置自定义映射</strong></p>
<p>相关标签：</p>
<p>主标签：<br>
<strong>resultMap</strong>:设置自定义的映射关系<br>
<strong>id</strong>：唯一标识<br>
<strong>type</strong>：处理映射关系到的实体类的类型<br>
内部常用标签：<br>
<strong>id</strong>：处理主键和实体类中实现的元素关系<br>
<strong>result</strong>：处理普通字段和实体类中属性的映射关系<br>
<strong>column</strong>:设置映射关系中的字段名，必须是sql查询出的某个字段<br>
<strong>property</strong>:设置映射关系中的属性的属性名，必须是处理的实体类类型中的属性名</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8.2、多对一映射处理</h3>
<h4> 8.2.1、级联方式处理映射关系</h4>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 8.2.2、使用association处理映射关系</h4>
<p>association:处理多对一的映射关系（处理实体类类型的属性）<br>
<strong>property：设置需要处理映射关系的属性的属性名<br>
javaType：设置要处理的属性的类型</strong></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 8.2.3、分步查询</h4>
<p>property：设置需要处理映射关系的属性的属性名<br>
select：设置下一步分步查询的唯一标识<br>
colum：将查询出的某个字段作为下一步分步查询的sql条件</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>分步查询的优点：可以实现**延迟加载 **<br>
但是必须在核心配置文件中设置全局配置信息：<br>
lazyLoadingEnabled：全局延迟加载。当开启时，<strong>所有关联对象都会延迟加载</strong><br>
aggressiveLazyLoading：当开启时，任何方法的调用都会加载该对象的所有属性。否则，<strong>每个属性会按需加载此时就可以实现按需加载，获取的数据是什么</strong><mark>(false)</mark>，就只会执行相应的sql。此时可通过association和collection中的fetchType属性设置当前的分步查询是否使用延迟加载， **fetchType="lazy(延迟加载)|eager(立即加载)"  **</p>
<p><strong>mytais-config:</strong></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>mapper接口：</p>
<p><strong>fetchType：在开启了延迟加载的环境中，通过该属性设置当前的分步查询是否使用延迟加载<br>
属性值：eager（立即加载）、lazy（延迟加载）</strong></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8.3、一对多映射处理</h3>
<p>处理一对多的映射关系：<br>
1、collection<br>
2、分步查询</p>
<h4> 8.3.1、collection</h4>
<p>collection:处理一对多的映射关系（处理集合类型的属性）<br>
ofType:设置集合类型的属性中存储读数据的类型</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 8.3.2、分步查询</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 9、动态SQL</h2>
<p>Mybatis框架的动态SQL技术是一种根据特定条件动态拼装SQL语句的功能，它存在的意义是为了解决 拼接SQL语句字符串时的痛点问题。</p>
<h3> 9.1、if  、where、trim</h3>
<p>动态SQL：<br>
1、if：通过test属性中的表达式判断标签中的内容是否有效（是否会拼接到sql中）<br>
2、where：若where标签中有条件成立，会自动生成where关键字。会自动将内容中<strong>前面多余的and去掉，但后面的and无法去掉</strong>。若where标签中没有条件成立，那就不生成where关键字<br>
3、trim：<br>
属性： prefix、suffix：在标签中内容前面或后面添加指定内容<br>
prefixOverrides、suffixOverrides：在标签中内容前面或后面去掉指定内容</p>
<p>方法一：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>方法二：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>方法三：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 9.2、choose、when、otherwise</h3>
<p>choose、when、 otherwise相当于if...else if..else<br>
when至少设置一个，otherwise至多设置一个<br>
只要有一个条件成立，下面的条件就都不判断了</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 9.3、foreach</h3>
<p>foreach：<br>
collection：设置要循环的数组或集合（一般通过java代码中的@Param()注解获取）<br>
item：用一个字符串表示数组或集合中的每一个数据<br>
separator：设置每次循环的数据之间的分隔符<br>
open：循环的所有内容以什么开始<br>
close：循环的所有内容以什么结束</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 9.4、SQL片段</h3>
<p>sql片段：可以记录一段sql，在需要用的地方<strong>使用include标签进行引用</strong></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 10、MyBatis缓存</h2>
<h3> 10.1、MyBatis的一级缓存</h3>
<p><strong>一级缓存是默认开启的</strong></p>
<p>MyBatis的一级缓存是SqlSession级别的，即通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问</p>
<p>使一级缓存失效的四种情况：<br>
1、不同的SqlSession对应不同的一级缓存<br>
2、同一个SqlSession但是查询条件不同<br>
3、同一个SqlSession两次查询期间执行了任何一次增删改操作<br>
4、同一个SqlSession两次查询期间手动清空了缓存</p>
<h3> 10.2、MyBatis的二级缓存</h3>
<p>二级缓存是<strong>SqlSessionFactory级别</strong>，通过<strong>同一个SqlSessionFactory创建的SqlSession查询的结果会被缓存</strong>；此后若再次执行相同的查询语句，结果就会从缓存中获取</p>
<p>二级缓存开启的条件：<br>
1、在核心配置文件中，设置全局配置属性cacheEnabled="true"，默认为true，不需要设置<br>
2、在<strong>映射文件中设置标签&lt;cache/&gt;</strong><br>
3、二级缓存必须在<strong>SqlSession关闭或提交之后有效</strong><br>
4、查询的数据所转换的实体类类型<strong>必须实现序列化的接口</strong><br>
使二级缓存失效的情况：<br>
两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效</p>
<h3> 10.3、二级缓存的相关配置</h3>
<p>在mapper配置文件中添加的cache标签可以设置一些属性：</p>
<p>①eviction属性：<br>
<strong>缓存回收策略，默认的是 LRU。</strong><br>
LRU（Least Recently Used） – 最近最少使用的：移除最长时间不被使用的对象。<br>
FIFO（First in First out） – 先进先出：按对象进入缓存的顺序来移除它们。<br>
SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。<br>
WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。</p>
<p>②flushInterval属性：<br>
刷新间隔，单位毫秒默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新</p>
<p>③size属性：<br>
引用数目，正整数代表缓存最多可以存储多少个对象，太大容易导致内存溢出</p>
<p>④readOnly属性：只读， true/false<br>
true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。<br>
false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是false。</p>
<h3> 10.4、MyBatis缓存查询的顺序</h3>
<p>先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用。<br>
如果二级缓存没有命中，再查询一级缓存<br>
如果一级缓存也没有命中，则查询数据库<br>
SqlSession关闭之后，一级缓存中的数据会写入二级缓存</p>
<h3> 10.5、整合第三方缓存EHCache</h3>
<p><strong>第三方缓存针对二级缓存</strong></p>
<h4> 10.5.1、添加依赖</h4>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 10.5.2、各jar包功能</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230103154950209.png" alt="image-20230103154950209" loading="lazy"></p>
<h4> 10.5.3、创建EHCache的配置文件ehcache.xml</h4>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 10.5.4、设置二级缓存的类型</h4>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 10.5.5、加入logback日志</h4>
<p>存在SLF4J时，作为简易日志的log4j将失效，此时我们<strong>需要借助SLF4J的具体实现logback来打印日志</strong>。 创建logback的配置文件**logback.xml  **</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 10.5.6、EHCache配置文件说明</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230103155446316.png" alt="image-20230103155446316" loading="lazy"></p>
<h2> 11、MyBatis的逆向工程</h2>
<p>正向工程：先创建Java实体类，由框架负责根据实体类生成数据库表。 Hibernate是支持正向工程的。</p>
<p>逆向工程：<strong>先创建数据库表</strong>，由框架负责根据数据库表，<strong>反向生成</strong>如下资源：<br>
**Java实体类、Mapper接口、Mapper映射文件 **</p>
<h3> 11.1、创建逆向工程的步骤</h3>
<h4> ①添加依赖和插件</h4>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> ②创建MyBatis的核心配置文件</h4>
<h4> ③创建逆向工程的配置文件</h4>
<p>**文件名必须是：generatorConfig.xml  **</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> ④执行MBG插件的generate目标</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230103165027389.png" alt="image-20230103165027388" loading="lazy"></p>
<h3> 11.2、QBC查询</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 12、分页插件</h2>
<p>分页思想：<br>
limit index,pageSize<br>
pageSize：每页显示的条数  、pageNum：当前页的页码<br>
index：当前页的起始索引，index=(pageNum-1)*pageSize<br>
count：总记录数  、 totalPage：总页数<br>
totalPage = count / pageSize;<br>
<code>if(count % pageSize != 0){totalPage += 1;}</code></p>
<p>pageSize=4，pageNum=1，index=0 limit 0,4<br>
pageSize=4，pageNum=3，index=8 limit 8,4<br>
pageSize=4，pageNum=6，index=20 limit 8,4</p>
<p>效果：首页 上一页 2 3 4 5 6 下一页 末页</p>
<h3> 12.1、分页插件的使用步骤</h3>
<h4> ①添加依赖</h4>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> ②配置分页插件</h4>
<p>在MyBatis的核心配置文件中配置插件</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 12.2、分页插件的使用</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>1、查询功能之前使用**PageHelper.startPage(int pageNum, int pageSize)开启分页功能 **<br>
pageNum：当前页的页码<br>
pageSize：每页显示的条数</p>
<p>2、在查询获取list集合之后，使用<code>PageInfo&lt;T&gt; pageInfo = new PageInfo&lt;&gt;(List&lt;T&gt; list, intnavigatePages)</code>获取分页相关数据<br>
list：分页之后的数据<br>
navigatePages：导航分页的页码数</p>
<p>3、分页相关数据<br>
pageNum：当前页的页码<br>
pageSize：每页显示的条数<br>
size：当前页显示的真实条数<br>
total：总记录数<br>
pages：总页数<br>
prePage：上一页的页码<br>
nextPage：下一页的页码<br>
isFirstPage/isLastPage：是否为第一页/最后一页<br>
hasPreviousPage/hasNextPage：是否存在上一页/下一页<br>
navigatePages：导航分页的页码数<br>
navigatepageNums：导航分页的页码，[1,2,3,4,5]</p>
]]></content:encoded>
      <enclosure url="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221226160430380.png" type="image/png"/>
    </item>
    <item>
      <title>MybatisPlus 基础</title>
      <link>https://T4mako.github.io/code/java/MybatisPlus.html</link>
      <guid>https://T4mako.github.io/code/java/MybatisPlus.html</guid>
      <source url="https://T4mako.github.io/rss.xml">MybatisPlus 基础</source>
      <description>1、MybatisPlus简介 MyBatis-Plus（简称 MP）是一个 MyBatis的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</description>
      <category>java</category>
      <content:encoded><![CDATA[<h2> 1、MybatisPlus简介</h2>
<p>MyBatis-Plus（简称 MP）是一个 MyBatis的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p>
<!-- more -->
<p>特性：<br>
无侵入、损耗小<br>
强大的 CRUD 操作：<strong>内置通用 Mapper、通用 Service</strong>，仅仅通过少量配置即可实现单表大部分CRUD 操作，更有强大的条件构造器，满足各类使用需求<br>
<strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错<br>
<strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题<br>
支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作<br>
支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ）<br>
内置代码生成器：采用代码或者 Maven 插件可<strong>快速生成 Mapper 、 Model 、 Service 、Controller 层代码</strong>，支持模板引擎，更有超多自定义配置等您来使用<br>
<strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询<br>
分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库<br>
内置性能分析插件：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询<br>
内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</p>
<p>支持数据库：<br>
MySQL，Oracle，DB2，H2，HSQL，SQLite，PostgreSQL，SQLServer，Phoenix，Gauss ，<br>
ClickHouse，Sybase，OceanBase，Firebird，Cubrid，Goldilocks，csiidb<br>
达梦数据库，虚谷数据库，人大金仓数据库，南大通用(华库)数据库，南大通用数据库，神通数据<br>
库，瀚高数据库</p>
<p>框架结构：<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230227202859252.png" alt="image-20230227202859252" loading="lazy"></p>
<p>代码文档地址：<br>
<em><strong>官方地址: <a href="http://mp.baomidou.com" target="_blank" rel="noopener noreferrer">http://mp.baomidou.com</a></strong></em><br>
代码发布地址:<br>
Github: <a href="https://github.com/baomidou/mybatis-plus" target="_blank" rel="noopener noreferrer">https://github.com/baomidou/mybatis-plus</a><br>
Gitee: <a href="https://gitee.com/baomidou/mybatis-plus" target="_blank" rel="noopener noreferrer">https://gitee.com/baomidou/mybatis-plus</a><br>
文档发布地址: <a href="https://baomidou.com/pages/24112f" target="_blank" rel="noopener noreferrer">https://baomidou.com/pages/24112f</a></p>
<h2> 2、入门案例</h2>
<h3> 1、创建、配置springboot工程</h3>
<p>加入依赖：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置数据源：</p>
<div class="language-YAML line-numbers-mode" data-ext="YAML"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2、创建实体类</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><em><strong>@Data</strong></em>注解：导入lombok依赖，在实体类上添加@Data注解，直接生成对应的get，set，有参，无参，equals，hashcode方法</p>
<h3> 3、创建mapper</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>BaseMapper是MyBatis-Plus提供的模板mapper，其中**包含了基本的CRUD方法，泛型为操作的实体类型 **</p>
<h3> 4、测试</h3>
<p>创建测试类<br>
<strong>Wrapper</strong>：条件构造器，当查询时有条件可以创建Wrapper对象，如果没有就设置null为参数</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>添加日志：<br>
在application.yml中配置日志输出</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3、基本CRUD</h2>
<h3> 1、BaseDAO</h3>
<p>mapper接口继承了BaseDAO，查看BaseDAO的源码（下载源码）<br>
MyBatis-Plus中的基本CRUD在内置的BaseMapper中都已得到了实现，我们可以直接使用</p>
<h3> 2、插入</h3>
<p>mapper.insert(对象)</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3、删除</h3>
<p>mapper.deleteById(id)	根据id删除<br>
mapper.deleteByMap(map)	根据map中对应的条件删除<br>
mapper.deleteBatchIds(list)	根据list中所有的id删除</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4、更新</h3>
<p>mapper.updateById(对象)	根据对象的id更新数据，null值不做修改</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5、查找</h3>
<p>mapper.selectById(id)	根据id查询用户信息<br>
mapper.selectBatchIds(list)	根据list中的值查询用户信息<br>
mapper.selectByMap(map)	根据map中的条件查询用户信息<br>
mapper.selectList(null)	根据wrapper查询用户信息，如果为null表示所有的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>自定义功能：<br>
在mapper接口中新建抽象方法，在resources文件夹下新建mapper文件夹，创建映射文件XXXMapper.xml，编写sql语句</p>
<h3> 6、通用Service</h3>
<p>MyBatis-Plus中有一个接口<strong>IService</strong>和其实现类<strong>ServiceImpl</strong>，封装了常见的业务层逻辑。详情查看源码IService和ServiceImpl</p>
<p>通用 Service CRUD 封装<strong>IService</strong>接口，进一步封装 CRUD 采用 <strong>get 查询单行</strong> <strong>remove 删<br>
除</strong> <strong>list 查询集合</strong> <strong>page 分页</strong> 前缀命名方式<strong>区分 Mapper 层避免混淆</strong>（方法名与mapper调用的方法名不同）<br>
泛型 T 为任意实体对象<br>
建议如果存在自定义通用 Service 方法的可能，请创建自己的 IBaseService 继承Mybatis-Plus 提供的基类</p>
<p>举例：<br>
创建<strong>UserService接口继承IService</strong>接口，IServie泛型填写对应<strong>实体类</strong><br>
编写UserService接口的实现类<strong>UserServiceImpl继承ServiceImpl实现UserService接口</strong><br>
ServiceImpl泛型编写<strong>mapper和对应的实体类</strong><br>
由于ServiceImpl实现了IService接口，因此UserServiceImpl不需要实现IService的方法<br>
在UserServiceImol上添加**@Service注解**</p>
<p>代码示例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 4、常用注解</h2>
<h3> 1、@TableName</h3>
<p>由此得出结论，MyBatis-Plus在<strong>确定操作的表</strong>时，由<strong>BaseMapper的泛型决定</strong>，即实体类型决定，且**默认操作的表名和实体类型的类名一致 **</p>
<p>如果实体类类名与表名不一致，可以在<strong>实体类</strong>上标注**@TableName("")**注解，标识实体类对应的表</p>
<p>如果所有表名都含有相同的前缀，可以使用MyBatis-Plus提供的全局配置，为实体类所对应的表名设置默认的前缀</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2、@TableId</h3>
<p>MyBatis-Plus在实现CRUD时，会<strong>默认将id作为主键列</strong>，并在插入数据时，默认基于雪花算法的策略生成id</p>
<p>如果表的主键字段名不为id，crud会出现错误</p>
<p>因此可以在<strong>实体类中uid属性上</strong>通过**@TableId将其标识为主键**，即可成功执行SQL语句</p>
<h4> @TableId的value属性</h4>
<p>若实体类中<strong>主键</strong>对应的属性为<strong>id</strong>，而<strong>表中</strong>表示主键的字段为<strong>uid</strong>，此时若只在<strong>属性id上添加注解@TableId</strong>，则抛出异常Unknown column 'id' in 'field list'，即MyBatis-Plus仍然会将id作为表的主键操作，而表中<strong>表示主键的是字段uid</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> @TableId的type属性</h4>
<p>type属性用来定义主键策略</p>
<p>常用的主键策略：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>IdType.ASSIGN_ID（默 认）</td>
<td>基于雪花算法的策略生成数据id，与数据库id是否设置自增无关</td>
</tr>
<tr>
<td>IdType.AUTO</td>
<td>使用数据库的自增策略，注意，该类型请确保数据库设置了id自增， 否则无效</td>
</tr>
</tbody>
</table>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置全局主键策略：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>雪花算法：</strong></p>
<p>背景：需要选择合适的方案去应对数据规模的增长，以应对逐渐增长的访问压力和数据量。数据库的扩展方式主要包括：<strong>业务分库、主从复制，数据库分表</strong>。</p>
<p>数据库分表：<br>
将不同业务数据分散存储到不同的数据库服务器，能够支撑百万甚至千万用户规模的业务，但如果业务继续发展，同一业务的单表数据也会达到单台数据库服务器的处理瓶颈。例如，淘宝的几亿用户数据，如果全部存放在一台数据库服务器的一张表中，肯定是无法满足性能要求的，此时就需要对单表数据进行拆分。</p>
<p>单表数据拆分有两种方式：垂直分表和水平分表。</p>
<p><strong>垂直分表</strong>：垂直分表适合将表中某些不常用且占了大量空间的列拆分出去。</p>
<p><strong>水平分表</strong>：水平分表适合表行数特别大的表，有的公司要求单表行数超过 5000 万就必须进行分表，这个数字可以作为参考，但并不是绝对标准，关键还是要看表的访问性能。对于一些比较复杂的表，可能超过 1000万就要分表了；而对于一些简单的表，即使存储数据超过 1 亿行，也可以不分表。但不管怎样，当看到表的数据量达到千万级别时，作为架构师就要警觉起来，因为这很可能是架构的性能瓶颈或者隐患。<br>
水平分表相比垂直分表，会引入更多的复杂性，例如要求全局唯一的数据id该如何处理  ：</p>
<p>①主键自增<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230228201035.png" alt="" loading="lazy"></p>
<p>②取模<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230228201101.png" alt="" loading="lazy"></p>
<p>③雪花算法<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230228201144.png" alt="" loading="lazy"></p>
<p>雪花算法是由Twitter公布的分布式主键生成算法，它能够保证不同表的主键的不重复性，以及相同表的主键的有序性。</p>
<p>1、核心思想：<br>
长度共64bit（一个long型）。<br>
首先是一个符号位，1bit标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0。41bit时间截(毫秒级)，存储的是时间截的差值（当前时间截 - 开始时间截)，结果约等于69.73年。<br>
10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID，可以部署在1024个节点）。<br>
12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID）。</p>
<p>2、优点：整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞，并且效率较高。</p>
<h3> 3、@TableField</h3>
<p>**MyBatis-Plus会自动将下划线命名风格转化为驼峰命名风格  **，所以无需手动开启驼峰转换</p>
<p>若实体类中的属性和表中的字段不同且也不是下划线、驼峰风格，此时需要在实体类属性上使用**@TableField("")**设置属性所对应的字段名</p>
<p>例如实体类属性name，表中字段username :</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4、@TableLogic</h3>
<p>物理删除：真实删除，将对应数据从数据库中删除，之后查询不到此条被删除的数据<br>
逻辑删除：假删除，将对应数据中代表是否被删除字段的状态修改为“被删除状态”，之后在数据库中仍旧能看到此条数据记录<br>
使用场景：可以进行数据恢复</p>
<h4> 实现逻辑删除:</h4>
<p>①数据库中创建逻辑删除状态列，设置默认值为0<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230228203636.png" alt="" loading="lazy"></p>
<p>②实体类中添加逻辑删除属性<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230228203654.png" alt="" loading="lazy"></p>
<p>③测试<br>
测试删除功能，真正执行的是修改<br>
UPDATE t_user SET is_deleted=1 WHERE id=? AND is_deleted=0<br>
测试查询功能，被逻辑删除的数据默认不会被查询<br>
SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0</p>
<h2> 5、条件构造器和常用接口</h2>
<h3> 1、Wrapper介绍</h3>
<p><strong>wrapper可以链式添加规则</strong></p>
<p>Wrapper ： 条件构造抽象类，最顶端父类<br>
AbstractWrapper ： 用于查询条件封装，生成 sql 的 where 条件<br>
<em><strong>QueryWrapper ： 查询条件封装</strong></em><br>
<strong>UpdateWrapper ： Update 条件封装</strong><br>
AbstractLambdaWrapper ： 使用Lambda 语法<br>
LambdaQueryWrapper ：用于Lambda语法使用的查询Wrapper<br>
LambdaUpdateWrapper ： Lambda 更新封装Wrapper</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230301143137.png" alt="" loading="lazy"></p>
<p>创建新的Wrapper对象，泛型为对应的实体类，给Wrapper添加条件，通过自动注入的mapper对象调用方法，执行wrapper条件</p>
<h3> 2、QueryWrapper</h3>
<p><strong>创建测试类，注入userMapper</strong></p>
<h4> ①组装查询条件：</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> ②组装排序条件</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> ③组装删除条件</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> ④条件的优先级</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> ⑤组装select字句</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> ⑥实现子查询</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3、UpdateWrapper</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4、组装条件</h3>
<p>在真正开发的过程中，<strong>组装条件是常见的功能</strong>，而这些条件数据来<strong>源于用户输入</strong>，是可选的，因此我们在组装这些条件时，必须先判断用户是否选择了这些条件，若选择<strong>则需要组装该条件</strong>，若没有选择则一定不能组装，以免影响SQL执行的结果</p>
<p>思路一：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>思路二：</p>
<p>上面的实现方案没有问题，但是代码比较复杂，我们可以使用带condition参数的重载方法构建查询条件，简化代码的编写</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5、LambdaQueryWrapper</h3>
<p><strong>使用实体类的方法引用，避免写错实体类的字段名</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6、LambdaUpdateWrapper</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 6、插件</h2>
<h3> 1、分页插件</h3>
<p>MyBatis Plus自带分页插件，只要简单的配置即可实现分页功能</p>
<h4> 1、添加配置类</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2、测试</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>page对象可以获取当前页码，是否有上一页，下一页，总页数等数据</strong></p>
<h3> 2、xml自定义分页</h3>
<h4> 1、UserMapper中定义接口方法</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2、UserMapper.xml中编写SQL</h4>
<p>可以再yaml文件中配置类型别名，在maper中编写resultType无需从com开始编写：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3、乐观锁</h3>
<h4> 1、乐观锁实现流程 ：</h4>
<p>​	数据库中添加<strong>version字段</strong><br>
​	取出记录时，获取当前version<br>
​	更新时，version + 1，如果where语句中的version版本不对，则更新失败</p>
<h4> 2、Mybatis-Plus实现乐观锁</h4>
<p>①修改实体类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>添加mapper</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>②添加乐观锁插件配置</p>
<p>在mybatisPlus配置文件中添加乐观锁配置</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试修改冲突</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 7、通用枚举</h2>
<p>表中的有些字段值是固定的，例如性别（男或女），此时我们可以使用MyBatis-Plus的通用枚举来实现</p>
<p>数据库表添加字段sex</p>
<p>①创建通用枚举类型：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置扫描通用枚举（可以省略）</p>
<p>②测试</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 8、代码生成器</h2>
<p><strong>比逆向工程更加强大，自动生成controller，entitu，mapper，service</strong></p>
<h3> 1、引入依赖</h3>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2、快速生成</h3>
<p>举例：</p>
<p>将生成的controller，entitu，mapper，service，mapper文件与java类放到指定的目录下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 9、多数据源</h2>
<p>适用于多种场景：纯粹多库、 读写分离、 一主多从、 混合模式等</p>
<p>场景说明：<br>
我们创建两个库，分别为：mybatis_plus（以前的库不动）与mybatis_plus_1（新建），将mybatis_plus库的product表移动到mybatis_plus_1库，这样每个库一张表，通过一个测试用例分别获取用户数据与商品数据，如果获取到说明多库模拟成功</p>
<p>创建新的数据库和新的工程</p>
<h3> 1、引入依赖</h3>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2、配置多数据源</h3>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3、创建用户service</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4、创建商品service</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5、测试</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>1、都能顺利获取对象，则测试成功<br>
2、如果我们实现读写分离，将写操作方法加上主库数据源，读操作方法加上从库数据源，自动切<br>
换，是不是就能实现读写分离？</p>
<h2> 10、MyBatisX插件</h2>
<p>MyBatis-Plus为我们提供了强大的mapper和service模板，能够大大的提高开发效率<br>
但是在真正开发过程中，MyBatis-Plus并不能为我们解决所有问题，例如一些复杂的SQL，多表联查，我们就需要自己去编写代码和SQL语句，我们该如何快速的解决这个问题呢，这个时候可以使用MyBatisX插件<br>
MyBatisX一款基于 IDEA 的快速开发插件，为效率而生。</p>
<p>MyBatisX插件用法：<a href="https://baomidou.com/pages/ba5b24/" target="_blank" rel="noopener noreferrer">https://baomidou.com/pages/ba5b24/</a></p>
]]></content:encoded>
      <enclosure url="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230227202859252.png" type="image/png"/>
    </item>
    <item>
      <title>RabbitMQ 基础</title>
      <link>https://T4mako.github.io/code/java/RabbitMQ.html</link>
      <guid>https://T4mako.github.io/code/java/RabbitMQ.html</guid>
      <source url="https://T4mako.github.io/rss.xml">RabbitMQ 基础</source>
      <description>RabbitMQ 1.初识MQ 1.1、同步和异步通讯 微服务间通讯有同步和异步两种方式： 同步通讯：就像打电话，需要实时响应。 异步通讯：就像发邮件，不需要马上回复。</description>
      <category>java</category>
      <content:encoded><![CDATA[<h2> RabbitMQ</h2>
<h2> 1.初识MQ</h2>
<h3> 1.1、同步和异步通讯</h3>
<p>微服务间通讯有同步和异步两种方式：<br>
<strong>同步通讯</strong>：就像打电话，需要实时响应。<br>
<strong>异步通讯</strong>：就像发邮件，不需要马上回复。</p>
<!-- more -->
<p>两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发送邮件可以同时与多个人收发邮件，但是往往响应会有延迟。</p>
<h4> 1.1.1、同步通讯</h4>
<p>同步调用的优点：<br>
时效性较强，可以立即得到结果</p>
<p>同步调用的问题：<br>
耦合度高<br>
性能和吞吐能力下降<br>
有额外的资源消耗<br>
有级联失败问题</p>
<h4> 1.1.2、异步通讯</h4>
<p>异步调用常见实现就是<strong>时间驱动模式</strong></p>
<p>异步调用则可以避免上述问题</p>
<p>在事件模式中，支付服务是<strong>事件发布者</strong>（publisher），在支付完成后只需要发布一个支付成功的事件（event），事件中带上订单id。<br>
订单服务和物流服务是<strong>事件订阅者</strong>（Consumer），订阅支付成功的事件，监听到事件后完成自己业务即可。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20210422095356088.png" alt="" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230327150410.png" alt="" loading="lazy"></p>
<p>解除事件发布者与订阅者之间的耦合，两者并不是直接通信，而是有一个<strong>中间人（Broker）</strong>。发布者发布事件到Broker，不关心谁来订阅事件。订阅者从Broker订阅事件，不关心谁发来的消息。</p>
<p>好处：</p>
<ul>
<li>
<p>吞吐量提升：无需等待订阅者处理完成，响应更快速</p>
</li>
<li>
<p>故障隔离：服务没有直接调用，不存在级联失败问题</p>
</li>
<li>
<p>调用间没有阻塞，不会造成无效的资源占用</p>
</li>
<li>
<p>耦合度极低，每个服务都可以灵活插拔，可替换</p>
</li>
<li>
<p>流量削峰：不管发布事件的流量波动多大，都由Broker接收，订阅者可以按照自己的速度去处理事件</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>架构复杂了，业务没有明显的流程线，不好管理</li>
<li>需要依赖于Broker的可靠、安全、性能</li>
</ul>
<h3> 1.2、技术对比</h3>
<p><strong>MQ</strong>，中文是<strong>消息队列（MessageQueue）</strong>，字面来看就是<strong>存放消息的队列</strong>。也就是<strong>事件驱动架构中的Broker</strong>。</p>
<p>比较常见的MQ实现：<br>
ActiveMQ、RabbitMQ、RocketMQ、Kafka</p>
<p>几种常见MQ的对比：</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>RabbitMQ</strong></th>
<th><strong>ActiveMQ</strong></th>
<th><strong>RocketMQ</strong></th>
<th><strong>Kafka</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>公司/社区</td>
<td>Rabbit</td>
<td>Apache</td>
<td>阿里</td>
<td>Apache</td>
</tr>
<tr>
<td>开发语言</td>
<td>Erlang</td>
<td>Java</td>
<td>Java</td>
<td>Scala&amp;Java</td>
</tr>
<tr>
<td>协议支持</td>
<td>AMQP，XMPP，SMTP，STOMP</td>
<td>OpenWire,STOMP，REST,XMPP,AMQP</td>
<td>自定义协议</td>
<td>自定义协议</td>
</tr>
<tr>
<td>可用性</td>
<td>高</td>
<td>一般</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>单机吞吐量</td>
<td>一般</td>
<td>差</td>
<td>高</td>
<td>非常高</td>
</tr>
<tr>
<td>消息延迟</td>
<td>微秒级</td>
<td>毫秒级</td>
<td>毫秒级</td>
<td>毫秒以内</td>
</tr>
<tr>
<td>消息可靠性</td>
<td>高</td>
<td>一般</td>
<td>高</td>
<td>一般</td>
</tr>
</tbody>
</table>
<h2> 2、RabbitMQ入门</h2>
<h3> 2.1、安装RabbitMQ</h3>
<h4> 2.1.1、单机部署</h4>
<p>在Centos7虚拟机中使用Docker来安装。</p>
<h5> 1）下载镜像</h5>
<p>方式一：在线拉取</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>方式二：从本地加载</p>
<p>在课前资料已经提供了镜像包，上传到虚拟机（/tmp）后，使用命令加载镜像即可</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h5> 2）安装MQ</h5>
<p>运行MQ容器：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>浏览器输入http://192.168.80.130:15672进行访问图形界面</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230327170357.png" alt="" loading="lazy"></p>
<p>RabbitMQ中的几个概念：<br>
channel：操作MQ的工具<br>
exchenge：路由消息到队列<br>
queue：缓存消息<br>
virtual host：虚拟主机，对queue、exchange等资源的逻辑分组（不同的路径代表不同用户）</p>
<p>MQ的基本结构：<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230327170223.png" alt="" loading="lazy"></p>
<h4> 2.1.2、集群部署</h4>
<h5> 1）集群分类</h5>
<p>在RabbitMQ的官方文档中，讲述了两种集群的配置方式：</p>
<ul>
<li>普通模式：普通模式集群不进行数据同步，每个MQ都有自己的队列、数据信息（其它元数据信息如交换机等会同步）。例如我们有2个MQ：mq1，和mq2，如果你的消息在mq1，而你连接到了mq2，那么mq2会去mq1拉取消息，然后返回给你。如果mq1宕机，消息就会丢失。</li>
<li>镜像模式：与普通模式不同，队列会在各个mq的镜像节点之间同步，因此你连接到任何一个镜像节点，均可获取到消息。而且如果一个节点宕机，并不会导致数据丢失。不过，这种方式增加了数据同步的带宽消耗。</li>
</ul>
<h5> 2）设置网络</h5>
<p>首先，我们需要让3台MQ互相知道对方的存在。</p>
<p>分别在3台机器中，设置 /etc/hosts文件，添加如下内容：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>并在每台机器上测试，是否可以ping通对方</p>
<h3> 2.2、RabbitMQ消息模型</h3>
<p><a href="https://www.rabbitmq.com/getstarted.html" target="_blank" rel="noopener noreferrer">RabbitMQ</a>官方提供了5个不同的Demo示例，对应了不同的用法：</p>
<p>没有交换机：<br>
基本消息队列（BasicQueue）<br>
工作消息队列（WorkQueue）</p>
<p>发布订阅（Publish、Subscribe），又根据交换机类型不同分为三种（有交换机）：<br>
Fanout Exchange：广播<br>
Direct Exchange：路由<br>
Topic Exchange：主题</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230327172104202.png" alt="image-20230327172104202" loading="lazy"></p>
<h3> 2.3、HelloWorld案例</h3>
<p>官方的HelloWorld是基于最基础的消息队列模型来实现的，只包括三个角色：<br>
publisher：消息发布者，将消息发送到queue<br>
queue：消息队列，负责接受并缓存消息<br>
consumer：订阅列表，处理队列中的消息</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230327172429.png" alt="" loading="lazy"></p>
<p>导入Demo工程：<br>
将资料中的mq-demo导入idea，导入后的结构如下：<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230327192106.png" alt="" loading="lazy"></p>
<p>包括三部分：<br>
mq-demo：父工程，管理项目依赖<br>
publisher：消息的发送者<br>
consumer：消息的消费者</p>
<p>官方的HelloWorld是基于最基础的消息队列模型来实现的，只包括三个角色：<br>
publisher：消息发布者，将消息发送到队列queue<br>
queue：消息队列，负责接受并缓存消息<br>
consumer：订阅队列，处理队列中的消息</p>
<h3> 2.4、publisher实现</h3>
<p>代码思路：建立连接、创建Channel、声明队列、发送消息、关闭连接和channel</p>
<p>代码实现：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.5、consumer实现</h3>
<p>代码思路：建立连接、创建Channel、声明队列、订阅消息</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.6、总结</h3>
<p>基本消息队列的消息发送流程：</p>
<ol>
<li>
<p>建立connection</p>
</li>
<li>
<p>创建channel</p>
</li>
<li>
<p>利用channel声明队列</p>
</li>
<li>
<p>利用channel向队列发送消息</p>
</li>
</ol>
<p>基本消息队列的消息接收流程：</p>
<ol>
<li>
<p>建立connection</p>
</li>
<li>
<p>创建channel</p>
</li>
<li>
<p>利用channel声明队列</p>
</li>
<li>
<p>定义consumer的消费行为handleDelivery()</p>
</li>
<li>
<p>利用channel将消费者与队列绑定</p>
</li>
</ol>
<h2> 3、SpringAMQP</h2>
<p>AMQP（Advanced Message Queuing Protocol）高级消息队列协议，是用于在应用程序之间传递业务消息的开放标准。该协议与语言和平台无关，更符合微服务中独立性的要求。</p>
<p><a href="https://spring.io/projects/spring-amqp" target="_blank" rel="noopener noreferrer">SpringAMQP</a>是基于RabbitMQ封装的一套模板，并且还利用SpringBoot对其实现了自动装配，使用起来非常方便。</p>
<p>SpringAMQP提供了三个功能：</p>
<ul>
<li>自动声明队列、交换机及其绑定关系</li>
<li>基于注解的监听器模式，异步接收消息</li>
<li>封装了RabbitTemplate工具，用于发送消息</li>
</ul>
<h3> 3.1、Basic Queue</h3>
<p>利用SpringAMQP实现HelloWorld中的基本消息队列功能</p>
<p>流程如下：<br>
1、在父工程中引入spring-amqp的依赖<br>
2、在publisher服务中利用RabbitTemplate发送消息到simple.queue这个队列<br>
3、在consumer服务中编写消费逻辑，绑定simple.queue这个队列</p>
<h4> 3.1.1、引入依赖</h4>
<p>在父工程mq-demo中引入依赖：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3.1.2、消息发送</h4>
<p>首先配置MQ地址，在<strong>publisher</strong>服务的<strong>application.yml</strong>中添加配置：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在publisher服务中编写测试类SpringAmqpTest，并利用RabbitTemplate实现消息发送：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3.1.2、消息接收</h4>
<p>首先配置MQ地址，在consumer服务的application.yml中添加配置：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在consumer服务的<code>cn.itcast.mq.listener</code>包中新建一个类SpringRabbitListener类，代码如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.2、Work Queue</h3>
<p><strong>Work queues</strong>，也被称为（Task queues），<strong>任务模型</strong>。单来说就是<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong>。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230328143733.png" alt="" loading="lazy"></p>
<p>当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。<br>
此时就可以使用work 模型，<strong>多个消费者共同处理消息</strong>处理，<strong>速度</strong>就能大大<strong>提高</strong>了。</p>
<h4> 3.2.1、消息发送</h4>
<p>循环发送，模拟大量消息堆积<br>
在publisher服务中的SpringAmqpTest类中添加一个测试方法：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3.2.2、消息接收</h4>
<p>模拟多个消费者绑定同一个队列，我们在consumer服务的SpringRabbitListener中添加2个新的方法：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3.2.4、能者多劳</h4>
<p>启动ConsumerApplication后，可以看到消费者1很快完成了自己的25条消息。消费者2却在缓慢的处理自己的25条消息。<br>
也就是说消息是平均分配给每个消费者，并<strong>没有考虑到消费者的处理能力</strong>。这样显然是有问题的。</p>
<p>在spring中有一个简单的配置，可以解决这个问题。我们修改consumer服务的application.yml文件，添加配置：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 总结</h4>
<p>Work模型的使用：<br>
<strong>多个消费者绑定到一个队列</strong>，同一条消息只会被一个消费者处理<br>
通过<strong>设置prefetch</strong>来控制消费者预取的消息数量</p>
<h3> 3.3、发布/订阅</h3>
<p>发布订阅模式与之前案例的区别：允许将一个消息发送给多个消费者。实现方式加入了exchange（交换机）</p>
<p>发布订阅的模型如图：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230328182402.png" alt="" loading="lazy"></p>
<p>常见的exchange包括：<br>
Fanout 广播： 将消息交给所有绑定到交换机的队列<br>
Direct 定向： 把消息交给符合指定routing key 的队列<br>
Topic 通配符： 把消息交给符合routing pattern（路由模式） 的队列</p>
<p><strong>不同类型的交换机，路由方式不同</strong></p>
<blockquote>
<p><strong>注意：exchange负责消息路由，而部署存储，路由失败则消息失败</strong></p>
</blockquote>
<h3> 3.4、Fanout Exchange</h3>
<p>Fanout Exchange会将接收到的消息<strong>路由到每一个跟其绑定的queue</strong></p>
<p>利用SpringAMQP演示FanoutExchange的使用：<br>
实现思路如下：<br>
1、consumer服务中，利用代码声明队列，并将队列与交换机绑定<br>
2、consumer服务中，编写两个消费者方法，分析监听fanout.queue1和fanout.queue2两个队列<br>
3、在publisher中编写测试方法，向itcast.fanout发送消息</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230328183449340.png" alt="image-20230328183449340" loading="lazy"></p>
<h4> 3.4.1、声明队列和交换机</h4>
<p>在consumer服务声明Exchange、Queue、Binding</p>
<p>Spring提供了一个接口Exchange，来表示所有不同类型的交换机：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230328183548.png" alt="" loading="lazy"></p>
<p>在consumer服务中创建一个类，添加@configuration注解，并声明FanoutExchange、Queue和绑定关系队形Binding</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3.4.2、消息发送</h4>
<p>在publisher服务的SpringAmqpTest类中添加测试方法：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3.4.3、消息接收</h4>
<p>在consumer服务的SpringRabbitListener中添加两个方法，作为消费者：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3.4.4、总结</h4>
<p>交换机的作用：<br>
接收publisher发送的消息<br>
将消息按照规则路由到与之绑定的队列<br>
不能缓存消息，路由失败，消息丢失<br>
FanoutExchange的会将消息路由到每个绑定的队列</p>
<p>声明队列、交换机、绑定关系的Bean是什么？<br>
Queue<br>
FanoutExchange<br>
Binding</p>
<h3> 3.5、Direct Exchange</h3>
<p>Direct Exchange会将接收到的消息根据规则<strong>路由到指定的Queue</strong>，因此称为路由模式（routes）</p>
<p>每一个Queue都与Exchange设置一个BindingKey<br>
发布者发送消息时，指定消息的RoutingKey<br>
Exchange将消息路由到BIndkey与消息RoutingKey一致的队列</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230328194337.png" alt="" loading="lazy"></p>
<p>案例：</p>
<ol>
<li>利用@RabbitListener声明Exchange、Queue、RoutingKey</li>
<li>在consumer服务中，编写两个消费者方法，分别监听direct.queue1和direct.queue2</li>
<li>在publisher中编写测试方法，向itcast. direct发送消息</li>
</ol>
<p>实现思路如下：<br>
1、利用@RabbitListener声明Exchange、Queue、RoutingKey<br>
2、在consumer服务中，编写两个测试方法，向itcast.direct发送消息<br>
3、在publisher中编写测试方法，向itcast.direct发送消息</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230328194553.png" alt="" loading="lazy"></p>
<h4> 3.5.1、基于注解声明队列和交换机</h4>
<p>基于@Bean的方式声明队列和交换机比较麻烦，Spring还提供了<strong>基于注解方式声明</strong>。</p>
<p>在consumer的SpringRabbitListener中<strong>添加两个消费者</strong>，<strong>同时</strong>基于注解来<strong>声明队列和交换机</strong>：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3.5.2、消息发送</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.6、Topic Exchange</h3>
<p>Topic Exchange与DirectExchange类似，区别在于<strong>routingKey</strong>必须是<strong>多个单词列表</strong>，并且以  <strong>.</strong>   分割，例如： <code>item.insert</code></p>
<p>Queue与Exchange指定BindingKey时可以使用<strong>通配符</strong>：<br>
#：代指0个或多个单词<br>
*：代指一个单词</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230328200530.png" alt="" loading="lazy"></p>
<p>案例需求：</p>
<p>实现思路如下：<br>
1、利用@RabbitListener声明Exchange、Queue、RoutingKey<br>
2、在consumer服务中，编写两个消费者方法，分别监听topic.queue1和topic.queue2<br>
3、在publisher中编写测试方法，向itcast. topic发送消息</p>
<h4> 3.6.2、消息发送</h4>
<p>在publisher服务的SpringAmqpTest类中添加测试方法：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3.6.3、消息接收</h4>
<p>在consumer服务的SpringRabbitListener中添加方法：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.7、消息转换器</h3>
<p>Spring会把<strong>发送的消息序列化为字节</strong>发送给MQ，<strong>接收</strong>消息的时候，还会<strong>把字节反序列化为Java对象</strong>。</p>
<p>默认情况下Spring采用的序列化方式是JDK序列化。众所周知，JDK序列化存在下列问题：</p>
<ul>
<li><strong>数据体积过大</strong></li>
<li><strong>有安全漏洞</strong></li>
<li><strong>可读性差</strong></li>
</ul>
<h4> 3.7.1、测试默认转换器</h4>
<p>修改消息发送的代码，发送一个Map对象：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>发送消息后查看控制台：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230328201619.png" alt="" loading="lazy"></p>
<h4> 3.7.2、配置JSON转换器</h4>
<p>DK序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此<strong>可以使用JSON方式来做序列化和反序列化</strong>。</p>
<p>在publisher和consumer两个服务中都引入依赖：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>配置消息转换器：</strong><br>
在<strong>启动类</strong>中添加一个Bean即可：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20210422095356088.png" type="image/png"/>
    </item>
    <item>
      <title>SpringBoot 基础</title>
      <link>https://T4mako.github.io/code/java/SpringBoot.html</link>
      <guid>https://T4mako.github.io/code/java/SpringBoot.html</guid>
      <source url="https://T4mako.github.io/rss.xml">SpringBoot 基础</source>
      <description>1、Spring与SpringBoot Spring的生态：web开发、数据访问、安全控制、分布式、消息服务、移动开发、批处理、...... Spring5重大升级：响应式编程、响应式编程</description>
      <category>java</category>
      <content:encoded><![CDATA[<h2> 1、Spring与SpringBoot</h2>
<p>Spring的生态：web开发、数据访问、安全控制、分布式、消息服务、移动开发、批处理、......<br>
Spring5重大升级：响应式编程、响应式编程</p>
<!-- more -->
<p>SpringBoot优点：创建独立Spring应用、内嵌web服务器、自动starter依赖，简化构建配置、自动配置Spring以及第三方功能、提供生产级别的监控、健康检查及外部化配置、无代码生成、无需编写XML<br>
SpringBoot缺点：称版本帝，迭代快，需要时刻关注变化、封装太深，内部原理复杂，不容易精通</p>
<p>时代背景：<br>
<strong>微服务：</strong><br>
微服务是一种架构风格<br>
一个应用拆分为一组小型服务<br>
每个服务运行在自己的进程内，也就是可独立部署和升级<br>
服务之间使用轻量级HTTP交互<br>
服务围绕业务功能拆分<br>
可以由全自动部署机制独立部署<br>
去中心化，服务自治。服务可以使用不同的语言、不同的存储技术<br>
**分布式	**<br>
<strong>云原生</strong></p>
<p><strong><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/documentation.html#documentation" target="_blank" rel="noopener noreferrer">springboot的官方文档</a></strong></p>
<h2> 2、SpringBoot2入门</h2>
<h3> 1、创建maven工程引入依赖</h3>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2、创建主程序</h3>
<div class="language-JAVA line-numbers-mode" data-ext="JAVA"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3、编写业务</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4、测试</h3>
<p><strong>直接运行main方法</strong></p>
<h3> 5、简化配置</h3>
<p>在 resources 中创建 <strong>application.properties</strong></p>
<div class="language-properties line-numbers-mode" data-ext="properties"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 6、简化部署</h3>
<p>如果添加插件启动时报错，可以尝试在<code>&lt;plugin&gt;</code>标签内部添加设置版本号的version标签，版本号要与Spring版本号一致</p>
<p>在pom.xml中添加：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>把项目打成 <strong>jar 包</strong>，直接在目标服务器执行即可。</p>
<p>注意点：<br>
有的时候cmd命令启动不了springboot项目，可能是因为在属性中开启了【快速编辑模式】，取消方法：右击cmd控制台的窗口上方标题区域打开【选项】取消勾选【快去编辑模式】</p>
<h2> 3、了解自动配置原理</h2>
<h3> 1、SpringBoot特点</h3>
<h4> 1、依赖管理</h4>
<h5> ① 父项目做依赖管理</h5>
<p><strong>在父工程中统一管理项目中的依赖信息，具体来说是管理依赖信息的版本。</strong></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>可以修改默认版本号</strong></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> ②starter场景启动器</h5>
<p>1、<strong>spring-boot-starter-*</strong> ： *就某种场景（<strong>官方starter</strong>）<br>
2、只要引入 <strong>starter</strong>，这个场景的所有常规需要的 <strong>依赖</strong> 都 <strong>自动引入</strong><br>
3、SpringBoot所有支持的场景<br>
<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter" target="_blank" rel="noopener noreferrer">https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter</a><br>
4、见到的 <strong>*-spring-boot-starter</strong>： <strong>第三方starter</strong>为我们提供的简化开发的场景启动器。<br>
5、所有 <strong>场景启动器</strong> <strong>最底层的依赖</strong>:</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注：无需关注版本号，自动版本仲裁:<br>
1、引入依赖默认都可以不写版本<br>
2、引入非版本仲裁的jar，要写版本号。</p>
<h4> 2、自动配置</h4>
<h5> 1、自动配好Tomcat</h5>
<p>​	引入Tomcat依赖<br>
​	配置Tomcat</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 2、自动配好SpringMVC</h5>
<p>​	引入 SpringMVC 全套组件<br>
​	自动配好 SpringMVC 常用组件（功能）</p>
<h5> 3、自动配好Web常见功能，如：字符编码问题</h5>
<p>​	SpringBoot 帮我们配置好了所有 web 开发的常见场景<br>
​		<em>字符过滤器</em> 等</p>
<h5> 4、默认的包扫描</h5>
<p>**主程序所在包 **及其下面的所有 <strong>子包</strong> 里面的组件都会被默认扫描进来<br>
<strong>无需以前的包扫描配置</strong></p>
<p><em>想要改变扫描路径</em>，在 MainApplication上添加<br>
<strong>@SpringBootApplication(scanBasePackages="com.t4mako")</strong> 或者 <strong>@ComponentScan指定扫描路径</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 5、各种配置拥有默认值</h5>
<p>默认配置最终都是映射到某个类上，（MultipartProperties类）<br>
配置文件的值（<strong>application.properties</strong>）最终会 <strong>绑定每个类上</strong>，这个类会在容器中创建对象</p>
<h5> 6、按需加载所有自动配置项</h5>
<p>非常多的 starter<br>
<strong>引入了哪些场景</strong> 这个场景的 <strong>自动配置才会被开启</strong><br>
SpringBoot 的 <strong>所有自动配置功能</strong> 都在 <strong>spring-boot-autoconfigur包</strong> 里面（不一定都生效）</p>
<h3> 2、容器功能(关键注解-重要)</h3>
<p><mark>spring boot 项目默认会扫描主类同级的包</mark></p>
<h4> 1、组件相关</h4>
<h5> 1、@Configuration</h5>
<p><strong>@Configuration <strong>==告诉SpringBoot这是一个</strong>配置类 == 配置文件（创建bean）</strong>==<br>
<strong>在类上添加 Configration 类似于 Spring 中的 beans.xml</strong><br>
<strong>标注了@Configuration 注解的类本身也是一个组件</strong></p>
<p>参数 proxyBeanMethods：<br>
<strong>true(默认)：单实例<br>
false：（类、方法）被调用时返回是新创建的</strong></p>
<p>在类<strong>方法</strong>中添加**@Bean**注解：<br>
<mark>Id = 方法名，容器中的实例 = 返回的值</mark></p>
<p><strong>Full(true)模式</strong> 与 <strong>Lite(false)模式</strong>：<br>
**配置类 **组件之间 <strong>无依赖关系</strong>（没有相互调用）用Lite模式加速容器启动过程，减少判断 <strong>false</strong><br>
**配置类 **组件之间 <strong>有依赖关系</strong>，方法会被调用得到之前单实例组件 <strong>true</strong></p>
<p><code>Full模式获取组件时，会先检查容器中是否有该组件，Lite模式不会检查容器，直接创建一个新的组件返回</code></p>
<p><em>Full(proxyBeanMethods = true)（保证每个</em>*@Bean方法<strong>被调用多少次返回的组件都是</strong>单实例<strong>的）<br>
Lite(proxyBeanMethods = false)（每个</strong>@Bean方法<strong>被调用多少次返回的组件都是</strong>新创建**的）*</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 2、@Bean、@Component、@Controller、@Service、@Repository（持久层注解）</h5>
<p>@Repository 注解可以将这个数据访问对象标记为 Spring 应用程序上下文中的 bean，从而使得我们可以在其他组件中使用该 bean。</p>
<p>常规组件</p>
<h5> 3、@ComponentScan、@Import</h5>
<p><strong>@Import</strong>：标注在有组件注解的类上（Configuration，Controller...）</p>
<p><strong>用于导入指定类型的组件并自动创建（放到容器中）</strong><br>
<strong>默认id = 全类名</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 4、@Conditional</h5>
<p>条件装配：<strong>满足</strong> Conditional指定的 <strong>条件</strong> 时才进行组件（bean）注入</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230120113626334.png" alt="" loading="lazy"></p>
<p>该注解可以标注在类上或方法上（类/方法是否生效）</p>
<p>例子：<br>
<strong>@ConditionalOnBean</strong>(name = "tom")  容器中 <strong>有</strong> tom组件才生效<br>
<strong>@ConditionalOnMissingBean</strong>(name = "tom") 容器中 <strong>没有</strong> tom组件才生效</p>
<h4> 2、原生配置文件引入@ImportResource</h4>
<p><mark>在随意一个配置类(@Configuration)上编写</mark></p>
<p><em>在随意一个配置类(@Configuration)上编写</em><br>
<strong>@ImportResource注解可以帮助</strong><br>
<strong>导入编写的beans.xml的文件导入配置文件中的bean</strong></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3、配置绑定 (两种方法)</h4>
<p>使用 Java 读取到 properties 文件中的内容，并且把它封装到 JavaBean 中，以供随时使用</p>
<p>只有在容器中的组件，才会拥有SpringBoot提供的强大功能</p>
<h5> 1、@ConfigurationProperties</h5>
<p>使用：<br>
该注解标注 <strong>在有组件注解的类</strong>上 （只有在 <strong>容器中的组件</strong> 才能有springboot的强大功能）<br>
<strong>@ConfigurationProperties(prefix = "")<br>
表示在Application.properties中的前缀</strong><br>
将有这些前缀的属性的属性值赋值，并生成一个 bean 保存到容器中</p>
<div class="language-properties line-numbers-mode" data-ext="properties"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 2、@EnableConfigurationProperties + @ConfigurationProperties</h5>
<p>适用于需要将第三方的没有标注 @Component 的类引入到 IOC 中</p>
<p>使用：<br>
在配置类上写 <strong>@EnableConfigurationProperties(Car.class)</strong>，作用：<br>
开启Car <strong>类的属性配置绑定功能</strong><br>
把Car这个组件自动注入到容器中</p>
<p><strong>此时Car类中就不用写@component注解了</strong><br>
（再通过@ConfigurationProperties配置属性）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3、自动配置原理入门（给容器中自动注入组件）</h3>
<h4> 3.1、引导加载自动配置类</h4>
<p><strong>@SpringBootApplication=</strong><br>
<strong>@SpringBootConfiguration + @EnableAutoConfiguration + @ComponentScan("com.t4mako.boot")</strong></p>
<p>1、<em>@SpringBootConfiguration：</em><br>
相当于*@Configuration*。代表当前是一个配置类</p>
<p>2、<em>@ComponentScan</em>：<br>
指定扫描哪些，Spring注解</p>
<p>3、<em><strong>@EnableAutoConfiguration：</strong></em></p>
<p><strong>@EnableAutoConfiguration = @AutoConfigurationPackage + @Import</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>① @AutoConfigurationPackage：</strong></p>
<p>自动配置包、指定了默认的包规则<br>
即 <strong>将MainApplication 所在包下所有组件导入进来</strong></p>
<p><em>点入@AutoConfigurationPackage：</em></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>AutoConfigurationPackages.Registrar.class</strong>：<br>
利用Registrar给容器中导入一系列组件<br>
将指定的一个包下的所有组件导入进来，即<strong>MainApplication 所在包下</strong>。</p>
<p><strong>② @Import(AutoConfigurationImportSelector.class)</strong></p>
<p><em>AutoConfigurationImportSelector.class：</em><br>
1、利用getAutoConfigurationEntry(annotationMetadata)方法：给容器中批量导入一些组件<br>
2、调用<code>List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes)</code>：获取到所有需要导入到容器中的配置类<br>
3、利用工厂加载 <code>Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader);</code>得到所有的组件<br>
4、从META-INF/spring.factories位置来加载一个文件。<br>
默认扫描我们当前系统里面所有META-INF/spring.factories位置的文件：<br>
spring-boot-autoconfigure-2.3.4.RELEASE.jar包里面也有META-INF/spring.factories</p>
<p>文件里面写死了spring-boot一启动就要给容器中加载的所有配置类（127个，往后的版本有更改）</p>
<h4> 3.2、按需开启自动配置项</h4>
<p>虽然我们127个场景的所有自动配置<strong>启动的时候默认全部加载</strong><br>
xxxxAutoConfiguration按照<strong>条件装配</strong>规则（@Conditional），最终会<strong>按需配置</strong>。</p>
<h4> 3.3、修改默认配置</h4>
<p>给@Bean标注的方法传入了对象参数，这个参数的值就会从容器中找。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>SpringBoot默认会在底层配好所有的组件。但是如果用户自己配置了以用户的优先</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>总结：<br>
SpringBoot先<strong>加载所有的自动配置类</strong>xxxxxAutoConfiguration<br>
每个自动配置类<strong>按照条件生效（不是全部）</strong>，默认都会绑定配置文件指定的值。xxxxProperties里面拿。xxxProperties和配置文件进行了绑定<br>
（对应注解*@EnableConfigurationProperties*）<br>
生效的 <strong>配置类</strong>就会<strong>给容器中装配很多组件</strong><br>
只要<strong>容器中有这些组件</strong>，相当于这些<strong>功能就有了</strong><br>
定制化配置：<br>
用户自己**@Bean替换底层组件**<br>
用户去看这个组件是获取的<strong>配置文件什么值就去修改</strong>。</p>
<p><strong>xxxxxAutoConfiguration ---&gt; 组件  ---&gt;</strong> <strong>xxxxProperties里面拿值  ----&gt; application.properties（修改）</strong></p>
<h4> 3.4最佳实践</h4>
<p>1、引入场景依赖：<br>
<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.build-systems.starters" target="_blank" rel="noopener noreferrer">https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.build-systems.starters</a></p>
<p>2、查看自动配置了哪些（选做）<br>
自己分析，引入场景对应的自动配置一般都生效了<br>
<strong>配置文件中debug=true</strong>开启<strong>自动配置报告</strong>。Negative（不生效）\ Positive（生效）</p>
<p>3、是否需要修改<br>
参照文档修改配置项<br>
<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties" target="_blank" rel="noopener noreferrer">https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties</a><br>
自己分析，xxxxProperties绑定了配置文件的哪些。<br>
自定义或加入替换组件<br>
@Bean、@Component...<br>
自定义器<br>
<strong>XXXXXCustomizer</strong>；</p>
<h3> 4、开发小技巧</h3>
<h4> 1、Lombok</h4>
<p><strong>简化JavaBean开发</strong></p>
<p>1、引入依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2、搜索安装 lombak 插件</p>
<p>3、编写 JavaBean</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2、dev-tools</h4>
<p>加入依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>项目或者页面修改以后：<strong>Ctrl+F9 （重启）即可</strong></p>
<h4> 3、Spring Initailizr（项目初始化向导）</h4>
<p>创建新项目</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230120164052376.png" alt="image-20230120164235192" loading="lazy"></p>
<p>选择需要的功能模块，boot版本等</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230120164418965.png" alt="image-20230120164418965" loading="lazy"></p>
<p>自动引入依赖</p>
<p>自动创建项目结构：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230120164443965.png" alt="image-20230120164443965" loading="lazy"></p>
<p>自动编写好主配置类：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230120164502332.png" alt="image-20230120164502332" loading="lazy"></p>
<h2> 4、配置文件</h2>
<h3> 1、文件类型</h3>
<h4> 1、propertie</h4>
<p>同以前的 properties 用法</p>
<h4> 2、yaml</h4>
<h5> yaml简介：</h5>
<p>YAML 是 "YAML Ain't Markup Language"（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是："Yet Another Markup Language"（仍是一种标记语言）。</p>
<p><strong>非常适合用来做以数据为中心的配置文件</strong></p>
<h5> 基本语法：</h5>
<ul>
<li>key: value；kv之间有空格</li>
<li>大小写敏感</li>
<li>使用缩进表示层级关系</li>
<li>缩进不允许使用tab，只允许空格（idea开发可以用）</li>
<li>缩进的空格数不重要，只要相同层级的元素左对齐即可</li>
<li>'#'表示注释</li>
<li>字符串无需加引号，如果要加，''与""表示字符串内容 会被 转义/不转义</li>
</ul>
<h5> 数据类型：</h5>
<p>字面量：单个的、不可再分的值。date、boolean、string、number、null</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>对象：键值对的集合。map、hash、set、object</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>数组：一组按次序排列的值。array、list、queue</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 示例：</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如何在其他类中使用yaml配置文件的值：<br>
在配置类中添加 <strong>@PropertySource</strong>注解指定要读取的配置文件路径。<br>
Spring Boot 的组件中使用 <strong>@Value</strong>注解来读取这些属性值</p>
<h3> 2、配置提示（常用）</h3>
<p>自定义的类和配置文件绑定一般没有提示。<br>
若要有提示，可以增加下面配置：</p>
<p>pom.xml 增加：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 5、Web开发</h2>
<h3> 1、静态资源/欢迎页/图标</h3>
<h4> 1、静态资源</h4>
<h5> 1、静态资源访问</h5>
<p>静态资源放在类路径下：<br>
<strong>/static</strong> (或 <code>/public</code> 或 <code>/resources</code> 或 <code>/META-INF/resources</code></p>
<p>访问方式 ：<br>
当前项目根路径/ + 静态资源名</p>
<p>原理：<br>
静态映射/**（拦截所有请求）<br>
请求进来， <strong>先去找Controller看能不能处理</strong>。不能处理的所有请求又都交给 <strong>静态资源处理器</strong>。静态资源也找不到则响应404页面</p>
<p>改变默认的静态资源路径的方式：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 2、静态资源访问前缀</h5>
<p>默认是无前缀的</p>
<p>修改带上前缀/res：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了让拦截能区分出静态资源和动态资源，所以一般在静态资源前面加个前缀，拦截器在看到指定前缀时就放行，从而达到动态静态分开的目的</p>
<p>当前项目 + static-path-pattern + 静态资源名 = 静态资源文件夹下找</p>
<h5> 3、webjar</h5>
<p>自动映射 /<a href="http://localhost:8080/webjars/jquery/3.5.1/jquery.js" target="_blank" rel="noopener noreferrer">webjars</a>/**</p>
<p>引入依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>访问地址：<a href="http://localhost:8080/webjars/jquery/3.5.1/jquery.js" target="_blank" rel="noopener noreferrer">http://localhost:8080/webjars/<strong>jquery/3.5.1/jquery.js</strong></a>   后面地址要按照依赖里面的包路径</p>
<h4> 2、欢迎页</h4>
<p><em><strong>创建欢迎页的两种方式：</strong></em></p>
<p><em><strong>1、静态资源路径下的index.html</strong></em><br>
可以配置静态资源路径<br>
但是不可以配置静态资源的<strong>访问前缀</strong>，否则导致index.html不能被默认访问</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><em><strong>2、编写controller能处理 /index 请求</strong></em></p>
<h4> 3、自定义Favicon</h4>
<p>favicon.ico 文件放在 <strong>静态资源目录下即可</strong>。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4、静态资源配置原理</h4>
<p>SpringBoot 启动默认加载  xxxAutoConfiguration 类（自动配置类）<br>
<code>SpringMVC 功能的自动配置类 WebMvcAutoConfiguration 就生效了</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>给容器中的配置：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>绑定配置文件：<br>
<strong>WebMvcProperties</strong>==<em>spring.mvc</em><br>
<strong>ResourceProperties</strong>==<em>spring.resources</em></p>
<p><em><strong>扩展：如果配置类只有一个有参构造器：</strong></em><br>
<em><strong>有参构造器所有的值都会从容器中确定</strong></em></p>
<p>ResourceProperties resourceProperties；获取和 <code>spring.resources</code> 绑定的所有的值的对象<br>
WebMvcProperties mvcProperties 获取和 <code>spring.mvc</code> 绑定的所有的值的对象<br>
ListableBeanFactory beanFactory Spring的 <code>beanFactory</code><br>
HttpMessageConverters 找到所有的 <code>HttpMessageConverters</code><br>
ResourceHandlerRegistrationCustomizer 找到 资源处理器的自定义器。<br>
DispatcherServletPath<br>
ServletRegistrationBean   给应用注册 Servlet、Filter....</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 1、资源处理的默认规则</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 2、欢迎页的处理规则</h5>
<p>**HandlerMapping：处理器映射。保存了每一个Handler能处理哪些请求。	**</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 3、favicon</h5>
<h3> 2、请求参数处理</h3>
<h4> 1、put、delete  请求映射</h4>
<h5> 1、开启 rest</h5>
<p>springBoot 中 需要 <strong>手动开启</strong></p>
<p><strong>开启页面表单的Rest功能</strong></p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>@xxxMapping<br>
Rest风格支持<br>
对用户的操作： /user*    GET-获取用户    DELETE-删除用户     PUT-修改用户     POST-保存用户</p>
<p>核心Filter：<strong>HiddenHttpMethodFilter</strong>（开启put，delete请求）<br>
（过滤器的一个作用）</p>
<p>前端发送put，delete请求的方式：<strong><code>表单 method=post，隐藏域 **\_**method=put</code></strong></p>
</blockquote>
<blockquote>
<p>Rest 原理：<br>
表单提交会带上 _method=PUT/DELETE<br>
请求被 <strong>HiddenHttpMethodFilter</strong> 拦截<br>
判断 <strong>请求</strong> 是否正常且  <strong>为POST</strong><br>
获取到 <strong>_method的值</strong> 并转为大写，判断是否为PUT、DELETE、PATCH<br>
包装模式 <strong>requesWrapper</strong> 与原生Request类类似，<strong>重写了getMethod方法，返回的是传入的值</strong><br>
过滤器链放行的时候用 wrapper。以后的方法调用getMethod是调用requesWrapper的。</p>
<p>注：<br>
使用客户端工具如 PostMan 直接发送Put、delete等方式请求，无需 Filter，直接为PUT/DELETE</p>
</blockquote>
<blockquote>
<p>扩展：更改 _method 这个名字：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote>
<h5> 2、请求映射原理（从请求到方法）</h5>
<p>DispatcherServlet 的继承树：<br>
<code>HttpServlet→FramworkServlet（重写doGet、doPost、调用doService）→DispatcherServlet（实现doService、调用doDispatch）</code></p>
<p>SpringMVC 功能分析都从 org.springframework.web.servlet.<strong>DispatcherServlet</strong> 类的 <strong>doDispatch()</strong> 方法开始</p>
<p>① <strong>通过请求地址找到对应的 Controller</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>② <strong>HandlerMapping：处理器映射</strong></p>
<p>所有的请求映射都在 HandlerMapping 中（请求→哪个handler处理器处理）</p>
<p>HandlerMapping一共有5个，依此寻找：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230122222555787.png" alt="image-20230122222555787" loading="lazy"></p>
<blockquote>
<p><strong>RequestMappingHandlerMapping</strong>：<br>
保存了所有 @RequestMapping 和 handler 的映射规则。（springboot启动后自动扫描保存）</p>
<p>所有的请求映射都在 HandlerMapping 中，寻找案例：<br>
SpringBoot自动配置欢迎页的 WelcomePageHandlerMapping 。访问 /能访问到index.html<br>
SpringBoot自动配置了默认 的 RequestMappingHandlerMapping<br>
请求进来，挨个尝试所有的HandlerMapping看是否有请求信息<br>
如果有就找到这个请求对应的handler<br>
如果没有就是下一个HandlerMapping</p>
<p>也可以自己给容器中放 HandlerMapping。自定义 HandlerMapping</p>
</blockquote>
<h4> 2、获取请求参数</h4>
<h5> 1、关键注解获取</h5>
<p><strong>@PathVariable（路径变量）<br>
@RequestParam（请求参数）</strong><br>
<strong>@RequestHeader（获取请求头）</strong><br>
<strong>@RequestBody（获取请求体 [post]）</strong><br>
<strong>@CookieValue（获取 cookiee 值）</strong><br>
<strong>@RequestAttribute（获取 Request 域属性）</strong><br>
<strong>@ModelAttribute</strong><br>
<strong>@MatrixVariable（矩阵变量）</strong></p>
<ol>
<li>
<p><strong>@RequestParam</strong></p>
<p>http请求的参数 =&gt; Controller 方法的 参数 上 （单个值，或封装成 List）</p>
<p>@RequestParam 注解的 <strong>三个属性</strong>：<br>
① <strong>value</strong>：设置和形参绑定 <strong>请求参数的名字</strong><br>
② <strong>required</strong>：设置是否必须传输value所对应的请求参数<br>
默认值为 true，请求参数必须传输，否则页面报错（400错误）<br>
若设置为 false，请求参数不必须传输，若不传输，则形参值为null	<br>
③ <strong>defaultValue</strong>：设置当没有传输 value 所对应的请求参数时，为<strong>形参设置默认值</strong>，此时和required属性值无关</p>
<blockquote>
<p>使用 @RequestParam 注解：如果请求参数的名称和控制器方法的参数名称不一致，或者我们需要使用@RequestParam注解的一些特性（如设置默认值或者必传属性等），那么必须使用@RequestParam注解来获取请求参数的值。</p>
</blockquote>
</li>
<li>
<p><strong>@PathVariable</strong></p>
<p>在 @RequestMapping 的 value 属性路径中，使用 <strong>{xxx}</strong> 的方式表示 <strong>路径中的数据</strong><br>
通过**@PathVariable注解**，将占位符所标识的值和控制器方法的形参进行绑定</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><strong>@RequestBody</strong></p>
<p>将 HTTP <strong>请求体</strong> 中的 <strong>JSON</strong> 或 XML =&gt; <strong>Java 对象</strong>。</p>
<p>案例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>@MatrixVariable（矩阵变量）（略）</p>
</li>
</ol>
<p>获取请求参数案例：</p>
<div class="language-java+ line-numbers-mode" data-ext="java+"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 2、Servlet API 获取</h5>
<p>参数中可以放 ServletAPI：</p>
<blockquote>
<p>WebRequest、ServletRequest、MultipartRequest、 HttpSession、javax.servlet.http.PushBuilder、Principal、InputStream、Reader、HttpMethod、Locale、TimeZone、ZoneId</p>
</blockquote>
<p><strong>ServletRequestMethodArgumentResolver 类解析以上的部分参数</strong></p>
<h5> 3、复杂参数</h5>
<blockquote>
<p>Map、Model（map、model里面的数据会被放在 request的请求域  request.setAttribute）<br>
Errors/BindingResult、RedirectAttributes（重定向携带数据）、ServletResponse（response）、SessionStatus、UriComponentsBuilder、ServletUriComponentsBuilder</p>
</blockquote>
<p>对 map&lt;String,Object&gt; map,<br>
Model model,<br>
HttpServletRequest request<br>
操作都是给 request 域中放数据，即 <strong>request.getAttribute();</strong></p>
<p>Map、Model类型的参数，返回的 都是 <strong>map</strong><br>
返回 mavContainer.getModel（）；---&gt; BindingAwareModelMap 是Model</p>
<h5> 4、自定义对象参数</h5>
<p>可以 <strong>自动类型转换</strong> 与格式化，可以 <strong>级联封装</strong>。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3、参数处理原理</h4>
<p>HandlerMapping 中找到能处理请求的 <strong>Handler</strong><br>
为当前 Handler 找一个适配器 <strong>HandlerAdapter</strong><br>
适配器执行目标方法并确定方法参数的每一个值</p>
<h5> 1、HandlerAdapter（适配器）</h5>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230123174924675.png" alt="image-20230123174924675" loading="lazy"></p>
<p>0 - 支持方法上标注@RequestMapping<br>
1 - 支持函数式编程的</p>
<h5> 2、执行目标方法</h5>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230123175018355.png" alt="image-20230123175018355" loading="lazy"></p>
<h5> 3、参数解析器-HandlerMethodArgumentResolver</h5>
<p><strong>确定将要执行的目标方法的每一个参数的值是什么</strong><br>
SpringMVC目标方法能写多少种参数类型。取决于参数解析器</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230123175246221.png" alt="image-20230123175246221" loading="lazy"></p>
<p>判断当前解析器是否（support方法）支持解析这种参数，支持就调用 resolveArgument</p>
<h5> 4、返回值处理器</h5>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230123175457405.png" alt="image-20230123175457405" loading="lazy"></p>
<h5> 5、如何确定目标方法每一个参数的值</h5>
<p>1、挨个判断所有参数解析器那个支持解析这个参数<br>
2、解析这个参数的值<br>
调用各自 HandlerMethodArgumentResolver 的 resolveArgument 方法即可<br>
3、自定义类型参数 封装POJO<br>
ServletModelAttributeMethodProcessor  这个参数处理器支持<br>
WebDataBinder 利用它里面的 Converters 将请求数据转成指定的数据类型。再次封装到JavaBean中<br>
GenericConversionService：在设置每一个值的时候，找它里面的所有converter那个可以将这个数据类型（request带来参数的字符串）转换到指定的类型（JavaBean -- Integer）</p>
<p><strong>byte -- &gt; file</strong></p>
<h5> 6、目标方法执行完成</h5>
<p>所有的数据都放在 <strong>ModelAndViewContainer</strong>；包含要去的页面地址View。还包含Model数据。</p>
<h5> 7、处理派发结果</h5>
<p><strong>processDispatchResult</strong>(processedRequest, response, mappedHandler, mv, dispatchException);<br>
renderMergedOutputModel(mergedModel, getRequestToExpose(request), response);</p>
<h3> 3、数据响应(JSON)与内容协商</h3>
<p>数据响应：<br>
① 响应页面<br>
② 响应数据（json，xml，xls，图片，音视频，自定义协议内容）</p>
<h4> 1、响应JSON</h4>
<h5> 1、jackson.jar+@ResponseBody</h5>
<p>通过 <strong>jackson.jar</strong> (自动导入) + <strong>@ResponseBody</strong> 注解可以给前端自动返回 json 数据；</p>
<p>@RequestBody 指示控制器方法参数应该 从 HTTP请求体中获取，并将其反序列化为方法参数的类型。<br>
@RequestBody 注解将 HTTP请求体 中的 JSON或XML 转换为 Java对象。</p>
<blockquote>
<p>HttpMessageConverter（内容协商）是Spring框架中的一种机制，用于将请求和响应消息转换为特定的格式，例如JSON或XML。当您使用@RequestBody注解时，Spring Boot将尝试从请求体中获取数据，并 <strong>使用适当的HttpMessageConverter</strong> 将其转换为控制器方法参数的类型。<br>
默认情况下，Spring Boot使用Jackson库将JSON请求体映射到Java对象中。<strong>Jackson使用Java反射机制，查找Java类中的setter方法</strong>，并使用它们将JSON字段映射到Java对象中。</p>
</blockquote>
<blockquote>
<p><code>原理： 1、有返回值解析器 2、返回值解析器原理： 	1、返回值处理器先判断是否支持这种类型返回值 （supportsReturnType()方法，返回Boolean类型） 	2、如果支持，返回值处理器调用 handleReturnValue() 进行处理 	3、RequestResponseBodyMethodProcessor() 可以处理返回值标了@ResponseBody 注解的方法 		1、利用 MessageConverters 进行处理 将数据写为json 			①内容协商（浏览器默认会以请求头的方式告诉服务器他能接受什么样的内容类型，且有优先级） 			②服务器最终根据自己自身的能力，决定服务器能生产出什么样内容类型的数据 			③SpringMVC会挨个遍历所有容器底层的 HttpMessageConverter ，看谁能处理 				得到MappingJackson2HttpMessageConverter可以将对象写为json 				利用MappingJackson2HttpMessageConverter将对象转为json再写出去。</code></p>
</blockquote>
<h5> 2、SpringMVC 支持的返回值</h5>
<blockquote>
<p>ModelAndView、Model、View<br>
ResponseEntity 、ResponseBodyEmitter、StreamingResponseBody、HttpEntity、HttpHeaders、Callable、DeferredResult、ListenableFuture、CompletionStage、WebAsyncTask<br>
有 @ModelAttribute 且为对象类型的<br>
@ResponseBody 注解 ---&gt; RequestResponseBodyMethodProcessor；</p>
</blockquote>
<h5> 3、HTTPMessageConverter（消息转换器）原理</h5>
<p>HttpMessageConverter: 看是否支持将 此 Class 类型的对象，转为MediaType类型的数据。<br>
例子：Person 对象转为 JSON。或者 JSON转为Person</p>
<p>默认的MessageConverter：<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230125154948610.png" alt="image-20230125154948610" loading="lazy"></p>
<p>0 - 只支持Byte类型的<br>
1 - String<br>
2 - String<br>
3 - Resource<br>
4 - ResourceRegion<br>
5 - DOMSource.class \ SAXSource.class \ StAXSource.class \StreamSource.class \Source.class<br>
6 - MultiValueMap<br>
7 - true<br>
8 - true<br>
9 - 支持注解方式xml处理的。</p>
<p>最终 MappingJackson2HttpMessageConverter  把对象转为JSON（利用底层的jackson的objectMapper转换的）</p>
<h4> 2、内容协商</h4>
<p><strong>根据客户端接收能力不同，返回不同媒体类型的数据。</strong><br>
（若客户端无法解析服务端返回的内容，即媒体类型未匹配，那么响应406）</p>
<h5> 1、引入xml依赖</h5>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 2、postman分别测试返回json和xml</h5>
<p>postman：模拟用户发起的各类HTTP请求</p>
<p>只需要改变请求头中Accept字段。Accept字段是Http协议中规定的，告诉服务器本客户端可以接收的数据类型。<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230125161757892.png" alt="image-20230125161757892" loading="lazy"></p>
<h5> 3、开启浏览器参数方式内容协商功能</h5>
<p>为了方便内容协商，开启基于请求参数的内容协商功能。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用方式：</p>
<p>发送请求时，带上format参数：<br>
<a href="http://localhost:8080/test/person?format=json" target="_blank" rel="noopener noreferrer">http://localhost:8080/test/person?format=json</a><br>
<a href="http://localhost:8080/test/person?format=xml" target="_blank" rel="noopener noreferrer">http://localhost:8080/test/person?format=xml</a></p>
<p>确定客户端接收什么样的内容类型：<br>
1、Parameter策略优先确定是要返回json数据（获取请求头中的format的值）<br>
2、最终进行内容协商返回给客户端json即可。</p>
<h5> 4、内容协商原理</h5>
<p>1、判断当前响应头中是否已经有确定的媒体类型。MediaType<br>
2、<strong>获取</strong>客户端（PostMan、浏览器）<strong>支持接收的内容类型</strong>。（获取客户端Accept请求头字段）【application/xml】<br>
contentNegotiationManager 内容协商管理器 默认使用基于请求头的策略<br>
HeaderContentNegotiationStrategy  确定客户端可以接收的内容类型<br>
3、遍历循环所有当前系统的 <strong>MessageConverter</strong>，看谁支持操作这个对象（Person）<br>
4、找到支持操作Person的converter，把converter支持的媒体类型统计出来。<br>
5、客户端需要【application/xml】。服务端能力【10种、json、xml】<br>
6、进行内容协商的最佳匹配媒体类型<br>
7、用 支持 将对象转为 最佳匹配媒体类型 的converter。调用它进行转化 。</p>
<h5> 5、自定义 MessageConverter</h5>
<p>实现多协议数据兼容。json、xml、x-guigu</p>
<p>0、@ResponseBody 响应数据出去 调用 <strong>RequestResponseBodyMethodProcessor</strong> 处理<br>
1、Processor 处理方法返回值。通过 <strong>MessageConverter</strong> 处理<br>
2、所有 <strong>MessageConverter</strong> 合起来可以支持各种媒体类型数据的操作（读、写）<br>
3、内容协商找到最终的 <strong>messageConverter</strong>；</p>
<p>SpringMVC的什么功能。一个入口给容器中添加一个  WebMvcConfigurer</p>
<h3> 4、视图解析与模板引擎（不看）</h3>
<p>视图解析：<strong>SpringBoot默认不支持JSP，需要引入第三方模板引擎技术实现页面渲染。</strong>（SpringBoot工程的打包结果是一个jar包，是压缩包，JSP不支持在压缩包中被编译运行，所以SpringBoot默认不支持JSP。）</p>
<h4> 1、视图解析原理流程</h4>
<p>1、目标方法处理的过程中，所有数据都会被放在 ModelAndViewContainer 里面。包括数据和视图地址<br>
2、方法的参数是一个自定义类型对象（从请求参数中确定的），把他重新放在 ModelAndViewContainer<br>
3、任何目标方法执行完成以后都会返回 ModelAndView（数据和视图地址）。<br>
4、processDispatchResult  处理派发结果（页面该如何响应）</p>
<h4> 2、模板引擎Thymeleaf</h4>
<h5> 1、thymeleaf简介</h5>
<p>现代化、服务端Java模板引擎</p>
<h5> 2、基本语法</h5>
<h6> 1、表达式</h6>
<table>
<thead>
<tr>
<th>表达式名字</th>
<th>语法</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>变量取值</td>
<td>**${...} **</td>
<td>获取请求域、session域、对象等值</td>
</tr>
<tr>
<td>选择变量</td>
<td css-module=".">*</td>
<td>获取上下文对象值</td>
</tr>
<tr>
<td>消息</td>
<td css-module=".">#</td>
<td>获取国际化等值</td>
</tr>
<tr>
<td>链接</td>
<td><strong>@{...}</strong></td>
<td>加了前后缀，自动拼接，生成链接</td>
</tr>
<tr>
<td>片段表达式</td>
<td css-module=".">~</td>
<td>jsp:include 作用，引入公共页面片段</td>
</tr>
</tbody>
</table>
<h6> 2、字面量</h6>
<p>文本值: 'one text' , 'Another one!'<br>
数字: 0 , 34 , 3.0 , 12.3<br>
布尔值: true , false<br>
空值: null<br>
变量： one，two  <strong>变量不能有空格</strong></p>
<h6> 3、文本操作</h6>
<p>字符串拼接: <strong>+</strong><br>
变量替换: <strong>|The name is ${name}|</strong></p>
<h6> 4、数学运算</h6>
<p>运算符: + , - , * , / , %</p>
<h6> 5、布尔运算</h6>
<p>运算符:  and , or<br>
一元运算: ! , not</p>
<h6> 6、比较运算</h6>
<p>比较: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le )等式: == , != ( eq , ne )</p>
<h6> 7、条件运算</h6>
<p>If-then: <strong>(if) ? (then)</strong></p>
<p>If-then-else: <strong>(if) ? (then) : (else)</strong></p>
<p>Default: (value) <strong>?: (defaultvalue)</strong></p>
<h6> 8、特殊操作</h6>
<p>无操作： _</p>
<h5> 3、设置属性值-th:attr</h5>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h5> 4、循环</h5>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 5、条件运算</h5>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3、thymeleaf使用</h4>
<h5> 1、引入Starter</h5>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 2、自动配置好了thymeleaf</h5>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230126124513640.png" alt="image-20230126124513640" loading="lazy"></p>
<p>自动配好的策略</p>
<p>1、所有thymeleaf的配置值都在 ThymeleafProperties<br>
2、配置好了 SpringTemplateEngine<br>
3、配好了 ThymeleafViewResolver 视图解析器<br>
4、我们只需要直接开发页面</p>
<p>ThymeleafProperties类中：视图前后缀</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4、构建后台管理系统</h4>
<h5> 1、项目创建</h5>
<p>添加模块：thymeleaf、web-starter、devtools、lombok</p>
<h5> 2、静态资源处理</h5>
<p>自动配置好，我们只需要把所有静态资源放到 static 文件夹下</p>
<h5> 3、路径构建</h5>
<p>th:action="@{/login}"</p>
<h5> 4、模板抽取</h5>
<p>th:insert/replace/include</p>
<h5> 5、页面跳转</h5>
<p>登入成功后创建user放入session中，通过session中的user对象判断是否要重新登录</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 6、数据渲染</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5、Interceptor 拦截器</h3>
<p>拦截器底层需要 <strong>Interceptor接口</strong><br>
接口中的三个方法：<br>
<strong><code>preHandle</code></strong>	目标方法执行之前<br>
<strong><code>postHandle</code></strong> 	目标方法执行之后<br>
<strong><code>afterCompletion</code></strong>	页面渲染</p>
<p>拦截器的作用：做登录检查</p>
<p><strong>配置拦截器要拦截哪些请求，把这些配置放在容器中（@Configuration）</strong><br>
实现 WebMvcConfigure 的 addInterceptors() 方法：<br>
<em>配置所有请求都别拦截，排除拦截登录页，静态页面</em></p>
<h4> 1、拦截器的使用</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2、配置拦截器（url）</h4>
<p><strong>实现WebMvcConfigure的addInterceptors()方法</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3、拦截器执行顺序、原理</h4>
<p>1、根据当前请求，找到 HandlerExecutionChain（可以处理请求的handler以及handler的所有拦截器）<br>
2、先 <strong>顺序执行</strong> 所有拦截器的 <strong>preHandle</strong>方法<br>
1、如果当前拦截器 prehandler返回为 <strong>true</strong>。则执行下一个拦截器的 preHandle 方法<br>
2、如果当前拦截器返回为 <strong>false</strong> 。<strong>倒序</strong> 执行经过的拦截器的 <strong>afterCompletion</strong> 方法；<br>
3、如果任何一个 <strong>拦截器返回false</strong>。直接跳出 <strong>不执行目标方法</strong><br>
4、所有拦截器 <strong>都返回True</strong>。<strong>执行目标方法</strong><br>
5、倒序执行所有拦截器的 postHandle 方法<br>
6、前面的步骤有任何异常都会直接 <strong>倒序</strong> 触发 afterCompletion<br>
7、页面成功渲染完成以后，也会 倒序 触发 afterCompletion</p>
<h3> 6、文件上传</h3>
<p>接收文件步骤：</p>
<p>① 注解：<strong>@RequestPart</strong>：表示一个文件<br>
② 接收的参数类：<strong>MultipartFile</strong> multipartFile<br>
③ 设置文件保存位置：<strong>multipartFile.transferTo()</strong>：</p>
<h4> 1、表单页面</h4>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2、文件上传代码</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3、修改上传文件大小限制</h4>
<div class="language-properties line-numbers-mode" data-ext="properties"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4、文件上传自动配置原理</h4>
<p>文件上传自动配置类-MultipartAutoConfiguration-MultipartProperties<br>
自动配置好了 StandardServletMultipartResolver   【文件上传解析器】<br>
原理步骤：<br>
请求进来使用文件上传解析器判断（isMultipart()）并封装（resolveMultipart，返回MultipartHttpServletRequest()）文件上传请求<br>
参数解析器来解析请求中的文件内容封装成MultipartFile<br>
将request中文件信息封装为一个Map，实现文件流的拷贝</p>
<h3> 7、异常处理</h3>
<h4> 1、默认规则</h4>
<p>默认情况下，Spring Boot 提供 <strong>/error</strong> 处理所有错误的映射<br>
对于机器客户端，它将生成 JSON 响应，其中包含错误，HTTP状态和异常消息的详细信息。<br>
对于浏览器客户端，响应一个 whitelabel 错误视图，以HTML格式呈现相同的数据</p>
<p>要对其进行 <strong>自定义</strong>，<strong>添加 View 解析为 error</strong><br>
error/下的4xx，5xx页面会被自动解析:</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230128171114694.png" alt="image-20230128171114694" loading="lazy"></p>
<h4> 2、定制错误处理逻辑</h4>
<p>自定义错误页:<br>
有精确的错误状态码页面就匹配精确，没有就找 4xx.html；如果都没有就触发白页</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230128173840949.png" alt="image-20230128173840949" loading="lazy"></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>@ControllerAdvice是一个Spring框架中的注解，用于定义全局控制器异常处理器。当控制器方法抛出未被处理的异常时，Spring将查找带有@ControllerAdvice注解的类来处理该异常。该类中的方法可以使用@ExceptionHandler注解来处理特定类型的异常。</p>
<p>@ExceptionHandler是一个Spring框架中的注解，用于处理控制器方法中的异常。在控制器方法上添加@ExceptionHandler注解，可以指定要处理的异常类型。当控制器方法抛出该异常时，Spring将调用带有@ExceptionHandler注解的方法来处理该异常。</p>
<p>@ExceptionHandler注解可以被用于单个方法或全局控制器。在单个方法中使用时，它只会应用于该方法中的异常处理。如果在全局控制器中使用，则它将应用于整个控制器中的所有方法。</p>
<p>使用@ExceptionHandler注解可以简化异常处理逻辑，使代码更易于维护和测试。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>自定义异常解析器，实现 HandlerExceptionResolver 处理异常；可以作为默认的全局异常处理规则</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3、异常处理自动配置原理</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230128173905589.png" alt="image-20230128173905589" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230128173913355.png" alt="image-20230128173913355" loading="lazy"></p>
<h4> 4、异常处理步骤流程</h4>
<p>1、执行目标方法，目标方法运行期间<strong>有任何异常都会被catch</strong>、而且标志当前<strong>请求结束</strong>；并且用 <strong>dispatchException</strong><br>
2、进入视图解析流程<br>
3、处理handler发生的异常，处理完成返回ModelAndView；<br>
遍历所有的 handlerExceptionResolvers(处理器异常解析器)，看谁能处理当前异常<br>
DefaultErrorAttributes先来处理异常。把异常信息保存到rrequest域，并且返回null<br>
默认没有任何人能处理异常，所以异常会被抛出<br>
如果没有任何人能处理最终底层就会发送 /error 请求。会被底层的BasicErrorController处理<br>
解析错误视图；遍历所有的ErrorViewResolver  看谁能解析。<br>
默认的 DefaultErrorViewResolver ,作用是把响应状态码作为错误页的地址，error/500.html<br>
模板引擎最终响应这个页面 error/500.html</p>
<h3> 8、Web原生组件注入（Servlet、Filter、Listener）</h3>
<p>有两种方式：</p>
<h4> 1、使用Servlet API</h4>
<p>核心注解：<br>
@ServletComponentScan(basePackage = "")：指定原生Servlet组件（写在application上）<br>
@WebServlet(urlPatterns = "“)  写在原生servlet上<br>
@WebFilter(urlPatterns = "") 写在原生Servlet上<br>
@WebListener 写在原生Listener上</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>扩展：DispatchServlet 如何注册进来<br>
容器中自动配置了  DispatcherServlet  属性绑定到 WebMvcProperties；对应的配置文件配置项是 <strong>spring.mvc。</strong><br>
通过ServletRegistrationBean&lt;DispatcherServlet&gt; 把 DispatcherServlet  配置进来。<br>
默认映射的是 / 路径。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230129152417865.png" alt="image-20230129152417865" loading="lazy"></p>
<p>Tomcat-Servlet；<br>
多个Servlet都能处理到同一层路径，精确优选原则<br>
A： /my/<br>
B： /my/1</p>
<h4> 2、使用RegistrationBean</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 9、嵌入式Servlet容器</h3>
<h4> 1、切换嵌入式Servlet容器</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230129153355545.png" alt="image-20230129153355545" loading="lazy"></p>
<h4> 2、定制Servlet容器</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230129153440517.png" alt="image-20230129153440517" loading="lazy"></p>
<h3> 10、定制化原理</h3>
<h4> 1、定制化的常见方式</h4>
<p><strong>①修改配置文件</strong><br>
<strong>②xxxxxCustomizer</strong><br>
<strong>③编写自定义的配置类   xxxConfiguration；+ @Bean替换、增加容器中默认组件；视图解析器</strong><br>
<strong>④Web应用 编写一个配置类实现 WebMvcConfigurer 即可定制化web功能；+ @Bean给容器中再扩展一些组件</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230129153616598.png" alt="image-20230129153616598" loading="lazy"></p>
<h4> 2、原理分析套路</h4>
<p><strong>场景starter</strong> <strong>- xxxxAutoConfiguration - 导入xxx组件 - 绑定xxxProperties --</strong> <strong>绑定配置文件项</strong></p>
<h2> 6、数据访问</h2>
<h3> 1、SQL</h3>
<h4> 1、数据源的自动配置</h4>
<h5> 1、导入JDBC场景</h5>
<p>① 导入JDBC starter：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>starter帮忙导入的内容：数据源(连接池)、jdbc、事务....</strong><br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230129162828197.png" alt="image-20230129162828197" loading="lazy"></p>
<p><strong>没有导入驱动的原因：官方不知道我们接下要操作什么数据库。</strong><br>
② <strong>因此要导入mysql驱动的依赖:</strong></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>springboot做了版本仲裁，默认版本：8.0.22<br>
修改版本的方式：<br>
①通过依赖修改版本号（maven的就近依赖原则）<br>
②重新声明版本（maven的就近依赖原则）</p>
<h5> 2、分析自动配置</h5>
<h6> 1、自动配置的类</h6>
<p>DataSourceAutoConfiguration类：<strong>数据源</strong> 的自动配置<br>
修改数据源相关配置：修改 <strong>spring.datasource</strong><br>
数据库连接池池的配置，自己容器中没有 DataSource 才自动配置<br>
底层配置好的连接池是：HikariDataSource</p>
<p>DataSourceTransactionManagerAutoConfiguration类： <strong>事务</strong> 管理器的自动配置</p>
<p>JdbcTemplateAutoConfiguration类： <strong>JdbcTemplate</strong> 的自动配置，可以来对数据库进行 <strong>crud</strong><br>
可以修改这个配置项 @ConfigurationProperties(prefix = <strong>"spring.jdbc"</strong>) 来修改JdbcTemplat<br>
容器中已经 <strong>有了JdbcTemplate</strong>这个组件（可以<strong>自动注入</strong>）</p>
<p>JndiDataSourceAutoConfiguration类： jndi的自动配置</p>
<p>XADataSourceAutoConfiguration乐扣： 分布式事务相关的</p>
<h5> 3、数据源配置</h5>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 4、测试</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2、使用Druid数据源</h4>
<p>整合第三方技术的两种方式：<br>
① <strong>自定义数据源：</strong><br>
原生JDBC数据源配置的 DataSourceAutoConfiguration 类在没有 DataSource 对象的时候自动创建<br>
所以只需要自己配置 <strong>Configuration 类的 DataSource 对象</strong>，返回其他数据源到IOC中即可</p>
<p>​	② <strong>找starter</strong></p>
<h5> 1、方式一：自定义方式</h5>
<p>导入druid依赖：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h6> 1、创建数据源</h6>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 2、方式二：官方starter方式</h5>
<h6> 1、引入druid-starter</h6>
<p>druid-starter引入的内容：druid数据源，slf4j，springboot自动配置</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>druid注入数据源：<br>
在 springboot 官方注入数据源之前注入一个数据源，官方的就不生效了</strong></p>
<h6> 2、分析自动配置</h6>
<p>扩展配置项：<strong>spring.datasource.druid</strong></p>
<p>DruidSpringAopConfiguration.class,：  监控 SpringBean 的<br>
配置项：<strong>spring.datasource.druid.aop-patterns</strong></p>
<p>DruidStatViewServletConfiguration.class： 监控页的配置：<br>
配置项：<strong>spring.datasource.druid.stat-view-servlet	默认开启</strong></p>
<p>DruidWebStatFilterConfiguration.class, web监控配置<br>
配置项：<strong>spring.datasource.druid.web-stat-filter；默认开启</strong></p>
<p>DruidFilterConfiguration.class})：所有Druid自己filter的配置</p>
<h6> 3、配置示例</h6>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3、整合MyBatis</h4>
<p><strong>引入starter：</strong></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>mybatis 引入的内容：mybatis，JDBCstarter，mybatis自动配置</p>
<h5> 1、配置模式</h5>
<p>全局配置文件<br>
SqlSessionFactory: 自动配置好了<br>
SqlSession：自动配置了 SqlSessionTemplate 组合了SqlSession<br>
@Import(AutoConfiguredMapperScannerRegistrar.class）：找到所有标注了@Mapper注解的接口<br>
Mapper： 只要我们写的操作MyBatis的接口标注了 <strong>@Mapper</strong> 就会被自动扫描进来</p>
<p>① 传统配置方式：</p>
<p>核心配置文件：mybatis-config.xml</p>
<p>yaml中：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Mapper接口→绑定mapper.xml</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>② <strong>通过yaml配置</strong></p>
<p>配置 private Configuration configuration; mybatis.configuration下面的所有，就是相当于改 mybatis 全局配置文件中的值</p>
<p><em><strong>无需创建mybatis-config.xml</strong></em></p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>总结，配置方式：<br>
导入 mybatis 官方 starter<br>
编写 mapper 接口。<strong>标注@Mapper注解</strong><br>
编写 sql 映射文件并绑定 mapper 接口<br>
在 <strong>application.yaml中指定Mapper配置文件的位置</strong>，以及指定全局配置文件的信息 （建议：<strong>配置在mybatis.configuration标签项下</strong>）</p>
<h5> 2、注解模式</h5>
<p>mapper映射文件可以省略</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 3、混合模式</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 4、总结</h5>
<p>最佳实战：<br>
引入 mybatis-starter<br>
<strong>配置 application.yam l中，指定 mapper-location 位置即可</strong><br>
编写 <strong>Mapper接口</strong> 并标注 <strong>@Mapper</strong> 注解<br>
简单方法直接注解方式<br>
复杂方法编写mapper.xml进行绑定映射<br>
<strong>配置类</strong> 上写 <strong>@MapperScan</strong>("com.t4mako.admin.mapper") 简化，其他的接口就可以 <strong>不用标注@Mapper注解</strong></p>
<h4> 4、整合 MyBatis-Plus</h4>
<h5> 1、引入starter</h5>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>starter引入内容：mybatis-plus、jdbc-starter</strong></p>
<p>只需要我们的 **Mapper 继承 BaseMapper **就可以拥有crud能力，并且批量扫描进来</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>MybatisPlusAutoConfiguration 配置类，MybatisPlusProperties 配置项绑定：<strong><a href="http://mybatis-plus.xxx" target="_blank" rel="noopener noreferrer">mybatis-plus.xxx</a></strong> 就是对 mybatis-plus 的定制</p>
<p><strong>SqlSessionFactory 自动配置</strong> 好，底层是容器中的数据源</p>
<p><strong>mapperLocations 自动配置</strong> 好：<br>
默认值：<strong><code>classpath\*:/mapper/\**/\*.xml</code></strong><br>
任意包的类路径下的<strong>所有mapper文件夹</strong>下任意路径下的<strong>所有xml</strong>都是sql映射文件。  建议<strong>sql映射文件，放在类路径mapper</strong>下</p>
<p>容器中也<strong>自动配置好了 SqlSessionTemplate</strong><br>
@Mapper 标注的接口也会被自动扫描<br>
建议<strong>直接 @MapperScan("com.t4mako.admin.mapper") 批量扫描</strong>就行</p>
<p><strong>@TableField(exist = false)：<br>
mybatis-plus的注解，标注在bean类的属性上，表示该属性在表中不存在</strong></p>
<h5> 2、CRUD功能</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2、NoSQL</h3>
<h4> 1、Redis自动配置</h4>
<p>引入starter</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>自动配置：<br>
自动配置类：RedisAutoConfiguration 。RedisProperties 属性类 --&gt; <strong>spring.redis.xxx是对redis的配置</strong><br>
连接工厂是准备好的。LettuceConnectionConfiguration、JedisConnectionConfiguration<br>
自动注入了RedisTemplate&lt;Object, Object&gt; ： xxxTemplate；<br>
自动注入了StringRedisTemplate；k：v都是String<br>
key：value<br>
底层只要我们使用 StringRedisTemplate、RedisTemplate就可以操作redis</p>
<h4> 2、RedisTemplate 与 Lettuce</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3、切换至jedis</h4>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 7、单元测试</h2>
<h3> 1、JUnit5 的变化</h3>
<p><strong>Spring Boot 2.2.0 版本开始引入 JUnit 5 作为单元测试默认库</strong><br>
作为最新版本的JUnit框架，JUnit5与之前版本的Junit框架有很大的不同。由三个不同子项目的几个不同模块组成：<br>
JUnit 5 = JUnit Platform + JUnit Jupiter + JUnit Vintage</p>
<p>JUnit Platform: Junit Platform是在JVM上启动测试框架的基础，不仅支持Junit自制的测试引擎，其他测试引擎也都可以接入。<br>
JUnit Jupiter: JUnit Jupiter提供了JUnit5的新的编程模型，是JUnit5新特性的核心。内部 包含了一个<strong>测试引擎</strong>，用于在Junit Platform上运行。<br>
JUnit Vintage: 由于JUint已经发展多年，为了照顾老的项目，JUnit Vintage提供了兼容JUnit4.x,Junit3.x的测试引擎。</p>
<p>注意：<br>
SpringBoot 2.4 以上版本移除了默认对 Vintage 的依赖。如果需要兼容junit4需要自行引入（不能使用junit4的功能 @Test）</p>
<p><strong>引入单元测试依赖</strong></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>现在单元测试的使用方式：</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>SpringBoot整合Junit以后：<br>
编写测试方法：@Test标注（注意需要使用junit5版本的注解）<br>
Junit类具有Spring的功能，@Autowired、比如 @Transactional 标注测试方法，测试完成后自动回滚</p>
<h3> 2、JUnit5常用注解</h3>
<p>JUnit5的注解与JUnit4的注解有所变化<a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations" target="_blank" rel="noopener noreferrer">https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations</a></p>
<ul>
<li>**@Test 😗*表示方法是测试方法。但是与JUnit4的@Test不同，他的职责非常单一不能声明任何属性，拓展的测试将会由Jupiter提供额外测试</li>
<li>**@ParameterizedTest 😗*表示方法是参数化测试，下方会有详细介绍</li>
<li>**@RepeatedTest 😗*表示方法可重复执行，下方会有详细介绍</li>
<li><strong>@DisplayName :<strong>为测试</strong>类</strong>或者测试<strong>方法</strong>设置<strong>展示名称</strong></li>
<li>**@BeforeEach 😗*表示在每个单元测试之前执行</li>
<li>**@AfterEach 😗*表示在每个单元测试之后执行</li>
<li>**@BeforeAll 😗*表示在所有单元测试之前执行</li>
<li>**@AfterAll 😗*表示在所有单元测试之后执行</li>
<li>**@Tag 😗*表示单元测试类别，类似于JUnit4中的@Categories</li>
<li>**@Disabled 😗*表示测试类或测试方法不执行，类似于JUnit4中的@Ignore</li>
<li>**@Timeout 😗*表示测试方法运行如果超过了指定时间将会返回错误</li>
<li>**@ExtendWith 😗*为测试类或测试方法提供扩展类引用</li>
</ul>
<p>示例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3、断言（assertions）</h3>
<p>断言（assertions）是测试方法中的核心部分，用来对测试需要满足的条件进行验证。这些断言方法都是 org.junit.jupiter.api.Assertions 的静态方法。<br>
断言检查业务逻辑返回的数据是否合理。<br>
<strong>所有的测试运行结束以后，会有一个详细的测试报告；</strong></p>
<p>断言分类：<br>
简单断言、数组断言、组合断言、异常断言、超时断言、快速失败</p>
<p><strong>断言：前面的断言失败，后面的断言都不会执行</strong></p>
<h4> 1、简单断言</h4>
<p>用来对单个值进行简单的验证。如：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>assertEquals</td>
<td>判断两个对象或两个原始类型是否相等</td>
</tr>
<tr>
<td>assertNotEquals</td>
<td>判断两个对象或两个原始类型是否不相等</td>
</tr>
<tr>
<td>assertSame</td>
<td>判断两个对象引用是否指向同一个对象</td>
</tr>
<tr>
<td>assertNotSame</td>
<td>判断两个对象引用是否指向不同的对象</td>
</tr>
<tr>
<td>assertTrue</td>
<td>判断给定的布尔值是否为 true</td>
</tr>
<tr>
<td>assertFalse</td>
<td>判断给定的布尔值是否为 false</td>
</tr>
<tr>
<td>assertNull</td>
<td>判断给定的对象引用是否为 null</td>
</tr>
<tr>
<td>assertNotNull</td>
<td>判断给定的对象引用是否不为 null</td>
</tr>
</tbody>
</table>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2、数组断言</h4>
<p>通过 assertArrayEquals 方法来判断两个对象或原始类型的数组是否相等</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3、组合断言</h4>
<p>assertAll 方法接受多个 org.junit.jupiter.api.Executable 函数式接口的实例作为要验证的断言，可以通过 lambda 表达式很容易的提供这些断言</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4、异常断言</h4>
<p>在JUnit4时期，想要测试方法的异常情况时，需要用**@Rule<strong>注解的ExpectedException变量还是比较麻烦的。而JUnit5提供了一种新的断言方式</strong>Assertions.assertThrows()** ,配合函数式编程就可以进行使用。</p>
<p>异常断言：一般断定业务逻辑一定出现异常</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 5、超时断言</h4>
<p>Junit5还提供了<strong>Assertions.assertTimeout()</strong> 为测试方法设置了超时时间</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 6、快速失败</h4>
<p>通过 fail 方法直接使得测试失败</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4、前置条件（assumptions）</h3>
<p>JUnit 5 中的前置条件（assumptions【假设】）类似于断言，不同之处在于<strong>不满足的断言会使得测试方法失败</strong>，而不满足的<strong>前置条件只会使得测试方法的执行终止</strong>。前置条件可以看成是测试方法执行的前提，当该前提不满足时，就没有继续执行的必要。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>assumeTrue 和 assumFalse 确保给定的条件为 true 或 false，不满足条件会使得<strong>测试执行终止</strong>。<br>
assumingThat 的参数是表示条件的布尔值和对应的 Executable 接口的实现对象。只有条件满足时，Executable 对象才会被执行；当条件不满足时，测试执行并不会终止。</p>
<h3> 5、嵌套测试</h3>
<p>JUnit 5 可以通过 Java 中的内部类和@Nested 注解实现嵌套测试，从而可以更好的把相关的测试方法组织在一起。在内部类中可以使用@BeforeEach 和@AfterEach 注解，而且嵌套的层次没有限制。</p>
<p>嵌套测试情况下，<strong>外层的Test不能驱动内层的Before(After)Each/All之类的方法</strong>提前/之后运行<br>
<strong>内层的Test可以驱动外层的Before(After)Each/All之类的方法</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6、参数化测试</h3>
<p>参数化测试是JUnit5很重要的一个新特性，它使得用不同的参数多次运行测试成为了可能，也为我们的单元测试带来许多便利。<br>
利用**@ValueSource**等注解，指定入参，我们将可以使用不同的参数进行多次单元测试，而不需要每新增一个参数就新增一个单元测试，省去了很多冗余代码。</p>
<p><strong>@ValueSource</strong>: 为参数化测试指定入参来源，支持<strong>八大基础类以及String类型,Class类型</strong><br>
<strong>@NullSource</strong>: 表示为参数化测试提供一个null的入参<br>
<strong>@EnumSource</strong>: 表示为参数化测试提供一个枚举入参<br>
<strong>@CsvFileSource</strong>：表示读取指定CSV文件内容作为参数化测试入参<br>
<strong>@MethodSource</strong>：表示读取指定方法的返回值作为参数化测试入参(注意方法返回需要是一个流)</p>
<p>CSV,YML,JSON 文件甚至方法的返回值也可以作为入参。只需要去实现<strong>ArgumentsProvider</strong>接口，任何外部文件都可以作为它的入参。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7、迁移指南</h3>
<p>使用junit5测试，在进行迁移的时候需要注意如下的变化：<br>
注解在 org.junit.jupiter.api 包中，断言在 org.junit.jupiter.api.Assertions 类中，前置条件在 org.junit.jupiter.api.Assumptions 类中。<br>
把@Before 和@After 替换成@BeforeEach 和@AfterEach。<br>
把@BeforeClass 和@AfterClass 替换成@BeforeAll 和@AfterAll。<br>
把@Ignore 替换成@Disabled。<br>
把@Category 替换成@Tag。<br>
把@RunWith、@Rule 和@ClassRule 替换成@ExtendWith。</p>
<h2> 8、指标监控</h2>
<h3> 1、SpringBoot Actuator</h3>
<h4> 1、简介</h4>
<p>未来每一个微服务在云上部署以后，我们都需要对其进行监控、追踪、审计、控制等。SpringBoot就抽取了Actuator场景，使得我们每个微服务快速引用即可获得生产级别的应用监控、审计等功能。</p>
<p>引入场景：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2、1.x与2.x的不同</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230131173627517.png" alt="image-20230131173627517" loading="lazy"></p>
<h4> 3、如何使用</h4>
<p>引入场景<br>
访问 <strong><a href="http://localhost:8080/actuator/%5C*%5C" target="_blank" rel="noopener noreferrer">http://localhost:8080/actuator/\*\</a></strong>*</p>
<p>暴露所有监控信息为HTTP:</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4、可视化</h4>
<p><a href="https://github.com/codecentric/spring-boot-admin" target="_blank" rel="noopener noreferrer">https://github.com/codecentric/spring-boot-admin</a></p>
<h3> 2、Actuator Endpoint</h3>
<h4> 1、最常使用的端点</h4>
<table>
<thead>
<tr>
<th>ID</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>auditevents</code></td>
<td>暴露当前应用程序的审核事件信息。需要一个<code>AuditEventRepository组件</code>。</td>
</tr>
<tr>
<td><code>beans</code></td>
<td>显示应用程序中所有Spring Bean的完整列表。</td>
</tr>
<tr>
<td><code>caches</code></td>
<td>暴露可用的缓存。</td>
</tr>
<tr>
<td><code>conditions</code></td>
<td>显示自动配置的所有条件信息，包括匹配或不匹配的原因。</td>
</tr>
<tr>
<td><code>configprops</code></td>
<td>显示所有<code>@ConfigurationProperties</code>。</td>
</tr>
<tr>
<td><code>env</code></td>
<td>暴露Spring的属性<code>ConfigurableEnvironment</code></td>
</tr>
<tr>
<td><code>flyway</code></td>
<td>显示已应用的所有Flyway数据库迁移。 需要一个或多个<code>Flyway</code>组件。</td>
</tr>
<tr>
<td><code>health</code></td>
<td>显示应用程序运行状况信息。</td>
</tr>
<tr>
<td><code>httptrace</code></td>
<td>显示HTTP跟踪信息（默认情况下，最近100个HTTP请求-响应）。需要一个<code>HttpTraceRepository</code>组件。</td>
</tr>
<tr>
<td><code>info</code></td>
<td>显示应用程序信息。</td>
</tr>
<tr>
<td><code>integrationgraph</code></td>
<td>显示Spring <code>integrationgraph</code> 。需要依赖<code>spring-integration-core</code>。</td>
</tr>
<tr>
<td><code>loggers</code></td>
<td>显示和修改应用程序中日志的配置。</td>
</tr>
<tr>
<td><code>liquibase</code></td>
<td>显示已应用的所有Liquibase数据库迁移。需要一个或多个<code>Liquibase</code>组件。</td>
</tr>
<tr>
<td><code>metrics</code></td>
<td>显示当前应用程序的“指标”信息。</td>
</tr>
<tr>
<td><code>mappings</code></td>
<td>显示所有<code>@RequestMapping</code>路径列表。</td>
</tr>
<tr>
<td><code>scheduledtasks</code></td>
<td>显示应用程序中的计划任务。</td>
</tr>
<tr>
<td><code>sessions</code></td>
<td>允许从Spring Session支持的会话存储中检索和删除用户会话。需要使用Spring Session的基于Servlet的Web应用程序。</td>
</tr>
<tr>
<td><code>shutdown</code></td>
<td>使应用程序正常关闭。默认禁用。</td>
</tr>
<tr>
<td><code>startup</code></td>
<td>显示由<code>ApplicationStartup</code>收集的启动步骤数据。需要使用<code>SpringApplication</code>进行配置<code>BufferingApplicationStartup</code>。</td>
</tr>
<tr>
<td><code>threaddump</code></td>
<td>执行线程转储。</td>
</tr>
</tbody>
</table>
<p>如果您的应用程序是Web应用程序（Spring MVC，Spring WebFlux或Jersey），则可以使用以下附加端点：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>heapdump</code></td>
<td>返回<code>hprof</code>堆转储文件。</td>
</tr>
<tr>
<td><code>jolokia</code></td>
<td>通过HTTP暴露JMX bean（需要引入Jolokia，不适用于WebFlux）。需要引入依赖<code>jolokia-core</code>。</td>
</tr>
<tr>
<td><code>logfile</code></td>
<td>返回日志文件的内容（如果已设置<code>logging.file.name</code>或<code>logging.file.path</code>属性）。支持使用HTTP<code>Range</code>标头来检索部分日志文件的内容。</td>
</tr>
<tr>
<td><code>prometheus</code></td>
<td>以Prometheus服务器可以抓取的格式公开指标。需要依赖<code>micrometer-registry-prometheus</code>。</td>
</tr>
</tbody>
</table>
<p>最常用的Endpoint（端点）<br>
<strong>Health：监控状况</strong><br>
<strong>Metrics：运行时指标</strong><br>
<strong>Loggers：日志记录</strong></p>
<h4> 2、Health Endpoint</h4>
<p>健康检查端点，我们一般用于在云平台，平台会定时的检查应用的健康状况，我们就需要Health Endpoint可以为平台返回当前应用的一系列组件健康状况的集合。</p>
<p>重要的几点：<br>
health endpoint返回的结果，应该是一系列健康检查后的一个汇总报告<br>
很多的健康检查默认已经自动配置好了，比如：数据库、redis等<br>
可以很容易的添加自定义的健康检查机制</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3、Metrics Endpoint</h4>
<p>提供详细的、层级的、空间指标信息，这些信息可以被pull（主动推送）或者push（被动获取）方式得到；</p>
<ul>
<li>通过Metrics对接多种监控系统</li>
<li>简化核心Metrics开发</li>
<li>添加自定义Metrics或者扩展已有Metrics</li>
</ul>
<h4> 4、管理Endpoints</h4>
<h6> 1、开启与禁用Endpoints</h6>
<p>默认所有的Endpoint除shutdown都是开启的。<br>
需要开启或者禁用某个Endpoint。配置模式为  management.endpoint.&lt;endpointName&gt;.enabled = true<br>
或者禁用所有的Endpoint然后手动开启指定的Endpoint</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 2、暴露Endpoints</h5>
<p>支持的暴露方式</p>
<ul>
<li>HTTP：默认只暴露<strong>health</strong>和<strong>info</strong> Endpoint</li>
<li><strong>JMX</strong>：默认暴露所有Endpoint</li>
<li>除health和info，剩下的Endpoint都应该进行保护访问。如果引入SpringSecurity，则会默认配置安全访问规则</li>
</ul>
<h5> 3、定制 Endpoint</h5>
<h6> 1、定制 Health 信息</h6>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h6> 2、定制Metrics信息</h6>
<p>增加定制Metrics</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h6> 3、定制Endpoint</h6>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 9、原理解析</h2>
<h3> 1、Profile功能</h3>
<p>为了方便多环境适配，springboot简化了profile功能。（在不同的生产环境下切换不同的配置文件）</p>
<h4> 1、application-profile功能</h4>
<p>默认配置文件  application.yaml；任何时候都会加载<br>
指定环境配置文件  application-{参数}.yaml<br>
激活指定环境：<br>
配置文件激活<br>
命令行激活：java -jar xxx.jar --<strong>spring.profiles.active=prod  --person.name=haha</strong><br>
修改配置文件的任意值，命令行优先<br>
默认配置与环境配置同时生效<br>
同名配置项，profile配置优先</p>
<h4> 2、@Profile条件装配功能</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3、profile分组</h4>
<div class="language-properties line-numbers-mode" data-ext="properties"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2、外部化配置</h3>
<h4> 1、外部配置源</h4>
<p>常用：<strong>Java属性文件</strong>、<strong>YAML文件</strong>、<strong>环境变量</strong>、<strong>命令行参数</strong>；</p>
<h4> 2、配置文件查找位置</h4>
<p>(1) classpath 根路径</p>
<p>(2) classpath 根路径下config目录</p>
<p>(3) jar包当前目录</p>
<p>(4) jar包当前目录的config目录</p>
<p>(5) /config子目录的直接子目录</p>
<h4> 3、配置文件加载顺序：</h4>
<ol>
<li>当前jar包内部的application.properties和application.yml</li>
<li>当前jar包内部的application-{profile}.properties 和 application-{profile}.yml</li>
<li>引用的外部jar包的application.properties和application.yml</li>
<li>引用的外部jar包的application-{profile}.properties 和 application-{profile}.yml</li>
</ol>
<h4> 4、指定环境优先，外部优先，后面的可以覆盖前面的同名配置项</h4>
<h3> 3、自定义starter</h3>
<h4> 1、starter启动原理</h4>
<p>starter-pom（pom的场景启动器）引入 <strong>autoconfigurer</strong> 包<br>
autoconfigure包中配置使用 META-INF/spring.factories 中 EnableAutoConfiguration 的值，使得项目启动加载指定的自动配置类</p>
<p>starter→autoconfigure→spring-boot-starter</p>
<p>编写自动配置类 xxxAutoConfiguration -&gt; xxxxProperties</p>
<p>引入starter --- xxxAutoConfiguration --- 容器中放入组件 ---- 绑定xxxProperties ---- 配置项</p>
<h4> 2、自定义starter</h4>
<p>atguigu-hello-spring-boot-starter（启动器）<br>
atguigu-hello-spring-boot-starter-autoconfigure（自动配置包）</p>
<h3> 4、SpringBoot原理</h3>
<p>Spring原理、SpringMVC原理、自动配置原理、SpringBoot原理</p>
<h4> 1、SpringBoot启动过程</h4>
<p>分两大步：</p>
<p><strong>①创建 SpringApplication</strong><br>
保存一些信息<br>
判断当前应用的类型（通过 ClassUtils 类：原生servlet 还是 响应式编程）<br>
获取所有初始化启动引导器 bootstrappers（去spring.factories文件中找）<br>
找 ApplicationContextInitializer（去spring.factories找）<br>
找 ApplicationListener  ；应用监听器（去spring.factories找）</p>
<p><strong>②运行SpringApplication</strong><br>
StopWahtch：监听整个应用程序启动停止的监听器<br>
记录应用启动时间<br>
创建引导上下文（Context环境）<br>
获取到所有之前的 bootstrappers 挨个执行 intitialize() 来完成对引导启动器上下文环境设置<br>
让当前应用进入headless模式（简言之就是自力更生模式）<br>
获取所有 RunListener保存到SpringApplicationRunListene（运行监听器）（为了方便所有Listener进行事件感知）<br>
遍历 SpringApplicationRunListener 调用 starting 方法（项目正在 starting）<br>
保存命令行参数；ApplicationArguments<br>
准备环境 prepareEnvironment（）<br>
返回或者创建基础环境信息对象<br>
<strong>创建IOC容器</strong>（createApplicationContext（））	<br>
根据项目类型（Servlet）创建容器<br>
遍历所有的 ApplicationContextInitializer 。调用 initialize.。来对ioc容器进行初始化扩展功能<br>
遍历所有的 listener 调用 contextPrepared。EventPublishRunListenr；通知所有的监听器contextPrepared<br>
刷新IOC容器。refreshContext<br>
创建容器中的所有组件（Spring注解）<br>
所有监听 器 调用 listeners.started(context); 通知所有的监听器 started<br>
调用所有runners；callRunners()<br>
获取容器中的 ApplicationRunner<br>
获取容器中的  CommandLineRunner<br>
如果以上有异常，调用Listener 的 failed</p>
<h4> 2、Application Events and Listeners</h4>
<p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-application-events-and-listeners" target="_blank" rel="noopener noreferrer">https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-application-events-and-listeners</a></p>
<h4> 3、ApplicationRunner 与 CommandLineRunner</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230201174654270.png" alt="image-20230201174654270" loading="lazy"></p>
<h2> 10、常见问题</h2>
<p>1、过滤器与拦截器的区别是什么</p>
<p>过滤器(Filter)和拦截器(Interceptor)都是在Web应用程序中用于拦截请求和响应的机制，但它们之间有以下几个区别：</p>
<ol>
<li>触发时间：过滤器在请求被分发给目标资源之前拦截请求，而拦截器在请求被分发给目标处理器(例如Controller)之前或之后拦截请求。</li>
<li>应用范围：过滤器可以在Web应用程序中的任何地方使用，而拦截器只能在Spring MVC应用程序中使用。</li>
<li>执行顺序：过滤器的执行顺序是根据它们在Web.xml中的声明顺序执行的，而拦截器的执行顺序是根据它们在Spring配置文件中的声明顺序执行的。</li>
<li>功能不同：过滤器是用于过滤请求和响应，例如修改请求参数，添加HTTP头等等。而拦截器用于在请求处理前或后执行某些操作，例如权限检查，日志记录等等。</li>
<li>对于返回结果的处理：过滤器可以直接处理请求和响应的内容，而拦截器只能拦截请求和响应的处理流程，无法直接处理内容。</li>
</ol>
<p>综上所述，虽然过滤器和拦截器都是用于拦截请求和响应的机制，但它们的触发时间、应用范围、执行顺序、功能和对于返回结果的处理等方面都存在差异。在实际开发中，开发人员应该根据具体的需求来选择合适的机制。</p>
]]></content:encoded>
      <enclosure url="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230120113626334.png" type="image/png"/>
    </item>
    <item>
      <title>SpringCloud 基础</title>
      <link>https://T4mako.github.io/code/java/SpringCloud%E5%9F%BA%E7%A1%80.html</link>
      <guid>https://T4mako.github.io/code/java/SpringCloud%E5%9F%BA%E7%A1%80.html</guid>
      <source url="https://T4mako.github.io/rss.xml">SpringCloud 基础</source>
      <description>1、微服务介绍 单体架构：将业务的所有能集中在一个项目中开发，打成一个包部署 优点：架构简单，部署成本低 缺点：耦合度高 分布式架构：根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，称为一个服务。 优点：降低服务耦合、有利于服务升级拓展 缺点：架构复杂，难度大</description>
      <category>java</category>
      <content:encoded><![CDATA[<h2> 1、微服务介绍</h2>
<p><strong>单体架构</strong>：将业务的所有能集中在一个项目中开发，打成一个包部署<br>
优点：架构简单，部署成本低<br>
缺点：耦合度高</p>
<p><strong>分布式架构</strong>：根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，称为一个服务。<br>
优点：降低服务耦合、有利于服务升级拓展<br>
缺点：架构复杂，难度大</p>
  <!-- more -->
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230321132615.png" alt="" loading="lazy"></p>
<p>分布式架构要考虑的问题：<br>
服务拆分粒度如何？服务集群地址如何维护？服务之间如何实现远程调用？服务健康状态如何感知？</p>
<p><strong>微服务</strong>：微服务是一种经过<strong>良好架构设计的分布式架构方案</strong>，微服务架构特征：<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230321134134.png" alt="" loading="lazy"></p>
<p>微服务技术对比：<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230321134826.png" alt="" loading="lazy"></p>
<p>企业需求：<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230321134909.png" alt="" loading="lazy"></p>
<h2> 2、服务拆分及远程调用</h2>
<h3> 2.1、SpringCloud介绍</h3>
<p><a href="https://spring.io/projects/spring-cloud" target="_blank" rel="noopener noreferrer">SpringCloud</a>是目前国内使用最广泛的微服务框架<br>
SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验</p>
<p>SpringCloud与SpringBoot的版本兼容关系如下：<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230321135409.png" alt="" loading="lazy"></p>
<p>本次学习的版本是Hoxton.SR10，因此对应的SpringBOot版本：2.3.x版本。</p>
<h3> 2.2、服务拆分及远程调用</h3>
<p>服务拆分注意事项：<br>
1、不同微服务，不要重复开发相同业务<br>
2、微服务数据独立，不要访问其他微服务的数据库<br>
3、微服务可以将自己的业务暴露为接口，供其他微服务调用</p>
<p>以课前资料中的微服务cloud-demo为例：</p>
<p>将项目解压到idea工作空间，通过idea打开工程文件：<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230321141027.png" alt="" loading="lazy"></p>
<h4> 2.2.1、功能需求</h4>
<p>运行项目，根据订单id查询订单的同时，返回的用户为null</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230321145505.png" alt="" loading="lazy"></p>
<p>需求：根据订单id查询订单的同时，把订单所属的用户信息一起返回，<strong>即从一个服务到另一个服务的远程调用</strong></p>
<p><strong>远程调用</strong>方式解析：<strong>在Java代码中发起Http请求</strong></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230321145718.png" alt="" loading="lazy"></p>
<h4> 2.2.2、远程调用，注册RestTemplate</h4>
<p><em><strong>RestTemplate</strong></em>：Spring提供的<strong>发送Http请求的工具</strong>，封装了HTTP请求的细节，可以快速地向其他Web服务发送GET、POST、PUT、DELETE等请求</p>
<p>在order-service的OrderApplication中<strong>注册RestTemplate</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在<strong>service中使用RestTemplate</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>两个概念：<br>
<strong>服务提供者</strong>：一次业务中，被其他微服务调用的服务（提供接口给其他微服务）<br>
<strong>服务消费者</strong>：一次业务中，调用其他微服务的服务（调用其他微服务提供的接口）<br>
若服务A调用服务B，服务B调用服务C，则它<strong>既是提供者，又是消费者</strong></p>
<h2> 3、Eureka注册中心</h2>
<h3> 3.1、Eureka的作用</h3>
<ul>
<li>消费者该如何获取服务提供者具体信息：
<ul>
<li>服务提供者启动时向eureka注册自己的信息</li>
<li>eureka保存这些信息</li>
<li>消费者根据服务名称向eureka拉去提供者信息</li>
</ul>
</li>
<li>如果有多个服务提供者，消费者该如何选择：
<ul>
<li>服务消费者利用负载均衡算法，从服务列表中挑选一个</li>
</ul>
</li>
<li>消费者如何感知服务提供者健康状态
<ul>
<li>服务提供者会每隔30s向EurekaServer发送心跳请求，报告健康状态</li>
<li>eureka会更新记录到服务列表信息，心跳不支持会被剔除</li>
<li>消费者就可以拉去到最新信息</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230321180314.png" alt="" loading="lazy"></p>
<h3> 3.2、搭建Eureka服务</h3>
<p><strong>搭建EurekaServer服务步骤如下：</strong></p>
<p>1、创建项目，引入spring-cloud-starter-netflix-eureka-<strong>server</strong>依赖</p>
<p>创建<strong>新的服务（model）</strong>，选择maven</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230322130611.png" alt="" loading="lazy"></p>
<p>2、编写<strong>启动类，添加@EnableEurekaServer</strong>注解</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3、添加application.yml文件，编写下面配置</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.3、Eureka服务注册</h3>
<p>将user-service项目引入到EurekaServer步骤如下：</p>
<p>1、在user-service项目中引入spring-cloud-starter-netflix-eureka-<strong>client</strong>依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2、在application.yml文件，编写下面配置</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另外，我们可以将user-service多次启动，模拟多实例部署，但为了避免端口冲突，需要修改端口设置</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230322133510.png" alt="" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230322133349.png" alt="" loading="lazy"></p>
<h3> 3.4、服务发现</h3>
<p>在OrderService完成服务拉取：<br>
服务拉取是基于服务名称获取服务列表，然后在服务列表做负载均衡</p>
<p>1、在OrderService的代码，修改访问的url路径，用服务名代替ip，端口：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>2、在order-service项目的启动类OrderApplication中的RestTemplate添加负载均衡注解：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 4、Ribbon负载均衡</h2>
<h3> 4.1负载均衡流程</h3>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20210713224517686.png" alt="" loading="lazy"></p>
<p>SpringCloudRibbon的底层采用了一个拦截器，拦截了RestTemplate发出的请求（拦截客户端发起的HTTP请求，RestTemplate符合，所以被拦截），获取拦截的地址，对地址做了修改。</p>
<p>基本流程如下：</p>
<ul>
<li>拦截我们的RestTemplate请求<a href="http://userservice/user/1" target="_blank" rel="noopener noreferrer">http://userservice/user/1</a></li>
<li>RibbonLoadBalancerClient会从请求url中获取服务名称，也就是userservice</li>
<li>DynamicServerListLoadBalancer根据userservice到eureka<strong>拉取服务</strong>列表</li>
<li>eureka<strong>返回列表</strong>，localhost:8081、localhost:8082</li>
<li>IRule利用<strong>内置负载均衡规则</strong>，从列表中选择一个，例如localhost:8081</li>
<li>RibbonLoadBalancerClient修改请求地址，用localhost:8081替代userservice，得到<a href="http://localhost:8081/user/1%EF%BC%8C%E5%8F%91%E8%B5%B7%E7%9C%9F%E5%AE%9E%E8%AF%B7%E6%B1%82" target="_blank" rel="noopener noreferrer">http://localhost:8081/user/1，发起真实请求</a></li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20210713224724673.png" alt="" loading="lazy"></p>
<h3> 4.2、负载均衡策略</h3>
<h4> 4.2.1.负载均衡策略</h4>
<p>Ribbon的负载均衡规则是一个叫做IRule的接口来定义的，每一个子接口都是一种规则</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20210713225653000.png" alt="" loading="lazy"></p>
<p>不同规则的含义如下：</p>
<table>
<thead>
<tr>
<th><strong>内置负载均衡规则类</strong></th>
<th><strong>规则描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>RoundRobinRule</td>
<td><strong>简单轮询</strong>服务列表来选择服务器。它是Ribbon<strong>默认</strong>的负载均衡规则。</td>
</tr>
<tr>
<td>AvailabilityFilteringRule</td>
<td>对以下两种服务器进行忽略：   （1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。  （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的<code>&lt;clientName&gt;.&lt;clientConfigNameSpace&gt;.ActiveConnectionsLimit</code>属性进行配置。</td>
</tr>
<tr>
<td>WeightedResponseTimeRule</td>
<td>为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td>
</tr>
<tr>
<td><strong>ZoneAvoidanceRule</strong></td>
<td>以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。</td>
</tr>
<tr>
<td>BestAvailableRule</td>
<td>忽略那些短路的服务器，并选择并发数较低的服务器。</td>
</tr>
<tr>
<td>RandomRule</td>
<td>随机选择一个可用的服务器。</td>
</tr>
<tr>
<td>RetryRule</td>
<td>重试机制的选择逻辑</td>
</tr>
</tbody>
</table>
<h4> 4.2.2修改Ribbon负载均衡策略</h4>
<p>通过定义IRule实现可以修改负载均衡规则，有两种方式：</p>
<ol>
<li>代码方式：在order-service中的OrderApplication类中，定义一个新的IRule：</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2">
<li>配置文件方式：在order-service的application.yml文件中，添加新的配置也可以修改规则：</li>
</ol>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p><strong>注意：一般用默认的负载均衡规则，不做修改。</strong></p>
</blockquote>
<h3> 4.3、饥饿加载</h3>
<p>Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。</p>
<p>而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 5、Nacos注册中心</h2>
<p><a href="https://nacos.io/" target="_blank" rel="noopener noreferrer">Nacos</a>是阿里巴巴的产品，现在是<a href="https://spring.io/projects/spring-cloud" target="_blank" rel="noopener noreferrer">SpringCloud</a>中的一个组件，相比<a href="https://github.com/Netflix/eureka" target="_blank" rel="noopener noreferrer">Eureka</a>功能更加丰富，在国内受欢迎程度较高</p>
<h3> 5.1、安装Nacos</h3>
<p><a href="/code/java/E:%5CStudy%5CJava%E5%90%8E%E7%AB%AF%5C14%E3%80%81SpringCloud%5C%E5%9F%BA%E7%A1%80%E7%AF%87%5Cday01-SpringCloud01%5C%E8%B5%84%E6%96%99%5CNacos%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97.html" target="blank">Nacos安装指南</a></p>
<p>在Windows下安装Nacos，安装路径：D:\Nacos</p>
<p>启动Nacos：<strong>startup.cmd -m standalone</strong> （单机启动）</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230322145507.png" alt="" loading="lazy"></p>
<p>通过地址访问Nacos</p>
<h3> 5.2、服务注册到Nacos</h3>
<p>1、在cloud-demo父工程的pom文件中的<code>&lt;dependencyManagement&gt;</code>中引入SpringCloudAlibaba的依赖：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在user-service和order-service中的pom文件中引入nacos-discovery依赖：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p><strong>注意：不要忘了注释掉eureka的依赖。</strong></p>
</blockquote>
<p>2、配置Nacos地址</p>
<p>在user-service和order-service的application.yml中添加nacos地址：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p><strong>注意：不要忘了注释掉eureka的依赖。</strong></p>
</blockquote>
<p>3、重启</p>
<p>重启微服务后，登录nacos管理页面，可以看到微服务信息：</p>
<h3> 5.3、Nacos集群配置</h3>
<h4> 5.3.1、服务分级存储模型</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20210713232522531.png" alt="" loading="lazy"></p>
<p>一个<strong>服务</strong>可以有多个<strong>实例</strong>，例如我们的user-service，可以有:<br>
127.0.0.1:8081、127.0.0.1:8082、127.0.0.1:8083</p>
<p>假如这些实例分布于全国各地的不同机房，例如：<br>
127.0.0.1:8081，在上海机房<br>
127.0.0.1:8082，在上海机房<br>
127.0.0.1:8083，在杭州机房</p>
<p>Nacos就将同一机房内的实例 划分为一个<strong>集群</strong>。</p>
<p>也就是说，user-service是服务，一个服务可以包含多个集群，如杭州、上海，每个集群下可以有多个实例，形成分级模型</p>
<p>微服务互相访问时，应该<strong>尽可能访问同集群实例</strong>，因为本地访问速度更快。当本集群内不可用时，才访问其它集群</p>
<h4> 5.3.2、给user-service配置集群</h4>
<p>修改application.yml，添加如下内容：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过修改application.yml，重启服务，实现不同集群</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230322152537.png" alt="" loading="lazy"></p>
<h4> 5.3.2、同集群优先的负载均衡</h4>
<p>Nacos中提供了一个<code>NacosRule</code>的实现，可以<strong>优先从同集群中挑选实例</strong>。</p>
<p>1）给order-service配置集群信息</p>
<p>修改order-service的application.yml文件，添加集群配置：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2）修改负载均衡规则</p>
<p>不修改负载均衡规则，依然以轮询的方式访问</p>
<p>修改order-service的application.yml文件，<strong>修改负载均衡规则</strong>：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时会优先向同集群挑选实例，<strong>同集群下默认随机访问</strong>，如果同集群挂掉，会发生跨集群访问</p>
<h3> 5.4、权重配置</h3>
<p>实际部署中会出现这样的场景：</p>
<p>服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们<strong>希望性能好的机器承担更多的用户请求</strong>。<br>
但<strong>默认情况下NacosRule是同集群内随机挑选</strong>，不会考虑机器的性能问题。<br>
因此，<strong>Nacos提供了权重配置</strong>来控制访问频率，权重越大则访问频率越高。</p>
<p>在nacos控制台，通过<strong>编辑按钮</strong>，即可<strong>修改权重</strong></p>
<p><strong>注意</strong>：如果权重修改为0，则该实例永远不会被访问</p>
<h3> 5.5、环境隔离</h3>
<p>Nacos中服务存储和数据存储的最外层都是一个名为namespace的东西，用来做最外层隔离</p>
<p>Nacos提供了<strong>namespace来实现环境隔离</strong>功能。</p>
<ul>
<li>nacos中可以有多个namespace</li>
<li>namespace下可以有group、service等</li>
<li>不同namespace之间相互隔离，例如不同namespace的服务互相不可见</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20210714000101516.png" alt="image-20210714000101516" loading="lazy"></p>
<h4> 5.5.1、创建namespace</h4>
<p>默认情况下，所有service、data、group都在同一个namespace，名为public：</p>
<p>我们可以点击页面新增按钮，添加一个namespace</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230322162127.png" alt="" loading="lazy"></p>
<h4> 5.5.2、给微服务配置namespace</h4>
<p>给微服务配置namespace只能通过修改配置来实现。</p>
<p>例如，修改order-service的application.yml文件：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时访问order-service，因为namespace不同，会导致找不到userservice，控制台会报错</p>
<h3> 5.6、Nacos与Eureka的区别</h3>
<p>Nacos的服务实例分为两种l类型：<br>
临时实例：如果实例宕机超过一定时间，会从服务列表剔除，默认的类型。|<br>
非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。</p>
<p>​	配置一个服务实例为永久实例：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Nacos和Eureka整体结构类似，服务注册、服务拉取、心跳等待，但是也存在一些差异：<br>
Nacos注册中心细节分析：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20210714001728017.png" alt="" loading="lazy"></p>
<ul>
<li>
<p>Nacos与eureka的共同点</p>
<ul>
<li>都支持服务注册和服务拉取</li>
<li>都支持服务提供者心跳方式做健康检测</li>
</ul>
</li>
<li>
<p>Nacos与Eureka的区别</p>
<ul>
<li>Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，<strong>非临时实例采用主动检测模式</strong></li>
<li>临时实例心跳不正常会被<strong>剔除</strong>，非临时实例则不会被剔除</li>
<li>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li>
<li>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</li>
</ul>
</li>
</ul>
<h2> 6、Nacos管理配置</h2>
<p>当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就会让人抓狂，而且很容易出错。所以需要一种统一配置管理方案，可以<strong>集中管理所有实例的配置</strong>。<br>
Nacos一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，实现配置的热更新。</p>
<p><strong>即将配置交给Nacos管理</strong></p>
<h3> 6.1、统一配置管理</h3>
<h4> 6.1.1、在Nacos中新建配置</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20210714164742924.png" alt="" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20210714164856664.png" alt="image-20210714164856664" loading="lazy"></p>
<blockquote>
<p>注意：项目的核心配置，<strong>需要热更新的配置才有放到nacos管理的必要</strong>。基本不会变更的一些配置还是保存在微服务本地比较好。</p>
</blockquote>
<h4> 6.1.2、配置的获取</h4>
<p>微服务要<strong>拉取nacos中管理的配置</strong>，并且<strong>与本地的application.yml配置合并</strong>，才能完成项目启动。</p>
<p>但<strong>若尚未读取application.yml，服务无法得知nacos地址</strong></p>
<p>因此<strong>spring</strong>引入了一种<strong>新的配置文件</strong>：<em><strong>bootstrap.yaml</strong></em>文件，会在application.yml之前被读取</p>
<p><strong>配置获取的步骤如下：</strong><br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/L0iFYNF.png" alt="" loading="lazy"></p>
<p>1）引入Nacos的配置管理客户端依赖</p>
<p>首先，在user-service服务中，引入nacos-config的客户端依赖：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2）在userservice中的Source目录添加一个bootstrap.yml文件，这个文件是引导文件，优先级高于application.yml</p>
<p>配置服务名称，开发环境，文件后缀名→就是Data Id，因此知道是nacos中的哪个文件<br>
配置Nacos地址，就知道去哪读取nacos中的配置文件</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>里会根据spring.cloud.nacos.server-addr获取nacos地址，再根据<br>
<code>${spring.application.name}-${spring.profiles.active}.${spring.cloud.nacos.config.file-extension}</code>作为文件id，来读取配置。<br>
本例中，就是去读取<code>userservice-dev.yaml</code>：</p>
<p>因此，可以删除application.yml中重复的配置：服务名称，Nacos地址等</p>
<p>3）读取nacos配置</p>
<p>在user-service中的UserController中添加业务逻辑，读取pattern.dateformat配置：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6.2、配置热更新</h3>
<p>在Nacos中配置文件变更后，微服务无需重启就可以感知。不过需要通过下面两种配置实现：</p>
<h4> 6.2.1、方式一</h4>
<p>在@Value注入的变量所在类上添加注解**@RefreshScope**：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 6.2.2、方式二</h4>
<p>使用**@ConfigurationProperties**注解</p>
<p>在user-service服务中，添加一个类，读取patterrn.dateformat属性：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在UserController中使用这个类代替@Value：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6.3、配置共享</h3>
<p>微服务启动时，会<strong>从nacos读取多个配置文件</strong>，例如：</p>
<ul>
<li>
<p><code>[spring.application.name]-[spring.profiles.active].yaml</code>，例如：userservice-dev.yaml</p>
</li>
<li>
<p><code>[spring.application.name].yaml</code>，例如：userservice.yaml</p>
</li>
</ul>
<p>而<code>[spring.application.name].yaml</code>这个文件一定会加载，因此多环境<strong>共享配置</strong>可以<strong>写入这个文件</strong></p>
<h4> 1）添加一个环境共享配置</h4>
<p>在nacos中添加一个userservice.yaml文件：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230323205335.png" alt="" loading="lazy"></p>
<h4> 2）在user-service中读取共享配置</h4>
<p>在user-service服务中，修改PatternProperties类，读取新添加的属性<br>
在user-service服务中，修改UserController，添加一个方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3）运行两个UserApplication，使用不同的profile</h4>
<p>修改UserApplication2这个启动项，改变其profile值：<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230323205521.png" alt="" loading="lazy"></p>
<p>这样，UserApplication(8081)使用的profile是dev，UserApplication2(8082)使用的profile是test。</p>
<p>启动UserApplication和UserApplication2，发现结果的差异<br>
可以看出来，不管是dev，还是test环境，都读取到了envSharedValue这个属性的值。</p>
<h4> 4）配置共享的优先级</h4>
<p>当nacos、服务本地同时出现相同属性时，优先级有高低之分：</p>
<p><strong>服务名-profile.yaml &gt; 服务名称.yaml &gt; 本地配置</strong></p>
<h2> 7、Nacos集群搭建</h2>
<p>Nacos生产环境下一定要部署为集群状态</p>
<h3> 7.1、集群结构图</h3>
<p>官方给出的Nacos集群图：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230323210255.png" alt="" loading="lazy"></p>
<p>其中包含3个nacos节点，然后一个负载均衡器代理3个Nacos。这里负载均衡器可以使用nginx。</p>
<p>我们计划的集群结构：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230323210319.png" alt="" loading="lazy"></p>
<p>三个nacos节点的地址：</p>
<table>
<thead>
<tr>
<th>节点</th>
<th>ip</th>
<th>port</th>
</tr>
</thead>
<tbody>
<tr>
<td>nacos1</td>
<td>192.168.137.1</td>
<td>8845</td>
</tr>
<tr>
<td>nacos2</td>
<td>192.168.137.1</td>
<td>8846</td>
</tr>
<tr>
<td>nacos3</td>
<td>192.168.137.1</td>
<td>8847</td>
</tr>
</tbody>
</table>
<h3> 7.2、集群搭建</h3>
<p>搭建集群的基本步骤：</p>
<ul>
<li>搭建数据库，初始化数据库表结构</li>
<li>下载nacos安装包</li>
<li>配置nacos</li>
<li>启动nacos集群</li>
<li>nginx反向代理</li>
</ul>
<h4> 7.2.1、初始化数据库</h4>
<p>Nacos默认数据存储在内嵌数据库Derby中，不属于生产可用的数据库。</p>
<p>这里以单点的数据库为例来讲解。</p>
<p>首先新建一个数据库，命名为nacos，而后导入相关的SQL</p>
<h4> 7.2.2、下载Nacos</h4>
<p><a href="https://github.com/alibaba/nacos/tags" target="_blank" rel="noopener noreferrer">nacos</a><br>
本例中使用1.4.1版本</p>
<h4> 7.2.3、配置Nacos</h4>
<p>进入nacos安装目录下的conf目录，修改配置文件cluster.conf.example，<strong>重命名为cluster.conf</strong></p>
<p>然后添加内容：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后修改conf文件下的application.properties文件，添加数据库配置</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230323211509.png" alt="" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230323211653.png" alt="" loading="lazy"></p>
<div class="language-properties line-numbers-mode" data-ext="properties"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7.3、启动</h3>
<p>将nacos文件夹复制三份，分别命名为：nacos1、nacos2、nacos3（模糊nacos集群）</p>
<p>然后分别修改三个文件夹中的application.properties</p>
<p>nacos1:</p>
<div class="language-properties line-numbers-mode" data-ext="properties"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>nacos2:</p>
<div class="language-properties line-numbers-mode" data-ext="properties"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>nacos3:</p>
<div class="language-properties line-numbers-mode" data-ext="properties"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后分别启动三个nacos节点：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 7.4、nginx反向代理</h3>
<p>修改nginx安装目录下的conf/nginx.conf文件，配置如下：</p>
<div class="language-nginx line-numbers-mode" data-ext="nginx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而后在浏览器访问：<a href="http://localhost/nacos%E5%8D%B3%E5%8F%AF%E3%80%82" target="_blank" rel="noopener noreferrer">http://localhost/nacos即可。</a></p>
<p>代码中application.yml文件配置如下：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 8、Feign远程调用</h2>
<p>目前利用RestTemplate发起远程调用的代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>存在下面的问题：<br>
代码可读性差，编程体验不统一<br>
参数复杂URL难以维护</p>
<p><a href="https://github.com/OpenFeign/feign" target="_blank" rel="noopener noreferrer">Feign</a>是一个声明式的http客户端，其作用就是帮助我们优雅的实现http请求的发送，解决上面提到的问题。</p>
<h3> 8.1、Feign替代RestTemplate</h3>
<p>Fegin的使用步骤如下：</p>
<h4> 1）引入依赖</h4>
<p>在order-service服务的pom文件中引入feign的依赖：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2）添加注解</h4>
<p>在order-service的启动类添加注解开启Feign的功能：</p>
<p><strong>@EnableFeginClients</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3）编写Feign的客户端</h4>
<p>在order-service中新建一个接口，内容如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请求路径为<a href="http://userservice/user/" target="_blank" rel="noopener noreferrer">http://userservice/user/</a></p>
<p>这个客户端主要是基于SpringMVC的注解来声明远程调用的信息，比如：</p>
<ul>
<li>服务名称：userservice</li>
<li>请求方式：GET</li>
<li id="">请求路径：/user/</li>
<li>请求参数：Long id</li>
<li>返回值类型：User</li>
</ul>
<p>这样，Feign就可以帮助我们发送http请求，无需自己使用RestTemplate来发送了。</p>
<h4> 5）总结</h4>
<p>使用Feign的步骤：<br>
① 引入依赖<br>
② 添加@EnableFeignClients注解<br>
③ 编写FeignClient接口<br>
④ 使用FeignClient中定义的方法代替RestTemplate</p>
<h3> 8.2、自定义配置</h3>
<p>Feign可以支持很多的自定义配置，如下表所示：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>feign.Logger.Level</strong></td>
<td>修改日志级别</td>
<td>包含四种不同的级别：NONE、BASIC、HEADERS、FULL</td>
</tr>
<tr>
<td>feign.codec.Decoder</td>
<td>响应结果的解析器</td>
<td>http远程调用的结果做解析，例如解析json字符串为java对象</td>
</tr>
<tr>
<td>feign.codec.Encoder</td>
<td>请求参数编码</td>
<td>将请求参数编码，便于通过http请求发送</td>
</tr>
<tr>
<td>feign.Contract</td>
<td>支持的注解格式</td>
<td>默认是SpringMVC的注解</td>
</tr>
<tr>
<td>feign.Retryer</td>
<td>失败重试机制</td>
<td>请求失败的重试机制，默认是没有，不过会使用Ribbon的重试</td>
</tr>
</tbody>
</table>
<p>一般情况下，默认值就能满足我们使用，如果要自定义时，只需要创建自定义的@Bean覆盖默认Bean即可。</p>
<p>配置Feign日志有两种方式：</p>
<h4> 8.2.1、配置文件方式</h4>
<p>基于配置文件修改feign的日志级别可以<strong>针对单个服务</strong>：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也可以针对所有服务（全局配置）：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而日志的级别分为四种：<br>
NONE：不记录任何日志信息，这是默认值。<br>
BASIC：仅记录请求的方法，URL以及响应状态码和执行时间<br>
HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息<br>
FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。</p>
<h4> 8.2.2、Java代码方式</h4>
<p>也可以基于Java代码来修改日志级别，<strong>先声明一个类，然后声明一个Logger.Level的对象</strong>：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果要<strong>全局生效</strong>，将其放到启动类的@EnableFeignClients这个注解中：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果是<strong>局部生效</strong>，则把它放到对应的@FeignClient这个注解中：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 8.3、Feign性能优化</h3>
<p>Feign<strong>底层发起http请求</strong>，依赖于其它的框架。其底层客户端实现包括：<br>
URLConnection：默认实现，不支持连接池<br>
Apache HttpClient ：支持连接池<br>
OKHttp：支持连接池</p>
<p>因此提高Feign的性能主要手段就是：<br>
① 使用<strong>连接池</strong>代替默认的URLConnection<br>
② 日志级别，最好使用basic或none</p>
<h4> 用Apache的HttpClient连接池</h4>
<p>1）引入依赖</p>
<p>在order-service的pom文件中引入Apache的HttpClient依赖：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2）配置连接池</p>
<p>在order-service的application.yml中添加配置：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>总结，Feign的优化：<br>
1.日志级别尽量用basic<br>
2.使用HttpClient或OKHttp代替URLConnection<br>
①  引入feign-httpClient依赖<br>
②  配置文件开启httpClient功能，设置连接池参数</p>
<h3> 8.4、Feign最佳实践</h3>
<p>Feign的客户端与服务提供者的controller代码非常相似：</p>
<p>feign客户端：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>controller：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以可以简化这种重复的代码</p>
<h4> 8.4.1、继承方式（不推荐）</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20210714190640857.png" alt="" loading="lazy"></p>
<p>缺点：</p>
<ul>
<li>
<p>服务提供方、服务消费方紧耦合</p>
</li>
<li>
<p>参数列表中的注解映射并不会继承，因此Controller中必须再次声明方法、参数列表、注解</p>
</li>
</ul>
<h4> 8.4.2、抽取方式</h4>
<p>将Feign的Client抽取为独立模块，并且把接口有关的POJO、默认的Feign配置都放到这个模块中，提供给所有消费者使用。</p>
<p>例如，将UserClient、User、Feign的默认配置都抽取到一个feign-api包中，所有微服务引用该依赖包，即可直接使用。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20210714214041796.png" alt="" loading="lazy"></p>
<h4> 8.4.3、实现Feign最佳实践</h4>
<h5> 1）抽取</h5>
<p>首先创建一个module，命名为feign-api</p>
<p>在feign-api中然后引入feign的starter依赖：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，order-service中编写的UserClient、User、DefaultFeignConfiguration都复制到feign-api项目中</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230324143244552.png" alt="image-20230324143244552" loading="lazy"></p>
<h5> 2）在order-service中使用feign-api</h5>
<p>删除order-service中的UserClient、User、DefaultFeignConfiguration等类或接口</p>
<p>在order-service的pom文件中中引入feign-api的依赖：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>修改order-service中的所有与上述三个组件有关的导包部分，改成导入feign-api中的包</p>
<h5> 3）重启测试</h5>
<p>重启后，发现服务报错了：无法注入UserClient对象</p>
<p>这是因为UserClient现在在cn.itcast.feign.clients包下，<br>
而order-service的@EnableFeignClients注解是在cn.itcast.order包下，<strong>不在同一个包，无法扫描到UserClient</strong></p>
<h5> 4）解决扫描包问题</h5>
<p>方式一（批量扫描）：</p>
<p>指定Feign应该扫描的包：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>方式二（精准定位，推荐）：</p>
<p><strong>指定需要加载的Client接口：</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 9、Gateway服务网关</h2>
<p>Spring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等响应式编程和事件流技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。</p>
<h3> 9.1、为什么需要网关</h3>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20210714210131152.png" alt="" loading="lazy"></p>
<p><strong>网关功能：</strong></p>
<ul>
<li>
<p><strong>权限控制</strong>：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。</p>
</li>
<li>
<p><strong>路由和负载均衡</strong>：一切请求都必须先经过gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。</p>
</li>
<li>
<p><strong>限流</strong>：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。</p>
</li>
</ul>
<p>在SpringCloud中网关的实现包括两种：</p>
<ul>
<li>gatewat</li>
<li>zuul</li>
</ul>
<p>Zuul是基于Servlet的实现，属于阻塞式编程。而<strong>SpringCloudGateway</strong>则是基于Spring5中提供的WebFlux，属于响应式编程的实现，具备更好的性能。</p>
<h3> 9.2、gateway快速入门</h3>
<p>搭建网关服务的步骤：</p>
<h4> 1）创建新的module，引入依赖</h4>
<p>引入SpringCloudGateway的依赖和nacos的服务发现依赖：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2）编写启动类</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3）编写路由配置及nacos地址</h4>
<p>创建application.yml文件，内容如下：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>将符合<code>Path</code> 规则的一切请求，都代理到 <code>uri</code>参数指定的地址</strong></p>
<p>本例中，我们将 <code>/user/**</code>开头的请求，代理到<code>lb://userservice</code>，lb是负载均衡，根据服务名拉取服务列表，实现负载均衡。</p>
<h4> 4）网关路由的流程图</h4>
<p>整个访问的流程如下：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20210714211742956.png" alt="" loading="lazy"></p>
<p>总结：</p>
<p>网关搭建步骤：</p>
<ol>
<li>
<p>创建项目，引入nacos服务发现和gateway依赖</p>
</li>
<li>
<p>配置application.yml，包括服务基本信息、nacos地址、路由</p>
</li>
</ol>
<p>路由配置包括：</p>
<ol>
<li>
<p>路由id：路由的唯一标示</p>
</li>
<li>
<p>路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡</p>
</li>
<li>
<p>路由断言（predicates）：判断路由的规则，</p>
</li>
<li>
<p>路由过滤器（filters）：对请求或响应做处理</p>
</li>
</ol>
<h3> 9.3、断言工厂</h3>
<p>我们在配置文件中写的断言规则只是字符串，这些字符串会被Predicate Factory读取并处理，转变为路由判断的条件</p>
<p>例如Path=/user/**是按照路径匹配，这个规则是由<code>org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory</code>类来<br>
处理的，像这样的断言工厂在SpringCloudGateway还有十几个:</p>
<table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>说明</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>After</td>
<td>是某个时间点后的请求</td>
<td>-  After=2037-01-20T17:42:47.789-07:00[America/Denver]</td>
</tr>
<tr>
<td>Before</td>
<td>是某个时间点之前的请求</td>
<td>-  Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]</td>
</tr>
<tr>
<td>Between</td>
<td>是某两个时间点之前的请求</td>
<td>-  Between=2037-01-20T17:42:47.789-07:00[America/Denver],  2037-01-21T17:42:47.789-07:00[America/Denver]</td>
</tr>
<tr>
<td>Cookie</td>
<td>请求必须包含某些cookie</td>
<td>- Cookie=chocolate, ch.p</td>
</tr>
<tr>
<td>Header</td>
<td>请求必须包含某些header</td>
<td>- Header=X-Request-Id, \d+</td>
</tr>
<tr>
<td>Host</td>
<td>请求必须是访问某个host（域名）</td>
<td>-  Host=<strong>.somehost.org,</strong>.anotherhost.org</td>
</tr>
<tr>
<td>Method</td>
<td>请求方式必须是指定方式</td>
<td>- Method=GET,POST</td>
</tr>
<tr>
<td><strong>Path</strong></td>
<td>请求路径必须符合指定规则</td>
<td>- Path=/red/{segment},/blue/**</td>
</tr>
<tr>
<td>Query</td>
<td>请求参数必须包含指定参数</td>
<td>- Query=name, Jack或者-  Query=name</td>
</tr>
<tr>
<td>RemoteAddr</td>
<td>请求者的ip必须是指定范围</td>
<td>- RemoteAddr=192.168.1.1/24</td>
</tr>
<tr>
<td>Weight</td>
<td>权重处理</td>
<td></td>
</tr>
</tbody>
</table>
<h3> 9.4、路由过滤器GateFilter</h3>
<p>GatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20210714212312871.png" alt="" loading="lazy"></p>
<p>过滤器的作用：<br>
① 对路由的请求或响应做加工处理，比如添加请求头<br>
② 配置在路由下的过滤器只对当前路由的请求生效</p>
<p>defaultFilters的作用：<br>
① 对所有路由都生效的过滤器</p>
<h4> 9.4.1、路由过滤器的种类</h4>
<p>Spring提供了31种不同的路由过滤器工厂。例如：</p>
<table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>AddRequestHeader</td>
<td>给当前请求添加一个请求头</td>
</tr>
<tr>
<td>RemoveRequestHeader</td>
<td>移除请求中的一个请求头</td>
</tr>
<tr>
<td>AddResponseHeader</td>
<td>给响应结果中添加一个响应头</td>
</tr>
<tr>
<td>RemoveResponseHeader</td>
<td>从响应结果中移除有一个响应头</td>
</tr>
<tr>
<td>RequestRateLimiter</td>
<td>限制请求的流量</td>
</tr>
</tbody>
</table>
<h4> 9.4.2、请求头过滤器</h4>
<p>以AddRequestHeader 为例：</p>
<blockquote>
<p>需求：给所有进入userservice的请求添加一个请求头：Truth=itcast is freaking awesome!</p>
</blockquote>
<p>只需要修改gateway服务的application.yml文件，添加路由过滤即可：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当前过滤器写在userservice路由下，因此<strong>仅仅对访问userservice的请求有效</strong>。</p>
<h4> 9.4.3、默认过滤器</h4>
<p>如果要对所有的路由都生效，则可以将过滤器工厂写到default下。格式如下：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 9.5、全局过滤器</h3>
<h4> 9.5.1.全局过滤器作用</h4>
<p>全局过滤器是处理一切进入网关的请求和微服务响应，与GatewayFilter的作用一样</p>
<p>它与GatewayFilter的区别：<br>
GatewayFilter通过配置定义，处理逻辑是固定的。而GlobalFilter的逻辑需要自己写代码实现<br>
（即复杂的逻辑可以自定义实现）</p>
<p>全局过滤器定义方式是<strong>实现GlobalFilter接口</strong>。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在filter中编写自定义逻辑，可以实现下列功能：<br>
登录状态判断、权限校验、请求限流等</p>
<h4> 9.5.2、自定义全局过滤器</h4>
<p>需求：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件：<br>
① 参数中是否有authorization<br>
② authorization参数值是否为admin<br>
如果同时满足则放行，否则拦截</p>
<p>实现：<br>
在gateway中定义一个过滤器：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 9.5.3、过滤器执行顺序</h4>
<p>请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter</p>
<p><em><strong>请求路由后</strong></em>，会将<strong>当前路由过滤器和DefaultFilter，GLobalFilter</strong>合并到一个<strong>过滤器链</strong>（集合）中，排序后依此执行每个过滤器</p>
<p><em><strong>排序的规则</strong></em>：</p>
<ul>
<li>每一个过滤器都必须指定一个int类型的order值，<strong>order值越小，优先级越高，执行顺序越靠前</strong>。</li>
<li>GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定</li>
<li>路由过滤器和defaultFilter的order<strong>由Spring指定</strong>，默认是<strong>按照声明顺序从1递增</strong>。（路由过滤器和defaultFilter分开计算）</li>
<li>当过滤器的<strong>order值一样时</strong>，会按照 <strong>defaultFilter &gt; 路由过滤器 &gt; GlobalFilter</strong>的顺序执行。</li>
</ul>
<h3> 9.6.跨域问题</h3>
<h4> 9.6.1.什么是跨域问题</h4>
<p>跨域：用于限制一个网页或应用程序的访问另一个源（网域）的资源，域名不一致就是跨域，主要包括：</p>
<ul>
<li>
<p>域名不同： <a href="http://www.taobao.com" target="_blank" rel="noopener noreferrer">www.taobao.com</a> 和 <a href="http://www.taobao.org" target="_blank" rel="noopener noreferrer">www.taobao.org</a> 和 <a href="http://www.jd.com" target="_blank" rel="noopener noreferrer">www.jd.com</a> 和 <a href="http://miaosha.jd.com" target="_blank" rel="noopener noreferrer">miaosha.jd.com</a></p>
</li>
<li>
<p>域名相同，端口不同：localhost:8080和localhost8081</p>
</li>
</ul>
<p>跨域问题：浏览器禁止请求的发起者与服务端发生跨域ajax请求，请求被浏览器拦截的问题</p>
<p>解决方案：CORS，可以查看<a href="https://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener noreferrer">https://www.ruanyifeng.com/blog/2016/04/cors.html</a></p>
<h4> 9.6.2.解决跨域问题</h4>
<p>比如：从localhost:8090访问localhost:10010，端口不同，显然是跨域的请求。</p>
<p>在gateway服务的application.yml文件中，添加下面的配置：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230321132615.png" type="image/png"/>
    </item>
    <item>
      <title>SpringMVC 基础</title>
      <link>https://T4mako.github.io/code/java/SpringMVC.html</link>
      <guid>https://T4mako.github.io/code/java/SpringMVC.html</guid>
      <source url="https://T4mako.github.io/rss.xml">SpringMVC 基础</source>
      <description>1、SpringMVC简介 1、什么是MVC MVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分</description>
      <category>java</category>
      <content:encoded><![CDATA[<h2> 1、SpringMVC简介</h2>
<h3> 1、什么是MVC</h3>
<p>MVC是一种软件架构的<strong>思想</strong>，将软件按照<strong>模型、视图、控制器</strong>来划分</p>
<!-- more -->
<p>M：<strong>Model</strong>，模型层，指工程中的JavaBean，作用是处理数据<br>
JavaBean分为两类：<br>
一类称为<strong>实体类Bean</strong>：专门存储业务数据的，如 <strong>Student、User</strong> 等<br>
一类称为<strong>业务处理 Bean</strong>：指 <strong>Service 或 Dao 对象</strong>，专门用于处理业务逻辑和数据访问。</p>
<p>V：<strong>View</strong>，视图层，指工程中的<strong>html或jsp等页面</strong>，作用是与用户进行交互，展示数据</p>
<p>C：<strong>Controller</strong>，控制层，指<strong>工程中的servlet</strong>，作用是<strong>接收请求和响应浏览器</strong></p>
<p>MVC的工作流程： 用户通过视图层发送请求到服务器，在服务器中请求被Controller接收，Controller调用相应的Model层处理请求，处理完毕将结果返回到Controller，Controller再根据请求处理的结果找到相应的View视图，渲染数据后最终响应给浏览器<br>
<strong>用户→View→Controller→Model→Controller→View→浏览器</strong></p>
<h3> 2、什么是SpringMVC</h3>
<p>SpringMVC是Spring的一个后续产品，是Spring的一个子项目</p>
<p>SpringMVC 是 Spring 为表述层开发提供的一整套完备的解决方案。在表述层框架历经 Strust、WebWork、Strust2 等诸多产品的历代更迭之后，目前业界普遍选择了 SpringMVC 作为 Java EE 项目表述层开发的首选方案<br>
注：三层架构分为<strong>表述层（或表示层）</strong>、<strong>业务逻辑层（业务层）</strong>、<strong>数据访问层（持久层）</strong><br>
<strong>表述层表示前台页面和后台servlet</strong></p>
<h3> 3、SpringMVC的特点</h3>
<p>Spring 家族原生产品，与 IOC 容器等基础设施无缝对接<br>
基于原生的Servlet，通过了功能强大的<strong>前端控制器DispatcherServlet</strong>，对请求和响应进行统一处理<br>
表述层各细分领域需要解决的问题全方位覆盖，提供全面解决方案<br>
代码清新简洁，大幅度提升开发效率<br>
内部组件化程度高，可插拔式组件即插即用，想要什么功能配置相应组件即可<br>
性能卓著，尤其适合现代大型、超大型互联网项目要求</p>
<h2> 2、入门案例</h2>
<h3> 1、创建maven工程</h3>
<p>①添加web模块</p>
<p>注意创建web.xml文件目录需要修改为如下图：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230222202004184.png" alt="image-20230222202004184" loading="lazy"></p>
<p>②打包方式：war</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>③引入依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2、配置web.xml</h3>
<p><strong>注册SpringMVC的前端控制器DispatcherServlet</strong></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3、创建请求控制器</h3>
<p>由于前端控制器对浏览器发送的请求进行了统一的处理，但是<strong>具体的请求有不同的处理过程</strong>，因此需要创建处理具体请求的类，即<strong>请求控制器</strong><br>
请求控制器中每一个处理请求的方法成为控制器方法<br>
因为SpringMVC的控制器由一个POJO（普通的Java类）担任，因此需要通过@Controller注解将其标识为一个控制层组件，交给Spring的IOC容器管理，此时SpringMVC才能够识别控制器的存在</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4、创建SpringMVC的配置文件</h3>
<p>SpringMVC的配置文件<strong>默认</strong>的位置和名称：<br>
位置：WEB-INF下<br>
名称：&lt;servlet-name&gt;-servlet.xml（web.xml文件下），所以当前配置下的配置文件名为SpringMVC-servlet.xml</p>
<p><strong>但配置文件一般都要放在resources下，因此在web.xml文件中添加&lt;init-param&gt;，配置springmvc的配置文件</strong><br>
<strong>所以，springmvc的配置文件一般放在resources下的springmvc.xml中</strong></p>
<p><strong>目标（物理视图）：/WEB-INF/templates/index.html<br>
视图前缀：/WEB-INF/templates/<br>
视图后缀：.html<br>
逻辑视图：index</strong></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5、配置Tomcat</h3>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230222202824265.png" alt="image-20230222202824265" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230109150922942.png" alt="image-20230109150922942" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230109151044511.png" alt="image-20230109151044511" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230109151102714.png" alt="image-20230109151102714" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230109151143776.png" alt="image-20230109151143776" loading="lazy"></p>
<p><strong>不同的上下文对应Web服务器（单个Tomcat）中不同的工程</strong></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230109151316851.png" alt="image-20230109151316851" loading="lazy"></p>
<p>**热部署 **</p>
<h3> 6、测试HelloWorld</h3>
<h4> ①实现对首页的访问</h4>
<p>在请求控制器中创建处理请求的方法</p>
<p>@RequestMapping注解：处理请求和控制器方法之间的映射关系<br>
@RequestMapping注解的<strong>value属性</strong>可以<strong>通过请求地址匹配请求</strong>，<strong>/表示的当前工程的上下文路径</strong>，匹配成功则执行对应的方法<br>
return的String字符串为对应的<strong>逻辑视图名称</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> ②通过超链接跳转到指定页面</h4>
<p>在主页index.html中设置超链接</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在请求控制器中创建处理请求的方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7、总结</h3>
<p><strong>浏览器发送请求</strong>，若请求地址<strong>符合前端控制器的url-pattern</strong>，该请求就会被前端控制器<strong>DispatcherServlet处理</strong>。前端控制器会<strong>读取SpringMVC的核心配置文件</strong>，通过<strong>扫描组件找到控制器</strong>，将请求地址和控制器中**@RequestMapping注解的value属性值进行匹配**，若匹配成功，该注解所标识的控制器方法就是处理请求的方法。处理请求的方法需要返回一个字符串类型的视图名称，该视图名称会被视图解析器解析，加上前缀和后缀组成视图的路径，通过Thymeleaf对视图进行渲染，最终转发到视图所对应页面</p>
<h3> 8、web.xml的改进</h3>
<p>设置SpringMVC核心配置文件的位置和名称<br>
将DispatcherServlet的初始化时间提前到服务器启动时</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3、@RequestMapping注解</h2>
<h3> 1、@RequestMapping注解的功能</h3>
<p>从注解名称上我们可以看到，@RequestMapping注解的作用就是将请求和处理请求的控制器方法关联起来，建立映射关系。<br>
SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的控制器方法来处理这个请求。</p>
<h3> 2、@RequestMapping注解的位置</h3>
<p>@RequestMapping<strong>标识一个类</strong>：设置映射请求的<strong>请求路径的初始信息</strong><br>
@RequestMapping<strong>标识一个方法</strong>：设置映射请求请求<strong>路径的具体信息</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3、@RequestMapping注解的value属性</h3>
<p>作用：通过请求的请求路径匹配请求<br>
<strong>value属性是数组类型</strong>，即当前浏览器发送请求的请求路径匹配<strong>value属性中的任何一个值</strong>，则当前请求就会被注解所表示的方法<strong>进行处理</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4、@RequestMapping注解的method属性</h3>
<p>作用：通过请求的<strong>请求方式匹配请求</strong><br>
method属性是RequestMethod类型的<strong>数组</strong>，即当前浏览器所发送的请路径匹配method属性中的任何一种请求方式<br>
若<strong>浏览器发送请求</strong>的请求路径和@RequestMapping的value值匹配，但<strong>请求方式和method值不匹配，报405错误</strong><br>
默认值为都支持</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在@RequestMapping的基础上，结合请求方式的一些派生注解：<br>
@GetMapping，@PostMapping，@DeleteMapping，@PutMapping</p>
<h3> 5、@RequestMapping注解的params属性（了解）</h3>
<p>作用：通过请求的请求参数匹配请求，即浏览器发送的请求的请求参数必须满足params属性的设置<br>
params可以使用四种表达式：<br>
"param"：要求请求映射所匹配的请求必须携带param请求参数<br>
"!param"：要求请求映射所匹配的请求必须不能携带param请求参数<br>
"param=value"：要求请求映射所匹配的请求必须携带param请求参数且param=value<br>
"param!=value"：要求请求映射所匹配的请求必须携带param请求参数但是param!=value</p>
<p>若当前请求满足@RequestMapping注解的value和method属性，但是不满足params属性，此时页面回报错400</p>
<h3> 6、@RequestMapping注解的headers属性（了解）</h3>
<p>作用：通过请求的请求头匹配请求，即浏览器发送的请求头信息必须满足headers属性的设置<br>
"header"：要求请求映射所匹配的请求必须携带header请求头信息<br>
"!header"：要求请求映射所匹配的请求必须不能携带header请求头信息<br>
"header=value"：要求请求映射所匹配的请求必须携带header请求头信息且header=value<br>
"header!=value"：要求请求映射所匹配的请求必须携带header请求头信息且header!=value</p>
<p>若当前请求满足@RequestMapping注解的value和method属性，但是不满足headers属性，此时页面显示404错误，即资源未找到<br>
（注：请求头和响应头不区分大小写）</p>
<h3> 7、SpringMVC支持ant风格的路径</h3>
<p>SpringMVC支持ant风格的路径<br>
在@requestMapping注解的value属性值中设置一些特殊字符：</p>
<p>*<em>？：表示任意的单个字符，不包括?本身<br>
<em>：表示任意的0个或多个字符，不包括?和/<br>
**：表示任意层数的任意目录，**只能写在双斜线中，中间，左右不能有其他字符</em></em><br>
注意：在使用**时，只能使用/**/xxx的方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8、SpringMVC支持路径中的占位符（重点）</h3>
<p>传统方式：/deleteUser?id=1  通过？传参数<br>
rest方式：/user/delete/1   通过/传参数</p>
<p>需要在@RequestMapping注解的value属性所设置的路径中，使用**{xxx}<strong>的方式表示路径中的数据<br>
再通过</strong>@PathVariable注解**，将占位符所标识的值和控制器方法的形参进行绑定</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 4、SpringMVC获取请求参数</h2>
<h3> 1、通过ServletAPI获取</h3>
<p>只需要在控制器方法的新参位置设置HttpServletRequest类型的形参<br>
就可以在控制器方法中使用request对象获取请求参数</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2、通过控制器方法的形参获取请求参数</h3>
<p>只需要在控制器方法的形参位置，设置一个形参，形参的名字和请求参数的名字一致即可</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3、@RequestParam  将请求参数和控制器形参绑定</h3>
<p>@RequestParam注解的三个属性：value、required，defaultValue</p>
<p>value：设置和形参绑定请求参数的名字<br>
required：设置是否必须传输value所对应的请求参数<br>
默认值为true，表示value所对应的请求参数必须传输，否则页面报错（400错误）<br>
若设置为false，表示value所对应的请求参数不是必须传输，若为传输，则形参值为null	<br>
defaultValue：设置当没有传输value所对应的请求参数时，为形参设置的默认值，此时和required属性值无关</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4、@RequestHeader</h3>
<p>将请求头信息和控制器方法的形参绑定</p>
<h3> 5、@CookieValue</h3>
<p>将cookie数据和控制器方法的形参绑定</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6、通过实体类类型的形参获取请求参数</h3>
<p>需要在控制器方法的形参位置设置实体类类型的形参</p>
<p>要保证实体类中的属性的属性名和请求参数的名字一致</p>
<p>可以通过实体类类型的形参获取请求参数</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7、解决获取请求参数的乱码问题</h3>
<p>在web.xml中配置Spring的编码过滤器CharacterEncodingFilter</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注：SpringMVC中处理编码的过滤器一定要配置到其他过滤器之前，否则无效</strong></p>
<h2> 5、域对象共享数据</h2>
<h3> 1、使用ServletAPI向request域对象共享数据</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2、使用ModelAndView向request域对象共享数据</h3>
<p>ModelAndView包含Model和View的功能：<br>
Model：向请求域中共享数据<br>
View：设置逻辑视图实现页面跳</p>
<p>通过ModelAndView向请求域共享数据：<br>
使用ModelAndView时，可以使用其<strong>Model功能向请求域共享数据</strong><br>
使用<strong>View功能设置逻辑视图</strong>，但是控制器方法<strong>一定要将ModelAndView作为方法的返回值</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3、使用Model，ModelMap，Map向request域对象共享数据</h3>
<p>Model，ModelMap和Map的关系：<br>
在底层中，这些类型的形参最终都是通过BindingAwareModelMap创建<br>
Model、ModelMap、Map类型的参数其实本质上都是 BindingAwareModelMap 类型的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4、向session域共享数据</h3>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5、向application域共享数据</h3>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 6、SpringMVC的视图</h2>
<p>SpringMVC中的视图是View接口，视图的作用渲染数据，将模型Model中的数据展示给用户<br>
SpringMVC视图的种类很多，默认有转发视图和重定向视图<br>
当工程引入jstl的依赖，转发视图会自动转换为JstlView<br>
若使用的视图技术为Thymeleaf，在SpringMVC的配置文件中配置了Thymeleaf的视图解析器，由此视图解析器解析之后所得到的是ThymeleafView</p>
<h3> 1、ThymeleafView</h3>
<p>当控制器方法中所设置的视图名称<strong>没有任何前缀</strong>时，此时的视图名称会被SpringMVC配置文件中所配置的视图解析器解析（ThymeleafView），视图名称拼接视图前缀和视图</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2、转发视图</h3>
<p>SpringMVC中默认的转发视图是InternalResourceView</p>
<p>当控制器方法中所设置的视图名称以"forward:"为前缀时，创建InternalResourceView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀"forward:"去掉，剩余部分作为最终路径通过转发的方式实现跳转</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3、重定向视图</h3>
<p>SpringMVC中默认的重定向视图是RedirectView</p>
<p>当控制器方法中所设置的视图名称以"redirect:"为前缀时，创建RedirectView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀"redirect:"去掉，剩余部分作为最终路径通过重定向的方式实现跳转</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4、视图控制器view-controller</h3>
<p>当控制器方法中，仅仅用来实现页面跳转，即只需要设置视图名称时，可以将处理器方法使用viewcontroller标签进行表示</p>
<p>SpringMVC.xml中添加：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 7、RESTful</h2>
<h3> 1、RESTful简介</h3>
<p>REST：Representational State Transfer，表现层资源状态转移。</p>
<p>①资源<br>
将服务器看作是由很多离散的资源组成，即一切皆资源。一个资源可以由一个或多个URI来标识。URI既是资源的名称，也是资源在Web上的地址。对某个资源感兴趣的客户端应用，可以通过资源的URI与其进行交互。</p>
<p>②资源的表述<br>
资源的表述可以有多种格式，例如HTML/XML/JSON/纯文本/图片/视频/音频等等。资源的表述格式可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式。</p>
<p>③状态转移<br>
状态转移说的是：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资源的表述，来间接实现操作资源的目的。</p>
<h3> 2、RESTful的实现</h3>
<p>具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。</p>
<p>它们分别对应四种基本操作：<br>
<strong>GET 用来获取资源<br>
POST 用来新建资源<br>
PUT 用来更新资源<br>
DELETE用来删除资源</strong></p>
<p>REST 风格提倡 URL 地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方式携带请求参数，而是将要发送给服务器的数据作为 URL 地址的一部分，以保证整体风格的一致性</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>传统方式</th>
<th>REST风格</th>
</tr>
</thead>
<tbody>
<tr>
<td>查询操作</td>
<td>getUserById?id=1</td>
<td>user/1--&gt;get请求方式</td>
</tr>
<tr>
<td>保存操作</td>
<td>saveUser</td>
<td>user--&gt;post请求方式</td>
</tr>
<tr>
<td>删除操作</td>
<td>deleteUser?id=1</td>
<td>user/1--&gt;delete请求方式</td>
</tr>
<tr>
<td>更新操作</td>
<td>updateUser</td>
<td>user--&gt;put请求方式</td>
</tr>
</tbody>
</table>
<h3> 3、HiddenHttpMethodFilter</h3>
<p>浏览器目前只能发送get和post请求<br>
若要发送put和delete请求，需要<strong>在web.xml中配置一个过滤器HiddenMethodFilter</strong><br>
配置了过滤器之后，发送的请求要<strong>满足两个条件</strong>，才能将请求方式转换为put或delete<br>
<strong>1、当前请求的请求方式必须为post<br>
2、当前请求参数必须传输请求参数_method,_method的值才是最终的请求方式</strong></p>
<p><strong>web.xml：</strong><br>
<strong>注：其他过滤器一定要放在Spring的编码过滤器的后面</strong></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>index.html:</strong></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Controller:</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 8、RESTful案例</h2>
<h3> 1、准备工作</h3>
<p>①创建pojo实体类<br>
②准备dao模拟数据</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2、功能清单</h3>
<table>
<thead>
<tr>
<th>功能</th>
<th>URL 地址</th>
<th>请求方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>访问首页√</td>
<td>/</td>
<td>GET</td>
</tr>
<tr>
<td>查询全部数据√</td>
<td>/employee</td>
<td>GET</td>
</tr>
<tr>
<td>删除√</td>
<td>/employee/2</td>
<td>DELETE</td>
</tr>
<tr>
<td>跳转到添加数据页面√</td>
<td>/toAdd</td>
<td>GET</td>
</tr>
<tr>
<td>执行保存√</td>
<td>/employee</td>
<td>POST</td>
</tr>
<tr>
<td>跳转到更新数据页面√</td>
<td>/employee/2</td>
<td>GET</td>
</tr>
<tr>
<td>执行更新√</td>
<td>/employee</td>
<td>PUT</td>
</tr>
</tbody>
</table>
<h3> 3、具体功能：访问首页</h3>
<h4> ①配置web.xml</h4>
<p>浏览器向服务器请求访问css样式等静态资源<br>
tomcat的xml配置的DefaultServlet的url-pattern是/<br>
当前工程的web.xml配置的前端控制器DispatcherServlet的url-pattern也是/<br>
因为tomcat中的xml有继承性，当前工程为子，tomcat为父，因此处理请求时会全给DispatcherServlet处理，而它不能处理静态资源等，只能处理有请求的request，所以要在当前工程的web.xml添加配置</p>
<p><strong>web.xml:</strong></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> ②创建页面</h4>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4、具体功能：查询所有员工数据</h3>
<h4> ①控制器方法</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> ②创建employee_list.html</h4>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5、其他功能添加</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 9、SpringMVC处理ajax请求</h2>
<h3> 1、@RequestBody</h3>
<p>@RequestBody可以获取请求体信息，使用@RequestBody注解标识控制器方法的形参，当前请求的请求体就会为当前注解所标识的形参赋值<br>
<strong>@RequestBody注解将HTTP <em>请求体</em> 中的 <em>JSON或XML等数据</em> 转换为 <em>Java对象</em> 。</strong></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果：<br>
requestBody:username=admin&amp;password=123456</p>
<h3> 2、@RequestBody获取json格式的请求参数</h3>
<p>1、@RequestBody：将请求体中的内容和控制器方法的形参惊醒绑定<br>
2、使用@RequestBody注解将json格式的请求参数转换为java对象</p>
<p>在使用了axios发送ajax请求之后，浏览器发送到服务器的请求参数有两种格式：<br>
1、name=value&amp;name=value...，此时的请求参数可以通过request.getParameter()获取，对应SpringMVC中，可以直接通过控制器方法的形参获取此类请求参数<br>
2、{key:value,key:value,...}，此时<strong>无法通过request.getParameter()获取</strong>，之前我们使用操作json的相关jar包gson或jackson处理此类请求参数，可以将其转换为指定的实体类对象或map集合。在SpringMVC中，<strong>直接使用@RequestBody注解</strong>标识控制器方法的形参即可将此类请求参数转换为java对象</p>
<p><strong>使用@RequestBody获取json格式的请求参数的条件</strong>：</p>
<p>1、导入jackson的依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2、SpringMVC的配置文件中设置开启mvc的注解驱动</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>3、在控制器方法的形参位置，设置<strong>json格式的请求参数要转换成的java类型</strong>（实体类或map）的参数，并使用@RequestBody注解标识</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用@RequestBody注解将json格式的数据转换为map集合</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3、@ResponseBody</h3>
<p>@ResponseBody用于标识一个控制器方法，可以将该方法的**返回值直接作为响应报文的响应体响应到浏览器  **</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4、@ResponseBody响应浏览器json数据</h3>
<p>1、@RequestBody：将请求体中的内容和控制器方法的形参进行绑定<br>
2、使用@requestBody注解将json格式的请求参数转换为java对象</p>
<p>服务器处理ajax请求之后，大多数情况都需要向浏览器响应一个java对象，此时必须将java对象转换为json字符串才可以响应到浏览器，之前我们使用操作json数据的jar包gson或jackson将java对象转换为json字符串。在SpringMVC中，我们可以直接**使用@ResponseBody注解实现此功能  **</p>
<p>**@ResponseBody响应浏览器json数据的条件：  **</p>
<p>1、导入jackson的依赖  (同上一个)<br>
2、SpringMVC的配置文件中设置开启mvc的注解驱动<br>
3、<strong>使用@ResponseBody注解标识控制器方法</strong>，在方法中，将需要转换为json字符串并响应到浏览器的<strong>java对象作为控制器方法的返回值</strong>，此时SpringMVC就可以将此对象直接转换为json字符串并响应到浏览器</p>
<p>常用的Java对象转换为json结果：<br>
实体类--&gt;json对象<br>
map--&gt;json对象<br>
list--&gt;json数组</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5、@RestController注解</h3>
<p>@RestController注解是springMVC提供的一个复合注解，标识在控制器的类上，就相当于为类添加了@Controller注解，并且为其中的每个方法添加了@ResponseBody注解<br>
<strong>@RestController = @Controller+@ResponseBody</strong></p>
<h2> 10、文件上传和下载</h2>
<h3> 1、文件下载</h3>
<p>ResponseEntity:可以作为控制器方法的返回值，表示响应到浏览器的响应报文<br>
ResponseEntity用于控制器方法的返回值类型，该控制器方法的返回值就是响应到浏览器的响应报文使用ResponseEntity实现下载文件的功能</p>
<p>文件下载的模板：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2、文件上传</h3>
<p>文件上传要求form表单的请求方式<strong>必须为post</strong>，并且添加**属性enctype="multipart/form-data"**SpringMVC中将上传的文件封装到MultipartFile对象中，通过此对象可以获取文件相关信息</p>
<p>上传步骤：<br>
①添加依赖：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>②在SpringMVC的配置文件中添加配置：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>③控制器方法：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 11、拦截器</h2>
<h3> 1、拦截器的配置</h3>
<p>SpringMVC中的拦截器用于拦截控制器方法的执行<br>
SpringMVC中的拦截器需要实现HandlerInterceptor<br>
SpringMVC的拦截器必须在SpringMVC的配置文件中进行配置</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2、拦截器的三个抽象方法</h3>
<p>SpringMVC中的拦截器有三个抽象方法：</p>
<p>preHandle：控制器方法执行之前执行preHandle()，其boolean类型的返回值表示是否拦截或放行，返回true为放行，即调用控制器方法；返回false表示拦截，即不调用控制器方法<br>
postHandle：控制器方法执行之后执行postHandle()<br>
afterCompletion：处理完视图和模型数据，渲染视图完毕之后执行afterCompletion()</p>
<h3> 3、多个拦截器的执行顺序</h3>
<p>多个拦截器的执行顺序和在SpringMVC配置文件中配置的顺序有关<br>
preHandle()按照配置的顺序执行，而postHandle()和afterCompletion()按照配置的反序执行</p>
<p>若拦截器中有某个拦截器的preHandle()返回了false<br>
拦截器的preHandel()返回false和它之前的拦截器的preHandle()都会执行<br>
所有的postHandle()都不执行<br>
拦截器的preHandle()返回false之前的拦截器的afterCompletion()会执行</p>
<h2> 12、异常处理器</h2>
<h3> 1、基于配置的异常处理</h3>
<p>SpringMVC提供了一个处理控制器方法执行过程中所出现的异常的接口：HandlerExceptionResolver<br>
HandlerExceptionResolver接口的实现类有：DefaultHandlerExceptionResolver和SimpleMappingExceptionResolver<br>
SpringMVC提供了自定义的异常处理器SimpleMappingExceptionResolver，使用方式：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2、基于注解的异常处理</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 13、注解配置SpringMVC</h2>
<p>使用配置类和注解代替web.xml和SpringMVC配置文件的功能</p>
<h3> 1、WebInit类，代替web.xml</h3>
<p>在Servlet3.0环境中，容器会在类路径中查找实现javax.servlet.ServletContainerInitializer接口的类，如果找到的话就用它来配置Servlet容器（Tomcat）。 Spring提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配置的任务交给它们来完成。Spring3.2引入了一个便利的WebApplicationInitializer基础实现，名为AbstractAnnotationConfigDispatcherServletInitializer，当我们的类扩展了AbstractAnnotationConfigDispatcherServletInitializer并将其部署到Servlet3.0容器的时候，容器会自动发现它，并用它来配置Servlet上下文。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2、SpringConfig类，代替spring的配置文件</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3、WebConfig类，代替SpringMVC的配置文件：</h3>
<p>功能：扫描组件，视图解析器，默认的servlet，mvc注解驱动，视图控制器、文件上传解析器、拦截器、异常解析器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 14、SpringMVC执行流程</h2>
<h3> 14.1、SpringMVC常用组件</h3>
<p>DispatcherServlet：前端控制器，不需要工程师开发，由框架提供<br>
作用：统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求</p>
<p>HandlerMapping：处理器映射器，不需要工程师开发，由框架提供<br>
作用：根据请求的url、method等信息查找Handler，即控制器方法</p>
<p>Handler：处理器，需要工程师开发<br>
作用：在DispatcherServlet的控制下Handler对具体的用户请求进行处理</p>
<p>HandlerAdapter：处理器适配器，不需要工程师开发，由框架提供<br>
作用：通过HandlerAdapter对处理器（控制器方法）进行执行</p>
<p>ViewResolver：视图解析器，不需要工程师开发，由框架提供<br>
作用：进行视图解析，得到相应的视图，例如：ThymeleafView、InternalResourceView、RedirectView</p>
<p>View：视图<br>
作用：将模型数据通过页面展示给用户</p>
<h3> 14.2、DispatcherServlet初始化过程</h3>
<p>DispatcherServlet <strong>本质上是一个 Servlet</strong>，所以天然的遵循 Servlet 的生命周期。所以宏观上是 <strong>Servlet生命周期来进行调度</strong>。</p>
<p>①初始化WebApplicationContext<br>
所在类：org.springframework.web.servlet.FrameworkServlet</p>
<p>②创建WebApplicationContext<br>
所在类：org.springframework.web.servlet.FrameworkServlet</p>
<p>③DispatcherServlet初始化策略<br>
FrameworkServlet创建WebApplicationContext后，刷新容器，调用onRefresh(wac)，此方法在DispatcherServlet中进行了重写，调用了initStrategies(context)方法，初始化策略，即初始化DispatcherServlet的各个组件<br>
所在类：org.springframework.web.servlet.DispatcherServlet</p>
<h3> 14.3、DispatcherServlet调用组件处理请求</h3>
<p>①processRequest()<br>
FrameworkServlet重写HttpServlet中的service()和doXxx()，这些方法中调用了processRequest(request, response)<br>
所在类：org.springframework.web.servlet.FrameworkServlet</p>
<p>②doService()<br>
所在类：org.springframework.web.servlet.DispatcherServlet</p>
<p>③doDispatch()<br>
所在类：org.springframework.web.servlet.DispatcherServlet</p>
<h3> 14.4、SpringMVC的执行流程</h3>
<p>1、用户向服务器发送请求，请求<strong>被SpringMVC 前端控制器 DispatcherServlet捕获</strong>。</p>
<p>2、DispatcherServlet<strong>对请求URL</strong>进行<strong>解析</strong>，得到请求<strong>资源标识符（URI）</strong>，<strong>判断请求URI对应的映射</strong>：</p>
<p>如果不存在：<br>
再判断是否配置了mvc:default-servlet-handler|<br>
如果没配置，则控制台报映射查找不到，客户端展示404错误<br>
如果有配置，则访问目标资源（一般为静态资源，如：JS,CSS,HTML），找不到客户端也会展示404错误</p>
<p>如果存在则执行下面的流程</p>
<p>3、根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain执行链对象的形式返回。</p>
<p>4、DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。</p>
<p>5、如果成功获得HandlerAdapter，此时将开始执行<strong>拦截器的preHandler</strong>(…)方法【正向】</p>
<p>6、提取Request中的模型数据，填充Handler入参，开始<strong>执行Handler（Controller 控制器)方法</strong>，处理请求。<br>
在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：<br>
HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息<br>
数据转换：对请求消息进行数据转换。如String转换成Integer、Double等<br>
数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等<br>
数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中</p>
<p>7、Handler执行完成后，向DispatcherServlet<strong>返回一个ModelAndView对象</strong>。</p>
<p>8、此时将开始执行<strong>拦截器的postHandle(...)方法</strong>【逆向】。</p>
<p>9、根据返回的ModelAndView（此时会判断是否存在异常：如果<strong>存在异常</strong>，则执行<strong>HandlerExceptionResolver进行异常处理</strong>）选择一个适合的ViewResolver进行<strong>视图解析</strong>，根据Model和View，来渲染视图。</p>
<p>10、<strong>渲染视图完毕</strong>执行<strong>拦截器的afterCompletion(…)方法</strong>【逆向】</p>
<p>11、将**渲染结果返回给客户端 **</p>
<h2> 15、SSM整合</h2>
<h3> 1、ContextLoaderListener</h3>
<p><strong>SpringMVC的IOC</strong>容器在<strong>DispatcherServlet初始化</strong>的时候创建，而配置文件中加入load-on-startup标签将<strong>DispatcherServlet初始化提前到服务器启动时创建servlet时创建</strong>，所以SpringMVC的IOC容器在服务器启动时就会创建。但SpringMVC的IOC容器中要注入Service等对象，而它由Spring的IOC创建，所以<strong>Spring的IOC要比SpringMVC的IOC创建要提前</strong>。在服务器启动时，会<strong>先创建监听器，过滤器，Servlet</strong>。所以<strong>将读取Spring配置文件，创建Spring的IOC放在监听器的初始方法中</strong>。</p>
<p><strong>web.xml新增：</strong></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>spring.xml</strong></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2、准备工作</h3>
<h4> ①创建Maven Module</h4>
<h4> ②导入依赖</h4>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>③创建表</p>
<h3> 3、配置web.xml</h3>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4、配置springmvc.xml</h3>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5、搭建MyBatis环境</h3>
<h4> ①创建属性文件jdbc.properties</h4>
<div class="language-properties line-numbers-mode" data-ext="properties"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> ②创建MyBatis的核心配置文件mybatis-config.xml</h4>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> ③创建Mapper接口和映射文件</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> ④创建日志文件log4j.xml</h4>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6、创建Spring的配置文件并配置</h3>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7、测试功能</h3>
<h4> ①创建组件</h4>
<p>实体类Employee  （略）</p>
<p>控制层组件EmployeeController</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>创建接口EmployeeService</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>创建实现类EmployeeServiceImpl</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> ②创建页面</h4>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> ③访问测试分页功能</h4>
<p><a href="http://localhost:8080/ssm/employee/page/2" target="_blank" rel="noopener noreferrer">http://localhost:8080/ssm/employee/page/2</a></p>
]]></content:encoded>
      <enclosure url="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230222202004184.png" type="image/png"/>
    </item>
    <item>
      <title>Spring 基础</title>
      <link>https://T4mako.github.io/code/java/Spring%E5%9F%BA%E7%A1%80.html</link>
      <guid>https://T4mako.github.io/code/java/Spring%E5%9F%BA%E7%A1%80.html</guid>
      <source url="https://T4mako.github.io/rss.xml">Spring 基础</source>
      <description>1、Sprin5框架概述 1、 Spring 是轻量级的开源的 JavaEE 框架 2、 Spring 可以解决企业应用开发的复杂性 3、 Spring 有两个核心部分： IOC 和 Aop （1） IOC：控制反转，把创建对象过程交给 Spring 进行管理</description>
      <category>java</category>
      <content:encoded><![CDATA[<h2> 1、Sprin5框架概述</h2>
<p>1、 Spring 是<strong>轻量级</strong>的<strong>开源</strong>的 JavaEE 框架<br>
2、 Spring 可以解决企业应用开发的复杂性<br>
3、 Spring 有两个核心部分： IOC 和 Aop<br>
<strong>（1） IOC：控制反转，把创建对象过程交给 Spring 进行管理</strong></p>
<!-- more -->
<p><strong>（2）Aop：面向切面，不修改源代码进行功能增强</strong><br>
4、 Spring 特点<br>
（1）<strong>方便解耦，简化开发</strong><br>
（2） <strong>Aop 编程支持</strong><br>
（3）<strong>方便程序测试</strong><br>
（4）<strong>方便和其他框架进行整合</strong><br>
（5）<strong>方便进行事务操作</strong><br>
（6）<strong>降低 API 开发难度</strong><br>
5、现在课程中，选取 Spring 版本 5.x</p>
<h2> 2、Spring的下载与使用</h2>
<p>Spring下载地址：<a href="https://repo.spring.io/release/org/springframework/spring/" target="_blank" rel="noopener noreferrer">https://repo.spring.io/release/org/springframework/spring/</a></p>
<h3> 1、简单使用</h3>
<h4> 1、新建项目</h4>
<h4> 2、导入相关jar包</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221107194510137.png" alt="image-20221107194510137" loading="lazy"></p>
<h4> 3、创建普通类，在这个类创建普通方法</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4、创建 Spring 配置文件，在配置文件配置创建的对象</h4>
<p><strong>Spring 配置文件使用 xml 格式</strong></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221107195317174.png" alt="image-20221107195317174" loading="lazy"></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 5、进行测试代码编写</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3、IOC（概念和原理）</h2>
<h3> 1、什么是 IOC</h3>
<p>（1）控制反转，把<strong>对象创建</strong>和<strong>对象之间的调用过程</strong>，<strong>交给 Spring 进行管理 **<br>
（2）使用 IOC <strong>目的</strong>：为了</strong>耦合度降低 **<br>
（3）做入门案例就是 IOC 实现</p>
<h3> 2、IOC底层原理</h3>
<p>xml 解析、工厂模式、反射</p>
<p>IOC过程：<br>
第一步：xml配置文件，配置创建的对象</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>第二步：有service类和dao类，创建工厂类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3、IOC（ BeanFactory 接口）</h3>
<p>1、 IOC 思想基于 IOC 容器完成， **IOC 容器底层就是对象工厂 **<br>
2、 Spring 提供 IOC 容器实现两种方式：（两个接口）<br>
（1） <strong>BeanFactory</strong>： IOC 容器基本实现，是 Spring 内部的使用接口，不提供开发人员进行使用 * **加载配置文件时候不会创建对象，在获取对象（使用）才去创建对象 **<br>
（2） <strong>ApplicationContext</strong>： <mark>BeanFactory 接口的子接口，提供更多更强大的功能，一般由开发人 员进行使用 * 加载配置文件时候就会把在配置文件对象进行创建</mark><br>
3、 ApplicationContext 接口有两个主要的实现类<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221108134930944.png" alt="image-20221108134930944" loading="lazy"></p>
<p>通常用<strong>ClassPathXmlApplication</strong>，通过**类路径（当前文件夹）**访问xml文件，而FileSystemXmlAppliaction通过文件系统访问，不常用。</p>
<h2> 4、IOC操作Bean管理（基于xml文件）</h2>
<h3> 1、什么是bean管理</h3>
<p>Bean 管理指的是两个操作<br>
（1） Spring 创建对象<br>
（2） Spirng 注入属性</p>
<h3> 2、Bean管理操作有两种实现方式</h3>
<p>（1）基于 xml 配置文件方式实现<br>
（2）基于注解方式实现</p>
<h3> 3、基于xml配置文件方式实现</h3>
<h4> 1、基于xml方式创建对象</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221109115835509.png" alt="image-20221109115835509" loading="lazy"></p>
<p>（1）在spring配置文件中使用bean标签，标签里添加对应的属性，可以实现对象的创建<br>
（2）在bean标签有横队属性，介绍常用的属性<br>
id 属性：唯一标识<br>
class 属性：类全路径（包类路径）<br>
（3）创建对象时候，默认也是执行无参数构造方法完成对象创建</p>
<h4> 2、基于xml方式注入属性</h4>
<p><strong>DI：依赖注入，就是注入属性</strong></p>
<h5> 1、第一种注入方式：使用set方式进行注入</h5>
<p>（1）创建类，定义属性和对应的 set 方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（2）在 spring 配置文件配置对象创建，配置属性注入</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 2、第二种注入方式：使用有参构造进行注入</h5>
<p>（1）创建类，定义属性，创建对应有参数的构造方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（2）在spring配置文件中进行配置</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3、p名称空间注入（了解）</h4>
<p>（1）使用p名称空间，可以简化基于xml配置方式</p>
<p>第一步：添加p名称空间咋配置文件中</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221109140816544.png" alt="image-20221109140816544" loading="lazy"></p>
<p>第二步：进行属性注入，在 bean 标签里面进行操作</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4、xml 注入其他类型属性</h3>
<h4> 1、字面量</h4>
<p>（1） null 值</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（2）属性值包含特殊符号</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5、注入属性-外部 bean</h3>
<p>（1）创建两个类service类和dao类<br>
（2）在service里调用dao的方法<br>
（3）在Spring配置文件中进行配置</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6、注入属性-内部bean和级联赋值</h3>
<p>（1）一对多关系：<br>
部门和员工 一个部门有多个员工，一个员工属于一个部门 部门是一，员工是多<br>
（2）在实体类之间表示一对多关系，<strong>员工表示所属部门，使用对象类型属性进行表示</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（3）在 spring 配置文件中进行配置</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7、注入属性-级联赋值</h3>
<p>第一种写法：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第二种写法：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8、xml注入集合属性</h3>
<h4> 1、注入数组，List集合，Map集合类型属性</h4>
<p>（1）创建类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（2）在spring配置文件进行配置</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2、在集合里面设置对象类型值</h4>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3、把集合注入部分提取出来</h4>
<p>（1）在spring配置文件中引入名称空间 util</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（2）使用util标签完成lsit集合注入提取</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 9、FactoryBean</h3>
<p>1、 Spring 有两种类型 bean，一种 <strong>普通 bean</strong>，另外一种 <strong>工厂 bean</strong>（FactoryBean）<br>
普通 bean：在配置文件中定义 bean 类型就是返回类型<br>
工厂bean：在配置文件定义bean类型可以和返回类型不一样</p>
<p>2、工厂bean的使用<br>
第一步 创建类，让这个类作为工厂 bean，实现接口 FactoryBean<br>
第二步 实现接口里面的方法，在实现的方法中定义返回的 bean 类型</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 10、bean作用域</h3>
<p>1、在Spring里，设置创建bean实例是单实例还是多实例（同一个对象还是每次都创建新的对象）</p>
<p>2、在Spring里，默认情况下，bean是单实例对象</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221112103808752.png" alt="image-20221112103808752" loading="lazy"></p>
<p>3、如何设置单实例还是多实例</p>
<p>（1）在 spring 配置文件 bean 标签里面有属性（<strong>scope</strong>）用于设置单实例还是多实例<br>
（2） scope 属性值 第一个值 默认值，<strong>singleton</strong>，表示是单实例对象 第二个值 <strong>prototype</strong>，表示是多实例对象</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221112104043739.png" alt="image-20221112104043739" loading="lazy"></p>
<p>（3） singleton 和 prototype 区别<br>
1、singleton 单实例， prototype 多实例<br>
2、  设置 scope 值是 <strong>singleton</strong> 时候，<strong>加载 spring 配置文件时候就会创建单实例对象</strong><br>
设置 scope 值是 <strong>prototype</strong> 时候，不是在加载 spring 配置文件时候创建对象，在 <strong>调用 getBean 方法时候创建多实例对象</strong></p>
<h3> 11、bean生命周期</h3>
<p>1、生命周期：从对象创建到对象销毁的过程</p>
<p>2、 bean 生命周期<br>
（1）通过构造器<strong>创建bean 实例</strong>（无参数构造）<br>
（2）为 bean 的<strong>属性设置</strong>值和对其他 bean 引用（调用 set 方法）<br>
（3）调用<strong>bean的初始化</strong>的方法（需要进行配置初始化的方法）<br>
（4） bean 可以使用了（对象获取到了）<br>
（5）当<strong>容器关闭</strong>时候，调用<strong>bean的销毁</strong>的方法（需要进行配置销毁的方法）</p>
<p>3、演示bean生命周期</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>4、bean的后置处理器</p>
<p><strong>添加后置处理器后</strong>，bean的生命周期为7步</p>
<p>（1）通过构造器<strong>创建bean 实例</strong>（无参数构造）<br>
（2）为 bean 的<strong>属性设置</strong>值和对其他 bean 引用（调用 set 方法）<br>
（3）把bean的实例传递给bean后置处理器的方法 <strong>postProcessBeforeInitialization</strong><br>
（4）调用<strong>bean的初始化</strong>的方法（需要进行配置初始化的方法）<br>
（5）把bean的实例传递给bean后置处理器的方法 <strong>postProcessAfterInitialization</strong><br>
（6） bean 可以使用了（对象获取到了）<br>
（7）当<strong>容器关闭</strong>时候，调用<strong>bean的销毁</strong>的方法（需要进行配置销毁的方法）</p>
<p>5、演示添加后置处理器的效果<br>
（1）创建类，实现接口 BeanPostProcessor，创建后置处理器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（2）配置后置处理器</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 12、XML自动装配</h3>
<p>1、什么是自动装配<br>
（1）根据指定装配规则（属性名称或者属性类型），Spring 自动将匹配的属性值进行注入<br>
2、演示自动装配的过程<br>
（1）根据属性名称自动注入</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（2）根据属性类型自动注入</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 13、外部属性文件</h3>
<p>1、直接配置数据库信息<br>
（1）配置德鲁伊连接池<br>
（2）引入德鲁伊连接池依赖jar包</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2、引入外部属性文件配置数据库连接池</p>
<p>（1）创建外部属性文件，properties格式文件，写数据库信息</p>
<div class="language-properties line-numbers-mode" data-ext="properties"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（2）把外部properties属性文件引入到spring配置文件中</p>
<p>引入context名称空间</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在spring配置文件使用标签引入外部属性文件</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 5、IOC操作Bean管理（基于注解方式）</h2>
<h3> 1、什么是注解</h3>
<p>（1）注解是代码特殊标记，格式： **@注解名称(属性名称=属性值, 属性名称=属性值..) **<br>
（2）使用注解，**注解作用在类上面，方法上面，属性上面 **<br>
（3）使用注解目的：简化 xml 配置</p>
<h3> 2、Spring针对Bean管理中创建对象提供注解</h3>
<p><strong>（1）@Compnent<br>
（2）@Service<br>
（3）@Controller<br>
（4）@Repository</strong></p>
<p><strong>上面四个注解功能是一样的，都可以用来创建bean实例</strong></p>
<h3> 3、基于注解方式实现对象创建</h3>
<h4> 第一步 引入依赖</h4>
<h4> 第二步  开启组件扫描</h4>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 第三步 创建类，在类上添加创建对象注解</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4、开启组件扫描细节配置</h3>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5、基于注解方式实现属性注入</h3>
<p>（1） <strong>@Autowired：根据属性类型进行自动装配</strong><br>
第一步：把service和dao对象创建，在service和dao类添加创建对象注解<br>
第二步：在service注入dao对象，在service类添加dao类型属性，在属性上面使用注解</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（2）<strong>@Qualifier：根据名称进行注入<br>
@Qualifier注解的使用，和上面的@Autowired一起使用</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（3） <strong>@Resource：可以根据类型注入，可以根据名称注入</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（4） <strong>@Value：注入普通类型属性</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6、完全注解开发</h3>
<p>（1）创建配置类，替代xml配置文件</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（2）编写测试类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 6、AOP</h2>
<h3> 1、AOP相关概念</h3>
<p>（1）面向切面编程（方面）， 利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得 业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。<br>
（2）通俗描述：不通过修改源代码方式，在主干功能里面添加新功能<br>
（3）使用登录例子说明 AOP</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221116143148275.png" alt="image-20221116143148275" loading="lazy"></p>
<h3> 2、AOP底层原理（动态代理）</h3>
<p>AOP底层使用动态代理</p>
<h4> 1、有两种情况动态代理</h4>
<p><strong>第一种 有接口情况，使用 JDK 动态代理</strong></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221116145007186.png" alt="image-20221116145007186" loading="lazy"></p>
<p><strong>第二种 没有接口情况，使用 CGLIB 动态代理</strong></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221116145816875.png" alt="image-20221116145816875" loading="lazy"></p>
<h3> 3、AOP（JDK动态代理）</h3>
<p>1、使用JDK动态代理，使用Proxy类里面的方法创建代理对象</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221116191550153.png" alt="image-20221116191550153" loading="lazy"></p>
<p>（1）<strong>调用 newProxyInstance 方法</strong></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221116191615418.png" alt="image-20221116191615418" loading="lazy"></p>
<p><strong>方法有三个参数：</strong><br>
<strong>第一个参数：类加载器</strong><br>
<strong>第二个参数：增强方法所在的类，这个类实现的接口，支持多个接口</strong><br>
<strong>第三个参数：实现这个接口InvocationHandler，创建代理对象，写增强的部分</strong></p>
<p>2、编写JDK动态代理代码</p>
<p>（1）创建接口，定义方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（2）创建接口实现类，实现方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（3）使用Proxy类创建代理对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4、AOP术语</h3>
<p>1、连接点<br>
类里面哪些方法可以被增强，这些方法称为连接点</p>
<p>2、切入点<br>
实际被真正增强的方法，称为切入点</p>
<p>3、通知（增强）<br>
（1）实际增强的逻辑的部分称为通知（增强）<br>
（2）通知有多种类型<br>
前置通知<br>
后置通知<br>
环绕通知（前+后）<br>
异常通知<br>
最终通知（finally）</p>
<p>4、切面<br>
是动作<br>
（1）把通知应用到切入点过程</p>
<h3> 5、AOP操作（准备）</h3>
<p>1、Spring框架一般基于AspectJ实现AOP操作<br>
（1） AspectJ 不是 Spring 组成部分，它是独立的 AOP 框架，一般把 AspectJ 和 Spirng 框架一起使用，进行 AOP 操作</p>
<p>2、基于 AspectJ 实现 AOP 操作<br>
（1）基于 xml 配置文件实现<br>
（2）基于注解方式实现（使用）</p>
<p>3、在项目工程里面引入AOP依赖</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221117195034575.png" alt="image-20221117195034575" loading="lazy"></p>
<p>4、切入点表达式<br>
（1）切入点表达式作用：知道对那个类里面的那个方法进行增强<br>
（2）语法结构：<br>
<em><em>execution([权限修饰符] [返回类型] [类全路径] [方法名称]([参数列表]) ) **<br>
举例 1：对 com.atguigu.dao.BookDao 类里面的 add 进行增强 execution(</em> com.atguigu.dao.BookDao.add(..))<br>
举例 2：对 com.atguigu.dao.BookDao 类里面的所有的方法进行增强 execution(</em> com.atguigu.dao.BookDao.* (..))<br>
举例 3：对 com.atguigu.dao 包里面所有类，类里面所有方法进行增强 execution(* com.atguigu.dao.*.* (..))</p>
<h3> 6、AspectJ注解</h3>
<h4> 1、创建类，在类里面定义方法</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2、创建增强类（编写增强逻辑）</h4>
<p>（1）在增强类里面创建方法，让不同方法代表不同通知类型</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3、进行通知的配置</h4>
<p>（1）在spring配置文件中，开启注解扫描</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（2）使用注解创建User和UserProxy对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（3）在增强类上面添加注解@Aspect</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（4）在spring配置文件中开启生成代理对象</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4、配置不同类型的通知</h4>
<p>（1）在增强类里面，在作为通知方法上面添加通知类型注解，使用切入点表达式配置</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 5、相同切入点抽取</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 6、增强优先级</h4>
<p>有<strong>多个增强类多同一个方法进行增强</strong>，设置增强类优先级<br>
（1）在增强类上面添加注解 @Order(数字类型值)，数字类型值越小优先级越高</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 7、完全注解开发</h4>
<p>创建配置类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7、AspectJ配置文件</h3>
<h4> 1、创建连个类，增强类和被增强类，创建方法</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2、在Spring配置文件中创建两个类的对象</h4>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3、在spring配置文件中配置切入点</h4>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 7、JdbcTemplate</h2>
<h3> 1、什么是JdbcTemplate</h3>
<p>（1）Spring框架对JDBC进行封装，使用 JdbcTemplate 方便实现对数据库操作</p>
<h3> 2、准备工作</h3>
<p>（1）引入相关 jar 包</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221119102945472.png" alt="image-20221119102945472" loading="lazy"></p>
<p>（2）在spring配置文件配置数据库连接池</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（3）配置JdbcTemplate对象，注入DataSource</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（4）创建service类，创建dao类，在dao注入jdbcTemplate对象</p>
<p>dao接口：对数据库的抽象方法<br>
daoImpl类：对dao接口中方法的实现<br>
service中：创建dao的对象，创建方法，内部调用dao子类的方法</p>
<p>配置文件中开启组件扫描</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>Service中</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Dao中</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3、JdbcTemplate操作数据库</h3>
<h4> 1、添加</h4>
<p>1、对应数据库创建实体类</p>
<p>2、编写service和dao<br>
（1）在dao进行数据库添加操作</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（2）调用JdbcTemplate对象里的update方法实现添加操作</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221119110350096.png" alt="image-20221119110350096" loading="lazy"></p>
<p><strong>有两个参数：<br>
第一个参数：sql语句<br>
第二个参数：可变参数，设置sql语句的值</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3、测试类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2、修改和删除</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3、查询</h4>
<h5> 1、查询返回某个值</h5>
<p>1、查询表里面有多少条记录，返回某个值<br>
2、使用JdbcTemplate实现查询返回某个值代码<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221119134145556.png" alt="image-20221119134145556" loading="lazy"></p>
<p>有两个参数：<br>
（1）sql语句<br>
（2）返回类型Class</p>
<h5> 2、查询返回对象</h5>
<p>1、场景：查询user详情<br>
2、JdbcTemplate实现查询返回对象<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221119134612167.png" alt="image-20221119134612167" loading="lazy"></p>
<p>有三个参数：<br>
（1）sql语句<br>
（2）RowMapper，是接口，返回不同类型数据，使用这个接口里面实现类完成数据封装<br>
（3）sql语句值</p>
<h5> 3、查询返回集合</h5>
<p>1、场景：查询user列表分页<br>
2、调用JdbcTemplate方法实现查询返回集合<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221119140026889.png" alt="image-20221119140026889" loading="lazy"></p>
<p>有三个参数<br>
（1）sql 语句<br>
（2）RowMapper 是接口，针对返回不同类型数据，使用这个接口里面实现类完成 数据封装<br>
（3）sql 语句值（没有可以省略不写）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4、JdbcTemplate批量操作</h3>
<p>1、批量操作：操作表里面多条记录<br>
2、 JdbcTemplate 实现批量添加操作</p>
<p>有两个参数：<br>
（1）sql语句<br>
（2）List集合，添加多条记录数据</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3、批量修改</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>4、批量删除</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 8、事务操作</h2>
<h3> 1、事务概念</h3>
<p>（1）事务是数据库操作最基本单元，逻辑上一组操作，要么都成功，如果有一个失败所有操 作都失败<br>
（2）典型场景：银行转账</p>
<p>事务四个特性（ACID）<br>
（1）原子性 （2）一致性 （3）隔离性 （4）持久性</p>
<h3> 2、搭建事务操作的环境</h3>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221121081816310.png" alt="image-20221121081816310" loading="lazy"></p>
<p>1、创建数据数据库表，添加记录</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221121082234231.png" alt="image-20221121082234231" loading="lazy"></p>
<p>2、创建service，搭建dao，完成对象创建和注入关系</p>
<p>（1）<strong>service注入dao，在dao注入JdbcTemplate，在JdbcTemplate注入DataSource</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3、在dao创建两个方法：多钱和少钱，在service创建方法（转账的方法）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>4、上面代码，如果正常执行没有问题，但是如果代码执行过程中出现异常，会使数据异常</p>
<p>使用事务解决上述异常<br>
事务操作过程：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221121171153711.png" alt="image-20221121171153711" loading="lazy"></p>
<h3> 3、事务操作</h3>
<p>1、事务添加到 JavaEE 三层结构里面 Service 层（业务逻辑层）</p>
<p>2、在Spring进行事务管理操作<br>
（1）有两种方式：<br>
<strong>编程式</strong>事务管理 （直接编写代码）<br>
<strong>声明式</strong>事务管理（使用配置文件、注解，推荐使用）</p>
<p>3、声明式事务管理<br>
（1）基于注解方式<br>
（2）基于xml配置文件方式</p>
<p>4、在Spring进行声明式事务管理，底层使用AOP原理</p>
<p>5、Spring事务管理API<br>
（1）提供一个接口，代表事务管理器，这个接口针对不同的框架提供不同的实现<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221121190002792.png" alt="image-20221121190002792" loading="lazy"></p>
<h3> 4、注解声明式事务管理</h3>
<p>1、在spring配置文件配置事务管理器</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2、在spring配置文件，开启事务注解</p>
<p>（1）在spring配置文件引入名称空间tx</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（2）开启事务注解</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>3、在service类上面（获取service类里面方法上面）添加事务注解</p>
<p>（1）@Transactional，这个注解添加到类上面，也可以添加到方法上<br>
（2）如果把这个<strong>注解添加类上面</strong>，这个<strong>类里面所有的方法都添加事务</strong><br>
（3）如果把这个<strong>注解添加方法上面</strong>，为这个<strong>方法添加事务</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5、声明式事务管理参数配置</h3>
<p>在 service 类上面添加注解@Transactional，在这个注解里面可以配置事务相关参数</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221121192313660.png" alt="image-20221121192313660" loading="lazy"></p>
<h4> 1、propagation：事务传播行为</h4>
<p>当一个事务方法被另外一个事务方法调用时，这个事务方法如何进行行为？</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221121194945546.png" alt="image-20221121194945546" loading="lazy"></p>
<p>REQUIRED：方法2会开启事务A，调用方法1，<strong>方法1加入到当前事务A</strong>里面<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221121195158088.png" alt="image-20221121195158088" loading="lazy"></p>
<p>REQUIRED_NEW：<strong>内层事务不依赖于外层事务</strong><br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221121195640486.png" alt="image-20221121195640486" loading="lazy"></p>
<p>SUPPORTS：方法b可以单独运行，如果在事务a中，那就在事务a中运行<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221121195811523.png" alt="image-20221121195811523" loading="lazy"></p>
<h4> 2、ioslation：事务隔离级别</h4>
<p>（1）事务有特性称为隔离性，多事务操作之间不会产生影响。不考虑隔离性产生很多问题<br>
（2）有三个读问题：脏读，不可重复读，幻读<br>
脏读：一个未提交事务读取到另一个未提交事务的数据<br>
不可重复读：一个未提交事务读取到另一提交事务修改数据<br>
幻读：一个未提交事务读取到另一提交事务添加数据</p>
<p>通过设置事务隔离级别，解读读的问题</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>READ UMCOMMITTED（读未提交）</td>
<td>有</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>READ COMMITTED（读已提交）</td>
<td>无</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>REPEATABLE READ（可重复读）</td>
<td>无</td>
<td>无</td>
<td>有</td>
</tr>
<tr>
<td>SERIALIZABLE（串行化）</td>
<td>无</td>
<td>无</td>
<td>无</td>
</tr>
</tbody>
</table>
<p><strong>Mysql默认隔离级别为REPEATABLE_READ</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3、timeout：超时时间</h4>
<p>（1）事务需要在一定时间内进行提交，如果不提交进行回滚<br>
（2）默认值是 -1（没有时间限制） ，设置时间以秒单位进行计算</p>
<h5> 4、readOnly：是否只读</h5>
<p>（1）读：查询操作，写：添加修改删除操作<br>
（2）readOnly默认值false，表示可以查询，也可以添加修改删除操作<br>
（3）设置readOnly值是true，设置成true之后，只能查询</p>
<h5> 5、rollbackFor：回滚</h5>
<p>（1）设置出现哪些异常进行事务回滚</p>
<h5> 6、noRollbackFor：不回滚</h5>
<p>（1）设置出现哪些异常不进行事务回滚</p>
<h3> 6、XML声明式事务操作</h3>
<p>1、在spring配置文件中进行配置<br>
第一步：配置事务管理器<br>
第二步：配置通知<br>
第三步：配置切入点和切面</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7、完全注解声明式事务管理</h3>
<p>1、创建配置类，使用配置类替代xml配置文件</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 9、Spring5 框架新功能</h2>
<h3> 1、整个 Spring5 框架的代码基于 Java8，运行时兼容 JDK9， 许多不建议使用的类和方法在代码库中删除</h3>
<h3> 2、 Spring 5.0 框架自带了通用的日志封装</h3>
<p>（1） Spring5 已经移除 Log4jConfigListener，官方建议使用 **Log4j2 **<br>
（2） Spring5 框架整合 Log4j2</p>
<p>Spring5 框架整合 Log4j2：<br>
第一步：引入jar包</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221122124121656.png" alt="image-20221122124121656" loading="lazy"></p>
<p>第二步：创建log4j2.xml</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3、spring5框架核心容器支持@Nullable注解</h3>
<p>（1）@Nullable注解可以使用在方法上面，属性上面，参数上面，表示方法返回可以为空，属性值可以为空，参数值可以为空<br>
（2）注解用在方法上面，方法返回值可以为空</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221122125445610.png" alt="image-20221122125445610" loading="lazy"></p>
<p>（3）注解使用在方法参数里面，方法参数可以为空</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221122125530349.png" alt="image-20221122125530349" loading="lazy"></p>
<p>（4）注解使用在属性上面，属性值可以为空</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221122125548844.png" alt="image-20221122125548844" loading="lazy"></p>
<h3> 4、Spring5核心容器支持函数式风格GenericApplicationContext</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5、Spring5 支持整合 JUnit5</h3>
<p>（1）Spring5整合JUnit4<br>
第一步 引入Spring相关针对测试依赖</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221122132456482.png" alt="image-20221122132456482" loading="lazy"></p>
<p>第二步 创建测试类，使用注解方式完成</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（2）Spring5整合JUnit5<br>
第一步：引入JUnit5的jar包</p>
<p>第二步：创建测试类，使用注解完成</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（3）使用一个复合注解替代上面两个注解完成整合</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 10、Webflux</h2>
<h3> 1、 SpringWebflux 介绍</h3>
<p>（1）是 Spring5 添加新的模块，用于 web 开发的，功能和 SpringMVC 类似的， Webflux 使用 当前一种比较流程响应式编程出现的框架。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221123150035139.png" alt="image-20221123150035139" loading="lazy"></p>
<p>（2）使用传统 web 框架，比如 SpringMVC，这些基于 Servlet 容器， Webflux 是一种异步非阻塞的框架，异步非阻塞的框架在 Servlet3.1 以后才支持，核心是基于 Reactor 的相关 API 实现 的。</p>
<p>（3）解释什么是异步非阻塞<br>
异步和同步针对调用者，调用者发送请求，如果等着对方回应之后才去做其他事情就是同步，如果发送请求之后不等着对方回应就去做其他事情就是异步<br>
阻塞和非阻塞针对被调用者，被调用者收到请求之后，做完请求任务之后才给出反馈就是阻塞，受到请求之后马上给出反馈然后再去做事情就是非阻塞</p>
<p>（4）Webflux 特点：<br>
第一 非阻塞式：在有限资源下，提高系统吞吐量和伸缩性，以 Reactor 为基础实现响应式编程<br>
第二 函数式编程： Spring5 框架基于 java8， Webflux 使用 Java8 函数式编程方式实现路由请求</p>
<p>（5）比较SpringMVC<br>
第一 两个框架都可以使用注解方式，都运行在 Tomet 等容器中<br>
第二 SpringMVC 采用命令式编程， Webflux 采用异步响应式编程</p>
<h3> 2、响应式编程</h3>
<p>（1）什么是响应式编程<br>
响应式编程是一种面向数据流和变化传播的编程范式。这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。<br>
电子表格程序就是响应式编程的一个例子。单元格可以包含字面值或类似"=B1+C1"的公 式，而包含公式的单元格的值会依据其他单元格的值的变化而变化。</p>
<p>（2）Java8及其之前版本<br>
提供的观察者模式两个类 Observer 和 Observable</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3、响应式编程（Reactor 实现）</h3>
<p>（1）响应式编程操作中， Reactor 是满足 Reactive 规范框架<br>
（2） Reactor 有两个核心类， Mono 和 Flux，这两个类实现接口 Publisher，提供丰富操作 符。<br>
Flux 对象实现发布者，返回 N 个元素；<br>
Mono 实现发布者，返回 0 或者 1 个元素<br>
（3） Flux 和 Mono 都是数据流的发布者，使用 Flux 和 Mono 都可以发出三种数据信号：元素值，错误信号，完成信号，错误信号和完成信号都代表终止信号，终止信号用于告诉 订阅者数据流结束了，错误信号终止数据流同时把错误信息传递给订阅者</p>
<h2> 11、Spring、Maven版</h2>
<h3> 1、Spring的使用</h3>
<h4> 导入依赖</h4>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2、基于XML管理bean  （IOC）</h3>
<h4> 1、获取bean</h4>
<p>①方式一：根据id获取<br>
②方式二：根据类型获取  当根据类型获取bean时，要求IOC容器中指定类型的bean有且只能有一个<br>
**③方式三：根据id和类型  **</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果组件类实现了接口，根据接口类型可以获取 bean 吗  ：可以，前提是bean唯一<br>
如果一个接口有多个实现类，这些实现类都配置了 bean，根据接口类型可以获取 bean 吗？  不行，因为bean不唯一</p>
<h4> 2、依赖注入之setter注入</h4>
<p>property标签：<strong>通过组件类的setXxx()方法给组件对象设置属性</strong><br>
name属性：指定属性名**（这个属性名是getXxx()、setXxx()方法定义的，和成员变量无关，即通过name的值找get，set方法）**<br>
value属性：指定属性值</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3、依赖注入之构造器注入</h4>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>constructor-arg标签还有两个属性可以进一步描述构造器参数：<br>
index属性：指定参数所在位置的索引（从0开始）<br>
name属性：指定参数名</p>
<h4> 4、特殊值处理</h4>
<h5> null值 ：</h5>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> xml实体  （&lt; &gt;）：</h5>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> CDATA节  ：</h5>
<p>CDATA节必须放在value标签中<br>
IDEA中快捷方式：大写的CD</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 5、为类类型属性赋值</h4>
<h5> 方式一：外部bean</h5>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 方式二：内部bean</h5>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 方式三：级联属性赋值  （一般不使用）</h5>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 6、为数组类型属性赋值</h4>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 7、为集合类型属性赋值</h4>
<h5> ①为List、Set集合类型属性赋值</h5>
<p>若为Set集合类型属性赋值，只需要将其中的list标签改为set标签即可</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> ②为Map集合类型属性赋值</h5>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> ③引用集合类型的bean  (p标签)</h5>
<p>引入util命名空间</p>
<h4> 8、p命名空间</h4>
<p>引入p命名空间后，可以通过以下方式为bean的各个属性赋值</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 9、引入外部属性文件</h4>
<p>加入依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>创建properties<br>
引入属性文件</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>配置bean</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 10、bean的作用域</h4>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
<th>创建对象的时机</th>
</tr>
</thead>
<tbody>
<tr>
<td><mark>singleton（默认）</mark></td>
<td>在IOC容器中，这个bean的对象始终为**单实例 **</td>
<td>IOC容器初始化时</td>
</tr>
<tr>
<td><mark>prototype</mark></td>
<td>这个bean在IOC容器中有<strong>多个实例</strong></td>
<td>获取bean时</td>
</tr>
</tbody>
</table>
<p>如果是在WebApplicationContext环境下还会有另外两个作用域（但不常用）：</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>request</td>
<td>在一个请求范围内有效</td>
</tr>
<tr>
<td>session</td>
<td>在一个会话范围内有效</td>
</tr>
</tbody>
</table>
<h4> 11、bean的生命周期</h4>
<p>1、实例化<br>
2、依赖注入<br>
3、初始化，需要通过ben的init-method属性指定初始化方法<br>
4、IOC容器关闭时销毁，需要通过bean的destory-method属性指定销毁的方法</p>
<p><strong>注：若bean的作用域为单例时，前三个步骤会在获取IOC容器时执行<br>
若bean的作用域为多个时，前三个步骤会在获取bean的时候执行</strong></p>
<p>bean的前后置处理器可以看前面笔记</p>
<p>具体的生命周期过程：<br>
bean对象创建（调用无参构造器）<br>
给bean对象设置属性<br>
bean对象初始化之前操作（由bean的后置处理器负责）<br>
bean对象初始化（需在配置bean时指定初始化方法）<br>
bean对象初始化之后操作（由bean的后置处理器负责）<br>
bean对象就绪可以使用<br>
bean对象销毁（需在配置bean时指定销毁方法）<br>
IOC容器关闭</p>
<h4> 12、FactoryBean</h4>
<p>FactoryBean是Spring提供的一种整合第三方框架的常用机制。和普通的bean不同，配置一个FactoryBean类型的bean，在获取bean的时候得到的并不是class属性中配置的这个类的对象，而是getObject()方法的返回值。通过这种机制，Spring可以帮我们把复杂组件创建的详细过程和繁琐细节都屏蔽起来，只把最简洁的使用界面展示给我们。</p>
<p>FactoryBean是一个接口，需要创建一个类实现该接口<br>
其中有三个方法：<br>
getObject()：通过一个对象交给IOC容器管理<br>
getObjectType()：设置所提供对象的类型<br>
isSingleton()：所提供的对象是否单例<br>
当把FactoryBean的实现类配置为bean时，会将当前类中getObject()所返回的对象交给IOC容器管理</p>
<h4> 13、基于xml的自动装配</h4>
<p>自动装配：根据指定的策略，在IOC容器中匹配某一个bean，**自动为指定的bean中所依赖的类类型或接口类型属性赋值 **</p>
<p>使用bean标签的<strong>autowire属性</strong>设置自动装配效果<br>
自动装配方式：<strong>byType</strong><br>
<strong>byType：根据类型匹配IOC容器中的某个兼容类型的bean，为属性自动赋值</strong><br>
若在IOC中，没有任何一个兼容类型的bean能够为属性赋值，则该属性不装配，即值为默认值null<br>
若在IOC中，有多个兼容类型的bean能够为属性赋值，则抛出异常NoUniqueBeanDefinitionException</p>
<p>配置自动准配后不用写property标签</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>自动装配方式：<strong>byName</strong><br>
<strong>byName：将自动装配的属性的属性名，作为bean的id在IOC容器中匹配相对应的bean进行赋值</strong><br>
当类型匹配的bean有多个时，此时使用byName实现自动装配</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3、基于注解管理bean  （IOC）</h3>
<p>①注解：和 XML 配置文件一样，注解本身并不能执行，注解本身仅仅只是做一个标记，具体的功能是<strong>框架检测到注解标记的位置</strong>，然后针对这个位置按照注解标记的功能来执行具体操作。<br>
本质上：所有一切的操作都是Java代码来完成的，XML和注解只是告诉框架中的Java代码如何执行。</p>
<p>②扫描：Spring 为了知道程序员在哪些地方标记了什么注解，就需要通过扫描的方式，来进行检测。然后根据注解进行后续操作。</p>
<h5> 1、基本注解</h5>
<p>@Component：将类标识为普通组件<br>
@Controller：将类标识为控制层组件<br>
@Service：将类标识为业务层组件<br>
@Repository：将类标识为持久层组件</p>
<p>通过查看源码我们得知，@Controller、@Service、@Repository这三个注解只是在@Component注解的基础上起了三个新的名字。<br>
对于Spring使用IOC容器管理这些组件来说没有区别。所以@Controller、@Service、@Repository这三个注解只是给开发人员看的，让我们能够便于分辨组件的作用。<br>
注意：虽然它们本质上一样，但是为了代码的可读性，为了程序结构严谨我们肯定不能随便胡乱标记。</p>
<h5> 2、扫描文件</h5>
<p>通过扫描，ioc就有了扫描到注解的类的bean对象</p>
<p>情况一：最基本的扫描方式</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>情况二：指定要排除的组件</p>
<p>type：设置排除或包含的依据<br>
type="annotation"，根据注解排除，expression中设置要排除的<strong>注解的全类名</strong><br>
type="assignable"，根据类型排除，expression中设置要排除的<strong>类型的全类名</strong></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>情况三：仅扫描指定组件</p>
<p>use-default-filters="true"（默认），所设置的包下所有的类都需要扫描，此时可以使用排除扫描<br>
use-default-filters="false"，所设置的包下所有的类都不需要扫描，此时可以使用包含扫描</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 3、组件所对应的bean的id</h5>
<p>默认情况： <strong>类名首字母小写就是bean的id</strong>。例如：UserController类对应的bean的id就是userController。</p>
<p>自定义bean的id：可通过标识组件的注解的value属性设置自定义的bean的id</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h5> 4、基于注解的自动装配</h5>
<p>@Autowired注解<br>
在成员变量上直接标记@Autowired注解即可完成自动装配，不需要提供setXxx()方法。</p>
<p>@Autowired注解能够标识的位置：<br>
标识在成员变量上，此时不需要设置成员变量的set方法<br>
标识在set方法上<br>
标识在成员变量赋值的有参构造上</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230106173514322.png" alt="image-20230106173514322" loading="lazy"></p>
<p>首先根据所需要的组件类型（<strong>byType</strong>）到IOC容器中查找，能够找到唯一的bean：直接执行装配<br>
如果完全找不到匹配这个类型的bean：装配失败<br>
和所需类型匹配的<strong>bean不止一个</strong><br>
没有@Qualifier注解：根据@Autowired标记位置成员变量的变量名作为bean的id进行匹配（<strong>byName</strong>）<br>
能够找到：执行装配<br>
找不到：装配失败<br>
使用@Qualifier注解：根据**@Qualifier注解<strong>中</strong>指定的名称作为bean的id进行匹配**<br>
能够找到：执行装配<br>
找不到：装配失败</p>
<h3> 4、AOP</h3>
<h4> 1、静态代理与动态代理</h4>
<h5> 1、静态代理</h5>
<p>创建静态代理类：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>静态代理确实实现了解耦，但是由于<strong>代码都写死了，完全不具备任何的灵活性</strong>。就拿日志功能来说，将来其他地方也需要附加日志，那还得再声明更多个静态代理类，那就产生了大量重复的代码，日志功能还是分散的，没有统一管理。<br>
提出进一步的需求：将日志功能<strong>集中到一个代理类</strong>中，将来有任何日志需求，都通过这一个代理类来实现。这就需要使用动态代理技术了。</p>
<h5> 2、动态代理</h5>
<p>生产代理对象的工厂类 ：</p>
<p>newProxyInstance()：创建一个代理实例<br>
其中有三个参数：<br>
1、classLoader：加载动态生成的代理类的类加载器<br>
2、interfaces：目标对象实现的所有接口的class对象所组成的数组<br>
3、invocationHandler：<strong>设置代理对象实现目标对象方法的过程，即代理类中如何重写接口中的抽象方法</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2、AOP概念及相关术语</h4>
<p>AOP（Aspect Oriented Programming）是一种设计思想，是软件设计领域中的<strong>面向切面编程</strong>，它是面向对象编程的一种补充和完善，它以通过预编译方式和运行期动态代理方式实现在不修改源代码的情况下给程序动态统一添加额外功能的一种技术 。</p>
<p>①横切关注点 ：从每个方法中抽取出来的同一类<strong>非核心业务</strong>。（日志等）</p>
<p>②通知 ：每一个<strong>横切关注点上要做的事情都需要写一个方法来实现</strong>，这样的方法就叫通知方法。<br>
前置通知：在被代理的目标方法前执行<br>
返回通知：在被代理的目标方法成功结束后执行（寿终正寝）<br>
异常通知：在被代理的目标方法异常结束后执行（死于非命）<br>
后置通知：在被代理的目标方法最终结束后执行（盖棺定论）<br>
环绕通知：使用try...catch...finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置</p>
<p>③切面 ：**封装通知方法的类  **</p>
<p>④目标 ：被代理的目标对象</p>
<p>⑤代理 ：向目标对象应用通知之后创建的代理对象</p>
<p>⑥连接点 ：类里面哪些方法可以被增强，这些方法称为连接点</p>
<p>⑦切入点：实际被真正增强的方法，称为切入点</p>
<h4> 3、基于注解的AOP</h4>
<p>动态代理（InvocationHandler）：JDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求代理对象和目标对象实现同样的接口（兄弟两个拜把子模式）。<br>
cglib：通过继承被代理的目标类（认干爹模式）实现代理，所以不需要目标类实现接口。<br>
<strong>AspectJ：本质上是静态代理，将代理逻辑“织入”被代理的目标类编译得到的字节码文件，所以最终效果是动态的。weaver就是织入器。Spring只是借用了AspectJ中的注解。</strong></p>
<h5> 1、准备工作</h5>
<h6> ①添加依赖</h6>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h6> ②准备被代理的目标资源</h6>
<p>接口：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实现类：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 2、创建切面类并配置</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在Spring的配置文件中配置：<br>
**&lt;aop:aspectj-autoproxy /&gt;**开启注解方式的AOP</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 3、各种通知</h5>
<p>前置通知：<strong>@Before</strong>，在被代理的目标<strong>方法前</strong>执行<br>
后置通知：<strong>@After</strong>，在被代理的目标方法<strong>finally</strong>中执行<br>
返回通知：<strong>@AfterReturning</strong>，在被代理的目标方法<strong>返回值之后</strong>执行<br>
异常通知：<strong>@AfterThrowing</strong>，在被代理的目标方法<strong>catch中执行</strong><br>
环绕通知：<strong>@Around</strong>，使用try...catch...finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置</p>
<h5> 4、切入点表达式语法</h5>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230107162255980.png" alt="image-20230107162255980" loading="lazy"></p>
<p><strong>重用切入点表达式 ：</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 5、获取通知的相关信息</h5>
<p><strong>获取连接点信息  **<br>
获取连接点信息可以</strong>在通知方法的参数位置设置JoinPoint类型的形参  **</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>**获取目标方法的返回值 **<br>
@AfterReturning中的属性returning，用来将通知方法的某个形参，接收目标方法的返回值</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>获取目标方法的异常</strong><br>
@AfterThrowing中的属性throwing，用来将通知方法的某个形参，接收目标方法的异常</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 6、环绕通知</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 7、切面的优先级</h5>
<p>相同目标方法上同时存在多个切面时，切面的优先级控制切面的内外嵌套顺序。<br>
优先级高的切面：外面<br>
优先级低的切面：里面<br>
使用@Order注解可以控制切面的优先级：<br>
@Order(较小的数)：优先级高<br>
@Order(较大的数)：优先级低</p>
<h3> 5、声明式事务</h3>
<h4> 1、JdbcTemplate</h4>
<p>Spring 框架对 JDBC 进行封装，使用 JdbcTemplate 方便实现对数据库操作</p>
<h6> 1、准备工作</h6>
<p>①加入依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>②创建jdbc.properties</p>
<p>③配置Spring的配置文件</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h6> 2、使用</h6>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2、声明式事务</h4>
<p>概念：既然事务控制的代码有规律可循，代码的结构基本是确定的，所以框架就可以将固定模式的代码抽取出来，进行相关的封装。（通过AOP抽取）</p>
<p>编程式：自己写代码实现功能<br>
声明式：通过配置让框架实现功能</p>
<h5> 1、基于注解的声明式事务</h5>
<h6> 准备工作：</h6>
<p>①加入依赖  (同上方依赖的加入)</p>
<p>②创建jdbc.properties （同上）</p>
<p>③配置Spring的配置文件</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>④数据表的准备</p>
<p>⑤创建组件</p>
<p>BookDao：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>BookDaoImpl：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>BookService：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>BookServiceImpl：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>BookController：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试类 :</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h6> 加入事务</h6>
<p>①添加事务配置<br>
在Spring的配置文件中添加配置：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：导入的名称空间需要 tx 结尾的那个。</p>
<p>②添加事务注解<br>
因为service层表示业务逻辑层，一个方法表示一个完成的功能，因此处理事务一般在**service层处理在BookServiceImpl的buybook()添加注解@Transactional  **</p>
<p>**@Transactional标识在方法上，咋只会影响该方法<br>
@Transactional标识的类上，则会影响类中所有的方法  **</p>
<p>事务属性：只读<br>
对一个查询操作来说，如果我们把它设置成<strong>只读</strong>，就能够明确告诉数据库，这个操作不涉及写操作。这样数据库就能够针对查询操作来进行优化。<br>
@Transactional(readOnly = true)<br>
例：对增删改操作设置只读会抛出异常</p>
<p>事务属性：超时（超时回滚，释放资源）<br>
例：@Transactional(timeout = 3)</p>
<p>事务属性：回滚策略<br>
可以通过@Transactional中相关属性设置回滚策略<br>
rollbackFor属性：需要设置一个Class类型的对象<br>
rollbackForClassName属性：需要设置一个字符串类型的全类名<br>
noRollbackFor属性：需要设置一个Class类型的对象<br>
rollbackFor属性：需要设置一个字符串类型的全类名<br>
例：@Transactional(noRollbackFor = ArithmeticException.class)</p>
<h5> 2、基于XML的声明式事务</h5>
<p>将Spring配置文件中去掉tx:annotation-driven 标签，并添加配置：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：基于xml实现的声明式事务，必须引入aspectJ的依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>LeetCode 刷题</title>
      <link>https://T4mako.github.io/code/leetcode/</link>
      <guid>https://T4mako.github.io/code/leetcode/</guid>
      <source url="https://T4mako.github.io/rss.xml">LeetCode 刷题</source>
      <description>LeetCode 刷题 每日更新（大概） 算法 SQL 多线程</description>
      <content:encoded><![CDATA[<h1> LeetCode 刷题</h1>
<p>每日更新（大概）</p>
<p><a href="/code/leetcode/%E7%AE%97%E6%B3%95/" target="blank">算法</a><br>
<a href="/code/leetcode/SQL/" target="blank">SQL</a><br>
<a href="/code/leetcode/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" target="blank">多线程</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>Python 基础语法</title>
      <link>https://T4mako.github.io/code/python/python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html</link>
      <guid>https://T4mako.github.io/code/python/python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html</guid>
      <source url="https://T4mako.github.io/rss.xml">Python 基础语法</source>
      <description># 1、数据类型 Python3 中有六个标准的数据类型： Number（数字）; String（字符串）; List（列表）; Tuple（元组）; Set（集合）; Dictionary（字典）; Python3 的六个标准数据类型中： 不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）（不可修改索引对应的值）;...</description>
      <content:encoded><![CDATA[<h1> </h1>
<!-- more -->
<h2> 1、数据类型</h2>
<p>Python3 中有六个标准的数据类型：</p>
<ul>
<li>Number（数字）</li>
<li>String（字符串）</li>
<li>List（列表）</li>
<li>Tuple（元组）</li>
<li>Set（集合）</li>
<li>Dictionary（字典）</li>
</ul>
<p>Python3 的六个标准数据类型中：</p>
<ul>
<li>**不可变数据（3 个）：**Number（数字）、String（字符串）、Tuple（元组）（不可修改索引对应的值）</li>
<li>**可变数据（3 个）：**List（列表）、Dictionary（字典）、Set（集合）</li>
</ul>
<h3> Number（数字）</h3>
<p><strong>int、float、bool、complex（复数）</strong>。</p>
<ul>
<li><strong>整型(Int)</strong> - 通常被称为是整型或整数，是正或负整数，不带小数点。</li>
<li><strong>长整型(long integers)</strong> - 无限大小的整数，整数最后是一个大写或小写的L。</li>
<li><strong>浮点型(floating point real values)</strong> - 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 = 2.5 x 102 = 250）</li>
<li><strong>复数(complex numbers)</strong> - 复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。</li>
</ul>
<p>我们可以使用十六进制和八进制来代表整数：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>bool 是 int 的子类，True 和 False 可以和数字相加</strong></p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> String（字符串）</h3>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> List（列表）</h3>
<p>列表是写在方括号 <strong>[]</strong> 之间、用逗号分隔开的元素列表。<br>
列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>常用方法：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> Tuple（元组）</h3>
<p>元组（tuple）与列表类似，不同之处在于元组的<strong>元素不能修改</strong>。元组写在小括号 <strong>()</strong> 里，元素之间用逗号隔开。<br>
元组中的元素类型也可以不相同：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>string、list 和 tuple 都属于 sequence（序列）。<br>
元祖不可以进行的操作：append，insert，pop，del，remove......</p>
<h3> Set（集合）</h3>
<p>集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。<br>
基本功能是进行成员关系测试和删除重复元素。<br>
可以使用大括号 <strong>{ }</strong> 或者 <strong>set()</strong> 函数创建集合，注意：创建一个空集合必须用 <strong>set()</strong> 而不是 <strong>{ }</strong>，因为 <strong>{ }</strong> 是用来创建一个空字典。</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> Dictionary（字典）</h3>
<p>列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。</p>
<p>字典是一种映射类型，字典用 <strong>{ }</strong> 标识，它是一个无序的 <strong>键(key) : 值(value)</strong> 的集合。<br>
<strong>键(key)必须使用不可变类型。</strong><br>
在同一个字典中，<strong>键(key)必须是唯一的。</strong></p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">函数及描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">dict.clear() 删除字典内所有元素</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">dict.copy() 返回一个字典的浅复制</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">dict.fromkeys(seq[, val]) 创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">dict.get(key, default=None)返回指定键的值，如果值不在字典中返回default值</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">dict.has_key(key) 如果键在字典dict里返回true，否则返回false</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">dict.items() 以<strong>列表返回可遍历的(键, 值) 元组数组</strong>  转换成list还需强转</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">dict.keys() 以列表返回一个字典所有的键</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">dict.setdefault(key, default=None) 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left">dict.update(dict2)把字典dict2的键/值对更新到dict里</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left">dict.values()以列表返回字典中的所有值</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left">pop(key[,default])删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。</td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left">popitem()返回并删除字典中的最后一对键和值。</td>
</tr>
</tbody>
</table>
<h3> Python数据类型转换</h3>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">int(x [,base])</td>
<td style="text-align:left">将x转换为一个整数，base为该数为几进制</td>
</tr>
<tr>
<td style="text-align:left">float(x)</td>
<td style="text-align:left">将x转换到一个浮点数</td>
</tr>
<tr>
<td style="text-align:left">[complex(real <a href="https://www.runoob.com/python3/python-func-complex.html" target="_blank" rel="noopener noreferrer">,imag])</a></td>
<td style="text-align:left">创建一个复数</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/python3/python-func-str.html" target="_blank" rel="noopener noreferrer">str(x)</a></td>
<td style="text-align:left">将对象 x 转换为字符串</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/python3/python-func-repr.html" target="_blank" rel="noopener noreferrer">repr(x)</a></td>
<td style="text-align:left">将对象 x 转换为表达式字符串</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/python3/python-func-eval.html" target="_blank" rel="noopener noreferrer">eval(str)</a></td>
<td style="text-align:left">用来计算在字符串中的有效Python表达式,并返回一个对象</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/python3/python3-func-tuple.html" target="_blank" rel="noopener noreferrer">tuple(s)</a></td>
<td style="text-align:left">将序列 s 转换为一个元组</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/python3/python3-att-list-list.html" target="_blank" rel="noopener noreferrer">list(s)</a></td>
<td style="text-align:left">将序列 s 转换为一个列表</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/python3/python-func-set.html" target="_blank" rel="noopener noreferrer">set(s)</a></td>
<td style="text-align:left">转换为可变集合</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/python3/python-func-dict.html" target="_blank" rel="noopener noreferrer">dict(d)</a></td>
<td style="text-align:left">创建一个字典。d 必须是一个 (key, value)元组序列。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/python3/python-func-frozenset.html" target="_blank" rel="noopener noreferrer">frozenset(s)</a></td>
<td style="text-align:left">转换为不可变集合</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/python3/python-func-chr.html" target="_blank" rel="noopener noreferrer">chr(x)</a></td>
<td style="text-align:left">将一个整数转换为一个字符</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/python3/python-func-ord.html" target="_blank" rel="noopener noreferrer">ord(x)</a></td>
<td style="text-align:left">将一个字符转换为它的整数值</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/python3/python-func-hex.html" target="_blank" rel="noopener noreferrer">hex(x)</a></td>
<td style="text-align:left">将一个整数转换为一个十六进制字符串</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/python3/python-func-oct.html" target="_blank" rel="noopener noreferrer">oct(x)</a></td>
<td style="text-align:left">将一个整数转换为一个八进制字符串</td>
</tr>
</tbody>
</table>
<h2> 2、注释</h2>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3、运算符</h2>
<h3> 逻辑运算符</h3>
<table>
<thead>
<tr>
<th>and</th>
<th>x and y</th>
<th>布尔"与" - 如果 x 为 False，x and y 返回 x 的值，否则返回 y 的计算值。</th>
<th>(a and b) 返回 20。</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>or</strong></td>
<td><strong>x or y</strong></td>
<td><strong>布尔"或" - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。</strong></td>
<td><strong>(a or b) 返回 10。</strong></td>
</tr>
<tr>
<td><strong>not</strong></td>
<td><strong>not x</strong></td>
<td><strong>布尔"非" - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</strong></td>
<td><strong>not(a and b) 返回 False</strong></td>
</tr>
</tbody>
</table>
<h3> Python成员运算符</h3>
<p>除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">in</td>
<td style="text-align:left">如果在指定的序列中找到值返回 True，否则返回 False。</td>
<td style="text-align:left">x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</td>
</tr>
<tr>
<td style="text-align:left">not in</td>
<td style="text-align:left">如果在指定的序列中没有找到值返回 True，否则返回 False。</td>
<td style="text-align:left">x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。</td>
</tr>
</tbody>
</table>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> Python身份运算符</h3>
<p>身份运算符用于比较两个对象的存储单元<br>
<strong>id()</strong> 函数用于获取对象内存地址。</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">is</td>
<td style="text-align:left">is 是判断两个标识符是不是引用自一个对象</td>
<td style="text-align:left"><strong>x is y</strong>, 类似 <strong>id(x) == id(y)</strong> , 如果引用的是同一个对象则返回 True，否则返回 False</td>
</tr>
<tr>
<td style="text-align:left">is not</td>
<td style="text-align:left">is not 是判断两个标识符是不是引用自不同对象</td>
<td style="text-align:left"><strong>x is not y</strong> ， 类似 <strong>id(x) != id(y)</strong>。如果引用的不是同一个对象则返回结果 True，否则返回 False。</td>
</tr>
</tbody>
</table>
<h2> 4、分支循环</h2>
<h3> 1、IF</h3>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2、While</h3>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3、For</h3>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4、break，continue</h3>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5、pass</h3>
<p><strong>pass</strong> 不做任何事情，一般用做占位语句。</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 5、math模块，cmath 模块</h2>
<p>Python 中数学运算常用的函数基本都在 math 模块、cmath 模块中。<br>
Python math 模块提供了许多对浮点数的数学运算函数。<br>
Python cmath 模块包含了一些用于复数运算的函数。<br>
cmath 模块的函数跟 math 模块函数基本一致，区别是 cmath 模块运算的是复数，math 模块运算的是数学运算。<br>
要使用 math 或 cmath 函数必须先导入：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> Python数学函数</h3>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">返回值 ( 描述 )</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">abs(x)</td>
<td style="text-align:left">返回数字的绝对值，如abs(-10) 返回 10</td>
</tr>
<tr>
<td style="text-align:left">ceil(x)</td>
<td style="text-align:left">返回数字的上入整数，如math.ceil(4.1) 返回 5</td>
</tr>
<tr>
<td style="text-align:left">cmp(x, y)</td>
<td style="text-align:left">如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1</td>
</tr>
<tr>
<td style="text-align:left">exp(x)</td>
<td style="text-align:left">返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045</td>
</tr>
<tr>
<td style="text-align:left">fabs(x)</td>
<td style="text-align:left">返回数字的绝对值，如math.fabs(-10) 返回10.0</td>
</tr>
<tr>
<td style="text-align:left">floor(x)</td>
<td style="text-align:left">返回数字的下舍整数，如math.floor(4.9)返回 4</td>
</tr>
<tr>
<td style="text-align:left">log(x)</td>
<td style="text-align:left">如math.log(math.e)返回1.0,math.log(100,10)返回2.0</td>
</tr>
<tr>
<td style="text-align:left">log10(x)</td>
<td style="text-align:left">返回以10为基数的x的对数，如math.log10(100)返回 2.0</td>
</tr>
<tr>
<td style="text-align:left">max(x1, x2,...)</td>
<td style="text-align:left">返回给定参数的最大值，参数可以为序列。</td>
</tr>
<tr>
<td style="text-align:left">min(x1, x2,...)</td>
<td style="text-align:left">返回给定参数的最小值，参数可以为序列。</td>
</tr>
<tr>
<td style="text-align:left">modf(x)</td>
<td style="text-align:left">返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。</td>
</tr>
<tr>
<td style="text-align:left">pow(x, y)</td>
<td style="text-align:left">x**y 运算后的值。</td>
</tr>
<tr>
<td style="text-align:left"><strong>round(x [,n])</strong></td>
<td style="text-align:left">返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数。</td>
</tr>
<tr>
<td style="text-align:left">sqrt(x)</td>
<td style="text-align:left">返回数字x的平方根</td>
</tr>
</tbody>
</table>
<h3> Python随机数函数</h3>
<p>随机数可以用于数学，游戏，安全等领域中，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性。</p>
<p>Python包含以下常用随机数函数：</p>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">choice(seq)</td>
<td style="text-align:left">从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。</td>
</tr>
<tr>
<td style="text-align:left">randrange ([start,] stop [,step])</td>
<td style="text-align:left">从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1</td>
</tr>
<tr>
<td style="text-align:left">random()</td>
<td style="text-align:left">随机生成下一个实数，它在[0,1)范围内。</td>
</tr>
<tr>
<td style="text-align:left">seed([x])</td>
<td style="text-align:left">改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。</td>
</tr>
<tr>
<td style="text-align:left">shuffle(lst)</td>
<td style="text-align:left">将序列的所有元素随机排序</td>
</tr>
<tr>
<td style="text-align:left">uniform(x, y)</td>
<td style="text-align:left">随机生成下一个实数，它在[x,y]范围内。</td>
</tr>
</tbody>
</table>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 6、Python 函数</h2>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 7、输入输出</h2>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 8、File方法</h2>
<h4> open() 方法</h4>
<p>Python <strong>open()</strong> 方法用于打开一个文件，并返回文件对象。<br>
在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 <strong>OSError</strong>。<br>
**注意：**使用 <strong>open()</strong> 方法一定要保证关闭文件对象，即调用 <strong>close()</strong> 方法。<br>
<strong>open()</strong> 函数常用形式是接收两个参数：文件名(file)和模式(mode)。</p>
<h2> 9、内置函数</h2>
<p>eval() 函数用来执行一个字符串表达式，并返回表达式的值。</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Ajax 教程</title>
      <link>https://T4mako.github.io/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Ajax.html</link>
      <guid>https://T4mako.github.io/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Ajax.html</guid>
      <source url="https://T4mako.github.io/rss.xml">Ajax 教程</source>
      <description>1、原生 Ajax 1.1、 Ajax简介 Ajax 全称为 Asynchronous Javascript And XML，即 异步JS和XML 通过Ajax可以在浏览器中向服务器发送异步请求，最大的优势：无刷新获取数据 AJAX不是新的编程语言，而是一种将 现有 的 标准组合 在一起使用的新方式 1.2、 XML简介 XML：可扩展标记语言 XML：被设计用来传输和存储数据 XML和HTML类似，不同点：HTML中都是预定义标签，XML 中没有预定义标签，全是 自定义标签，用来表示一些数据 现在已被JSON取代</description>
      <content:encoded><![CDATA[<h2> 1、原生 Ajax</h2>
<h3> 1.1、 Ajax简介</h3>
<ul>
<li>Ajax 全称为 Asynchronous Javascript And XML，即 <strong>异步JS和XML</strong></li>
<li>通过Ajax可以在浏览器中向服务器发送异步请求，最大的优势：<strong>无刷新获取数据</strong></li>
<li>AJAX不是新的编程语言，而是一种将 <strong>现有</strong> 的 <strong>标准组合</strong> 在一起使用的新方式</li>
</ul>
<h3> 1.2、 XML简介</h3>
<ul>
<li>XML：可扩展标记语言</li>
<li>XML：被设计用来传输和存储数据</li>
<li>XML和HTML类似，不同点：HTML中都是预定义标签，<strong>XML</strong> 中没有预定义标签，全是 <strong>自定义标签</strong>，用来表示一些数据</li>
<li>现在已被JSON取代</li>
</ul>
<h3> 1.3 、AJAX 的特点</h3>
<h4> 1.3.1 AJAX的优点</h4>
<ol>
<li>可以 <strong>无刷新页面</strong> 与 <strong>服务端进行通信</strong></li>
<li>允许你 <strong>根据用户事件</strong> 来 <strong>更新部分页面</strong> 内容</li>
</ol>
<h4> 1.3.2、 AJAX 的缺点</h4>
<ol>
<li>没有浏览历史，不能回退</li>
<li><strong>Ajax</strong> 存在 <strong>跨域问题</strong>（同源）</li>
<li>SEO不友好（爬虫获取不到信息）</li>
</ol>
<h3> 1.4、 AJAX 的使用</h3>
<h4> 1.4.1、 核心对象 XMLHttpRequest</h4>
<ol>
<li>
<p><strong>XMLHttpRequest ：</strong><br>
<code>XMLHttpRequest</code>（<strong>XHR</strong>）对象用于与服务器交互。通过 XMLHttpRequest 可以在不刷新页面的情况下请求特定 URL，获取数据。<br>
这允许网页在不影响用户操作的情况下，更新页面的局部内容。<code>XMLHttpRequest</code> 在 AJAX 编程中被大量使用。</p>
</li>
<li>
<p><strong>构造函数：<code>XMLHttpRequest()</code></strong><br>
该构造函数用于初始化一个 <code>XMLHttpRequest</code> 实例对象。<br>
在调用下列任何其他方法之前，<strong>必须先调用该构造函数</strong>，或通过其他方式，得到一个实例对象。</p>
<p><strong>const xhr = new XMLHttpRequest();</strong></p>
</li>
<li>
<p><strong>常用属性：</strong></p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>status</td>
<td>响应状态码。<strong>200,404,5XX...</strong></td>
</tr>
<tr>
<td>readystate</td>
<td>请求的状态。<strong>0 1 2 3 4</strong><br>0：初始值<br>1：open 方法调用<br>2：send 方法调用<br>3：服务端返回部分结果<br>4：服务端返回全部结果</td>
</tr>
<tr>
<td>onreadystatechange</td>
<td>当 <code>readyState</code> 属性发生变化时，调用的事件处理器</td>
</tr>
<tr>
<td>responseType</td>
<td>指定响应的数据类型<br>如：<strong>xhr.responseType = 'json';</strong></td>
</tr>
<tr>
<td>timeout</td>
<td>设置响应超时时间，超过该时间，取消 ajax 请求</td>
</tr>
<tr>
<td>ontimeout</td>
<td>超时回调的方法<br>xhr.ontimeout = function(){}</td>
</tr>
<tr>
<td>onerror</td>
<td>网络异常回调</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>常用方法：</strong></p>
</li>
</ol>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>open()</td>
<td>初始化一个请求，设置 请求方法 和 url<br>xhr.open('GET', '<a href="http://127.0.0.1:8000/server?a=100&amp;b=200&amp;c=300" target="_blank" rel="noopener noreferrer">http://127.0.0.1:8000/server?a=100&amp;b=200&amp;c=300</a>')</td>
</tr>
<tr>
<td>send()</td>
<td>发送请求。如果请求是异步的（默认），那么该方法将在请求发送后立即返回。<br>xhr.send()</td>
</tr>
<tr>
<td>setRequestHeader()</td>
<td>设置 <strong>请求头</strong> 的值。必须在 <code>open()</code> 之后、<code>send()</code> 之前调用 该方法。</td>
</tr>
<tr>
<td>abort()</td>
<td>立刻中止请求</td>
</tr>
</tbody>
</table>
<h4> 1.4.2、GET 请求</h4>
<p>GET.html：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Server.js：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.4.3、POST 请求</h4>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.4.4、 处理 JSON 响应体</h4>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.4.5、超时与网络异常</h4>
<p>设置服务器响应的时间，如果超过该时间，取消 ajax 请求</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.4.6、 取消 Ajax 请求</h4>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.4.7、 Ajax 重复发送问题</h4>
<p>通过 节流 的方式<br>
设置一个 <strong>判断标识变量</strong></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2、Axios 发送 Ajax</h2>
<p>使用 cnd链接 引入Axios：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>发送请求：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3、fetch 函数发送 Ajax</h2>
<p>fetch 区别于 ajax<br>
可以直接通过 window对象 内置的 <strong>fetch</strong> 发送请求<br>
fetch 也是 promise 风格</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 4、 跨域</h2>
<h3> 4.1、同源策略</h3>
<p>同源策略（Same-Origin Policy）最早由 Netscape 公司提出，是浏览器的一种安全策略。<br>
<strong>同源</strong>：<strong>协议、域名、端口号</strong> 必须 <strong>完全相同</strong><br>
违背同源策略就是 <strong>跨域</strong></p>
<p>Ajax 默认遵循同源规则</p>
<h3> 4.2、 JSONP 解决跨域 （几乎不用）</h3>
<ol>
<li>
<p>JSONP是什么</p>
<p>JSONP (JSON with Padding)，是一个非官方的跨域解决方案，纯粹凭借程序员的聪明才智开发出来，<strong>只支持get请求</strong></p>
</li>
<li>
<p>JSONP 怎么工作的？</p>
<p>在网页有一些 <strong>标签</strong> 天生 <strong>具有跨域能力</strong>，比如：img, link, iframe, script</p>
<p>JSONP就是利用 <strong>script</strong> <strong>标签</strong> 的跨域能力来发送请求的</p>
</li>
<li>
<p>JSONP的使用</p>
<ul>
<li>动态的创建一个script标签</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>设置script的src，设置回调函数</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
</ol>
<p>JSONP 实践：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4.3、CORS 解决跨域</h3>
<ol>
<li>
<p>CORS是什么？</p>
<p><strong>CORS</strong> (Cross-Origin Resource Sharing), 跨域资源共享。CORS 是 <strong>官方的跨域解决方案</strong>，它的特点是不需要在客户端做任何特殊的操作，<strong>完全在服务器中进行处理</strong>，支持 get 和 post 等请求。跨域资源共享标准 <strong>新增了一组 HTTP  首部字段</strong>（<strong>响应头</strong>），允许服务器声明哪些源站通过浏览器有权限访问哪些资源</p>
</li>
<li>
<p>CORS怎么工作的？</p>
<p>CORS 是通过设置一个 <strong>响应头</strong> 来告诉浏览器，<strong>该请求允许跨域，浏览器收到该响应以后就会对响应放行</strong>。</p>
</li>
</ol>
<p>主要是服务端的设置<br>
在 node.js 中设置 响应头</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>推荐阅读：</p>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener noreferrer">http://www.ruanyifeng.com/blog/2016/04/cors.html</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener noreferrer">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS</a></li>
</ul>
<h3> 4.4、配置代理服务器</h3>
<p>1、借助 nginx<br>
2、借助 vue-cli （vue脚手架）见 vue 笔记</p>
]]></content:encoded>
    </item>
    <item>
      <title>Axios 教程</title>
      <link>https://T4mako.github.io/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Axios.html</link>
      <guid>https://T4mako.github.io/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Axios.html</guid>
      <source url="https://T4mako.github.io/rss.xml">Axios 教程</source>
      <description>axios 引入方式：https://github.com/axios/axios#installing 1、json-server 介绍与服务搭建 json-server 介绍与服务搭建 Get a full fake REST API with zero coding in less than 30 seconds</description>
      <content:encoded><![CDATA[<p>axios 引入方式：<a href="https://github.com/axios/axios#installing" target="_blank" rel="noopener noreferrer">https://github.com/axios/axios#installing</a></p>
<h2> 1、json-server 介绍与服务搭建</h2>
<p><a href="https://github.com/typicode/json-server" target="_blank" rel="noopener noreferrer">json-server</a> 介绍与服务搭建<br>
Get a full fake REST API with zero coding in less than 30 seconds</p>
<p>全局安装：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>创建一个 db.json 文件</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>开启服务（在 db.json 所在目录）</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>访问<br>
<a href="http://localhost:3000/posts/1" target="_blank" rel="noopener noreferrer">http://localhost:3000/posts/1</a><br>
<a href="http://localhost:3000/posts" target="_blank" rel="noopener noreferrer">http://localhost:3000/posts</a><br>
<a href="http://localhost:3000/comments" target="_blank" rel="noopener noreferrer">http://localhost:3000/comments</a><br>
<a href="http://localhost:3000/profile" target="_blank" rel="noopener noreferrer">http://localhost:3000/profile</a></p>
<h2> 2、Axios() 函数发送请求</h2>
<p>axios ：前端最流行的 ajax 请求库，react/vue 官方都推荐使用 axios 发 ajax 请求 ，基于 xhr + promise 的异步 ajax 请求库</p>
<p><strong>axios 函数返回一个 Promise 对象</strong></p>
<p>axios 可以向服务端发送 ajax 请求<br>
在 node.js 中向远端服务发送 http 请求</p>
<p>对应 <strong>Restful</strong> 风格的 增删改查 基本使用：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3、Axios 对象方法发送请求</h2>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 4、Axios 请求配置</h2>
<p><a href="https://github.com/axios/axios#request-config" target="_blank" rel="noopener noreferrer">Axios 请求配置</a></p>
<h3> 4.1、常用配置</h3>
<p><strong>url</strong>： 是必须的</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>请求方式：默认为 GET</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>headers：设置请求头信息</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>data：请求体</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>params：传递 url 参数：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>baseUrl：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>timeout：请求超时时间，超时就取消，单位为 <strong>ms</strong></p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>responseType：响应结果类型</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>proxy：代理</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4.2、设置默认值</h3>
<p><strong><a href="http://axios.defaults.XXX" target="_blank" rel="noopener noreferrer">axios.defaults.XXX</a> = 值</strong></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 5、Axios 实例对象发送请求</h2>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 6、Axios 配置拦截器</h2>
<p>使用介绍：<a href="https://github.com/axios/axios#interceptors" target="_blank" rel="noopener noreferrer">https://github.com/axios/axios#interceptors</a></p>
<p><strong>① 请求拦截器：</strong></p>
<p>通过回调对请求的参数等进行校验等功能</p>
<p><strong>② 响应拦截器：</strong></p>
<p>通过回调函数对结果进行预处理</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行顺序：请求拦截器 2，请求拦截器 1，响应拦截器 1，响应拦截器 2</p>
<h2> 7、Axios 取消请求</h2>
<p><a href="https://github.com/axios/axios#cancellation" target="_blank" rel="noopener noreferrer">https://github.com/axios/axios#cancellation</a></p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 8、Axios 源码分析</h2>
<h3> axios.js</h3>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>axios运行的整体流程：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230507102721089.png" alt="image-20230507102721089" loading="lazy"></p>
<p>request(config) ==&gt; dispatchRequest(config) ==&gt; xhrAdapter(config)</p>
<p>request(config):<br>
将请求拦截器 / dispatchRequest() / 响应拦截器 通过 promise 链串连起来,<br>
返回 promise<br>
dispatchRequest(config):<br>
转换请求数据 =&gt; 调用 xhrAdapter()发请求 =&gt; 请求返回后转换响应数<br>
据. 返回 promise<br>
xhrAdapter(config):<br>
创建 XHR 对象, 根据 config 进行相应设置, 发送特定请求, 并接收响应数据,<br>
返回 promise</p>
]]></content:encoded>
      <enclosure url="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230507102721089.png" type="image/png"/>
    </item>
    <item>
      <title>CSS 基础</title>
      <link>https://T4mako.github.io/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/CSS3.html</link>
      <guid>https://T4mako.github.io/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/CSS3.html</guid>
      <source url="https://T4mako.github.io/rss.xml">CSS 基础</source>
      <description>1、CSS 层叠样式表 Cascading style sheets 1.1、语法规则 1.2、书写位置 head 标签中的 style 标签中 css注释为 /* */ 1.3、CSS 引入方式 引入方式 书写位置 作用范围 使用场景 -------- -------------------------- -------- ------------ ...</description>
      <content:encoded><![CDATA[<h1> </h1>
<!-- more -->
<h2> 1、CSS 层叠样式表</h2>
<p>Cascading style sheets</p>
<h3> 1.1、语法规则</h3>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.2、书写位置</h3>
<p>head 标签中的 style 标签中</p>
<p>css注释为 <em><em>/</em> <em>/</em></em></p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3、CSS 引入方式</h3>
<table>
<thead>
<tr>
<th>引入方式</th>
<th>书写位置</th>
<th>作用范围</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>内嵌式</td>
<td>style 标签</td>
<td>当前页面</td>
<td>小案例</td>
</tr>
<tr>
<td>外链式</td>
<td>link 标签引入单独 css 文件</td>
<td>多个页面</td>
<td>项目中</td>
</tr>
<tr>
<td>行内式</td>
<td>标签 style 属性中</td>
<td>当前标签</td>
<td>配合 js 使用</td>
</tr>
</tbody>
</table>
<h4> （1）内嵌式</h4>
<ul>
<li>CSS 写在 <strong>style 标签</strong>中</li>
<li>style 标签可以写在页面任意位置，<strong>一般放在 head 标签</strong>中</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> （2）外链式</h4>
<ul>
<li>CSS 写在<strong>单独的<code>.css</code>文件</strong>中</li>
<li>通过 <strong>link 标签</strong>引入到网页中</li>
</ul>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> （3）行内式</h4>
<ul>
<li>CSS 写在标签 <strong>style 属性</strong>中</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.4、基础选择器</h3>
<ul>
<li>标签选择器</li>
<li>类选择器</li>
<li>id 选择器</li>
<li>通配符选择器</li>
</ul>
<h4> （1）标签选择器</h4>
<p>格式：<br>
标签选择器会选择所有相同标签</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>举例：</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> （2）类选择器</h4>
<p>格式：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>合法的<strong>类名</strong>：<strong>数字、字母、下划线、中划线</strong></li>
<li><strong>一个元素</strong>可以有<strong>多个类名</strong>，<strong>空格隔开</strong></li>
</ul>
<p>举例：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> （3）id 选择器</h4>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><strong>页面中唯一</strong>，不能重复</li>
<li><strong>一个标签</strong>只能有<strong>一个 id</strong></li>
<li>id 选择器一般与 js 配合使用</li>
</ul>
<p>举例：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> （4）通配符选择器</h4>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>选中页面<strong>所有标签</strong></li>
<li>一般用于统一设置页面样式</li>
</ul>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2、CSS 字体和文本样式</h2>
<p>样式的层叠问题：给同一个标签设置相同的样式，此时样式会层叠（覆盖），写在最下面的会生效<br>
所谓层叠即叠加，样式一层一层层叠覆盖</p>
<h3> 2.1、字体大小</h3>
<p>浏览器默认字体大小 <strong>16px</strong><br>
修改字体大小：<strong>font-size</strong></p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.2、字体粗细</h3>
<p><strong>font-weigh</strong><br>
数值为100~900的<strong>整百</strong>数</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><table>
<thead>
<tr>
<th>属性值</th>
<th>数值</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>normal</td>
<td>400</td>
<td>正常</td>
</tr>
<tr>
<td>bold</td>
<td>700</td>
<td>加粗</td>
</tr>
</tbody>
</table>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>注意：不是所有字体都提供了九种粗细，因此部分取值页面中无变化。<br>
实际开发中以：正常、加粗两种取值使用最多</p>
</blockquote>
<h3> 2.3、字体样式</h3>
<p><strong>font-style</strong></p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><table>
<thead>
<tr>
<th>属性值</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>normal</strong></td>
<td>正常</td>
</tr>
<tr>
<td><strong>italic</strong></td>
<td>倾斜</td>
</tr>
</tbody>
</table>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.4、字体系列</h3>
<p><strong>font-family</strong></p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table>
<thead>
<tr>
<th>操作系统</th>
<th>默认字体</th>
</tr>
</thead>
<tbody>
<tr>
<td>windows</td>
<td>微软雅黑</td>
</tr>
<tr>
<td>Mac</td>
<td>PingFang SC</td>
</tr>
</tbody>
</table>
<p>常见字体系列</p>
<table>
<thead>
<tr>
<th>常见字体系列</th>
<th>特点</th>
<th>场景</th>
<th>该系列常见字体</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>无衬线字体（sans-serif）</strong></td>
<td>文字笔画粗细均匀，并且首尾无装饰</td>
<td>网页</td>
<td>黑体、Arial</td>
</tr>
<tr>
<td><strong>衬线字体（serif）</strong></td>
<td>文字笔画粗细不均匀，并且首尾有装饰</td>
<td>报刊书籍</td>
<td>宋体、Times New Roman</td>
</tr>
<tr>
<td><strong>等宽字体（monospace）</strong></td>
<td>每个字母或文字的宽度相等</td>
<td>程序代码编写</td>
<td>Consolas、 fira Code</td>
</tr>
</tbody>
</table>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.5、文本缩进</h3>
<p><strong>text-indent</strong></p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>取值</p>
<ul>
<li>数字 + px</li>
<li>数字 + em  (推荐：<strong>1em</strong>=当前标签的 <strong>font-size 大小</strong>)</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.6、文本水平对齐（内容对齐）方式</h3>
<p><strong>text-align（内容居中，针对字标签的内容进行居中）</strong></p>
<p>可以用<strong>text-align</strong>居中的<strong>内容标签</strong>：（inline-block，inline）<br>
<strong>文本、span、a、input、img</strong></p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table>
<thead>
<tr>
<th>属性值</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>left</td>
<td>左对齐（默认）</td>
</tr>
<tr>
<td>center</td>
<td>居中对齐</td>
</tr>
<tr>
<td>right</td>
<td>右对齐</td>
</tr>
</tbody>
</table>
<p>内容居中需要给 <strong>父元素</strong> 设置居中属性</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.7、文本修饰</h3>
<p><strong>清除a标签</strong>默认下划线：</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><table>
<thead>
<tr>
<th>属性值</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>underline</td>
<td>下划线</td>
</tr>
<tr>
<td>line-through</td>
<td>删除线</td>
</tr>
<tr>
<td>overline</td>
<td>上划线</td>
</tr>
<tr>
<td>none</td>
<td>无</td>
</tr>
</tbody>
</table>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.8、行高</h3>
<p><strong>line-height</strong></p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230401135946.png" alt="" loading="lazy"></p>
<p><strong>文本高度</strong> = 上间距 + 文本高度 + 下间距</p>
<p>line-height 取值：<br>
<strong>数字 + px</strong><br>
<strong>倍数</strong>（当前标签 font-size 的倍数，即<strong>不算上下间距</strong>的倍数）</p>
<p>常用应用方式：<br>
单行文本垂直居中：l<strong>ine-height=元素父元素高度</strong><br>
取消上下间距：<strong>line-height=1</strong></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.9、font 属性简写（复合属性）</h3>
<p>复合属性:<br>
<strong>font: style weight size/lh 字体</strong> <strong>分先后顺序</strong></p>
<p>只能省略前面两个，如果省略了相当于设置默认值<br>
若要同时设置<strong>单独和连写</strong>模式：单独写在连写下面（层叠）</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在线配置 font 简写-形式<br>
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/font#live_sample" target="_blank" rel="noopener noreferrer">https://developer.mozilla.org/en-US/docs/Web/CSS/font#live_sample</a></p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>关于Chrome调试工具：f12打开，选择元素，左边为html，右边为css3，<strong>css3样式</strong>可以通过<strong>键盘方向键</strong>修改，<strong>TAB键新增样式</strong><br>
<strong>查看网页源代码：ctrl+u 或者右键网页 查看源代码</strong></p>
</blockquote>
<h3> 2.10、颜色取值</h3>
<ul>
<li><strong>文字颜色 color</strong></li>
<li><strong>背景颜色 background-color</strong></li>
</ul>
<table>
<thead>
<tr>
<th>颜色表示方式</th>
<th>表示含义</th>
<th>属性值</th>
</tr>
</thead>
<tbody>
<tr>
<td>关键词</td>
<td>预定义的颜色名</td>
<td>red、green、blue</td>
</tr>
<tr>
<td>rbg 表示法</td>
<td>红绿蓝三原色，取值 0-255</td>
<td>rgb(0,0,0)</td>
</tr>
<tr>
<td><strong>rgba 表示法</strong></td>
<td>红绿蓝三原色+透明度，取值 0-1</td>
<td>rgba(0, 0, 0, 0.5)</td>
</tr>
<tr>
<td><strong>十六进制表示法</strong></td>
<td>#开头，数字转换为16进制</td>
<td>#ff0000 简写 #f00</td>
</tr>
</tbody>
</table>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.11、水平居中</h3>
<p><strong>margin</strong></p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>div、p、h（大盒子） 需要设置元素的宽度，否则会自动撑满父元素</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3、CSS 选择器进阶</h2>
<h3> 3.1、后代选择器</h3>
<p>后代选择器，即<strong>后代，儿子，孙子，重孙子...都会被选中</strong></p>
<p>格式：</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>选择器可以是标签、类、id......等选择器</p>
<p>示例：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.2、子代选择器</h3>
<p><strong>只会选中儿子</strong></p>
<p>格式：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>示例：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.3、并集选择器</h3>
<p>格式：</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>示例：<br>
<strong>代码规范：多个选择器，空格后回车</strong></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.4、交集选择器</h3>
<p>交集选择器是找两个或多个选择器的交集</p>
<p>格式：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>示例：</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.4、相邻兄弟选择器</h3>
<p>相邻兄弟选择器是用来选取<strong>某个元素紧邻的兄弟元素</strong>,它的语法是 "选择器A + 选择器B"</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.5、通用兄弟选择器</h3>
<p>通用兄弟选择器和相邻兄弟选择器很相似,它的语法是"选择器A ~ 选择器B"，会匹配选择器A后面所有符合选择器B的元素</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.6、:hover 伪类选择器</h3>
<p>作用：<strong>鼠标悬停</strong>在元素上的样式<br>
<strong>任何标签都可以添加伪类，任何一个标签都可以鼠标悬停</strong></p>
<p>格式：</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>示例：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.7、结构伪类选择器</h3>
<ul>
<li>作用：根据元素在 HTML 中的**（父子）结构关系查找元素**</li>
<li>优势：减少对 HTML 中类的依赖，有利于<strong>保持代码整洁</strong></li>
<li>场景：常<strong>用于查找某父级选择器中的子元素</strong></li>
</ul>
<table>
<thead>
<tr>
<th>选择器</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>E:first-child</td>
<td>父元素中的第一个子元素 E</td>
</tr>
<tr>
<td>E:last-child</td>
<td>父元素中的最后一个子元素 E</td>
</tr>
<tr>
<td>E:nth-child(n)</td>
<td>父元素中的第 n 个子元素 E</td>
</tr>
<tr>
<td>E:nth-last-child(n)</td>
<td>父元素中的倒数第 n 个子元素 E</td>
</tr>
</tbody>
</table>
<p>n 可以写公式</p>
<p>n 可取值：0 1 2 3 4...</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>公式</th>
</tr>
</thead>
<tbody>
<tr>
<td>偶数</td>
<td>2n、even</td>
</tr>
<tr>
<td>奇数</td>
<td>2n+1、2n-1、odd</td>
</tr>
<tr>
<td>找到前 5 个</td>
<td>-n+5</td>
</tr>
<tr>
<td>找到从第 5 个往后</td>
<td>n+5</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230401221325.png" alt="" loading="lazy"></p>
<h3> 3.8、伪元素</h3>
<ul>
<li>元素：HTML 标签</li>
<li>伪元素：<strong>CSS 模拟出标签效果</strong>，装饰性内容</li>
</ul>
<table>
<thead>
<tr>
<th>作用</th>
<th>伪元素</th>
</tr>
</thead>
<tbody>
<tr>
<td>在父元素内容的<strong>最前</strong>添加一个伪元素</td>
<td>::before</td>
</tr>
<tr>
<td>在父元素内容的<strong>最后</strong>添加一个伪元素</td>
<td>::after</td>
</tr>
</tbody>
</table>
<p>注意点：</p>
<ul>
<li>必须设置 <strong>content 属性</strong>才能生效</li>
<li>伪元素默认是<strong>行内元素，宽高不生效</strong></li>
</ul>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.9、:focus 伪类选择器</h3>
<p><code>:focus</code>表示获得焦点的元素（如<strong>表单输入</strong>）。当用户点击或触摸元素或通过键盘的“tab”键选择它时会被触发。</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.10、:checked 伪类选择器</h3>
<p>任何处于选中状态的<strong>radio</strong>，<strong>checkbox</strong> 或 ("select") 元素中的<strong>option</strong> HTML 元素 ("option")。</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.11、属性选择器</h3>
<p>CSS <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Attribute_selectors" target="_blank" rel="noopener noreferrer"><strong>属性选择器</strong></a> 匹配那些具有特定属性或属性值的元素。（常配合 <strong>自定义属性</strong> 使用）</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 4、Emmet 语法</h2>
<ul>
<li>简写语法，快速生成代码</li>
<li>VS Code 等代码编辑器自带</li>
</ul>
<table>
<thead>
<tr>
<th>语法</th>
<th>示例</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>标签名</td>
<td>div</td>
<td><code>&lt;div&gt;&lt;/div&gt;</code></td>
</tr>
<tr>
<td>类选择器</td>
<td><strong>.red</strong></td>
<td><code>&lt;div class="red"&gt;&lt;/div&gt;</code></td>
</tr>
<tr>
<td>id 选择器</td>
<td><strong>#one</strong></td>
<td><code>&lt;div id="one"&gt;&lt;/div&gt;</code></td>
</tr>
<tr>
<td>交集选择器</td>
<td>p.red#one</td>
<td><code>&lt;p class="red" id="one"&gt;&lt;/p&gt;</code></td>
</tr>
<tr>
<td>子代选择器</td>
<td>ul&gt;li</td>
<td><code>&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;</code></td>
</tr>
<tr>
<td>内部文本</td>
<td 内容="">ul&gt;li</td>
<td><code>&lt;ul&gt;&lt;li&gt;Hello&lt;/li&gt;&lt;/ul&gt;</code></td>
</tr>
<tr>
<td>创建多个</td>
<td>ul&gt;li*3</td>
<td><code>&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;</code></td>
</tr>
<tr>
<td>创建<strong>自增</strong></td>
<td>ul&gt;li{$}*3</td>
<td><code>&lt;ul&gt;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;li&gt;3&lt;/li&gt;&lt;/ul&gt;</code></td>
</tr>
<tr>
<td>同级</td>
<td>div+p</td>
<td><code>&lt;div&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;</code></td>
</tr>
</tbody>
</table>
<p>css 提示</p>
<table>
<thead>
<tr>
<th>单词首字母</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>fw</td>
<td>font-weight</td>
</tr>
<tr>
<td>w</td>
<td>width</td>
</tr>
<tr>
<td>h</td>
<td>height</td>
</tr>
<tr>
<td>bgc</td>
<td>backgroud-color</td>
</tr>
<tr>
<td>lh</td>
<td>line-height</td>
</tr>
<tr>
<td>w300+h200</td>
<td><code>width: 300px;height: 200px;</code></td>
</tr>
</tbody>
</table>
<h2> 5、CSS 背景相关属性</h2>
<h3> 5.1、背景颜色</h3>
<p><strong>background-color</strong><br>
<strong>Emment：gbc</strong></p>
<p>默认背景色是透明；背景色在背景图之下</p>
<p><strong>transparent</strong>：透明</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5.2、背景图片</h3>
<p><strong>background-image</strong><br>
<strong>Emment：bgi</strong></p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>示例：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5.3、背景平铺</h3>
<p><strong>background-repeat</strong><br>
<strong>Emment：bgr</strong></p>
<table>
<thead>
<tr>
<th>取值</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>repeat</td>
<td>（默认值）水平和垂直方向都平铺</td>
</tr>
<tr>
<td><strong>no-repeat</strong></td>
<td>（最常用）<strong>不平铺</strong></td>
</tr>
<tr>
<td>repeat-x</td>
<td>水平方向平铺（x 轴）</td>
</tr>
<tr>
<td>repeat-y</td>
<td>垂直方向平铺（y 轴）</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5.4、背景位置</h3>
<p><strong>background-position</strong><br>
<strong>Emment：bgp</strong></p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230401153740.png" alt="" loading="lazy"></p>
<p>属性值</p>
<p>方位名词（最多只能表示 9 个位置）<br>
水平方向：left center right<br>
垂直方向：top center bottom</p>
<p>数字+px（坐标）<br>
坐标轴 原点**(0,0)** 盒子的<strong>左上角</strong><br>
x 轴 水平方向<br>
y 轴 垂直方向<br>
图片左上角与坐标原点重合</p>
<p>示例：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>注意：正数：向右向下移动，负数：向左向右移动<br>
背景色和背景图只显示在盒子里面</p>
</blockquote>
<h3> 5.5、背景属性连写</h3>
<p><strong>background</strong><br>
<strong>Emment：bg</strong></p>
<p>格式：<br>
<strong>不分先后顺序</strong><br>
对于position：背景图位置如果是英文单词可以颠倒顺序<br>
测试背景图位置如果是数值 不能颠倒顺序</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>示例：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5.6、img 标签和背景图片区别</h3>
<p>需求：需要在网页中展示一一张图片效果：<br>
方法一：直接写上img标签即可<br>
方法二：div标签+背景图片<br>
<strong>必须设置div的宽高</strong>，因为背景图片只是装饰CSS样式，不能撑开div标签</p>
<p><strong>img：</strong><br>
不设置高宽会默认显示<br>
<strong>重要突出的图，产品图</strong>使用 img</p>
<p><strong>background-image：</strong><br>
需要设置元素尺寸<br>
<strong>装饰性图片</strong>使用背景图</p>
<h2> 6、CSS 盒模型</h2>
<h3> 6.1、元素显示模式</h3>
<p>块级、行内、行内块</p>
<h3> 6.2、块级元素</h3>
<ul>
<li><strong>独占一行</strong></li>
<li><strong>宽度</strong>默认为<strong>父元素 100%</strong>；<strong>高度</strong>默认由<strong>元素撑开</strong></li>
<li><strong>设置宽度和高度生效</strong>，但仍然独占一行</li>
</ul>
<p>代表标签</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 6.3、行内元素</h3>
<ul>
<li><strong>不换行，一行显示多个</strong></li>
<li><strong>宽度和高度</strong>默认<strong>由内容撑开</strong></li>
<li><strong>设置宽度和高度不生效</strong></li>
</ul>
<p>代表标签</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 6.4、行内块元素</h3>
<ul>
<li><strong>不换行</strong>，一行显示多个</li>
<li><strong>设置宽度和高度生效</strong></li>
</ul>
<p>代表标签</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>注意</strong>：<strong>img标签</strong>有行内元素的特点，但是chrome调试工具中显式结果是<strong>inline</strong></p>
<h3> 6.5、元素显示模式转换</h3>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><table>
<thead>
<tr>
<th>属性值</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>block</td>
<td><strong>块</strong>级元素（常用）</td>
</tr>
<tr>
<td>inline-block</td>
<td><strong>行内块</strong>元素（常用）</td>
</tr>
<tr>
<td>inline</td>
<td><strong>行内</strong>元素（不常用）</td>
</tr>
</tbody>
</table>
<p>举例：</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6.6、HTML 嵌套规范注意点</h3>
<p>元素之间的关系：<strong>父子</strong>关系，<strong>并列</strong>关系</p>
<ul>
<li><strong>块级</strong>元素一般作为<strong>大容器</strong></li>
<li>可以嵌套文本、块级元素、行内元素、行内块元素</li>
</ul>
<blockquote>
<p><strong>p</strong> 标签中<strong>不要嵌套 div p h</strong> 等块级元素</p>
</blockquote>
<ul>
<li><strong>a 标签</strong>内部可以<strong>嵌套任意内容（除了a）</strong></li>
</ul>
<blockquote>
<p>a 标签<strong>不能嵌套 a</strong> 标签</p>
</blockquote>
<h3> 6.7、盒子模型</h3>
<p>（1）盒子</p>
<p>标签可以看做是一个盒子</p>
<p>（2）盒子模型：</p>
<ul>
<li><strong>外边距</strong>区域 <strong>margin</strong></li>
<li><strong>边框</strong>区域 <strong>border</strong></li>
<li><strong>内边距</strong>区域 <strong>padding</strong></li>
<li><strong>内容</strong>区域 <strong>content</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230401203350.png" alt="" loading="lazy"></p>
<p>（3）盒子内容的宽高</p>
<ul>
<li>width</li>
<li>height</li>
</ul>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6.8、边框 border</h3>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>线条可选样式<br>
<strong>solid 实线</strong><br>
<strong>dashed 虚线</strong><br>
<strong>dotted 点线</strong></p>
<p><strong>布局顺序：从外到内，从上到下</strong></p>
<h3> 6.9、内边距 padding</h3>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>规律：顺时针，值不够看对边</p>
<h3> 6.10、练习：导航实例</h3>
<p>注意：可以<strong>使用padding替代width</strong></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6.11、盒子尺寸计算</h3>
<p>给盒子设置border或padding时，盒子会被撑大，不想盒子撑大的方法：</p>
<p>①手动内减：<br>
自己计算多余大小，手动在content中减去<br>
缺点：项目中计算量太大，很麻烦</p>
<p>②<strong>自动内减：</strong>（内减模式）<br>
给盒子设置 <strong>box-sizing: border-box;</strong> 即可<br>
优点：浏览器自动计算多余大小，自动在内容中减去</p>
<p>box-sizing: content-box 默认<br>
盒子最终宽度 = width(content) + padding + border</p>
<p><strong>box-sizing: border-box</strong><br>
<strong>盒子最终宽度 = width</strong> = padding + border + content<br>
适用于inline-block，block</p>
<h3> 6.12、外边距 margin</h3>
<p>设置值的方式<strong>和 padding 类似</strong></p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 margin 让元素居中</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6.13、清除浏览器默认样式</h3>
<p>浏览器会默认给部分标签设置默认的margin和padding，但一般在项目开始前要先<strong>清除这些默认的margin和padding</strong>，后续自己设置<br>
（比如：body有margin：8px、p有margin，ul有margin和padding）</p>
<p>京东</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>淘宝</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>常用的清除样式</strong></p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>去掉列表前的符号</strong></p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>版心居中</strong></p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6.14、外边距折叠现象</h3>
<ul>
<li>合并现象</li>
<li>塌陷现象</li>
</ul>
<h4> （1）合并现象</h4>
<ul>
<li>场景：<strong>垂直</strong>布局的块级元素，<strong>上下的 margin 会合并</strong></li>
<li>结果：<strong>最终</strong>两者距离为 <strong>margin 的最大值</strong></li>
<li>解决方法：<strong>只给其中一个盒子设置 margin</strong></li>
</ul>
<p>下面代码div间隔只有100px</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> （2）塌陷现象</h4>
<ul>
<li>场景：相互嵌套的块级元素，<strong>子元素的 margin-top 会作用在父元素上</strong></li>
<li>结果：导致父元素一起往下移动</li>
<li>解决方法：</li>
</ul>
<ol>
<li>给父元素设置 border-top 或者 padding-top(分隔父子元素的 margin-top)</li>
<li>给父元素设置 <strong>overflow:hidden</strong></li>
<li>转换为 行内块元素</li>
<li>设置浮动</li>
</ol>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6.15、行内标签的 margin/pading</h3>
<p><strong>行内标签的 margin/pading 垂直方向不生效</strong>，使用行高 <strong>line-height</strong> 实现</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 7、CSS 特性</h2>
<ul>
<li>继承性</li>
<li>层叠性</li>
<li>优先级</li>
</ul>
<h3> 7.1、继承性 inherited</h3>
<p>（1）子元素有默认继承父元素样式的特点</p>
<p>可继承的常见属性（<strong>文字属性都可以继承，非文字属性不能继承</strong>）：<br>
color font-style font-weight font-size font-family text-align text-indent<br>
line-height</p>
<p>（2）继承失效的特殊情况</p>
<p>如果元素有浏览器默认样式，就不继承父元素属性：<br>
a 标签的 color 会继承时效<br>
h 系列标签的 font-size 会继承失效</p>
<p>示例 ：</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>给body赋值，子元素也会别继承<br>
若子元素有属性（h，a）用子元素的</p>
<h3> 7.2、层叠性</h3>
<p>同一个标签设置<strong>不同</strong>的样式<br>
样式<code>层叠叠加</code>，共同作用在标签上</p>
<p>同一个标签设置<strong>相同</strong>的样式<br>
样式会<code>层叠覆盖</code>，最终写在最后的样式生效</p>
<p>当样式冲突时，只有当选择器优先级相同时，才能通过层叠性判断结果</p>
<blockquote>
<p>技巧: 编辑器多行输入</p>
</blockquote>
<p>示例 ：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7.3、优先级</h3>
<p><strong>不同选择器具有不同的优先级，</strong></p>
<p><strong>优先级高</strong>的选择器样式会<strong>覆盖优先级低</strong>的选择器</p>
<h4> 7.3.1、优先级公式（由低到高）</h4>
<p>​	继承<br>
​	通配符选择器<br>
​	标签选择器<br>
​	类选择器<br>
​	id 选择器<br>
​	行内样式（style=""）<br>
​	!important（慎重使用）</p>
<p>总结：选择范围越小，优先级越高</p>
<p>!important使用示例<br>
注：!important 不要给继承的添加，自己有样式无法继承父级样式</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 7.3.2、复合选择器权重叠加</h4>
<p>如果是符合选择器，此时需要通过权重叠加计算方法，判断最终哪个选择器优先级最高会生效</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230401173923.png" alt="" loading="lazy"></p>
<p>计算公式，每级之间不进位</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第一级 行内样式个数<br>
第二级 id 选择器个数<br>
第三级 类选择器个数<br>
第四级 标签选择器个数<br>
继承最低</p>
<p>需要注意：<br>
!important 权重最高<br>
继承权重最低</p>
<blockquote>
<p>chrome 调试: 元素右键 -&gt; 检查元素</p>
</blockquote>
<p>工具：PxCook <a href="https://www.fancynode.com.cn/pxcook" target="_blank" rel="noopener noreferrer">https://www.fancynode.com.cn/pxcook</a> （像素大厨）</p>
<p>示例 ：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7.4、常见问题</h3>
<p>熟练掌握chrome调试工具</p>
<p>css语法出错后，后面的css样式都不执行</p>
<h2> 8、CSS 浮动</h2>
<h3> 8.1、标准流</h3>
<p>标准流：又称为<strong>文档流</strong>，浏览器排列元素的规则</p>
<p>常见标准流的排版规则</p>
<ul>
<li>块级元素：从上往下，垂直布局，独占一行</li>
<li>行内元素或行内块元素：从左往右，水平布局，空间不够自动折行</li>
</ul>
<p>浏览器解析 <strong>行内元素 或 行内块元素</strong> <strong>换行书写会产生一个空格</strong><br>
但在书写是，转行内块后不可能全书写在一列上，因此需要浮动</p>
<h3> 8.2、浮动</h3>
<p>浮动的作用：</p>
<ul>
<li>早期：图文环绕</li>
<li>现在：网页布局</li>
</ul>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>fll、flr</strong></p>
<p>浮动的特点：</p>
<ul>
<li>
<p>浮动的标签默认<strong>顶对齐</strong>（<strong>相较于父标签</strong>），可使用 margin-top 修改距离顶部距离</p>
</li>
<li>
<p>浮动元素会<strong>脱离标准流</strong>（脱标），在标准流中不占用位置（飘到空中）</p>
</li>
<li>
<p>浮动元素比标准流<strong>高半个级别</strong>，可以覆盖标准流中的元素（盖不住文字）</p>
</li>
<li>
<p><strong>浮动找浮动</strong>，下一个浮动元素会在上一个浮动元素后面，左右浮动</p>
</li>
<li>
<p><strong>浮动标签</strong>具备<strong>行内块</strong>特点：</p>
<ol>
<li>一行<strong>显示多个</strong></li>
<li>可<strong>设置宽高</strong></li>
</ol>
</li>
<li>
<p><strong>浮动之后盒子水平居中不生效 margin: 0 auto;</strong></p>
</li>
</ul>
<p>示例：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>CSS 书写顺序</strong></p>
<ul>
<li><strong>浮动 / display</strong></li>
<li><strong>盒子模型 margin border padding 宽度高度背景色</strong></li>
<li><strong>文字样式</strong></li>
</ul>
<p>常用 css</p>
<ul>
<li>内减模式：box-sizing: border-box;</li>
<li>版心居中： margin: 0 auto;</li>
</ul>
<h3> 8.3、清除浮动</h3>
<p><strong>清除浮动给别的元素带来的影响</strong></p>
<p>影响：如果子元素浮动了，此时子元素不能撑开标准流的块级父元素（父子级标签，父级没有设置高度，后面的标准流盒子会受影响）</p>
<p><strong>清除浮动的方法</strong></p>
<h4> 8.3.1、直接设置父元素高度（不用）</h4>
<p>缺点：太麻烦</p>
<h4> 8.3.2、额外标签（有缺点）</h4>
<ul>
<li>在父元素css内容的最后添加一个块级元素</li>
<li>给添加的块级元素设置 <strong>clear:both;</strong></li>
</ul>
<p>缺点：需要额外加标签</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 8.3.3、单伪元素清除法</h4>
<p>用<strong>伪元素替代</strong>了<strong>额外标签</strong></p>
<p>优点：<strong>直接给标签加类即可清除浮动</strong></p>
<p>（1）基本写法</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（2）补充写法</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 8.3.4、双伪元素清除法（常用）</h4>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 8.3.5、父元素设置overflow</h4>
<p>直接给父元素设置overflow：hidden<br>
优点：方便</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 9、Flex 布局</h2>
<h3> 9.1、Flex 布局介绍</h3>
<p><strong>Flex布局</strong>也叫<strong>弹性布局</strong>，是浏览器提倡的布局模型，非常适合结构化布局，提供了强大的<strong>空间分布</strong>和<strong>对齐</strong>能力。<br>
Flex模型<strong>不会</strong>产生浮动布局中<strong>脱标</strong>现象，布局网页更简单灵活</p>
<h3> 9.2、Flex 组成</h3>
<p>设置方式：给 <strong>父</strong> 元素设置 <strong>display: flex</strong> ，<strong>子</strong> 元素可以自动挤压或拉伸</p>
<p><strong>父级：弹性容器</strong><br>
<strong>子级：弹性盒子</strong></p>
<p>组成部分：<br>
弹性容器<br>
弹性盒子<br>
主轴：默认在<strong>水平</strong>方向<br>
侧抽/交叉轴：默认在<strong>垂直</strong>方向</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 9.3、主轴对齐方式</h3>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230407212933.png" alt="" loading="lazy"></p>
<p><strong>属性名：justify-content：</strong></p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>flex-start</td>
<td>默认值，弹性盒子从<strong>起点</strong>开始依此排列</td>
</tr>
<tr>
<td>flex-end</td>
<td>弹性盒子<strong>终点</strong>开始一次排列</td>
</tr>
<tr>
<td><strong>center</strong></td>
<td>弹性盒子沿主轴<strong>居中</strong>排列</td>
</tr>
<tr>
<td><strong>space-between</strong></td>
<td>弹性盒子沿主轴均匀排列，<strong>间距</strong>均分盒子<strong>之间</strong></td>
</tr>
<tr>
<td><strong>space-around</strong></td>
<td>弹性盒子沿主轴均匀排列，<strong>间距</strong>均分盒子<strong>两侧</strong></td>
</tr>
<tr>
<td><strong>spce-evenly</strong></td>
<td>弹性盒子沿主轴均匀排列，弹性盒子与容器之间间距相等</td>
</tr>
</tbody>
</table>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 9.4、侧轴对齐方式</h3>
<p>属性名：<br>
<strong>align-items</strong>：当前弹性容器内所有弹性盒子对齐方式（给<strong>弹性容器设置</strong>）<br>
<strong>align-self</strong>：单独控制某个弹性盒子的侧轴对齐方式（给<strong>弹性盒子设置</strong>）</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>stretch</td>
<td>弹性盒子沿侧轴线被拉伸至<strong>铺满容器</strong>（弹性盒子无高度则默认拉伸，有高度不生效）</td>
</tr>
<tr>
<td>center</td>
<td>弹性盒子沿侧轴<strong>居中</strong>排列</td>
</tr>
<tr>
<td>flex-start</td>
<td>弹性盒子从<strong>起点</strong>开始依此排列</td>
</tr>
<tr>
<td>flex-end</td>
<td>弹性盒子从<strong>终点</strong>开始依此排列</td>
</tr>
</tbody>
</table>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 9.5、修改主轴方向</h3>
<p>主轴默认水平方向，侧轴默认垂直方向</p>
<p>属性名：flex-direction</p>
<p>属性值:</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>row</td>
<td>水平方向，从左向右（默认）</td>
</tr>
<tr>
<td><strong>column</strong></td>
<td><strong>垂直方向，从上向下</strong></td>
</tr>
<tr>
<td>row-reverse</td>
<td>水平方向，从右往左</td>
</tr>
<tr>
<td>column-reverse</td>
<td>垂直方向，从上向下</td>
</tr>
</tbody>
</table>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 9.6、弹性伸缩比</h3>
<p><strong>默认</strong>情况下，<strong>主轴</strong>方向的尺寸是<strong>靠内容撑开</strong>，<strong>侧轴</strong>默认是<strong>拉伸</strong>的效果</p>
<p>作用：控制弹性盒子的 <strong>主轴</strong> 方向的 <strong>尺寸</strong><br>
属性名：flex<br>
属性值：整数数字，表示占用父级<strong>剩余</strong>尺寸的<strong>份数</strong></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 9.7、弹性盒子换行</h3>
<p>弹性盒子可以自<strong>动挤压或拉伸</strong>，默认情况下，所有弹性盒子<strong>在一行显示</strong></p>
<p>属性名：<strong>flex-wrap</strong></p>
<p>属性值：<br>
<strong>wrap：换行</strong><br>
<strong>nowrap：不换行</strong>（默认值）</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 9.8、行对齐方式</h3>
<p>属性名：<strong>align-content</strong></p>
<p>属性值：（与主轴对齐方式相同）</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>flex-start</td>
<td>默认值，弹性盒子从<strong>起点</strong>开始依此排列</td>
</tr>
<tr>
<td>flex-end</td>
<td>弹性盒子<strong>终点</strong>开始一次排列</td>
</tr>
<tr>
<td><strong>center</strong></td>
<td>弹性盒子沿主轴<strong>居中</strong>排列</td>
</tr>
<tr>
<td><strong>space-between</strong></td>
<td>弹性盒子沿主轴均匀排列，<strong>间距</strong>均分盒子<strong>之间</strong></td>
</tr>
<tr>
<td><strong>space-around</strong></td>
<td>弹性盒子沿主轴均匀排列，<strong>间距</strong>均分盒子<strong>两侧</strong></td>
</tr>
<tr>
<td><strong>spce-evenly</strong></td>
<td>弹性盒子沿主轴均匀排列，弹性盒子与容器之间间距相等</td>
</tr>
</tbody>
</table>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>注：align-content 对单行弹性盒子不生效</p>
</blockquote>
<h2> 10、CSS 定位</h2>
<h3> 10.1、网页常见布局方式</h3>
<p>1、标准流：<br>
块级元素独占一行 -&gt; 垂直布局<br>
行内元素/行内块元素一行显示多个 -&gt; 水平布局</p>
<p>2、浮动<br>
原本垂直布局的块级元素变成水平布局</p>
<p>3、定位<br>
可以让元素<strong>自由的摆放在网页的任意位置</strong><br>
一般用于<strong>盒子之间</strong>的<strong>层叠</strong>情况<br>
让盒子<strong>固定</strong>在页面某一位置</p>
<h3> 10.2、使用定位的步骤</h3>
<p><strong>1、设置定位方式</strong></p>
<p>属性名: <strong>position</strong></p>
<table>
<thead>
<tr>
<th>定位方式</th>
<th>属性值</th>
</tr>
</thead>
<tbody>
<tr>
<td>静态定位</td>
<td>static（默认，不定为，就是文档流）</td>
</tr>
<tr>
<td>相对定位</td>
<td>relative</td>
</tr>
<tr>
<td>绝对定位</td>
<td>absolute</td>
</tr>
<tr>
<td>固定定位</td>
<td>fixed</td>
</tr>
</tbody>
</table>
<p><strong>2、设置偏移值</strong><br>
偏移值可以设置水平和垂直方向<br>
选取原则：<strong>就近原则</strong></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230402201907.png" alt="" loading="lazy"></p>
<h3> 10.3、相对定位</h3>
<ul>
<li><strong>相对于自己</strong>之前的位置</li>
<li><strong>占有原来的位置</strong>（原来处在的位置不会被填充）</li>
<li><strong>不改变显示模式</strong>（块还是块）</li>
</ul>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p><strong>Tips: 如果 4 个定位都有，以 top 和 left 为准</strong><br>
<strong>相对定位只加position，还是原来的位置</strong></p>
</blockquote>
<h3> 10.4、绝对定位</h3>
<p>绝对定位：<br>
先找已经定位的父级，如果有这样的父级就以这个父级为参照物进行定位<br>
有父级，但父级没有定位，以浏览器窗口为参照进行定位</p>
<ul>
<li><strong>相对于非静态定位的父元素定位</strong></li>
<li>脱标，<strong>不占</strong>有<strong>原</strong>来的<strong>位</strong>置</li>
<li>改变显示模式（行内块特点，行内共存，宽高生效）</li>
<li>默认以浏览器 body 定位</li>
</ul>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><em><strong>子绝父相</strong></em>：<strong>父级相对定位，子级绝对定位</strong></li>
<li>绝对定位查找父级的方法：逐级向上，最终是浏览器窗口</li>
</ul>
<p>1绝对定位的盒子<strong>不能使用margin 0 auto居中</strong><br>
解决方式：</p>
<p>① 手动修改（耦合性高）</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>②位移 <strong>transform</strong>（常用）</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 10.5、固定定位</h3>
<p><strong>fixed</strong></p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>特点：</p>
<ul>
<li>脱标-<strong>不占位置</strong></li>
<li><strong>相对于浏览器</strong>定位</li>
<li>具备<strong>行内块</strong>特点</li>
</ul>
<h3> 10.6、元素层级关系</h3>
<ol>
<li>不同布局方式元素的层级关系：</li>
</ol>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol>
<li><strong>同层级</strong>，<strong>后写</strong>的会<strong>覆盖</strong>在<strong>先写</strong>的元素</li>
<li><strong>设置元素层级</strong></li>
</ol>
<p><strong>z-index</strong></p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> 11、CSS 装饰</h2>
<h3> 11.1. 垂直对齐 vertical-align</h3>
<p><strong>基线</strong>(baseline)：浏览器<strong>文字</strong>类型元素排版中存在<strong>用于对齐的基线</strong><br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230403143444.png" alt="" loading="lazy"></p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>baseline</td>
<td>默认，基线对齐</td>
</tr>
<tr>
<td>top</td>
<td>顶部对齐</td>
</tr>
<tr>
<td>middle</td>
<td>中部对齐</td>
</tr>
<tr>
<td>bottom</td>
<td>底部对齐</td>
</tr>
</tbody>
</table>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>处理行内块和文字对齐，或行内块和行内块对齐都用 vertical-align: middle; <strong>|<br>
浏览器把</strong>行内</strong>和<strong>行内块</strong>当做文字处理，文字默认基线对齐（有时可以改为块状元素解决问题）</p>
<p>示例一：输入框垂直居中对齐</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230403145733.png" alt="" loading="lazy"></p>
<p>示例二：图片垂直居中对齐</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>示例三：图片水平垂直居中</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 11.2、cursor</h3>
<table>
<thead>
<tr>
<th>属性值</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>default</td>
<td>默认，箭头</td>
</tr>
<tr>
<td><strong>pointer</strong></td>
<td>小手，提示可点击</td>
</tr>
<tr>
<td><strong>text</strong></td>
<td>工字型，提示可选择</td>
</tr>
<tr>
<td><strong>move</strong></td>
<td>十字光标，提示可移动</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 11.3、border-radius</h3>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230403152739.png" alt="" loading="lazy"></p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（1）正圆</p>
<ul>
<li>盒子必须是正方形</li>
<li>设置边框圆角为盒子宽高的一半</li>
</ul>
<p>示例：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>（2）胶囊按钮</p>
<ul>
<li>盒子设置为长方形</li>
<li>设置边框圆角为高度的一半</li>
</ul>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>示例：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 11.4、 溢出部分效果 overflow</h3>
<p>溢出部分：盒子内容部分<strong>超出盒子范围的区域</strong></p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>visible （ovv）</td>
<td>默认，溢出部分可见</td>
</tr>
<tr>
<td>hidden （ovh）</td>
<td>溢出部分隐藏</td>
</tr>
<tr>
<td>scroll</td>
<td>无论是否溢出都显示滚动条</td>
</tr>
<tr>
<td>auto （ova）</td>
<td>根据是否溢出，自动显示或隐藏滚动条</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 11.5、 元素本身隐藏</h3>
<p>让某个元素本身在屏幕中不可见，如：鼠标:hover之后元素隐藏<br>
常见属性：<br>
1、visibility：hidden （不常用，占位的隐藏）<br>
2、<strong>display：none （常用，不占位的隐藏）</strong></p>
<p>示例：默认隐藏，鼠标悬停显示</p>
<p>box鼠标悬停，修改box2的显示模式：.box:hover .box2</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 11.6、 opacity</h3>
<p>属性值：<br>
0-1 之间的数字；<br>
0 完全透明，1 完全不透明</p>
<p>示例：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>半透明：rgba(0, 0, 0, 0.5);</p>
<h3> 11.7、精灵图</h3>
<p>将多张小图合并成一张大图，这张<strong>大图称为精灵图</strong><br>
优点：减少服务器发送次数，减轻服务器压力，提高页面加载速度<br>
缺点：修改起来比较麻烦</p>
<p>精灵图使用步骤<br>
1、创建一个盒子，设置盒子尺寸和小图尺寸相同<br>
2、将精灵图设置为盒子的背景图片<br>
3、修改背景图位置</p>
<p>一般<strong>精灵图的标签</strong>都用<strong>行内标签</strong></p>
<p><strong>修改背景图片的位置：  background-position: 0 0</strong>（往左往上给负值）</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 11.8、background-size</h3>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><table>
<thead>
<tr>
<th>取值</th>
<th>场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>数字+px</td>
<td>简单方便，常用</td>
</tr>
<tr>
<td>百分比</td>
<td>相对于当前<strong>盒子自身</strong>的<strong>宽高百分比</strong></td>
</tr>
<tr>
<td>contain</td>
<td>包含，背景图等比缩放，<strong>直到不会超出盒子的最大</strong>，可能有留白</td>
</tr>
<tr>
<td>cover</td>
<td>覆盖，背景图等比缩放，直到刚好填满整个盒子<strong>没有空白</strong>，图片可能显示不全</td>
</tr>
</tbody>
</table>
<p>background连写拓展：</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 11.9、盒子阴影 box-shadow</h3>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>h-shadow</td>
<td>必须，水平偏移量，允许负值</td>
</tr>
<tr>
<td>v-shadow</td>
<td>必须，垂直偏移量，允许负值</td>
</tr>
<tr>
<td>blur</td>
<td>可选，模糊度</td>
</tr>
<tr>
<td>spread</td>
<td>可选，阴影扩大</td>
</tr>
<tr>
<td>color</td>
<td>可选，阴影颜色</td>
</tr>
<tr>
<td>inset</td>
<td>可选，将阴影改为内部阴影</td>
</tr>
</tbody>
</table>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>注意：外阴影不能添加outside，添加了会导致属性报错</p>
</blockquote>
<h3> 11.10、过渡 transition</h3>
<p><strong>transition （trs）</strong></p>
<ul>
<li>让元素样式慢慢变化</li>
<li>常配合 hover 使用</li>
</ul>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><table>
<thead>
<tr>
<th>参数</th>
<th>取值</th>
</tr>
</thead>
<tbody>
<tr>
<td>过渡属性</td>
<td>所有属性 all；具体属性 width...</td>
</tr>
<tr>
<td>过渡时长</td>
<td>数字 + s(秒)</td>
</tr>
</tbody>
</table>
<p>注意：</p>
<ul>
<li><strong>transition</strong> 属性给需要过渡的<strong>元素本身加</strong></li>
<li>transition 属性设置在不同状态中，效果不同
<ul>
<li>给<strong>默认状态设置</strong>，鼠标<strong>移入移出</strong>都有过渡效果</li>
<li>给 <strong>hover 状态</strong>设置，鼠标<strong>移入</strong>有过渡效果，<strong>移出没有</strong>过渡效果</li>
</ul>
</li>
</ul>
<p>如果变化的属性多，直接写all，表示所有</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 11.11、scroll-behavior</h3>
<p>当用户手动导航或者 CSSOM scrolling API 触发滚动操作时，让滚动条丝滑滚动</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 12、CSS 常用代码/实战</h2>
<h3> 1、项目结构</h3>
<p><em><strong>根目录：</strong></em><br>
<strong>index.html</strong>  首页<br>
<strong>css /</strong>  base.css   基本公共的样式 清除浏览器默认样式<br>
common.css 重复使用样式，网页头与尾<br>
index.css  页面单独的样式<br>
<strong>favicon.ico</strong><br>
<strong>images/</strong>       固定使用的图片素材<br>
**uploads/ **     非固定使用的图片素材</p>
<h3> 2、常用CSS</h3>
<h4> 2.1、base.css 清除默认样式</h4>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.2、 common.css 版心</h4>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.3、CSS样式引入顺序：</h4>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.4、控制 input placeholder 样式</h4>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.4、调节图片垂直对齐方式（上下居中）</h4>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.5、通栏盒子（与浏览器宽度相同的盒子）</h4>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.6、小圆点</h4>
<p>通过ol li增加宽高，设置border-radius：50px</p>
<h3> 2、骨架标签解读</h3>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3、SEO</h3>
<h4> SEO</h4>
<p><strong>Search Engine Optimization 搜索引擎优化</strong><br>
作用：让网站在搜索引擎上的排名靠前</p>
<p>提升SEO的常见方法：<br>
1、竞价排名<br>
2、将网页制作成 html 后缀<br>
3、标签语义化，适合的地方使用合适的标签</p>
<h4> SEO 三大标签</h4>
<p>​	1、title 标题<br>
​	2、description 描述<br>
​	3、keywords 关键词，英文逗号分隔</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4、icon 图标</h3>
<p>favicon.ico 文件放<strong>根目录</strong></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5、对齐方式</h3>
<ol>
<li>vertical-align</li>
<li>行高</li>
<li>定位</li>
</ol>
<h3> 6、常用类名</h3>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230401135946.png" type="image/png"/>
    </item>
    <item>
      <title>HTML 基础</title>
      <link>https://T4mako.github.io/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/HTML.html</link>
      <guid>https://T4mako.github.io/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/HTML.html</guid>
      <source url="https://T4mako.github.io/rss.xml">HTML 基础</source>
      <description># 1、前导概念 WEB标准： 1.结构（HTML） 2.表现 （CSS3） 3.行为（JavaScript） HTML语法规范： HTML基本结构标签： VSCode的基础用法： 输入感叹号！回车创建基本骨架 必装插件：中文包，open in browser，AUTO Rename Tag，CSS peek 感叹号输入默认代码解析： **HTML标签...</description>
      <content:encoded><![CDATA[<h1> </h1>
<!-- more -->
<h2> 1、前导概念</h2>
<p><strong>WEB标准：</strong><br>
1.结构（HTML）<br>
2.表现 （CSS3）<br>
3.行为（JavaScript）</p>
<p><strong>HTML语法规范：</strong></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>HTML基本结构标签：</strong></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>VSCode的基础用法：</strong></p>
<p>输入感叹号！回车创建基本骨架<br>
必装插件：中文包，open in browser，AUTO Rename Tag，CSS peek</p>
<p><strong>感叹号输入默认代码解析：</strong></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>HTML标签名大小写不敏感<br>
标签拥有自己的属性（分为基本属性和时间属性）<br>
标签分为单标签和双标签</strong></p>
<p>标签属性卸载开始标签内部<br>
属性之间以<strong>空格隔开</strong><br>
<strong>标签名与属性名</strong>之间必须以<strong>空格隔开</strong><br>
属性之间没有顺序之分</p>
<h1> 1、h1 标题标签</h1>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>标题标签<strong>加大加粗，独占一行</strong><br>
属性：align 对齐属性（默认left 左对齐）</p>
<h2> 2、p 段落标签</h2>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>paragraph段落标签<br>
（1）根据浏览器窗口自动换行<br>
（2）段落与段落有空隙</p>
<h2> 3、hr br 换行、水平线标签</h2>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>（1）break，打断，强制换行<br>
（2）是单标签</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>水平线标签</p>
<h2> 4、文本格式化标签</h2>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果要突出重要性，使用左边一排标签，语义更加强烈（标签语义化）</p>
<h2> 5、div、span 语义化标签</h2>
<p><strong>（1）一个div独占一行 大盒子</strong><br>
<strong>（2）一行可放多个span 小盒子</strong></p>
<p>手机端使用较多：<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230401113629.png" alt="" loading="lazy"></p>
<h1> 6、img图象标签</h1>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>属性：<br>
src	路径 <strong>必须</strong>的属性<br>
alt	 用于图象不显示的<strong>文字替换</strong><br>
title=“aaa”	 提示文本<br>
width=“500” 	宽度500px<br>
height=“500” 	高度500px	<br>
border="15" 	边框15px</p>
<blockquote>
<p>注：宽度高度只修改一个是等比缩放，绝对路径与相对路径(<strong>./</strong> 与 <strong>../</strong>)</p>
</blockquote>
<h2> 7、音、视频标签</h2>
<h3> 音频标签</h3>
<p>属性：<br>
src	路径<br>
controls	显示播放控件<br>
autoplay	自动播放（部分浏览器不支持）<br>
loop	循环播放</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 视频标签</h3>
<p>属性：<br>
src	路径<br>
controls	显示播放的控件<br>
autoplay	自动播放（谷歌浏览器中需要配合muted实现静音播放）<br>
loop	循环播放</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> 8、a 超链接标签</h2>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（1）herf为必须的属性，目标url地址<br>
（2）target中<br>
<strong>_self</strong>		为默认值当前页面打开<br>
**_blank	 **为在新窗口中打开</p>
<h2> 9、注释</h2>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>快捷键 ctrl+/快速创建</p>
<h2> 10、字符实体</h2>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230401114019.png" alt="" loading="lazy"></p>
<h2> 11、table 表格标签</h2>
<p><strong>table &gt; tr &gt; td</strong></p>
<h3> 1、结构，单元格标签</h3>
<p><strong>表格样式使用css样式</strong></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>table 标签是表格标签<br>
border 设置表格边框<br>
width 设置表格宽度<br>
height 设置表格高度<br>
aline 设置表格相对于页面的对齐方式<br>
cellspacing 设置单元格间距<br>
border-collapse collapse <strong>合并边框</strong></p>
<p>tr 是行标签<br>
th 是<strong>表头</strong>标签（thead）<br>
tbody、tfoot （了解）<br>
td 是<strong>单元格</strong>标签<br>
align 设置单元格文本对齐方式</p>
<p><strong>caption</strong> 表格大标题，默认在表格整体顶部居中显示<br>
captioin标签书写在table标签内部</p>
<p><strong>th表头单元格 td单元格</strong><br>
thead 表头部标签 tbody表格主题区域<br>
table标签不可省</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过css样式修改表格样式</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220612181816313.png" alt="image-20220612181816313" loading="lazy"></p>
<h3> 2、合并单元格</h3>
<p>跨行合并：rowspan=-“合并单元格的个数”</p>
<p>跨列合并：colspan=“合并单元格的个数”</p>
<p><strong>目标单元格：</strong></p>
<p>跨行：最上侧单元格为目标单元格<br>
跨列：最左边单元格为目标单元格<br>
合并单元格三部曲：<br>
（1）确定跨行还是跨列（2）找目标单元格写上合并方式（3）删除多余单元格</p>
<p>不能<strong>跨结构标签</strong>合并（不能跨thead、tbody、tfoot）</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 12、列表</h2>
<h3> 1、无序列表</h3>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（1）无序列表各列表项之间没有顺序级别之分，是并列的<br>
（2）<strong>ul中只能有li标签</strong>，不能有其他标签或文字。<br>
（3）<strong>type属性</strong>可以修改列表项前面的符号</p>
<h3> 2、有序列表</h3>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（1）<strong>ol中只能放li</strong>，其他标签或文字是不被允许的<br>
（2）li相当于一个容器，可以容纳所有元素<br>
（3）<strong>type属性</strong>可以修改列表项前面的符号</p>
<h3> 3、自定义列表</h3>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（1）<strong>dl中只能有dt和dd</strong><br>
（2）dt和dd个数没有限制，通常是1对多</p>
<h2> 13、form 表单标签</h2>
<h3> 1、表单域</h3>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>表单域的属性</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220614152819557.png" alt="image-20220614152819557" loading="lazy"></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Attributes/autocomplete" target="_blank" rel="noopener noreferrer">autocomplete</a>属性：可用于以文本或数字作为输入的 <code>input</code> 、<code>textarea</code>、<code>select</code> 、<code>form</code> 元素，指定<strong>浏览器</strong>是否有权限在填写表单字段值时<strong>提供自动帮助</strong>，常用值：<strong>off</strong></p>
<p>表单提交时，数据没有发送给服务器的三种情况：<br>
1、表单项没有name属性值<br>
2、单选，复选(下拉列表中的option标签)都需要添加value属性，以便发送给服务器<br>
3、表单项不在提交的form标签中</p>
<p>get请求的的特点：<br>
1、浏览器地址栏中的地址是：action属性[+?+请求参数]<br>
请求参数的格式是：name=value&amp;name=value<br>
2、不安全<br>
3、有数据长度的限制</p>
<p>post请求的特点：<br>
1、浏览器地址中只有action属性<br>
2、相对于get安全<br>
3、理论上没有数据长度限制</p>
<h3> 2、input表单元素</h3>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>（1）input是单标签，用于收集用户信息<br>
（2）input标签中包含<strong>type属性</strong>用于确定input的形式</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230401110532.png" alt="" loading="lazy"></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>input的其他属性：</strong><br>
（1）<strong>placeholder</strong>属性，占位符，提示用户输入内容的文本<br>
（2）name是表单元素名字，<strong>单选按钮的name要相同</strong><br>
（3）value中的数据会传给后台<br>
（4）<strong>checked</strong>属性用于单选按钮和复选按钮，当页面打开时就可以默认选中这个按钮<br>
（5）maxlength 正整数，规定字符中的字符的最大长度<br>
（6）type="file" <strong>nultiple</strong>：上传多个文件</p>
<h3> 3、label标签</h3>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>lebel标签用于绑定一个表单元素，当<strong>点击</strong>label标签内<strong>文本</strong>时，<strong>单选框会被选中</strong></p>
<p><strong>label标签中的for属性应当与相关元素id属性</strong></p>
<h3> 4、select下拉表单</h3>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（1）select中至少包含一对option<br>
（2）在option中定义selected="<strong>selected</strong>"时，为默认选中项</p>
<h3> 5、textarea文本域元素</h3>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>起始标签和结束标签中的内容是默认值<br>
rows 属性设置可以显示几行的高度<br>
cols 属性设置每行可以显示几个字符宽度</p>
<h2> 14、iframe框架标签</h2>
<p>iframe标签可以在页面上开辟一个小区域显示一个单独的页面<br>
iframe和a标签组合使用的步骤：<br>
1、在iframe标签中使用name属性定义一个名称<br>
2、在a标签的target属性上设置iframe的name属性值</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230401113629.png" type="image/png"/>
    </item>
    <item>
      <title>Node.js 教程</title>
      <link>https://T4mako.github.io/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Node.js%E7%AC%94%E8%AE%B0.html</link>
      <guid>https://T4mako.github.io/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Node.js%E7%AC%94%E8%AE%B0.html</guid>
      <source url="https://T4mako.github.io/rss.xml">Node.js 教程</source>
      <description>node.js API 1、Node.js介绍 1.1、Node.js 概念 Node.js 是一个开源的，跨平台的 JavaScript 运行环境 通俗来讲，Node.js 就是一款应用程序，是一款软件，它可以运行JS</description>
      <content:encoded><![CDATA[<p><a href="https://nodejs.cn/api-v16/" target="_blank" rel="noopener noreferrer">node.js API</a></p>
<h2> 1、Node.js介绍</h2>
<h3> 1.1、Node.js 概念</h3>
<p><strong>Node.js</strong> 是一个<strong>开源</strong>的，<strong>跨平台</strong>的 JavaScript 运行环境<br>
通俗来讲，Node.js 就是一款<strong>应用程序</strong>，是一款<strong>软件</strong>，它可以运行JS</p>
<p><strong>Node.js 作用：</strong></p>
<ul>
<li>开发服务器应用</li>
<li>开发工具类应用</li>
<li>开发桌面端应用</li>
</ul>
<h3> 1.2、Node.js 的安装</h3>
<p><a href="https://nodejs.org/en" target="_blank" rel="noopener noreferrer">Node.js 官网</a> 下载LTS版本</p>
<p>打开cmd，输入 <code>node -v</code> 查看安装情况<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230420185728.png" alt="" loading="lazy"></p>
<blockquote>
<p>注：<a href="https://www.jianshu.com/p/e8c29211fba9" target="_blank" rel="noopener noreferrer">注册表配置使用VSCode打开文件与文件夹</a></p>
</blockquote>
<h2> 2、Node.js 入门</h2>
<h3> 2.1、NodeJS 初体验</h3>
<p>新建一个js文件，通过vs使用终端运行文件</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230420192316.png" alt="" loading="lazy"></p>
<p>使用 <code>node hello.js</code> 运行文件</p>
<blockquote>
<p>注意：Node.js 中<strong>不能使用 BOM 和 DOM 的 API</strong><br>
Node.js 中的顶级对象为 <strong>global</strong>（相当于浏览器中的windows）<br>
<strong>console，定时器</strong> 的API可以使用</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230420192544.png" alt="" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230420192620431.png" alt="image-20230420192620431" loading="lazy"></p>
<h2> 3、Buffer</h2>
<h3> 3.1、概念</h3>
<p>Buffer 是一个类似于数组的 <strong>对象</strong> ，用于表示固定长度的字节序列<br>
Buffer 本质是一段内存空间，专门用来处理 <strong>二进制数据</strong> 。</p>
<h3> 3.2、特点</h3>
<ol>
<li>Buffer 大小固定且无法调整</li>
<li>Buffer 性能较好，可以直接对计算机内存进行操作</li>
<li>每个元素的大小为 1 字节（byte）</li>
</ol>
<h3> 3.3、创建 Buffer</h3>
<p>Node.js 中创建 Buffer 的方式主要如下几种：</p>
<ol>
<li>Buffer.alloc</li>
<li>Buffer.allocUnsafe</li>
<li>Buffer.from</li>
</ol>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.4、Buffer 与字符串的转化</h3>
<p>可以借助 <strong>toString</strong> 方法将 Buffer 转为字符串</p>
<p>toString 默认是按照 utf-8 编码方式进行转换的。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.5、Buffer 的读写</h3>
<p>Buffer 可以直接通过 <strong>[ ]</strong> 的方式对数据进行处理</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>注意:<br>
如果修改的数值<strong>超过 255</strong> ，则超过 8 位数据会被舍弃<br>
一个 utf-8 的字符 一般占 <strong>3</strong> 个字节</p>
</blockquote>
<h2> 4、fs 模块</h2>
<p>fs 全称为 <strong>file system</strong> ，称之为 文件系统 ，是 Node.js 中的 内置模块 ，可以对计算机中的磁盘进行操作。</p>
<h4> <em><strong>fs模块的导入：</strong></em></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 4.1、文件写入</h3>
<p>文件写入就是将 数据 保存到 文件 中，我们可以使用如下几个方法来实现该效果</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>writeFile()</td>
<td>异步写入</td>
</tr>
<tr>
<td>writeFileSync()</td>
<td>同步写入</td>
</tr>
<tr>
<td>appendFile() / appendFileSync()</td>
<td>追加写入</td>
</tr>
<tr>
<td>createWriteStream()</td>
<td>流式写入</td>
</tr>
</tbody>
</table>
<h4> 4.1.1、writeFile 异步写入</h4>
<p><strong>主线程 不会等待 其他线程的执行结果，直接执行后续的主线程代码，效率较好</strong></p>
<p><strong>语法</strong>： <strong>fs.writeFile(file, data[, options], callback)</strong></p>
<blockquote>
<p>注：<strong>callback（回调函数）</strong></p>
</blockquote>
<p><strong>参数</strong>说明：<br>
file 文件名<br>
data 待写入的数据<br>
options 选项设置 （可选）<br>
callback 写入回调</p>
<p><strong>返回值</strong>： undefined</p>
<p>案例：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4.1.2、writeFileSync 同步写入</h4>
<p>**主线程等待写入完成后继续执行，效率较低  **</p>
<p><strong>语法</strong>: fs.writeFileSync(file, data[, options])</p>
<p><strong>参数</strong>与 fs.writeFile 大体一致，只是没有 callback 参数</p>
<p><strong>返回值</strong>： undefined</p>
<p>示例：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4.1.3、appendFile / appendFileSync 追加写入</h4>
<p><strong>appendFile</strong> 作用是在文件尾部追加内容，appendFile 语法与 writeFile 语法完全相同</p>
<p><strong>语法:</strong><br>
fs.appendFile(file, data[, options], callback)<br>
fs.appendFileSync(file, data[, options])</p>
<p><strong>返回值</strong>： 都为 undefined</p>
<p>案例：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过 <strong>writeFile 实现追加写入</strong></p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4.1.4、createWriteStream 流式写入</h4>
<p><strong>语法</strong>： fs.createWriteStream(path[, options])</p>
<p><strong>参数</strong>说明：<br>
path 文件路径<br>
options 选项配置（ 可选 ）</p>
<p><strong>返回值</strong>： Object</p>
<p>案例：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>程序打开一个文件是需要消耗资源的 ，流式写入可以<strong>减少打开关闭文件的次数</strong>。<br>
<strong>流式写入</strong>方式 <strong>适用于大文件写入或者频繁写入</strong> 的场景, writeFile 适合于写入频率较低的场景</p>
<h3> 4.2、文件读取</h3>
<p>通过程序从文件中取出其中的数据，有如下几种方式：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>readFile()</td>
<td>异步读取</td>
</tr>
<tr>
<td>readFileSync()</td>
<td>同步读取</td>
</tr>
<tr>
<td>createReadStream()</td>
<td>流式读取</td>
</tr>
</tbody>
</table>
<h4> 4.2.1、readFile 异步读取</h4>
<p><strong>语法</strong>： fs.readFile(path[, options], callback)</p>
<p><strong>参数</strong>说明：<br>
path 文件路径<br>
options 选项配置<br>
callback 回调函数</p>
<p><strong>返回值</strong>： undefined</p>
<p>案例：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4.2.2、readFileSync 同步读取</h4>
<p><strong>语法</strong>： fs.readFileSync(path[, options])</p>
<p><strong>参数</strong>说明：<br>
path 文件路径<br>
options 选项配置</p>
<p><strong>返回值</strong>： string | Buffer</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4.2.3、createReadStream 流式读取</h4>
<p>流式读取 为 <strong>一块一块读取</strong><br>
每次从文件中读取数据 <strong>64K</strong></p>
<p><strong>语法</strong>： fs.createReadStream(path[, options])</p>
<p><strong>参数</strong>说明：<br>
path 文件路径<br>
options 选项配置（ 可选 ）</p>
<p><strong>返回值</strong>： Object</p>
<p>案例：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4.3、复制文件</h3>
<p>方式一：readFile</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>方式二：流式操作</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>方式三：pip（不常用）</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4.4、文件移动与重命名</h3>
<p>在 Node.js 中，我们可以使用 <strong>rename</strong> 或 <strong>renameSync</strong> 来移动或<strong>重命名 文件或文件夹</strong></p>
<p><strong>语法</strong>：<br>
fs.rename(oldPath, newPath, callback)<br>
fs.renameSync(oldPath, newPath)</p>
<p><strong>参数</strong>说明：<br>
oldPath 文件当前的路径<br>
newPath 文件新的路径（可以用于移动文件）<br>
callback 操作后的回调</p>
<p>案例：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4.5、文件删除</h3>
<p>在 Node.js 中，我们可以使用 <strong>unlink</strong> 或 <strong>unlinkSync</strong> 或 <strong>rm</strong> 来删除文件</p>
<p><strong>语法</strong>：<br>
fs.unlink(path, callback)<br>
fs.unlinkSync(path)<br>
fs.rm(path,callback)</p>
<p><strong>参数</strong>说明：<br>
path 文件路径<br>
callback 操作后的回调</p>
<p>示例：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4.6、文件夹操作</h3>
<p>借助 Node.js 的能力，我们可以对文件夹进行 <strong>创建 、 读取 、 删除</strong> 等操作</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>mkdir / mkdirSync</td>
<td>创建文件夹</td>
</tr>
<tr>
<td>readdir / readdirSync</td>
<td>读取文件夹</td>
</tr>
<tr>
<td>rmdir / rmdirSync</td>
<td>删除文件夹</td>
</tr>
</tbody>
</table>
<h4> 4.6.1、mkdir 创建文件夹</h4>
<p>在 Node.js 中，我们可以使用 <strong>mkdir</strong> 或 <strong>mkdirSync</strong> 来创建文件夹</p>
<p><strong>语法</strong>：<br>
fs.mkdir(path[, options], callback)<br>
fs.mkdirSync(path[, options])</p>
<p>参数说明：<br>
path 文件夹路径<br>
options 选项配置（ 可选 ）<br>
callback 操作后的回调</p>
<p>示例：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>递归创建：<br>
<strong>recursive:true</strong> 表示递归创建</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4.6.2、readdir 读取文件夹</h4>
<p>在 Node.js 中，我们可以使用 <strong>readdir</strong> 或 <strong>readdirSync</strong> 来读取文件夹</p>
<p><strong>语法</strong>：<br>
fs.readdir(path[, options], callback)<br>
fs.readdirSync(path[, options])</p>
<p><strong>参数</strong>说明：<br>
path 文件夹路径<br>
options 选项配置（ 可选 ）<br>
callback 操作后的回调</p>
<p>示例：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4.6.3、 rmdir 删除文件夹</h4>
<p>在 Node.js 中，我们可以使用 <strong>rm</strong> ， <strong>rmdir</strong> 或 <strong>rmdirSync</strong> 来删除文件夹</p>
<p><strong>语法</strong>：<br>
fs.rmdir(path[, options], callback)<br>
fs.rmdirSync(path[, options])</p>
<p><strong>参数</strong>说明：<br>
path 文件夹路径<br>
options 选项配置（ 可选 ）<br>
callback 操作后的回调</p>
<p><strong>示例</strong>：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>递归删除：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>建议使用 <strong>rm</strong> 方法：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4.7、查看资源状态</h3>
<p>在 Node.js 中，我们可以使用 <strong>stat</strong> 或 <strong>statSync</strong> 来查看资源的详细信息</p>
<p><strong>语法</strong>：<br>
fs.stat(path[, options], callback)<br>
fs.statSync(path[, options])</p>
<p><strong>参数</strong>说明：<br>
path 文件夹路径<br>
options 选项配置（ 可选 ）<br>
callback 操作后的回调</p>
<p><strong>示例</strong>：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4.8、__dirname</h3>
<p><strong>相对路径存在的问题：</strong><br>
fs模块<strong>相对路径</strong>的<strong>参照</strong>为：<strong>命令行的工作目录</strong>，并非是文件的所在目录</p>
<p><strong>__dirname</strong> 与 <strong>require</strong> 类似，都是 Node.js 环境中的 <strong>'全局变量'</strong><br>
__dirname 保存着 当前<strong>文件</strong>所在目录的<strong>绝对路径</strong> ，可以使用 __dirname 与文件名拼接成绝对路径</p>
<p>作用：通过 <strong>__dirname</strong> 拼接 绝对路径</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4.9、批量重命名</h3>
<p>案例：批量重命名</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 5、path 模块</h2>
<p>path模块的导入：<strong>const path = require('path')</strong></p>
<p>path 模块提供了 操作路径 的功能，如下为几个较常用的API：</p>
<table>
<thead>
<tr>
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>path.resolve</td>
<td>拼接规范的绝对路径 常用</td>
</tr>
<tr>
<td>path.sep</td>
<td>获取操作系统的路径分隔符</td>
</tr>
<tr>
<td>path.parse</td>
<td>解析路径并返回对象</td>
</tr>
<tr>
<td>path.basename</td>
<td>获取路径的基础名称</td>
</tr>
<tr>
<td>path.dirname</td>
<td>获取路径的目录名</td>
</tr>
<tr>
<td>path.extname</td>
<td>获得路径的扩展名</td>
</tr>
</tbody>
</table>
<p>为 <strong>规范化</strong> 绝对路径 （将路径中的斜线都改为 <code>/</code> ）可以使用 <strong>path.resolve</strong></p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 6、http 模块</h2>
<p>HTTP（hypertext transport protocol）协议；中文叫超文本传输协议<br>
是一种基于TCP/IP的应用层通信协议<br>
这个协议详细规定了 浏览器 和万维网 服务器 之间互相通信的规则。</p>
<p>协议中主要规定了两个方面的内容<br>
客户端：用来向服务器发送数据，可以被称之为<strong>请求报文</strong><br>
服务端：向客户端返回数据，可以被称之为<strong>响应报文</strong></p>
<h3> 6.1、请求报文</h3>
<p>请求报文的组成：请求行、请求头、空行、请求体</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230422090654.png" alt="" loading="lazy"></p>
<h4> 6.1.1、请求行</h4>
<p>请求行的组成：<br>
请求方法（get、post、put、delete等），请求URL（统一资源定位器）</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230422090923.png" alt="" loading="lazy"></p>
<h4> 6.1.2、请求头</h4>
<p>请求头为<strong>键值对</strong>类型</p>
<p>格式：『头名：头值』</p>
<p>常见的请求头有：</p>
<table>
<thead>
<tr>
<th>请求头</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>Host</td>
<td>主机名</td>
</tr>
<tr>
<td>Connection</td>
<td>连接的设置 keep-alive（保持连接）；close（关闭连接）</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>缓存控制 max-age = 0 （没有缓存）</td>
</tr>
<tr>
<td>Upgrade Insecure Requests</td>
<td>将网页中的http请求转化为https请求（很少用）老网站升级</td>
</tr>
<tr>
<td>User-Agent</td>
<td>用户代理，客户端字符串标识，服务器可以通过这个标识来识别这个请求来自 哪个客户端 ，一般在PC端和手机端的区分</td>
</tr>
<tr>
<td>Accept</td>
<td>设置浏览器接收的数据类型</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>设置接收的压缩方式</td>
</tr>
<tr>
<td>Accept Language</td>
<td>设置接收的语言 q=0.7 为喜好系数，满分为1</td>
</tr>
<tr>
<td>Cookie</td>
<td>cookie</td>
</tr>
</tbody>
</table>
<h4> 6.1.3、请求体</h4>
<p>请求体内容的格式是非常灵活的，</p>
<p>（可以是空）=&gt; GET请求，<br>
（也可以是字符串，还可以是JSON）=&gt; POST请求</p>
<h3> 6.2、响应报文</h3>
<p>响应报文组成：</p>
<p>响应行：<br>
HTTP协议版本号 、状态码、响应状态描述  <code>例如 HTTP/1.1 200 OK  </code><br>
响应状态码和响应字符串关系是一一对应的。</p>
<p>响应头</p>
<p>空行</p>
<p>响应体:<br>
响应体内容的类型是非常灵活的，常见的类型有 HTML、CSS、JS、图片、JSON</p>
<h3> 6.3、创建 HTTP 服务</h3>
<p>使用 nodejs 创建 HTTP 服务</p>
<p>操作步骤：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>http.createServer 里的回调函数的执行时机： 当接收到 HTTP 请求的时候，就会执行</p>
</blockquote>
<p>使用浏览器访问：<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230422095002.png" alt="" loading="lazy"></p>
<p>停止服务的方式：<strong>ctrl+c</strong></p>
<p>响应内容<strong>中文乱码</strong>的<strong>解决办法</strong> ：response.setHeader('content-type','text/html;charset=utf-8');</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>HTTP 协议默认端口是 80 。HTTPS 协议的默认端口是 443, HTTP 服务开发常用端口有 3000，8080，8090，9000 等<br>
端口号被占用 的报错：Error: listen EADDRINUSE: address already in use :::9000</p>
<p>如果端口被其他程序占用，可以使用 资源监视器 找到占用端口的程序，然后使用 任务管理器 关闭对应的程序</p>
<h3> 6.4、查看 HTTP 报文</h3>
<p>查看请求行，请求头</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230422101448.png" alt="" loading="lazy"></p>
<p>查看请求体</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230422101526.png" alt="" loading="lazy"></p>
<p>查看响应行，响应头</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230422101053.png" alt="" loading="lazy"></p>
<p>查看响应体</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230422101148.png" alt="" loading="lazy"></p>
<h3> 6.5、获取 HTTP 请求报文</h3>
<p>想要获取请求的数据，需要通过 <strong>request</strong> 对象</p>
<table>
<thead>
<tr>
<th>含义</th>
<th>语法</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>请求方法</strong></td>
<td><strong>request.method</strong></td>
</tr>
<tr>
<td>请求版本</td>
<td>request.httpVersion</td>
</tr>
<tr>
<td><strong>请求路径</strong></td>
<td><strong>request.url</strong></td>
</tr>
<tr>
<td><strong>URL 路径</strong></td>
<td><strong>require('url').parse(request.url).pathname</strong></td>
</tr>
<tr>
<td><strong>URL 查询字符串</strong></td>
<td><strong>require('url').parse(request.url, true).query</strong></td>
</tr>
<tr>
<td><strong>请求头</strong></td>
<td><strong>request.headers</strong></td>
</tr>
<tr>
<td>请求体</td>
<td>request.on('data', function(chunk){}) request.on('end', function(){});</td>
</tr>
</tbody>
</table>
<p>注意：</p>
<p>1、<strong>request.url</strong> 只能获取<strong>路径以及查询字符串</strong>，无法获取 URL 中的域名以及协议的内容（如 <code>/search?name=A</code>）<br>
2、 <strong>request.headers</strong> 将请求信息转化成一个<strong>对象</strong>，并将<strong>属性名</strong>都转化成了『<strong>小写</strong>』<br>
3、favicon.ico：这个请求是属于浏览器自动发送的请求</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 6.5.1、提取请求体</h4>
<p>请求为POST才有请求体，GET没有请求体</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 6.5.2、获取请求路径和查询字符串</h4>
<p>方式一：</p>
<p>const res =  <strong>url.parse(request.url,true)</strong><br>
该方法用于解析request.url （<code>比如解析/search?name=A</code>）<br>
第二个参数用于将返回结果 res 的 <strong>query</strong> 属性设置为对象<br>
参数二默认为 false ，query对象为数组</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>方式二：</p>
<p>实例化 UR L对象 url<br>
通过 url 的 <strong>pathname</strong> 属性 和 <strong>searchParams.get()</strong> 方法 获取请求路径和查询字符串</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 6.5.3、练习：获取请求报文</h4>
<table>
<thead>
<tr>
<th>请求类型(方法)</th>
<th>请求地址</th>
<th>响应体结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>get</td>
<td>/login</td>
<td>登录页面</td>
</tr>
<tr>
<td>get</td>
<td>/reg</td>
<td>注册页面</td>
</tr>
</tbody>
</table>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6.6、获取 HTTP 响应报文</h3>
<table>
<thead>
<tr>
<th>作用</th>
<th>语法</th>
</tr>
</thead>
<tbody>
<tr>
<td>设置响应状态码</td>
<td>response.statusCode</td>
</tr>
<tr>
<td>设置响应状态描述</td>
<td>response.statusMessage （ 用的非常少 ）</td>
</tr>
<tr>
<td>设置响应头信息</td>
<td>response.setHeader('头名', '头值')</td>
</tr>
<tr>
<td>设置响应体</td>
<td>response.write('xx') response.end('xxx')</td>
</tr>
<tr>
<td>返回对 <code>ClientRequest</code> 的引用</td>
<td>response.end(字符串 或 <strong>buffer</strong>)</td>
</tr>
</tbody>
</table>
<p>注意：setHeader() 可以<strong>多次调用</strong>，使用了该方法一般不在 end() 方法中写值，end() 方法只能<strong>调用一次</strong></p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 响应文件内容</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>注：网页资源加载的基本过程：浏览器向服务器先发送访问 html 的请求，解析 html 文件中的其他文件，发送的请求包括请求 css，js，图片等等，这些请求许多是并行的。</p>
</blockquote>
<h4> 实现网页引入外部资源</h4>
<p>根据不同的请求路径，获取不同的文件</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>代码仍然存在麻烦的问题<br>
因此引入静态资源服务</p>
<h3> 6.7、静态资源服务</h3>
<p>静态资源：图片，视频，css，js，html文件，字体文件<br>
动态资源：内容常更新的资源，例如列表搜索页面等</p>
<h4> 6.7.1、网站根目录或静态资源目录</h4>
<p>HTTP 服务在哪个文件夹中寻找静态资源，那个文件夹就是 <strong>静态资源目录</strong> ，也称之为网站 <strong>根目录</strong></p>
<p>vscode 中使用 live-server 访问 HTML 时， 它启动的服务中网站根目录是vs打开的当前目录</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6.8、网页中的URL</h3>
<p>网页中的 URL 主要分为两大类：相对路径与绝对路径</p>
<h4> 6.8.1 绝对路径</h4>
<p>绝对路径可靠性强，而且相对容易理解，在项目中运用较多</p>
<table>
<thead>
<tr>
<th>形式</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><a href="http://bilibli.com/web" target="_blank" rel="noopener noreferrer">http://bilibli.com/web</a></strong></td>
<td>直接向目标资源发送请求，容易理解。网站的外链会用到此形式</td>
</tr>
<tr>
<td><a href="//bilibili.com/web" target="_blank" rel="noopener noreferrer">//bilibili.com/web</a></td>
<td>与页面 URL 的协议拼接形成完整 URL 再发送请求。大型网站用的比较多</td>
</tr>
<tr>
<td><strong>/web</strong></td>
<td>与页面 URL 的协议、主机名、端口拼接形成完整 URL 再发送请求。中小 型网站（<strong>常用</strong>，方便在修改域名时防止大规模修改代码url）</td>
</tr>
</tbody>
</table>
<h4> 6.8.2 相对路径</h4>
<p>相对路径在发送请求时，需要<strong>与当前页面 URL</strong> 路径进行 <strong>计算</strong> ，得到完整 URL 后，再发送请求，学习阶段用的较多<br>
例如当前网页 url 为 <a href="http://www.bilibili.com/course/h5.html" target="_blank" rel="noopener noreferrer">http://www.bilibili.com/course/h5.html</a></p>
<table>
<thead>
<tr>
<th>形式</th>
<th>最终的 URL</th>
</tr>
</thead>
<tbody>
<tr>
<td>./css/app.css</td>
<td><a href="http://www.bilibili.com/course/css/app.css" target="_blank" rel="noopener noreferrer">http://www.bilibili.com/course/css/app.css</a></td>
</tr>
<tr>
<td>js/app.js</td>
<td><a href="http://www.bilibili.com/course/js/app.js" target="_blank" rel="noopener noreferrer">http://www.bilibili.com/course/js/app.js</a></td>
</tr>
<tr>
<td>../img/logo.png</td>
<td><a href="http://www.bilibili.com/img/logo.png" target="_blank" rel="noopener noreferrer">http://www.bilibili.com/img/logo.png</a></td>
</tr>
<tr>
<td>../../mp4/show.mp4</td>
<td><a href="http://www.bilibili.com/mp4/show.mp4" target="_blank" rel="noopener noreferrer">http://www.bilibili.com/mp4/show.mp4</a></td>
</tr>
</tbody>
</table>
<p>网页中使用 URL ：a 标签 href、link 标签 href、script 标签 src、img 标签 src、video audio 标签 src、form 中的 action、AJAX 请求中的 URL  等</p>
<h3> 6.9、设置资源类型  （MIME类型）</h3>
<p>媒体类型（通常称为 Multipurpose Internet Mail Extensions 或 MIME 类型 ）是一种标准，用来表示文档、文件或字节流的性质和格式。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>HTTP 服务可以<strong>设置响应头</strong> <strong>Content-Type</strong> 来表明响应体的 <strong>MIME 类型</strong>，浏览器会根据该类型决定如何处理资源</p>
<p>下面是常见文件对应的 mime 类型<br>
可以根据请求文件路径<strong>后缀名</strong>获取对应类型（便于规范）（如果获取不到可选application/octet-stream类型）</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>对于未知的资源类型，可以选择 <strong>application/octet-stream</strong> 类型，浏览器在遇到该类型的响应时，会对响应体内容进行独立存储，也就是我们常见的 <strong>下载</strong> 效果</p>
</blockquote>
<p>解决乱码问题：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>注：响应头的字符集优先级大于 html 中的 meta 标签</p>
<p>网页字符集为utf-8，所以一般不需要设置字符集</p>
</blockquote>
<h2> 7、Node.js 模块化</h2>
<h3> 7.1、模块化介绍</h3>
<p>将一个复杂的程序文件依据一定规则（规范）拆分成多个文件的过程称之为 <strong>模块化</strong><br>
其中拆分出的 <strong>每个文件就是一个模块</strong> ，模块的<strong>内部数据</strong>是<strong>私有</strong>的，不过模块可以<strong>暴露内部数据</strong>以便其他模块使用</p>
<p>编码时是按照模块一个一个编码的， 整个项目就是一个模块化的项目</p>
<p>模块化好处：防止命名冲突、高复用性、高维护性</p>
<h3> 7.2、模块暴露数据</h3>
<h4> 7.2.1、暴露数据</h4>
<p>模块暴露数据的方式有两种：</p>
<ol>
<li><strong>module.exports = value</strong></li>
<li><strong><a href="http://exports.name" target="_blank" rel="noopener noreferrer">exports.name</a> = value</strong></li>
</ol>
<p>注：<br>
① module.exports 可以暴露 <strong>任意</strong> 数据<br>
② 不能使用 exports = value 的形式暴露数据<br>
模块内部 module 与 exports 的隐式关系：<strong>exports = module.exports = {}</strong> ，<strong>require()</strong> 函数返回的是<strong>目标模块</strong>中 <strong>module.exports 的值</strong></p>
<p>exports 与 module.exports地址关系：<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230423093420.png" alt="" loading="lazy"></p>
<p>案例：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7.3、require() 函数</h3>
<p>在模块中使用 <strong>require()</strong> 传入<strong>文件路径</strong>即可引入文件</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>require 使用的一些注意事项：</p>
<ol>
<li>对于<strong>自己创建的模块</strong>，导入时路径建议写 <strong>相对路径</strong> ，且<strong>不能省略 ./ 和 ../</strong></li>
<li><strong>js</strong> 和 <strong>json</strong> 文件导入时可以<strong>不用写后缀</strong>，c/c++编写的 node 扩展文件也可以不写后缀，但是一般用不到</li>
<li>如果导入其他类型的文件，会以 <strong>js</strong> 文件进行处理</li>
<li>如果<strong>导入</strong>的路径是个<strong>文件夹</strong>，则会 <strong>首先</strong> 检测该文件夹下 <strong>package.json</strong> 文件中 <strong>main</strong> 属性<strong>对应的文件</strong>，如果存在则导入，反之如果文件不存在会报错。<br>
如果 main 属性<strong>不存在</strong>，或者 package.json 不存在，则会尝试<strong>导入</strong>文件夹下的 i<strong>ndex.js 和index.json</strong> ，如果还是没找到，就会报错</li>
<li>导入 <strong>node.js 内置模块</strong>时，直接 <strong>require</strong> <strong>模块</strong>的<strong>名</strong>字即可，<strong>无需加 ./ 和 ../</strong></li>
</ol>
<h3> 7.4、require 导入的基本流程</h3>
<p><strong>require</strong> 导入 <strong>自定义模块</strong> 的基本流程</p>
<ol>
<li>将相对路径转为绝对路径，定位目标文件</li>
<li>缓存检测</li>
<li>读取目标文件代码</li>
<li>将代码包裹为一个函数并执行（自执行函数）。可以通过 <strong>arguments.callee.toString()</strong> 查看自执行函数</li>
<li>缓存模块的值</li>
<li>返回 <strong>module.exports</strong> 的值</li>
</ol>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230423100033.png" alt="" loading="lazy"></p>
<h3> 7.5、 CommonJS 规范</h3>
<p>module.exports 、 exports 以及 require 这些都是 CommonJS 模块化规范中的内容。<br>
而 Node.js 是实现了 CommonJS 模块化规范，二者关系有点像 JavaScript 与 ECMAScript</p>
<h2> 8、npm 包管理工具</h2>
<p>『包』package ，代表了一组特定功能的源码集合</p>
<p>管理『包』的应用软件，可以对「包」进行 <strong>下载安装 ， 更新 ， 删除 ， 上传</strong> 等操作<br>
借助包管理工具，可以快速开发项目，提升开发效率<br>
包管理工具是一个通用的概念，很多编程语言都有包管理工具，所以 掌握好包管理工具非常重要</p>
<p>常用的包管理工具：<strong>npm</strong>、yarn、cnpm</p>
<p>npm 全称 <strong>Node Package Manager</strong> ，翻译为中文意思是Node 的包管理工具<br>
npm 是 node.js 官方内置的包管理工具，是 必须要掌握住的工具</p>
<h3> 8.1、npm 的安装</h3>
<p>node.js 在安装时会 自动安装 npm ，安装了 node.js，可以直接使用 npm<br>
在 cmd 通过 <strong>npm -v</strong> 查看版本号测试，如果显示版本号说明安装成功</p>
<h3> 8.2、npm 初始化</h3>
<p>创建一个空目录，然后以此目录作为工作目录 启动命令行工具 ，执行 <strong>npm init</strong></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230423101809069.png" alt="image-20230423101809069" loading="lazy"></p>
<p>输入一些值（没有直接回车，括号中的为默认）</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230423102006.png" alt="" loading="lazy"></p>
<p><strong>npm init</strong> 命令的作用是将文件夹初始化为一个包， 交互式创建 <strong>package.json</strong> 文件<br>
package.json 是包的配置文件，<strong>每个包都必须要有 package.json</strong></p>
<p>初始化的过程中还有一些<strong>注意事项</strong>：</p>
<ol>
<li><strong>package name</strong> ( 包名 ) <strong>不能使用中文、大写</strong>，默认值是 文件夹的名称 ，所以文件夹名称也不能使用中文和大写</li>
<li>version ( 版本号 )要求 x.x.x 的形式定义， x 必须是数字，默认值是 1.0.0</li>
<li>ISC 证书与 MIT 证书功能上是相同的，关于开源证书扩展阅读<a href="http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html" target="_blank" rel="noopener noreferrer">http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html</a></li>
<li>package.json 可以手动创建与修改</li>
<li>使用 npm init -y 或者 npm init --yes 极速创建 package.json</li>
</ol>
<p>package.json 讲解：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8.3、npm 搜索包</h3>
<p>搜索包的方式有两种</p>
<ol>
<li>命令行 <strong>npm s/search</strong> 关键字</li>
<li>网站搜索 网址是 <a href="https://www.npmjs.com/" target="_blank" rel="noopener noreferrer">https://www.npmjs.com/</a>  （常用）</li>
</ol>
<h3> 8.4、npm 下载包</h3>
<p>可以通过 <strong>npm install</strong> 和 <strong>npm i</strong> 命令安装包</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下载包之后会增加两个资源：<br>
<strong>node_modules</strong> 文件夹 存放 <strong>下载的包</strong><br>
<strong>package-lock.json</strong> 包的锁文件 ，用来<strong>锁定包的版本</strong></p>
<p>依赖的概念：<br>
创建一个包名字为 A，A 中安装了包名字是 B，我们就说 B 是 A 的一个依赖包，也会说A 依赖 B</p>
<h3> 8.5、npm 包使用</h3>
<p>通过 <strong>require</strong> 导入 npm 包</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>require</strong> 导入 npm 包<strong>基本流程</strong>：<br>
① 在当前文件夹下 node_modules 中寻找同名的文件夹<br>
② 在上级目录中下的 node_modules 中寻找同名的文件夹，直至找到磁盘根目录</p>
<h3> 8.6、 生产依赖与开发依赖</h3>
<p>生产环境与开发环境 对应 生产依赖与开发依赖</p>
<p>可以在安装时设置选项来 <strong>区分依赖的类型</strong> ，目前分为两类：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>命令</th>
<th>补充</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>生产</strong>依赖</td>
<td>npm i -S uniq npm i --save uniq</td>
<td>-S 等效于 --save， -S 是<strong>默认选项</strong> 包信息保存在 package.json 中 <strong>dependencies</strong> 属性下</td>
</tr>
<tr>
<td><strong>开发</strong>依赖</td>
<td>npm i -D less npm i --save-dev less</td>
<td>-D 等效于 --save-dev 包信息保存在 package.json 中 <strong>devDependencies</strong> 属性下</td>
</tr>
</tbody>
</table>
<p>开发依赖 是只在开发阶段使用的依赖包 	-D<br>
生产依赖 是开发阶段和最终上线运行阶段都用到的依赖包  	-S（默认选项）</p>
<h3> 8.7、npm 全局安装</h3>
<p>可以执行安装选项 <strong>npm i -g 包名</strong> 进行全局安装</p>
<p>安装 <strong>nodemon</strong> 包：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>nodemon 该命令的作用是 <strong>自动重启 node 应用程序</strong> （文件保存后自动重启）<br>
全局安装后可以在命令行的任何位置运行 nodemon  命令</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>全局安装的命令不受工作目录位置影响<br>
可以通过 <strong>npm root -g</strong> 可以查看<strong>全局安装包的位置</strong><br>
不是所有的包都适合全局安装 ， 只有全局类的工具才适合，可以通过 查看包的官方文档来确定安装方式</p>
<blockquote>
<p>注：windows 默认不允许 npm 全局命令执行脚本文件，所以需要修改执行策略：<br>
① 以管理员身份打开PowerShell<br>
② 键入命令 set-ExecutionPolicy remoteSigned<br>
③ 键入 A 然后敲回车<br>
④ 重启 vscode</p>
<p>方法二：修改默认配置文件，使用cmd运行<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230423111538.png" alt="" loading="lazy"></p>
</blockquote>
<h3> 8.8、npm 安装包所有依赖</h3>
<p>在项目协作中有一个常用的命令就是 <strong>npm i</strong> ，通过该命令可以<strong>依据</strong> <strong>package.json</strong> 和 <strong>packagelock.json</strong> 的依赖声明安装项目依赖</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>node_modules 文件夹大多数情况都不会存入版本库 （文件大，数量多）</p>
<h3> 8.9、npm 安装指定版本包</h3>
<p>项目中可能会遇到版本不匹配的情况，有时就需要安装指定版本的包，可以使用下面的命令的</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8.10、npm 删除包</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8.11、npm 配置命令别名</h3>
<p>通过配置命令别名可以更简单的执行命令<br>
配置 package.json 中的 <strong>scripts</strong> 属性<br>
配置完成后，可以使用 <strong>npm run 别名</strong> 执行别名</p>
<p>案例：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以使用别名执行命令</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>不过 <strong>start</strong> 别名比较特别，使用时可以省略 run</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>npm start</strong> 是项目中常用的一个命令，一般用来启动项目<br>
<strong>npm run</strong> 有自动向上级目录查找的特性，跟 require 函数也一样<br>
对于陌生的项目，我们可以通过查看 <strong>scripts</strong> 属性来参考项目的一些操作</p>
<h3> 8.12、npm 配置淘宝镜像</h3>
<p>方式一：直接配置</p>
<p>​	执行如下命令即可完成配置</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>方式二：工具配置（推荐）</p>
<p>​	使用 <strong>nrm</strong> 配置 npm 的镜像地址 （nrm：<strong>npm registry manager</strong>）：</p>
<p>​	① 安装nrm：<br>
（最新的open版本变成了ES Module版本）</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>​	② 修改镜像 ：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>​	③ 检查是否配置成功：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>检查 registry 地址是否为 <a href="https://registry.npmmirror.com/" target="_blank" rel="noopener noreferrer">https://registry.npmmirror.com/</a> , 如果 是 则表明成功</p>
<p>建议使用第二种方式 进行镜像配置，因为后续修改起来会比较方便</p>
<h2> 9、cnpm</h2>
<h3> 9.1、介绍</h3>
<p>cnpm 是一个淘宝构建的 <strong><a href="http://npmjs.com" target="_blank" rel="noopener noreferrer">npmjs.com</a></strong> 的完整镜像，也称为 淘宝镜像，网址<a href="https://npmmirror.com/" target="_blank" rel="noopener noreferrer">https://npmmirror.com/</a><br>
cnpm 服务部署在国内 阿里云服务器上 ， 可以提高包的下载速度<br>
官方也提供了一个全局工具包 <strong>cnpm</strong> ，操作命令与 npm 大体相同</p>
<h3> 9.2、安装</h3>
<p>可以通过 npm 来安装 cnpm 工具</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 9.3、命令</h3>
<table>
<thead>
<tr>
<th>功能</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>初始化</td>
<td>cnpm init</td>
</tr>
<tr>
<td>安装包</td>
<td>cnpm i uniq<br>cnpm i -S uniq<br> cnpm i -D uniq <br>cnpm i -g nodemon</td>
</tr>
<tr>
<td>安装项目依赖</td>
<td>cnpm i</td>
</tr>
<tr>
<td>删除</td>
<td>cnpm r uniq</td>
</tr>
</tbody>
</table>
<p>虽然 cnpm 可以提高速度，但是 npm 也可以通过淘宝镜像进行加速，所以 npm 的使用率还是高于 cnpm</p>
<h2> 10、yarn</h2>
<h3> 10.1、yarn 介绍</h3>
<p><a href="https://yarnpkg.com/" target="_blank" rel="noopener noreferrer">yarn</a> 是由 Facebook 在 2016 年推出的新的 Javascript 包管理工具</p>
<p>yarn 官方宣称的一些特点 ：<br>
速度超快：yarn 缓存了每个下载过的包，所以再次使用时无需重复下载。 同时利用并行下载以最大化资源利用率，因此安装速度更快<br>
超级安全：在执行代码之前，yarn 会通过算法校验每个安装包的完整性<br>
超级可靠：使用详细、简洁的锁文件格式和明确的安装算法，yarn 能够保证在不同系统上无差异的<br>
工作</p>
<h3> 10.2、yarn 安装</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 10.3、yarn 常用命令</h3>
<table>
<thead>
<tr>
<th>功能</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>初始化</td>
<td>yarn init / yarn init -y</td>
</tr>
<tr>
<td>安装包</td>
<td>yarn add uniq 生产依赖 <br>yarn add less --dev 开发依赖 <br>yarn global add nodemon 全局安装</td>
</tr>
<tr>
<td>删除包</td>
<td>yarn remove uniq 删除项目依赖包 yarn global remove nodemon 全局删除包</td>
</tr>
<tr>
<td>安装项目依赖</td>
<td>yarn</td>
</tr>
<tr>
<td>运行命令别名</td>
<td>yarn &lt;别名&gt; # 不需要添加 run<br>(yarn start / yarn server)</td>
</tr>
</tbody>
</table>
<p>这里有个小问题就是 全局安装的包（ nodemon）不可用 ，yarn 全局安装包的位置可以通过 yarn global bin 来查看，将查看到的文件夹配置到环境变量即可解决问题</p>
<h3> 10.4、yarn 配置淘宝镜像</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>通过 <strong>yarn config list</strong> 查看 yarn 的配置项</p>
<h3> 10.5、npm 和 yarn 选择</h3>
<p>哪个工具都可以</p>
<p>他人的项目可以通过<strong>锁文件</strong>判断 项目的包管理工具</p>
<p>npm 的锁文件为 package-lock.json<br>
yarn 的锁文件为 yarn.lock</p>
<p>包管理工具 <strong>不要混着用</strong>，切记，切记，切记</p>
<h2> 11、nvm</h2>
<p>nvm 全称 Node Version Manager 顾名思义它是用来管理 node 版本的工具，方便 <strong>切换不同版本的Node.js</strong></p>
<p>nvm 的使用非常的简单，跟 npm 的使用方法类似</p>
<p>首先先下载 nvm，下载地址 <a href="https://github.com/coreybutler/nvm-windows/releases%EF%BC%8C" target="_blank" rel="noopener noreferrer">https://github.com/coreybutler/nvm-windows/releases，</a>  选择 nvm-setup.exe 下载即可</p>
<p>nvm 常用命令（cmd下）：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>nvm list available</td>
<td>显示所有可以下载的 Node.js 版本</td>
</tr>
<tr>
<td>nvm list</td>
<td>显示已安装的版本</td>
</tr>
<tr>
<td>nvm install 18.12.1</td>
<td>安装 18.12.1 版本的 Node.js</td>
</tr>
<tr>
<td>nvm install latest</td>
<td>安装最新版的 Node.js</td>
</tr>
<tr>
<td>nvm uninstall 18.12.1</td>
<td>删除某个版本的 Node.js</td>
</tr>
<tr>
<td>nvm use 18.12.1</td>
<td>切换 18.12.1 的 Node.js</td>
</tr>
</tbody>
</table>
<h2> 12、Express JS</h2>
<h3> 12.1、express 介绍</h3>
<p>express 是一个基于 Node.js 平台的极简、灵活的 WEB 应用开发框架，官方网址：<a href="https://www.expressjs.com.cn/" target="_blank" rel="noopener noreferrer">https://www.expressjs.com.cn/</a><br>
简单来说，express 是一个<strong>封装好的工具包</strong>，封装了很多功能，便于我们<strong>开发 WEB 应用（HTTP 服务）</strong></p>
<h3> 12.2、express 使用</h3>
<p>express 本身是一个 npm 包，所以可以通过 npm 安装</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>命令行下执行该脚本</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在浏览器就可以访问 <a href="http://127.0.0.1:3000/home" target="_blank" rel="noopener noreferrer">http://127.0.0.1:3000/home</a></p>
<h3> 12.3、express  路由</h3>
<p><strong>路由</strong>的概念：路由确定了<strong>应用程序（服务端）<strong>如何 <strong>响应客户端</strong> 对</strong>特定端点</strong>的请求</p>
<h4> 12.3.1、路由的使用</h4>
<p>一个路由的组成有 <strong>请求方法</strong> ， <strong>路径</strong> 和 <strong>回调函数</strong> 组成</p>
<p>express 中提供了一系列方法，可以很方便的使用路由，使用格式如下：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 12.3.2、获取请求参数</h4>
<p>express 框架封装了一些 API 来方便获取请求报文中的数据，并且兼容原生 HTTP 模块的获取方式</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 12.3.3、获取路由参数</h4>
<p>路由参数指的是 <strong>URL 路径中的参数（数据）</strong></p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 12.4、express 响应设置</h3>
<p>express 框架封装了一些 API 来方便给客户端响应数据，并且兼容原生 HTTP 模块的获取方式</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 12.5、express 中间件</h3>
<p>中间件（Middleware）本质是一个回调函数</p>
<p>中间件函数 可以像路由回调一样访问 请求对象（request） ， 响应对象（response）</p>
<p>中间件的作用 就是 <strong>使用函数封装公共操作，简化代码</strong></p>
<p>中间件的类型：全局中间件， 路由中间件</p>
<h4> 12.5.1、全局中间件</h4>
<p>（拦截）<strong>每一个请求</strong> 到达服务端之后 都会<strong>执行全局中间件函数</strong></p>
<p>声明全局中间件函数：<br>
函数： function(request,response,next)	<code>（公共部分提取）</code><br>
next：调用后续的路由回调函数</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>应用中间件</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>声明时可以直接将匿名函数传递给 <strong>use</strong></p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230425170744017.png" alt="image-20230425170744017" loading="lazy"></p>
<p>多个全局中间件：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 15.2.2、路由中间件</h4>
<p>如果 只需要对某一些路由进行功能封装 ，则就需要路由中间件</p>
<p>调用格式如下</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 15.2.3、静态资源中间件</h4>
<p>express 内置处理静态资源的中间件</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>注：<br>
index.html 文件为<strong>默认打开</strong>的资源<br>
如果静态资源与路由规则同时匹配，谁<strong>先</strong>匹配谁就响应<br>
<strong>路由</strong>响应<strong>动态资源</strong>，<strong>静态</strong>资源中间件响应<strong>静态资源</strong></p>
</blockquote>
<h3> 12.6、获取请求体数据 body-parser</h3>
<p>express 可以使用 <strong>body-parser</strong> 包处理请求体</p>
<p>安装：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>导入 body-parser 包 ：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>获取中间件函数</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>设置路由中间件，然后使用 <strong>request.body</strong> 来获取请求体数据</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 12.7、防盗链实现</h3>
<p>防盗链：禁止其他网站访问非此域名下的资源（图片，css等）</p>
<p>防盗链实现：通过 请求头中 <strong>referer</strong>（参考页）判断是否为当前域名下的访问，如果不是返回404</p>
<p>实现：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 12.8、Router 路由模块化</h3>
<p>express 中的 <strong>Router</strong> 是一个完整的中间件和路由系统，可以看做是一个<strong>小型的 app 对象</strong>。</p>
<p>Router 的作用：对路由进行模块化，更好的 <strong>管理路由</strong></p>
<p>使用案例：</p>
<p>创建独立的 JS 文件（homeRouter.js）</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>主文件</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 12.9、express generator工具</h3>
<p>使用应用程序生成器工具 <a href="http://expressjs.com/en/starter/generator.html#express-application-generator" target="_blank" rel="noopener noreferrer">express-generator</a> 快速创建应用程序框架。</p>
<p>可以使用命令运行应用程序生成器<code>npx</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>npm start 开启服务</p>
<h2> 13、接口</h2>
<h3> 13.1、介绍</h3>
<p>接口API (Application Program Interface)  是 前后端通信的桥梁  ，这里的接口指的是 <strong>数据接口</strong></p>
<p>一个接口就是 服务中的一个路由规则 ，根据请求响应结果</p>
<h3> 13.2、Restful</h3>
<p>RESTful API 是一种特殊风格的接口</p>
<p>规则示例：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>请求类型</th>
<th>URL</th>
<th>返回</th>
</tr>
</thead>
<tbody>
<tr>
<td>新增歌曲</td>
<td>POST</td>
<td>/song</td>
<td>返回新生成的歌曲信息</td>
</tr>
<tr>
<td>删除歌曲</td>
<td>DELETE</td>
<td>/song/10</td>
<td>返回一个空文档</td>
</tr>
<tr>
<td>修改歌曲</td>
<td>PUT</td>
<td>/song/10</td>
<td>返回更新后的歌曲信息</td>
</tr>
<tr>
<td>修改歌曲</td>
<td>PATCH</td>
<td>/song/10</td>
<td>返回更新后的歌曲信息</td>
</tr>
<tr>
<td>获取所有歌曲</td>
<td>GET</td>
<td>/song</td>
<td>返回歌曲列表数组</td>
</tr>
<tr>
<td>获取单个歌曲</td>
<td>GET</td>
<td>/song/10</td>
<td>返回单个歌曲信息</td>
</tr>
</tbody>
</table>
<h3> 13.3、json-server</h3>
<p><a href="https://github.com/typicode/json-server" target="_blank" rel="noopener noreferrer">json-server</a> 本身是一个 JS 编写的工具包，可以快速搭建 RESTful API 服务</p>
<p>全局安装 json-server  ：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用：</p>
<p>创建 JSON 文件（db.json），编写基本结构</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以 JSON 文件所在文件夹作为工作目录 ，执行如下命令 ，默认监听端口为 3000</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>测试访问：<br>
127.0.0.1:3000/song<br>
127.0.0.1:3000/song/2</p>
<h2> 14、会话控制</h2>
<p>HTTP 是一种 <strong>无状态</strong> 协议，它没有办法区分多次的请求是否来自于同一个客户端， <strong>无法区分用户</strong>，所以我们需要通过 <strong>会话控制</strong> 来解决该问题</p>
<p>常见的会话控制技术有三种：<br>
<strong>cookie  ，session  ，token</strong></p>
<h3> 14.1、cookie</h3>
<p>cookie 是 **保存在 浏览器端 **（本地）的一小块数据<br>
cookie 是按照域名划分保存的</p>
<p>浏览器向服务器发送请求时，会自动将 当前域名下 <strong>可用的 cookie 设置在请求头中</strong>，然后传递给服务器<br>
这个请求头的名字也叫 cookie ，所以将 cookie 理解为一个 HTTP 的请求头也是可以的</p>
<p>不同浏览器中的 cookie 是相互独立的，不共享<br>
浏览器限制单个 cookie 保存的数据不能超过 4K</p>
<p>express 中可以使用 cookie-parser 进行处理  （使用较少）：<br>
向cookie中添加，读取，删除数据，设置数据的时效性</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 14.2、session</h3>
<p>session 是<strong>保存在 服务器端</strong> 的一块儿数据 ，保存当前访问用户的相关信息</p>
<p>填写账号和密码校验身份，校验通过后创建 session 信息 ，然后将 session_id 的值通过响应头返回给浏览器<br>
有了 cookie，下次发送请求时会自动携带 cookie，服务器通过 cookie 中的 session_id 的值确定用户的身份</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230430123721044.png" alt="image-20230430123721044" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230430123752.png" alt="" loading="lazy"></p>
<p>express 中可以使用 express-session 对 session 进行操作</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>cookie 和 session 的区别：<br>
① 存储位置：<br>
cookie：浏览器端<br>
session：服务端</p>
<p>②  安全性：<br>
cookie 是以<strong>明文</strong>的方式存放在客户端的，安全性相对较低<br>
session 存放于服务器中，所以安全性 相对 较好</p>
<p>③  网络传输量<br>
cookie 设置内容过多会增大报文体积， 会影响传输效率<br>
session 数据存储在服务器，只是通过 cookie 传递 id，所以不影响传输效率</p>
<p>④  存储限制<br>
浏览器限制单个 cookie 保存的数据不能超过 4K ，且单个域名下的存储数量也有限制<br>
session 数据存储在服务器中，所以没有这些限制</p>
<h3> 14.3、token</h3>
<p><strong>token 保存在客户端</strong></p>
<p><strong>token</strong> 是 <strong>服务端生成</strong> 并 <strong>返回给 HTTP 客户端</strong> 的一串<strong>加密字符串</strong>， token 中保存着 用户信息</p>
<p>token 可以实现会话控制，识别用户的身份，主要用于<strong>移动端 APP</strong></p>
<p>token 工作流程：<br>
填写账号和密码校验身份，<strong>服务端</strong> 校验通过后创建并<strong>响应 token</strong>，token 一般是在 <strong>响应体</strong> 中返回给客户端的</p>
<p>后续 <strong>客户端</strong> 发送请求时，需要 <strong>手动</strong>将 <strong>token 添加在</strong> 请求报文** 中，一般是放在 <strong>请求头</strong> 中</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230430135704524.png" alt="image-20230430135704524" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230430135727.png" alt="" loading="lazy"></p>
<p>token特点：<br>
① 数据存储在客户端<br>
② 数据加密  ，可以避免 CSRF（跨站请求伪造）<br>
③ 扩展性更强  ，服务间可以共享  ，增加服务节点更简单</p>
<h4> JWT 工具</h4>
<p>JWT（JSON Web Token ）是目前最流行的跨域认证解决方案，可用于基于 token 的身份验证<br>
JWT 使 <strong>token 的生成与校验更规范</strong><br>
可以使用 jsonwebtoken 包 来操作 token</p>
<p>安装 jsonwebtoken ：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>创建（生成）token：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 15、EJS（不常用）</h2>
<p>EJS 是一个高效的 Javascript 的模板引擎  ，文件后缀名 .ejs</p>
<p>官网: <a href="https://ejs.co/" target="_blank" rel="noopener noreferrer">https://ejs.co/</a><br>
中文站：<a href="https://ejs.bootcss.com/" target="_blank" rel="noopener noreferrer">https://ejs.bootcss.com/</a></p>
<h2> 16、扩展：配置HTTPS证书</h2>
<p>https = http + ssl<br>
https 可以加密 http 报文</p>
<p>工具官网：<a href="https://certbot.eff.org" target="_blank" rel="noopener noreferrer">https://certbot.eff.org</a></p>
]]></content:encoded>
      <enclosure url="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230420185728.png" type="image/png"/>
    </item>
    <item>
      <title>Promise 基础</title>
      <link>https://T4mako.github.io/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Promise.html</link>
      <guid>https://T4mako.github.io/code/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/Promise.html</guid>
      <source url="https://T4mako.github.io/rss.xml">Promise 基础</source>
      <description>1、Promise 介绍 1.1、Promise 是什么 1.1.1、概念 Promise 是一门新的技术(ES6 规范) Promise 是 JS 中进行 异步编程 的新解决方案 （旧方案是单纯使用 回调函数 ） 从语法上来说: Promise 是一个构造函数 从功能上来说: promise 对象用来封装（包裹）一个异步操作并可以获取其成功/失败的结果值</description>
      <content:encoded><![CDATA[<h2> 1、Promise 介绍</h2>
<h3> 1.1、Promise 是什么</h3>
<h4> 1.1.1、概念</h4>
<p>Promise 是一门新的技术(ES6 规范)<br>
Promise 是 JS 中进行 <strong>异步编程</strong> 的新解决方案  （旧方案是单纯使用 <strong>回调函数</strong>  ）</p>
<p>从语法上来说: Promise 是一个<strong>构造函数</strong><br>
从功能上来说: promise 对象用来<strong>封装（包裹）一个异步操作</strong>并可以获取其成功/失败的结果值</p>
<h4> 1.1.2、promise 的状态</h4>
<ol>
<li>pending 变为 <strong>resolved</strong></li>
<li>pending 变为 <strong>rejected</strong></li>
</ol>
<p>说明: 只有这 2 种, 且一个 promise 对象<strong>只改变一次</strong><br>
无论变为成功还是失败, 都会有一个结果数据<br>
成功的结果数据一般称为 <strong>value</strong>, 失败的结果数据一般称为 <strong>reason</strong></p>
<h3> 1.2、promise 工作流程</h3>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230503142157.png" alt="" loading="lazy"></p>
<h3> 1.3、Promise 的优点</h3>
<p>① 指定回调函数的方式更加灵活</p>
<p>旧回调：必须在启动异步任务前指定</p>
<p>promise: 启动异步任务 =&gt; 返回promie对象 =&gt; 给promise对象绑定回调函<br>
数(甚至可以在异步任务结束后指定/多个)</p>
<p>② 支持<strong>链式调用</strong>, 可以解决回调地狱问题</p>
<p>回调函数嵌套调用, 外部回调函数异步执行的结果是嵌套的回调执行的条件</p>
<p>回调地狱不便于阅读和异常处理</p>
<p>解决方案：promise 链式调用，async/await</p>
<h3> 1.4、Promise API</h3>
<h4> 1、构造函数</h4>
<p>Promise <strong>构造函数</strong>: <strong>Promise (excutor) {}</strong><br>
executor 函数: 执行器 <strong>(resolve, reject) =&gt; {}</strong><br>
resolve 函数: 内部定义 <strong>成功时的回调</strong> <strong>value =&gt; {}</strong><br>
reject 函数: 内部定义 <strong>失败时的回调</strong> <strong>reason =&gt; {}</strong><br>
说明: executor 会在 Promise 内部立即 <em><strong>同步</strong></em> 调用,异步操作在执行器中执行</p>
<h4> 2、PromiseState 属性</h4>
<p>Promise 内置 <strong>属性</strong>：<strong>PromiseState</strong><br>
<strong>pending</strong>：未决定的<br>
<strong>resolved / fullfilled</strong> 成功<br>
<strong>rejected</strong> 失败</p>
<h4> 3、PromiseResult 属性</h4>
<p>Promise 内置 <strong>属性</strong>：<strong>PromiseResult</strong><br>
该属性保存对象 成功 / 失败 的结果<br>
resolve() 和 reject() 两个函数 可以修改 PromiseResult 的值</p>
<h4> 4、then() 方法</h4>
<p>Promise.prototype.<strong>then</strong>(onResolved, [onRejected]) =&gt; {} 方法:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>(1) onResolved 函数: <strong>成功</strong> 的回调函数 <strong>(value) =&gt; {}</strong><br>
(2) onRejected 函数: <strong>失败</strong> 的回调函数 <strong>(reason) =&gt; {}</strong><br>
说明: 指定用于得到成功 value 的成功回调 和 用于得到失败 reason 的失败回调<br>
返回一个新的 promise 对象</p>
<h4> 5、catch() 方法</h4>
<p>Promise.prototype.catch (onRejected) =&gt; {} 方法:</p>
<p>catch 只能指定 <strong>失败</strong> 的回调<br>
onRejected 函数:  (reason) =&gt; {}<br>
说明: then()的语法糖, 相当于: then(undefined, onRejected)</p>
<h4> 6、resolve() 方法</h4>
<p>Promise.resolve(value) =&gt; {} 方法:</p>
<p>value: 数据 或 promise 对象<br>
说明: 快速返回一个成功/失败的 promise 对象</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 7、reject() 方法</h4>
<p>Promise.reject(reason) =&gt; {} 方法:</p>
<p>reason: 失败的原因<br>
说明: 快速返回一个失败的 promise 对象</p>
<h4> 8、all() 方法</h4>
<p>Promise.<strong>all</strong>(promises) =&gt; {} 方法:</p>
<p>(1) promises: 包含 n 个 promise 的 <strong>数组</strong><br>
说明: 返回一个新的 promise, 只有<strong>所有的 promise 都成功才成功</strong>, 只要有一个失败了就 直接失败</p>
<h4> 9、race() 方法</h4>
<p>Promise.<strong>race</strong>(promises) =&gt; {} 方法:</p>
<p>(1) promises: 包含 n 个 promise 的 <strong>数组</strong><br>
说明: 返回一个新的 promise, <strong>第一个完成的 promise</strong> 的结果状态就是最终的结果状态</p>
<h3> 1.5、几个关键问题</h3>
<p>1、如何改变 promise 的状态：<br>
(1) resolve(value): 如果当前是 pending 就会变为 resolved<br>
(2) reject(reason): 如果当前是 pending 就会变为 rejected<br>
(3) 抛出异常 <code>throw '出问题了'</code>: 如果当前是 pending 就会变为 rejected</p>
<p>2、一个 promise 调用 then 方法 指定多个成功/失败回调函数, 都会调用（当 promise 改变为对应状态时都会调用  ）</p>
<p>3、改变 promise 状态改变 和 then方法 的先后顺序<br>
(1) 都有可能, 正常情况下是先指定回调（then）再 改变状态, 但也可以先改状态再指定回调<br>
(2) 如何先改状态再指定回调?<br>
① 在执行器中直接调用 resolve()/reject()<br>
② 延迟更长时间才调用 then()<br>
(3) 什么时候才能得到数据?<br>
① 如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据<br>
② 如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据</p>
<p>4、promise.then()返回的 <strong>新 promise 的结果状态</strong> 由什么决定?<br>
由 then()指定的回调函数执行的结果决定<br>
① 如果抛出异常, 新 promise 变为 rejected, reason 为抛出的异常<br>
② 如果返回的是非 promise 的任意值, 新 promise 变为 resolved, value 为返回的值<br>
③ 如果返回的是另一个新 promise, 此 promise 的结果就会成为新  promise 的结果</p>
<p>5、promise 如何串连多个操作任务?（<strong>链式</strong>操作）<br>
(1) promise 的 then()返回一个新的 promise, 可以看成 then()的链式调用<br>
(2) 通过 then 的链式调用串连多个同步/异步任务</p>
<p>6、promise <strong>异常传透</strong><br>
(1) 当使用 promise 的 then 链式调用时, 可以 <strong>在最后指定失败的回调,</strong><br>
(2) 前面任何操作出了异常, 都会传到最后失败的回调中处理 （类似异常处理 catch）</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>7、<strong>中断</strong> promise <strong>链</strong><br>
(1) 当使用 promise 的 then 链式调用时, 在中间中断, 不再调用后面的回调函数<br>
(2) 办法: 在回调函数中<strong>返回一个 pendding 状态的 promise 对象</strong></p>
<h2> 2、Promise 使用</h2>
<h3> 2.1、promise 初体验</h3>
<p>需求： 点击按钮,  1s 后显示是否中奖(30%概率中奖)<br>
若中奖弹出   恭喜恭喜, 奖品为 10万 RMB 劳斯莱斯优惠券<br>
若未中奖弹出  再接再厉</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.2、fs 模块使用 Promise</h3>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.3、Ajax 操作 Promise</h3>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.4、util.promise</h3>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.5、Promise 封装 Ajax 请求</h3>
<p>封装一个函数 sendAJAX 发送 GET AJAX 请求</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3、Promise 自定义（手写）</h2>
<h3> Promise 自定义封装</h3>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> Class 版本封装</h3>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 4、async 和 await</h2>
<p>MDN：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank" rel="noopener noreferrer">async</a><br>
<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await" target="_blank" rel="noopener noreferrer">await</a></p>
<h3> 4.1、async 函数</h3>
<p>async 函数的返回值是一个 Promise 对象<br>
返回的 promise 对象的结果由 async 函数执行的返回值决定</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4.2、await 表达式</h3>
<p><strong>await 右侧</strong> 的表达式一般为 <strong>promise 对象</strong>, 但也可以是其它的值<br>
如果表达式是 promise 对象, await 返回的是 promise 成功的值<br>
如果表达式是其它值, 直接将此值作为 await 的返回值</p>
<blockquote>
<p>注：<strong>await 必须写在 async 函数中</strong>，但 async 函数中可以没有 await<br>
如果表达式是其它值, 直接将此值作为 await 的返回值</p>
</blockquote>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4.3、使用案例</h3>
<h4> 读取三个文件的内容</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> async + await 发送 Ajax 请求</h4>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230503142157.png" type="image/png"/>
    </item>
    <item>
      <title>git 基础</title>
      <link>https://T4mako.github.io/code/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Git.html</link>
      <guid>https://T4mako.github.io/code/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Git.html</guid>
      <source url="https://T4mako.github.io/rss.xml">git 基础</source>
      <description>0、常用命令速览： ①git工作机制： 工作区（写代码）git add → 暂存区（临时存储）git commit → 本地库（会生成对应的历史版本）push→ 远程库 ②在本地使用的git命令： 命令 解释 git add 文件名(*) 添加到暂存区 git commit -m &amp;quot;日志信息&amp;quot; 文件名(*) 提交到本地库 git reflog 查看历史记录 git reset --hard 版本号 版本穿梭 git log 查看版本详细信息 git config --list 查看配置信息 git config --global user.name 用户名 git config --global user.email 邮箱</description>
      <category>基础</category>
      <content:encoded><![CDATA[<h2> 0、常用命令速览：</h2>
<h3> ①git工作机制：</h3>
<p><strong>工作区（写代码）<code>git add</code> → 暂存区（临时存储）<code>git commit</code> → 本地库（会生成对应的历史版本）<code>push</code>→ 远程库</strong></p>
<h3> ②在本地使用的git命令：</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>git add 文件名(*)</td>
<td>添加到暂存区</td>
</tr>
<tr>
<td>git commit -m "日志信息" 文件名(*)</td>
<td>提交到本地库</td>
</tr>
<tr>
<td>git reflog</td>
<td>查看历史记录</td>
</tr>
<tr>
<td>git reset --hard 版本号</td>
<td>版本穿梭</td>
</tr>
<tr>
<td>git log</td>
<td>查看版本详细信息</td>
</tr>
<tr>
<td>git config --list</td>
<td>查看配置信息</td>
</tr>
<tr>
<td>git config --global <a href="http://user.name" target="_blank" rel="noopener noreferrer">user.name</a></td>
<td>用户名</td>
</tr>
<tr>
<td>git config --global user.email</td>
<td>邮箱</td>
</tr>
</tbody>
</table>
<h3> ③远程仓库操作</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>git remote</td>
<td>查看远程仓库</td>
</tr>
<tr>
<td>git remote -v</td>
<td>查看当前所有远程地址别名</td>
</tr>
<tr>
<td>git remote add 别名 远程地址</td>
<td>关联/添加远程仓库（用于push,pull），添加一个新的远程git仓库，同时可以起别名</td>
</tr>
<tr>
<td>git remote remove 别名</td>
<td>取消关联远程仓库</td>
</tr>
<tr>
<td>git clone 远程地址</td>
<td>将远程仓库的内容克隆到本地</td>
</tr>
<tr>
<td>git pull 远程库地址别名 远程分支名</td>
<td>将远程仓库对于分支最新内容拉下来后与 当前本地分支直接合并</td>
</tr>
<tr>
<td>git push 别名 分支</td>
<td>推送本地分支上的内容到远程仓库</td>
</tr>
</tbody>
</table>
<h3> ④分支操作</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>git branch 分支名</td>
<td>创建分支</td>
</tr>
<tr>
<td>git branch</td>
<td>查看分支</td>
</tr>
<tr>
<td>git branch -v</td>
<td>查看分支</td>
</tr>
<tr>
<td>git checkout 分支名</td>
<td>切换分支</td>
</tr>
<tr>
<td>git merge 分支名</td>
<td>把指定的分支合并到当前分支上</td>
</tr>
</tbody>
</table>
<h3> ⑤标签操作</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>git tag</td>
<td>列出已有标签</td>
</tr>
<tr>
<td>git tag 标签名</td>
<td>创建标签</td>
</tr>
<tr>
<td>git push 远程仓库别名 标签名</td>
<td>将标签推送至远程仓库</td>
</tr>
<tr>
<td>git checkout -b 新分支名 标签名</td>
<td>检出标签（将当前标签的状态下载下来）</td>
</tr>
</tbody>
</table>
<h2> 1、Git 概述</h2>
<p>Git 是一个免费的、开源的<strong>分布式版本控制系统</strong>，可以快速高效地处理从小型到大型的各种项目</p>
<p>Git 易于学习，占地面积小，性能极快。 它具有廉价的本地库(在磁盘上)，方便的暂存区域和多个工作分支等特性。 其性能优于 Subversion、 CVS、 Perforce 和 ClearCase 等版本控制工具。</p>
<h3> 1.1 何为版本控制</h3>
<p>版本控制是一种记录文件内容变化，以便将来查阅特定版本修订情况的系统。<br>
版本控制其实最重要的是可以<strong>记录文件修改历史记录</strong>，从而让<strong>用户能够查看历史版本，方便版本切换</strong>。</p>
<p>为什么需要版本控制：协作开发</p>
<h3> 1.2 版本控制工具</h3>
<h4> ①集中式版本控制工具</h4>
<p>CVS、 SVN(Subversion)、 VSS……<br>
集中化的版本控制系统诸如 CVS、 SVN 等，都有一个<strong>单一的集中管理的服务器</strong>，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这已成为版本控制系统的标准做法。<br>
这种做法带来了许多好处，每个人都可以在一定程度上看到项目中的其他人正在做些什么。而<strong>管理员也可以轻松掌控每个开发者的权限</strong>，并且管理一个集中化的版本控制系统， 要远<strong>比在各个客户端上维护本地数据库来得轻松容易</strong>。<br>
这么做显而易见的缺点是<strong>中央服务器的单点故障</strong>。如果服务器宕机一小时，那么在这一小时内，<strong>谁都无法提交更新，也就无法协同工作</strong> 。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230208144134.png" alt="" loading="lazy"></p>
<h4> ②分布式版本控制工具</h4>
<p>Git、 Mercurial、 Bazaar、 Darcs……<br>
像 Git 这种分布式版本控制工具，<strong>客户端</strong>提取的不是最新版本的文件快照，而是<strong>把代码仓库完整地镜像下来（本地库）</strong>。这样任何一处协同工作用的文件发生故障，事后都可以用<strong>其他客户端的本地仓库进行恢复</strong>。因为每个客户端的每一次文件提取操作，实际上都是一次对整个文件仓库的完整备份。<br>
分布式的版本控制系统出现之后,解决了集中式版本控制系统的缺陷:<br>
<strong>服务器断网的情况下也可以进行开发</strong>（因为版本控制是在本地进行的）<br>
<strong>每个客户端保存的也都是整个完整的项目</strong>（包含历史记录， 更加安全）</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230207181938977.png" alt="image-20230207181938977" loading="lazy"></p>
<h3> 1.3 Git 简史</h3>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230207183809424.png" alt="" loading="lazy"></p>
<h3> 1.4 Git 工作机制</h3>
<p><mark><strong>工作区（写代码）<code>git add</code> → 暂存区（临时存储）<code>git commit</code> → 本地库（会生成对应的历史版本）<code>push</code>→ 远程库</strong></mark></p>
<h3> 1.5 Git 和代码托管中心</h3>
<p><strong>代码托管中心</strong>是基于网络服务器的<strong>远程代码仓库</strong>，一般我们简单称为<strong>远程库</strong></p>
<p>局域网：GitLab<br>
互联网：GitHub（外网）、Gitee 码云（国内网站）</p>
<h2> 2、Git 安装</h2>
<p>修改安装路径和是否修改环境变量，其他保持默认</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230207185923544.png" alt="" loading="lazy"></p>
<h2> 3、Git本地命令</h2>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230208131542077.png" alt="" loading="lazy"></p>
<p><strong>快捷键：</strong><br>
<strong>ctrl+l：清屏</strong><br>
<strong>ctrl+insert 复制</strong><br>
<strong>shift+insert 粘贴</strong><br>
<strong>选中+鼠标中键：复制</strong></p>
<p><strong>重要概念：<br>
commit：提交，将本地文件和版本信息保存到本地仓库<br>
push：推送，将本地仓库文件和版本信息上传到远程仓库<br>
pull：拉取，将远程仓库文件和版本信息下载到本地仓库<br>
clone：从远程服务器克隆整个版本到本地（下载）</strong></p>
<h3> 3.1 设置用户签名</h3>
<p>基本语法：<br>
git config --global <a href="http://user.name" target="_blank" rel="noopener noreferrer">user.name</a> 用户名<br>
git config --global user.email 邮箱<br>
git config --list 查看配置信息</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230208135606324.png" alt="" loading="lazy"></p>
<p>签名的作用是区分不同操作者身份。<strong>用户的签名信息在每一个版本的提交信息中能够看到</strong>，以此确认本次提交是谁做的。 Git 首次安装<strong>必须设置一下用户签名</strong>，否则无法提交代码。<br>
注意： 这里设置用户签名和将来登录 GitHub（或其他代码托管中心）的账号没有任何关系。</p>
<h3> 3.2 初始化本地库</h3>
<p>未跟踪：没有git add<br>
已跟踪：已git add</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230314202301.png" alt="" loading="lazy"></p>
<p>基本语法：git init</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230208140317884.png" alt="image-20230208140317884" loading="lazy"></p>
<h3> 3.3 查看本地库状态</h3>
<p>基本语法：git status</p>
<h3> 3.4 添加暂存区</h3>
<h4> 3.4.1 将工作区的文件添加到暂存区</h4>
<p>基本语法：git add 文件名</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230208141427049.png" alt="" loading="lazy"></p>
<h3> 3.5 提交本地库</h3>
<p>基本语法：git commit -m "日志信息" 文件名</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230208141853101.png" alt="" loading="lazy"></p>
<h3> 3.6 历史版本</h3>
<h4> 3.6.1 查看历史版本</h4>
<p>基本语法：<br>
git reflog 查看版本信息<br>
git log 查看版本详细信息</p>
<h4> 3.6.2 版本穿梭</h4>
<p>基本语法：git reset --hard 版本号</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230208143353.png" alt="" loading="lazy"></p>
<p>Git 切换版本， 底层其实是移动的 HEAD 指针，具体原理如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230208144344.png" alt="" loading="lazy"></p>
<h2> 4、Git 分支操作</h2>
<h3> 4.1 什么是分支</h3>
<p>在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务的单独分支。使用分支意味着程序员可以把自己的工作<em><strong>从开发主线上分离开来</strong>， <strong>发自己分支的时候，不会影响主线分支的运行</strong>。对于初学者而言，<strong>分支可以简单理解为副本</strong>，一个分支就是一个单独的副本。（分支底层其实也是</em><em>指针的引用</em>*）</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230208144807.png" alt="" loading="lazy"></p>
<h3> 4.2 分支的好处</h3>
<p>同时<strong>并行推进多个功能开发</strong>，提高开发效率。<br>
各个分支在开发过程中，如果某一个分支开发失败，<strong>不会对其他分支有任何影响</strong>。失败的分支删除重新开始即可。</p>
<h3> 4.3 分支的操作</h3>
<table>
<thead>
<tr>
<th>命令名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>git branch 分支名</td>
<td>创建分支</td>
</tr>
<tr>
<td>git branch -v</td>
<td>查看分支</td>
</tr>
<tr>
<td>git checkout 分支名</td>
<td>切换分支</td>
</tr>
<tr>
<td>git merge 分支名</td>
<td>把指定的分支合并到当前分支上</td>
</tr>
</tbody>
</table>
<h4> 4.3.1 查看分支</h4>
<p>基本语法：git branch -v</p>
<h4> 4.3.2 创建分支</h4>
<p>基本语法：git branch 分支名</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230208150636020.png" alt="" loading="lazy"></p>
<h4> 4.3.3 修改分支</h4>
<p>先切换到分支</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230208151114.png" alt="" loading="lazy"></p>
<h4> 4.3.4 切换分支</h4>
<p>基本语法：git checkout 分支名</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230208150846.png" alt="" loading="lazy"></p>
<h4> 4.3.5 合并分支</h4>
<p>基本语法：git merge 分支名</p>
<p><strong>合并到master主分支</strong></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230208151426.png" alt="" loading="lazy"></p>
<h4> 4.3.6 产生冲突</h4>
<p>冲突产生的表现： 后面状态为 **MERGING  **</p>
<div class="language-git line-numbers-mode" data-ext="git"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>冲突产生的原因：<br>
合并分支时，两个分支在<strong>同一个文件的同一个位置有两套完全不同的修改</strong>。 Git 无法替我们决定使用哪一个。必须人为决定新代码内容。</p>
<p>查看状态（检测到有文件有两处修改）</p>
<h4> 4.3.7 解决冲突</h4>
<p><strong>编辑有冲突的文件，删除特殊符号</strong>，决定要使用的内容</p>
<p>​	特殊符号：&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>
​	当前分支的代码：=======<br>
​	合并过来的代码：&gt;&gt;&gt;&gt;&gt;&gt;&gt; hot-fix</p>
<p>**添加到暂存区  **</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230208152657.png" alt="" loading="lazy"></p>
<p><strong>执行提交（注意： 此时使用 git commit 命令时</strong><mark>不能带文件名</mark><strong>）</strong></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230208152726.png" alt="" loading="lazy"></p>
<p>注：<strong>合并分支只会修改被合并的那个分支</strong></p>
<h3> 4.4 创建分支和切换分支图解</h3>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230208152913324.png" alt="" loading="lazy"></p>
<p>master、 hot-fix 其实都是指向具体版本记录的指针。<strong>当前所在的分支</strong>，其实是由 <strong>HEAD决定的</strong>。所以创建分支的本质就是多创建一个指针。<br>
HEAD 如果指向 master，那么我们现在就在 master 分支上。<br>
HEAD 如果执行 hotfix，那么我们现在就在 hotfix 分支上。<br>
所以切换分支的本质就是移动 HEAD 指针</p>
<h2> 5、Git 团队协作机制</h2>
<h3> 5.1 团队内协作</h3>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230208153723251.png" alt="" loading="lazy"></p>
<h3> 5.2 跨团队协作</h3>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230208153915.png" alt="" loading="lazy"></p>
<h2> 6、GitHub/git远程命令</h2>
<h3> 6.1 创建远程仓库</h3>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230208160941.png" alt="" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230208161047.png" alt="" loading="lazy"></p>
<h3> 6.2 远程仓库操作</h3>
<table>
<thead>
<tr>
<th>命令名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>git remote -v</td>
<td>查看当前所有远程地址别名</td>
</tr>
<tr>
<td>git remote add 别名 远程地址</td>
<td>起别名</td>
</tr>
<tr>
<td>git push 别名 分支</td>
<td>推送本地分支上的内容到远程仓库</td>
</tr>
<tr>
<td>git clone 远程地址</td>
<td>将远程仓库的内容克隆到本地</td>
</tr>
<tr>
<td>git pull 远程库地址别名 远程分支名</td>
<td>将远程仓库对于分支最新内容拉下来后与 当前本地分支直接合并</td>
</tr>
</tbody>
</table>
<p><strong>git  clone与git pull的区别：</strong><br>
git clone是在<strong>没有版本</strong>库的时候，从远程服务器克隆整个版本到本地（下载），是一个本地从无到有的过程<br>
git pull是在本地<strong>有版本库</strong>的情况下，从远程库获取最新commit数据并且merge到本地</p>
<p>注意：如果当前本地仓库不是远程仓库克隆，而是本地创建的仓库，并且仓库中存在文件，此时再从远程仓库拉去文件时会宝座（fastal：refusing to merge histories）<code>本地有远程库没有的文件</code><br>
|解决方法：在git pull命令后加入参数--allow-unterlate-histories</p>
<p>适用场景：<br>
通常情况下，远程操作的第一步是先使用git clone从远程主机克隆一个到本地<br>
本地修改代码后，<strong>每次从本地仓库push到远程仓库前都要先进行git pull操作，保证push到远程仓库时没有版本冲突</strong></p>
<h4> 6.2.1 创建远程仓库别名</h4>
<p>基本语法：<br>
git remote -v 查看当前所有远程地址别名<br>
git remote add 别名 远程地址</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230208163110.png" alt="" loading="lazy"></p>
<h4> 6.2.2 推送本地分支到远程仓库</h4>
<p>基本语法：git push 别名 分支</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230208170934154.png" alt="image-20230208170934154" loading="lazy"></p>
<p><em><strong>注意使用token登录</strong></em></p>
<h4> 6.2.3 拉取远程库内容</h4>
<p>基本语法：git pull 远程库地址别名 远程分支名</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230208174717409.png" alt="image-20230208174717409" loading="lazy"></p>
<h4> 6.2.4 克隆远程仓库到本地</h4>
<p>基本语法：git clone 远程地址</p>
<p>例如：git clone <a href="https://github.com/atguiguyueyue/git-shTest.git" target="_blank" rel="noopener noreferrer">https://github.com/atguiguyueyue/git-shTest.git</a></p>
<p><strong>克隆代码不需要登录账号</strong></p>
<p>clone 会做如下操作：<br>
1、拉取代码。 2、初始化本地仓库。 3、创建别名</p>
<h4> 6.2.5 邀请加入团队</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230208180634.png" alt="" loading="lazy"></p>
<p>生成邀请函，发给别人<br>
然后同意邀请</p>
<h3> 6.3 跨团队协作</h3>
<p>找到他人的项目，点击folk</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230208181210.png" alt="" loading="lazy"></p>
<p>编辑完后提交。</p>
<p>可以创建一个新的请求：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230208181337.png" alt="" loading="lazy"></p>
<p>还可以聊天</p>
<p>如果代码没有问题，可以点击 Merge pull request 合并代码。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230208181551.png" alt="" loading="lazy"></p>
<h3> 6.4 SSH 免密登录</h3>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230208181656.png" alt="" loading="lazy"></p>
<p>生成ssh文件（用户文件夹下）</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230208181925.png" alt="" loading="lazy"></p>
<p>复制公钥</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230208182104368.png" alt="image-20230208182104368" loading="lazy"></p>
<p>添加ssh</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230208182303.png" alt="" loading="lazy"></p>
<p><em><strong>可以通过ssh来pull，push	不用多次输入密码</strong></em></p>
<h2> 7、IDEA 集成 Git</h2>
<h3> 7.1 配置 Git 忽略文件</h3>
<p>eclipse，Idea都有一定的无关配置文件（.iml，target文件）</p>
<p>为什么要忽略他们：<br>
与项目的实际功能无关，不参与服务器上部署运行。把它们忽略掉能够屏蔽 IDE 工具之间的差异。</p>
<p>怎么忽略：<br>
1） 创建忽略规则文件 xxxx.ignore（前缀名随便起，<strong>建议是 git.ignore</strong>）<br>
这个文件的存放位置原则上在哪里都可以，为了便于让~/.gitconfig 文件引用，建议也放在用户家目录下</p>
<p>git.ignore文件模板内容如下：</p>
<div class="language-txt line-numbers-mode" data-ext="txt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2） 在.gitconfig 文件中引用忽略配置文件（此文件在 Windows 的家目录中）</p>
<div class="language-txt line-numbers-mode" data-ext="txt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7.2 定位 Git 程序</h3>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230209141311.png" alt="" loading="lazy"></p>
<h3> 7.3 初始化本地库</h3>
<p>在窗体栏选择==<strong>VCS</strong>==(版本控制)：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230209141528.png" alt="" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230209141619.png" alt="" loading="lazy"></p>
<h3> 7.4 添加到暂存区、提交到本地库</h3>
<p>右键点击项目选择 Git -&gt; Add 将项目添加到暂存区。<br>
右键点击项目选择 Git -&gt; Commit Directory 将项目添加到暂存区。</p>
<h3> 7.5 切换版本</h3>
<p>在 IDEA 的左下角，点击Git，然后点击 Log 查看版本</p>
<p>右键选择要切换的版本，然后在菜单里点击 Checkout Revision。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230209143755.png" alt="" loading="lazy"></p>
<h3> 7.6 创建分支</h3>
<p>创建方式：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230209144140.png" alt="" loading="lazy"></p>
<p>或：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230209144201.png" alt="" loading="lazy"></p>
<h3> 7.7 切换分支</h3>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230209144309.png" alt="" loading="lazy"></p>
<h3> 7.8 合并分支</h3>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230209144646.png" alt="" loading="lazy"></p>
<h3> 7.9 解决冲突</h3>
<p>手动合并代码：<br>
点击 Conflicts 框里的 Merge 按钮，进行手动合并代码<br>
手动合并完代码以后，点击右下角的 Apply 按钮<br>
代码冲突解决，自动提交本地库。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230209144949.png" alt="" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230209145042.png" alt="" loading="lazy"></p>
<h2> 8、IDEA 集成 GitHub</h2>
<h3> 8.1 设置 GitHub 账号</h3>
<p>密码或token登录</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230209145418.png" alt="" loading="lazy"></p>
<h3> 8.2 分享工程到 GitHub</h3>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230209145819.png" alt="" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230209150159.png" alt="" loading="lazy"></p>
<h3> 8.3 push 推送本地库到远程库</h3>
<p>右键点击项目，可以将当前分支的内容 push 到 GitHub 的远程仓库中</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230209150425.png" alt="" loading="lazy"></p>
<p>或者</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230209150455.png" alt="" loading="lazy"></p>
<p>默认使用https来push<br>
也可以用ssh push：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230209150649.png" alt="" loading="lazy"></p>
<p>注意： push 是将本地库代码推送到远程库，如果<strong>本地库代码跟远程库代码版本不一致，push 的操作是会被拒绝的</strong>。也就是说， 要想 push 成功，一定要<strong>保证本地库的版本要比远程库的版本高</strong>！ 因此一个成熟的程序员在动手改本地代码之前，一定会<strong>先检查下远程库跟本地代码的区别</strong>！如果本地的<strong>代码版本</strong>已经<strong>落后</strong>，切记要<strong>先 pull 拉取一下远程库的代码</strong>，将本地代码更新到最新以后，然后再修改，提交，推送！</p>
<h3> 8.4 pull 拉取远程库到本地库</h3>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230209151108.png" alt="" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230209151236.png" alt="" loading="lazy"></p>
<p>注意： pull 是拉取远端仓库代码到本地，如果远程库代码和本地库代码不一致，会自动合并，如果自动合并失败，还会涉及到手动解决冲突的问题。</p>
<h3> 8.5 clone 克隆远程库到本地</h3>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230314213440.png" alt="" loading="lazy"></p>
<p>或者<br>
<strong>在idea初始化界面点击Get from VCSl通过url克隆代码</strong></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230209152200957.png" alt="image-20230209152200957" loading="lazy"></p>
<p>设置打开idea为初始化界面：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230209152424.png" alt="" loading="lazy"></p>
<h2> 9、码云</h2>
<h3> 9.1 码云创建远程库</h3>
<p>点击首页右上角的加号，选择下面的新建仓库<br>
填写仓库名称，路径和选择是否开源（共开库或私有库）<br>
最后根据需求选择分支模型，然后点击创建按钮。<br>
远程库创建好以后，就可以看到 HTTPS 和 SSH 的链接。</p>
<h3> 9.2 IDEA 集成码云</h3>
<p>Idea 默认不带码云插件，我们第一步要安装 Gitee 插件</p>
<p>添加码云账号：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230209202215.png" alt="" loading="lazy"></p>
<p>分享项目到码云上：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230209202655.png" alt="" loading="lazy"></p>
<p>push、pull与github操作差不多（注意ssh或https链接地址</p>
<h3> 9.3 码云复制 GitHub 项目</h3>
<p>新建仓库时导入</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230209203418.png" alt="" loading="lazy"></p>
<h2> 10、自建代码托管平台-GitLab</h2>
<h3> 10.1 GitLab 简介</h3>
<p>​	GitLab 是由 GitLabInc.开发，使用 MIT 许可证的基于网络的 Git 仓库管理工具，且具有wiki 和 issue 跟踪功能。使用 Git 作为代码管理工具，并在此基础上搭建起来的 web 服务。<br>
​	GitLab 由乌克兰程序员 DmitriyZaporozhets 和 ValerySizov 开发，它使用 Ruby 语言写成。后来，一些部分用 Go 语言重写。截止 2018 年 5 月，该公司约有 290 名团队成员，以及 2000 多名开源贡献者。 GitLab 被 IBM， Sony， JülichResearchCenter， NASA， Alibaba，<br>
Invincea， O’ReillyMedia， Leibniz-Rechenzentrum(LRZ)， CERN， SpaceX 等组织使用。</p>
<h3> 10.2 GitLab 官网地址</h3>
<p>官网地址： <a href="https://about.gitlab.com/" target="_blank" rel="noopener noreferrer">https://about.gitlab.com/</a><br>
安装说明： <a href="https://about.gitlab.com/installation/" target="_blank" rel="noopener noreferrer">https://about.gitlab.com/installation/</a></p>
<h3> 10.3 GitLab 安装</h3>
<h4> 10.3.1 服务器准备</h4>
<p>准备一个系统为 CentOS7 以上版本的服务器， 要求内存 4G，磁盘 50G。<br>
关闭防火墙， 并且配置好主机名和 IP，保证服务器可以上网。<br>
此教程使用虚拟机：主机名： gitlab-server<br>
IP 地址： 192.168.6.200</p>
<h4> 10.3.2 安装包准备</h4>
<p>​	Yum 在线安装 gitlab- ce 时，需要下载几百 M 的安装文件，非常耗时，所以最好提前把所需 RPM 包下载到本地，然后使用离线 rpm 的方式安装。</p>
<p>下载地址：<br>
<a href="https://packages.gitlab.com/gitlab/gitlabce/packages/el/7/gitlab-ce-13.10.2-ce.0.el7.x86_64.rpm" target="_blank" rel="noopener noreferrer">https://packages.gitlab.com/gitlab/gitlabce/packages/el/7/gitlab-ce-13.10.2-ce.0.el7.x86_64.rpm</a></p>
<h4> 10.3.3 编写安装脚本</h4>
<p>安装 gitlab 步骤比较繁琐，因此我们可以参考官网编写 gitlab 的安装脚本。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230209215654883.png" alt="image-20230209215654883" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230209215709.png" alt="" loading="lazy"></p>
<p>给脚本增加执行权限</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230209215726.png" alt="" loading="lazy"></p>
<p>然后执行该脚本，开始安装 gitlab-ce。注意一定要保证服务器可以上网</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230209215747.png" alt="" loading="lazy"></p>
<h4> 10.3.4 初始化 GitLab 服务</h4>
<p>执行以下命令初始化 GitLab 服务，过程大概需要几分钟，耐心等待</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230209215813902.png" alt="image-20230209215813902" loading="lazy"></p>
<h4> 10.3.5 启动 GitLab 服务</h4>
<p>执行以下命令启动 GitLab 服务：gitlab-ctl start<br>
如需停止：执行 gitlab-ctl stop</p>
<h4> 10.3.6 使用浏览器访问 GitLab</h4>
<p>使用主机名或者 IP 地址即可访问 GitLab 服务。需要提前配一下 windows 的 hosts 文件。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230209215915.png" alt="" loading="lazy"></p>
<p>首次登陆之前，需要修改下 GitLab 提供的 root 账户的密码，要求 8 位以上，包含大小写子母和特殊符号。因此我们修改密码<br>
然后使用修改后的密码登录 GitLab</p>
<h4> 10.3.7 GitLab 创建远程库</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230209220007.png" alt="" loading="lazy"></p>
<h4> 10.3.8 IDEA 集成 GitLab</h4>
<p>1） 安装 GitLab 插件</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230209220030.png" alt="" loading="lazy"></p>
<p>2）设置 GitLab 插件</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230209220053.png" alt="" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230209220108.png" alt="" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230209220123.png" alt="" loading="lazy"></p>
<p>3） push 本地代码到 GitLab 远程库</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230209220146.png" alt="" loading="lazy"></p>
<p>自定义远程连接</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230209220208.png" alt="" loading="lazy"></p>
<p>注意： gitlab 网页上复制过来的连接是： <a href="http://gitlab.example.com/root/git-test.git%EF%BC%8C" target="_blank" rel="noopener noreferrer">http://gitlab.example.com/root/git-test.git，</a><br>
需要手动修改为： <a href="http://gitlab-server/root/git-test.git" target="_blank" rel="noopener noreferrer">http://gitlab-server/root/git-test.git</a><br>
选择 gitlab 远程连接，进行 push。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230209220238.png" alt="" loading="lazy"></p>
<p>只要 GitLab 的远程库连接定义好以后， 对 GitLab 远程库进行 pull 和 clone 的操作和 Github 和码云一致</p>
<h2> 11、Git标签操作</h2>
<p>Git中的标签是指<strong>某个分支某个特定时间点的状态</strong>（快照？），通过标签，可以很方便的切换到标记时的状态</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230314211432.png" alt="" loading="lazy"></p>
<p>git tag				列出已有标签<br>
git tag 标签名	创建标签<br>
git push 远程仓库别名 标签名	将标签推送至远程仓库<br>
git checkout -b 新分支名 标签名	检出标签（将当前标签的状态下载下来）</p>
<p><strong>标签是一个静态的概念，标签打好了，就不会变了</strong><br>
<strong>分支可以修改，是动态的</strong></p>
]]></content:encoded>
      <enclosure url="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230208144134.png" type="image/png"/>
    </item>
    <item>
      <title>Markdown 语法基础</title>
      <link>https://T4mako.github.io/code/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Markdown%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80.html</link>
      <guid>https://T4mako.github.io/code/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Markdown%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80.html</guid>
      <source url="https://T4mako.github.io/rss.xml">Markdown 语法基础</source>
      <description>Markdown 语法基础 Markdown官方教程 编辑器推荐：Typora 概述 Markdown 是一种可以使用普通文本编辑器编写的 标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 Markdown 的目标是实现「易读易写」</description>
      <category>基础知识</category>
      <content:encoded><![CDATA[<h1> Markdown 语法基础</h1>
<p><a href="https://markdown.com.cn/" target="_blank" rel="noopener noreferrer">Markdown官方教程</a><br>
编辑器推荐：<a href="https://www.typora.io/" target="_blank" rel="noopener noreferrer">Typora</a></p>
<h2> 概述</h2>
<p>Markdown 是一种可以使用普通文本编辑器编写的 <strong>标记语言</strong>，通过简单的标记语法，它可以使普通文本内容具有一定的格式。<br>
Markdown 的目标是实现「易读易写」</p>
<h2> 行内 HTML</h2>
<p>不在 Markdown 涵盖范围之外的标签，都可以直接在文件里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。</p>
<p>举例来说，在 Markdown 文件里加上一段 HTML 表格:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 换行</h2>
<p>想要插入 <code>&lt;br /&gt;</code> 标签或者换行的话，在行尾加上两个以上的空格 () 然后按 Enter</p>
<h2> 标题</h2>
<p>在行首插入 1 到 6 个 <code>#</code> ，对应到标题 1 到 6 阶</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 块引言</h2>
<p>Markdown 使用 email 形式的块引言<br>
在每行的最前面加上<code>&gt;</code><br>
或只在整个段落的第一行最前面加上<code>&gt;</code><br>
块引言可以有阶层 (例如: 引言内的引言)<br>
引言的块内也可以使用其他的 Markdown 语法，包括标题、列表、代码块等</p>
<p>演示：</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>效果：</p>
<blockquote>
<h2> This is a header.</h2>
<ol>
<li>This is the first list item.</li>
<li>This is the second list item.</li>
</ol>
<p>Here's some example code:</p>

</blockquote>
<h2> 列表</h2>
<p>无序列表使用减号作为列表标记(也可使用星号、加号):</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ul>
<p>有序列表则使用数字接着一个英文句点:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol>
<li>Bird</li>
<li>McHale</li>
<li>Parish</li>
</ol>
<h2> 代码块</h2>
<p>和代码相关的写作或是标签语言原始码通常会有已经排版好的代码块，通常这些块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 <code>&lt;pre&gt;</code> 和 <code>&lt;code&gt;</code> 标签来把代码块包起来。<br>
如果你想要在代码块里输入用 Markdown 表示的代码库，你可以进行嵌套。(使用多个)</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 代码段</h2>
<p>如果要标记一小段行内代码，你可以用反引号把它包起来 (`)</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>const a = 10</code></p>
<h2> 分隔线</h2>
<p>你可以在一行中用三个或以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号中间插入空白。下面每种写法都可以建立分隔线:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><hr>
<h2> 链接</h2>
<p>Markdown支持行内和参考两种方式，在此仅展示行内方式</p>
<p>在方块括号后面马上接着括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>相对路径链接到同样主机的资源:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 强调与删除</h2>
<p>使用星号 (*) 和底线 (_) 作为标记强调字词的符号<br>
被单个 * 或 _ 包围的字词会被转成用 <code>&lt;em&gt;</code> 标签包围<br>
用两个 * 或 _ 包起来的话，则会被转成 <code>&lt;strong&gt;</code></p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><em>em</em><br>
<strong>strong</strong><br>
删除:<code>~~delete~~</code>  <s>delete</s></p>
<h2> 图片</h2>
<p>Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式: 行内 和 参考。再次仅展示行内方式。</p>
<p>行内图片的语法:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 <code>&lt;img&gt;</code> 标签。</p>
<h2> 自动链接</h2>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><a href="http://example.com/" target="_blank" rel="noopener noreferrer">http://example.com/</a><br>
<a href="http://example.com/" target="_blank" rel="noopener noreferrer">http://example.com/</a></p>
<h2> 转义字符</h2>
<p>使用 <code>\</code> 用于对字符转义</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 表格</h2>
<p>要添加表，请使用三个或多个连字符（---）创建每列的标题，并使用管道（|）分隔每列。您可以选择在表的任一端添加管道。</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table>
<thead>
<tr>
<th>Syntax</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Header</td>
<td>Title</td>
</tr>
<tr>
<td>Paragraph</td>
<td>Text</td>
</tr>
</tbody>
</table>
<p>对齐方式:<br>
居中使用<code>:-:</code>  ，右对齐使用<code>-:	</code>  ，左对齐使用<code>:-</code></p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table>
<thead>
<tr>
<th style="text-align:left">Syntax</th>
<th style="text-align:center">Description</th>
<th style="text-align:right">Test Text</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Header</td>
<td style="text-align:center">Title</td>
<td style="text-align:right">Here's this</td>
</tr>
<tr>
<td style="text-align:left">Paragraph</td>
<td style="text-align:center">Text</td>
<td style="text-align:right">And more</td>
</tr>
</tbody>
</table>
<h2> Emoji</h2>
<p><code>:emoji名称:</code><br>
<code>:smile:</code> 😄<br>
<a href="https://gist.github.com/rxaviers/7360908" target="_blank" rel="noopener noreferrer">Emoji列表</a><br>
<a href="https://theme-hope.vuejs.press/zh/cookbook/markdown/emoji/" target="_blank" rel="noopener noreferrer">Emoji列表分类版</a></p>
]]></content:encoded>
      <enclosure url="https://T4mako.github.io/path/to/img.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>操作系统</title>
      <link>https://T4mako.github.io/code/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html</link>
      <guid>https://T4mako.github.io/code/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html</guid>
      <source url="https://T4mako.github.io/rss.xml">操作系统</source>
      <category>基础知识</category>
    </item>
    <item>
      <title>数据结构</title>
      <link>https://T4mako.github.io/code/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html</link>
      <guid>https://T4mako.github.io/code/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html</guid>
      <source url="https://T4mako.github.io/rss.xml">数据结构</source>
      <category>基础知识</category>
    </item>
    <item>
      <title>正则表达式</title>
      <link>https://T4mako.github.io/code/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</link>
      <guid>https://T4mako.github.io/code/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</guid>
      <source url="https://T4mako.github.io/rss.xml">正则表达式</source>
      <description>正则表达式是含有一些具有特殊意字符的字符序列 正则表达式有三个主要用途： 模式验证: 检测某个字符串是否符合规则，如手机号、身份证号等 匹配读取: 将目标字符串中满足规则的部分 读取 出来，如将整段文本中的邮箱地址读取出来（） 匹配替换: 将目标字符串中满足标准的部分 替换 为其他字符串，如将整段文本中的 &amp;quot;hello&amp;quot; 替换成 &amp;quot;haha&amp;quot; Java 中 String 类用到正则表达式的方法： 方法 描述 String replaceAll(String regex, String replacement) 使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。 String replaceFirst(String regex, String replacement) 使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串 boolean matches(String regex) 告知此字符串是否匹配给定的正则表达式 String[] split(String regex) 根据给定正则表达式的匹配拆分此字符串 String[] split(String regex, int limit) 根据匹配给定的正则表达式来拆分此字符串，最多不超过 limit 个，如果超过了，剩下的全部都放到最后一个元素中</description>
      <category>基础</category>
      <content:encoded><![CDATA[<p>正则表达式是含有一些具有特殊意字符的字符序列</p>
<p>正则表达式有三个主要用途：</p>
<ul>
<li>模式验证: 检测某个字符串是否符合规则，如手机号、身份证号等</li>
<li>匹配读取: 将目标字符串中满足规则的部分 <strong>读取</strong> 出来，如将整段文本中的邮箱地址读取出来（）</li>
<li>匹配替换: 将目标字符串中满足标准的部分 <strong>替换</strong> 为其他字符串，如将整段文本中的 "hello" 替换成 "haha"</li>
</ul>
<p>Java 中 String 类用到正则表达式的方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>String replaceAll(String regex, String replacement)</td>
<td>使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。</td>
</tr>
<tr>
<td>String replaceFirst(String regex, String replacement)</td>
<td>使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串</td>
</tr>
<tr>
<td>boolean matches(String regex)</td>
<td>告知此字符串是否匹配给定的正则表达式</td>
</tr>
<tr>
<td>String[] split(String regex)</td>
<td>根据给定正则表达式的匹配拆分此字符串</td>
</tr>
<tr>
<td>String[] split(String regex, int limit)</td>
<td>根据匹配给定的正则表达式来拆分此字符串，最多不超过 limit 个，如果超过了，剩下的全部都放到最后一个元素中</td>
</tr>
</tbody>
</table>
<p>Java 中 StringTokenizer 类用到正则表达式方法</p>
<ul>
<li><code>StringTokenizer(String str,String delim)</code>：为字符串 str 构造一个 tokenizer 对象，分隔标记为 delim 中的字符</li>
</ul>
<p>Java 中 Pattern 类 Matcher 类中用到正则表达式的方法</p>
<ul>
<li><code>Pattern.compile(regex);</code></li>
</ul>
<p>正则表达式的使用三步骤：</p>
<ul>
<li>定义正则表达式的对象</li>
<li>定义带校验字符串</li>
<li>校验</li>
</ul>
<h2> 1、元字符</h2>
<p>在正则表达式中被赋予特殊含义的字符，不能被直接当做普通字符使用。<br>
如果要匹配元字符本身，需要对元字符进行转义，转义的方式是在元字符前面加上 <code>\</code> 如：<code>\^</code></p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.</code></td>
<td>任何一个字符，除换行符外</td>
</tr>
<tr>
<td><code>\w</code></td>
<td>匹配字母或数字或下划线等价于 [a-zA-Z0-9_]</td>
</tr>
<tr>
<td><code>\W</code></td>
<td>匹配任何非单词字符。等价于 [^A-Za-z0-9_]</td>
</tr>
<tr>
<td><code>\d</code></td>
<td>匹配数字。等价于 [0-9]。</td>
</tr>
<tr>
<td><code>\D</code></td>
<td>匹配一个非数字字符。等价于 [^0-9]</td>
</tr>
<tr>
<td><code>\s</code></td>
<td>匹配任意空白符，包括空格、制表符、换页符等等。等价于 [\f\n\r\t\v]。</td>
</tr>
<tr>
<td><code>\S</code></td>
<td>匹配任何非空白字符。等价于 [^\f\n\r\t\v]。</td>
</tr>
<tr>
<td><code>\p{Lower}</code></td>
<td>小写字母[a-z]</td>
</tr>
<tr>
<td><code>\p{Upper}</code></td>
<td>大写字母[A-Z]</td>
</tr>
<tr>
<td><code>\p{ASCII}</code></td>
<td>ASCII 字符</td>
</tr>
<tr>
<td><code>\p{Alpha}</code></td>
<td>字母</td>
</tr>
<tr>
<td><code>\p{Digit}</code></td>
<td>[0-9]</td>
</tr>
<tr>
<td><code>\p{Alnum}</code></td>
<td>字母或数字</td>
</tr>
<tr>
<td><code>\p{Punct}</code></td>
<td>标点符号</td>
</tr>
<tr>
<td><code>\p{Blank}</code></td>
<td>空格或制表符[\t]</td>
</tr>
<tr>
<td><code>\p{Cntrl}</code></td>
<td>控制字符[\x00-\x1F\x7F]</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>匹配单词的开始或结束</td>
</tr>
<tr>
<td><code>^</code></td>
<td>匹配字符串的开始，但在 [] 中使用表示取反</td>
</tr>
<tr>
<td><code>$</code></td>
<td>匹配字符串的结束</td>
</tr>
</tbody>
</table>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>上述元字符在 java 表达式中的写法除 <code>.</code> 为 <code>.</code>，其余都是在原本的字符前加一个「\」，如 <code>\\w</code></p>
</div>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2、字符集合</h2>
<table>
<thead>
<tr>
<th>语法格式</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>[abc]</td>
<td>包含 abc 中的任何一个字符</td>
</tr>
<tr>
<td>[^abc]</td>
<td>包含除了 abc 中的任何一个字符</td>
</tr>
<tr>
<td>[a-zA-Z]</td>
<td>包含任何英文字母</td>
</tr>
<tr>
<td>[a-d]</td>
<td>包含 a-d 任何一个字符</td>
</tr>
<tr>
<td>[a-d[m-p]]</td>
<td>包含 a-d 或 m-p 中任何字母（并）</td>
</tr>
<tr>
<td>[a-z&amp;&amp;[def]]</td>
<td>包含 def 中的任何一个（交）</td>
</tr>
<tr>
<td>[a-f&amp;&amp;[^bc]]</td>
<td>包含 adef 中任何一个</td>
</tr>
</tbody>
</table>
<h2> 3、限定符</h2>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>X*</code></td>
<td>X 出现零次或多次</td>
</tr>
<tr>
<td><code>X+</code></td>
<td>X 出现一次或多次</td>
</tr>
<tr>
<td><code>X?</code></td>
<td>X 出现零次或一次</td>
</tr>
<tr>
<td><code>X{n}</code></td>
<td>X 出现 n 次</td>
</tr>
<tr>
<td><code>X{n,}</code></td>
<td>X 出现 n 次或多次</td>
</tr>
<tr>
<td><code>X{n,m}</code></td>
<td>X 出现 n 到 m 次</td>
</tr>
<tr>
<td><code>XY</code></td>
<td>X 的后缀是 Y</td>
</tr>
<tr>
<td><code>X|Y</code></td>
<td>X 或 Y</td>
</tr>
</tbody>
</table>
<h2> 4、创建正则表达式</h2>

<h2> 5、正则表达式案例</h2>
<p>校验字符串中是否包含 o 字母</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>匹配读取</p>
<p>读取字符串中的所有 o（全局匹配，对应所有匹配到的字符）</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>匹配替换</p>
<p>将字符串中的第一个 o 替换成 '@'</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>全文查找</p>
<p>如果不使用 g 对正则表达式对象进行修饰，则使用正则表达式进行查找时，仅返回第一个匹配；使用 g 后，返回所有匹配。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对比代码：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>忽略大小写</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对比代码：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>多行查找（m）</p>
<p>不使用多行查找模式，目标字符串中不管有没有换行符都会被当作一行。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对比代码：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 6、常用正则表达式</h2>
<table>
<thead>
<tr>
<th>需求</th>
<th>正则表达式</th>
</tr>
</thead>
<tbody>
<tr>
<td>数字</td>
<td><code>-?[0-9]\\d*</code></td>
</tr>
<tr>
<td>浮点数</td>
<td><code>-?[0-9][0-9]*[.][0-9]+</code></td>
</tr>
<tr>
<td>年份</td>
<td><code>[0-9][1-9]{3}</code></td>
</tr>
<tr>
<td>月份</td>
<td><code>((0?[1-9]|1[012]))</code></td>
</tr>
<tr>
<td>日期</td>
<td><code>(0?[1-9][^0-9]|([12][0-9])|(3[01]?))</code></td>
</tr>
<tr>
<td>身份证号</td>
<td><code>[1-9][0-9]{16}[a-zA-Z0-9]{1}</code></td>
</tr>
<tr>
<td>电子邮箱</td>
<td><code>\\w+@\\w+\\.[a-z]+(\\.[a-z]+)?</code></td>
</tr>
</tbody>
</table>
]]></content:encoded>
    </item>
    <item>
      <title>计算机组成原理</title>
      <link>https://T4mako.github.io/code/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.html</link>
      <guid>https://T4mako.github.io/code/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.html</guid>
      <source url="https://T4mako.github.io/rss.xml">计算机组成原理</source>
      <category>基础知识</category>
    </item>
    <item>
      <title>计算机网络</title>
      <link>https://T4mako.github.io/code/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html</link>
      <guid>https://T4mako.github.io/code/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html</guid>
      <source url="https://T4mako.github.io/rss.xml">计算机网络</source>
      <category>基础知识</category>
    </item>
    <item>
      <title>设计模式</title>
      <link>https://T4mako.github.io/code/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</link>
      <guid>https://T4mako.github.io/code/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</guid>
      <source url="https://T4mako.github.io/rss.xml">设计模式</source>
      <description>设计模式（pattern）是针对某一类问题的最佳解决方案，且已被成功应用与许多系统的设计中 设计模式的分类： 「行为型模式」：涉及怎样合理设计对象之间的交互通信，怎样合理地为对象分配职责，使设计有弹性、易维护、易复用 策略模式 状态模式 命令模式 中介者模式 责任链模式 模板方法模式 观察者模式 访问者模式 「结构型模式」：涉及如何组合类的对象，以形成更大的对象与结构 装饰模式 组合模式 适配器模式 外观模式 代理模式 享元模式 桥接模式 「创建型模式」：涉及对象的实例化，避免用户直接使用 new 创建对象 工厂方法模式 抽象工厂模式 生成器模式 原型模式 单件模式</description>
      <category>基础知识</category>
      <content:encoded><![CDATA[<p>设计模式（pattern）是针对某一类问题的最佳解决方案，且已被成功应用与许多系统的设计中</p>
<p>设计模式的分类：</p>
<ul>
<li>「行为型模式」：涉及怎样合理设计对象之间的交互通信，怎样合理地为对象分配职责，使设计有弹性、易维护、易复用
<ul>
<li>策略模式</li>
<li>状态模式</li>
<li>命令模式</li>
<li>中介者模式</li>
<li>责任链模式</li>
<li>模板方法模式</li>
<li>观察者模式</li>
<li>访问者模式</li>
</ul>
</li>
<li>「结构型模式」：涉及如何组合类的对象，以形成更大的对象与结构
<ul>
<li>装饰模式</li>
<li>组合模式</li>
<li>适配器模式</li>
<li>外观模式</li>
<li>代理模式</li>
<li>享元模式</li>
<li>桥接模式</li>
</ul>
</li>
<li>「创建型模式」：涉及对象的实例化，避免用户直接使用 new 创建对象
<ul>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
<li>生成器模式</li>
<li>原型模式</li>
<li>单件模式</li>
</ul>
</li>
</ul>
<h2> 单例模式（Singleton Pattern）</h2>
<p>单例模式是最常用的设计模式之一。它可以确保在整个应用程序中，某个类只有一个实例存在，并提供一种访问这个实例的全局访问点。<br>
单例模式在需要限制某些类的实例数量时非常有用。它通常用于需要全局访问的资源，如配置文件、日志记录器、数据库连接等。</p>
<p>应用场景：日志记录器、数据库连接、系统配置</p>
<table>
<thead>
<tr>
<th>实现方式</th>
<th>是否线程安全</th>
<th>是否延迟加载（只有需要时才创建单例对象）</th>
</tr>
</thead>
<tbody>
<tr>
<td>懒汉式</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>饿汉式</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>静态内部类</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>双重检查锁</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>枚举方式（最简便）</td>
<td>是</td>
<td>否</td>
</tr>
</tbody>
</table>
<h3> 懒汉式单例模式</h3>
<p>懒汉式不是线程安全的，需要通过加锁等方式来保证线程安全</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 饿汉式单例模式</h3>
<p>饿汉式在类加载时就创建了单例对象，所以不存在线程安全问题。<br>
不过，这种方式可能会导致不必要的资源浪费，因为单例对象的创建可能在应用程序启动时就完成了，而有些应用场景中可能并不需要使用单例对象。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 静态内部类方式</h3>
<p>SingletonHolder 是一个静态内部类，它包含一个静态的 INSTANCE 成员变量，用于存储单例对象。<br>
在第一次调用 getInstance 方法时，静态内部类会被加载，从而创建单例对象。这种方式既兼顾了线程安全又兼顾了延迟加载的需求。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 双重检查锁（线程安全的懒汉式）</h3>
<p>它可以在保证线程安全的同时实现延迟加载</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 枚举方式</h3>
<p>使用枚举实现单例模式的好处是，可以避免反射和序列化攻击。因为枚举类型的构造函数是私有的，所以无法使用反射来创建实例；而且枚举类型的实例在序列化和反序列化时会自动处理好，所以也无法通过序列化和反序列化来破坏单例。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 工厂方法模式</h2>
<p>工厂方法模式（Factory Method、虚拟构造）：定义一个用于创建对象的接口，让子类决定实例化哪一个类<br>
工厂方法模式使一个类的实例化延迟到子类</p>
<p>在 Java 中，工厂模式广泛应用于各种框架和类库中，例如 JDBC 中的 DataSource 工厂、Spring 框架中的 Bean 工厂、MyBatis 框架中的 SqlSessionFactory 等等。</p>
<p>工厂方法模式的四个角色：</p>
<ul>
<li>抽象产品（Product）：抽象类或接口，定义具体产品必须实现的方法</li>
<li>具体产品（ProductImpl）：实现 Product 的类</li>
<li>工厂/构造者（Factory/Creator）：抽象类或接口，构造者负责定义一个被称为工厂方法的抽象方法，返回 ConcreteProduct 类的实例</li>
<li>实现工厂/具体构造者（FactoryImpl/CreatorImpl）：实现 Factory 的类</li>
</ul>
<p>UML 图如下：</p>
<div class="hint-container warning">
<p class="hint-container-title">注意</p>
<p>注意：接口名、抽象类名为斜体</p>
</div>
<p>案例：使用各种颜色笔芯的圆珠笔</p>
<p>抽象产品（Product）:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>具体产品（ProductImpl）:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>工厂（Factory）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实现工厂（FactoryImpl）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在使用工厂模式时，只和 Product、Creator 和 ConcreteCreator 打交道，用户只需要了解抽象产品有哪些方法即可，不需要知道有哪些具体产品</p>
<ul>
<li>创建 Product 引用</li>
<li>创建 Factory 引用</li>
<li>将 FactoryImpl 对象赋给 Factory 的引用</li>
<li>调用 FactoryImpl 对象重写的工厂方法返回 ProductImpl 对象赋值给 Product 的引用</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其他参考：<a href="https://www.runoob.com/design-pattern/factory-pattern.html" target="_blank" rel="noopener noreferrer">https://www.runoob.com/design-pattern/factory-pattern.html</a></p>
<h2> 抽象工厂模式</h2>
<p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂<br>
该超级工厂又称为其他工厂的工厂。它提供了一种创建对象的最佳方式</p>
<p>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p>
<p>抽象工厂模式提供了一种创建一系列相关或相互依赖对象的接口，而无需指定具体实现类。通过使用抽象工厂模式，可以将客户端与具体产品的创建过程解耦，使得客户端可以通过工厂接口来创建一族产品。</p>
<p>抽象工厂模式包含以下几个核心角色：</p>
<ul>
<li>抽象产品（Abstract Product）：定义了一组产品对象的共同接口或抽象类，描述了产品对象的公共方法。</li>
<li>具体产品（Concrete Product）：实现了抽象产品接口，定义了具体产品的特定行为和属性。</li>
<li>抽象工厂（Abstract Factory）：声明了一组用于创建产品对象的方法，每个方法对应一种产品类型。抽象工厂可以是接口或抽象类。</li>
<li>具体工厂（Concrete Factory）：实现了抽象工厂接口，负责创建具体产品对象的实例。</li>
</ul>
<p>抽象工厂模式通常涉及一族相关的产品，每个具体工厂类负责创建该族中的具体产品。客户端通过使用抽象工厂接口来创建产品对象，而不需要直接使用具体产品的实现类。</p>
<p>案例：创建生产带有颜色与形状的工厂</p>
<ol>
<li>抽象产品 Shape 和 Color 接口：</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2">
<li>Shape 与 Color 的具体产品：</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3">
<li>为 Color 和 Shape 对象创建抽象类 AbstractFactory 来获取工厂<br>
AbstractFactory 抽象工厂声明了多个创建产品对象的方法，每个方法对应一种产品类型</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4">
<li>创建扩展了 AbstractFactory 的具体工厂 ShapeFactory、ColorFactory，基于给定的信息生成实体类的对象</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="5">
<li>创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂。</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="6">
<li>使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象。</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>参考：<a href="https://www.runoob.com/design-pattern/abstract-factory-pattern.html" target="_blank" rel="noopener noreferrer">https://www.runoob.com/design-pattern/abstract-factory-pattern.html</a></p>
<h2> 原型模式</h2>
<p>原型模式，即 Prototype，用于创建重复的对象，同时又能保证性能。</p>
<ul>
<li>浅拷贝实现 Cloneable，重写 clone() 方法 或 手动添加 copy() 方法</li>
<li>深拷贝是通过实现 Serializable 读取二进制流或第三方 JSON 相关包实现</li>
</ul>
<p>通过实现 Cloneable 接口实现浅拷贝</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过编写 copy() 方法实现浅拷贝</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过 Serializable 实现深拷贝</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>面向对象设计基本原则（UML）</title>
      <link>https://T4mako.github.io/code/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99.html</link>
      <guid>https://T4mako.github.io/code/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99.html</guid>
      <source url="https://T4mako.github.io/rss.xml">面向对象设计基本原则（UML）</source>
      <description>UML 类图简介 UML（Unified Modeling Language） 类图（Class Diagram）属于结构图（静态图），常用于被描述一个系统的静态结构。 UML 类图包含 类、接口、泛化（继承）、实现、组合、聚合、关联、依赖关系 1. 类的 UML 图 类图分为三层结构： 第一层：名字层，如果类的名字是斜体，则这个类是抽象类 第二层：变量层（属性层），格式： 变量名:类型 第三层：方法层，格式：方法名(参数列表)</description>
      <category>基础知识</category>
      <content:encoded><![CDATA[<h2> UML 类图简介</h2>
<p>UML（Unified Modeling Language） 类图（Class Diagram）属于结构图（静态图），常用于被描述一个系统的静态结构。</p>
<p>UML 类图包含 类、接口、泛化（继承）、实现、组合、聚合、关联、依赖关系</p>
<h3> 1. 类的 UML 图</h3>
<p>类图分为三层结构：</p>
<ul>
<li>第一层：名字层，如果类的名字是斜体，则这个类是抽象类</li>
<li>第二层：变量层（属性层），格式： <code>变量名:类型</code></li>
<li>第三层：方法层，格式：<code>方法名(参数列表)</code></li>
</ul>
<p>四种权限修饰符：public、protected、缺省（友好）、private<br>
对应：+、#、、-</p>
<h3> 2. 接口的 UML 图</h3>
<p>接口的 UML 图分为三层结构：</p>
<ul>
<li>第一层：名字层，接口名字必须使用斜体，且上方使用 <code>&lt;&lt;interface&gt;&gt;</code> 修饰（分为两行）</li>
<li>第二层：常量层，列出接口的常量以及类型，<code>常量名:类型</code>，常量都是 public，所以使用 +</li>
<li>第三层：方法层（操作层），列出接口中的方法及返回类型，<code>方法名(参数列表):类型</code>，方法都是 public ，所以使用 +</li>
</ul>
<div class="hint-container warning">
<p class="hint-container-title">注意</p>
<p>注意：接口名、抽象类名为斜体</p>
</div>
<h3> 3. 泛化（继承）关系（Generalization/extends）</h3>
<p>UML 中的泛化关系（Generalization）就是值指类或接口的继承关系<br>
继承用「实线空心箭头」表示，由子类指向父类。</p>
<h3> 4、实现关系（implements）</h3>
<p>指的是一个 class 类实现 interface 接口（可以是多个）的功能<br>
实现使用「虚线空心箭头」表示，由实现类指向接口</p>
<h3> 5、组合关系（Composition）</h3>
<ul>
<li>组合是关联关系的一种特例，它体现的是一种 contains-a 的关系，这种关系比聚合更强，也称为强聚合</li>
<li>它同样体现整体与部分间的关系，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束</li>
</ul>
<p>组合使用的是「实线实心菱形」表示，菱形端为整体类，另一端为部分类</p>
<h3> 6、聚合关系（Aggregation）</h3>
<ul>
<li>聚合也是关联关系的一种特例，它体现的是整体与部分、拥有的关系，即 has-a 的关系</li>
<li>此时整体与部分之间是可分离的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享</li>
</ul>
<p>聚合使用的是「实线空心菱形」表示，菱形端为整体类，另一端为部分类</p>
<h3> 7、关联关系（Association）</h3>
<p>如果 A 类中的成员变量有用 B 类（接口）来声明变量，则 A 与 B 为关联关系，称 A 关联于 B<br>
如果 A 关联 B，那么 UML 通过一个「实线」连接 A 和 B 的 UML 图</p>
<p>关联使用的是「实线普通箭头」，引用类（A）指向被引用类（B）</p>
<h3> 8. 依赖关系（Dependency）</h3>
<p>如果 A 类中某个方法的参数用 B 类（接口）来声明的变量或某个方法返回的数据类型是 B 类型的，那么 A 和 B 的关系是依赖关系，称 A 依赖于 B</p>
<p>关联使用的是「虚线普通箭头」，引用类（A）指向被依赖类（B）</p>
<h3> 9. 注释</h3>
<p>UML 使用注释（Annotation）为类图提供附加的说明，UML 在一个带卷角的长方形中显式给出注释，并使用虚线将这个长方形和它注释的实体连接起来</p>
<h3> 10. 设计类的原则</h3>
<h4> 「开-闭」原则</h4>
<h4> 「多用组合、少用继承」原则</h4>
<h4> 「高内聚-低耦合」原则</h4>
<ul>
<li>高内聚：类中的方法是一组相关行为</li>
<li>低耦合：尽量不让一个类含有太多其他类的实例的引用</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Elasticsearch</title>
      <link>https://T4mako.github.io/code/%E6%95%B0%E6%8D%AE%E5%BA%93/Elasticsearch.html</link>
      <guid>https://T4mako.github.io/code/%E6%95%B0%E6%8D%AE%E5%BA%93/Elasticsearch.html</guid>
      <source url="https://T4mako.github.io/rss.xml">Elasticsearch</source>
      <description>elasticsearch分布式搜索引擎</description>
      <content:encoded><![CDATA[<p>elasticsearch分布式搜索引擎</p>
<!-- more -->
<h2> 1、初识elasticsearch</h2>
<h3> 1.1、了解ES</h3>
<h4> 1.1.1、elasticsearch的作用</h4>
<p>elasticsearch是一款非常强大的<strong>开源搜索引擎</strong>，具备非常多强大功能，可以帮助我们<strong>从海量数据中快速找到需要的内容</strong>，可以用来实现搜索、日志统计、分析、系统监控等功能</p>
<h4> 1.1.2、ELK技术栈</h4>
<p>elasticsearch结合kibana、Logstash、Beats，也就是<strong>elastic stack（ELK）</strong>。被广泛应用在日志数据分析、实时监控等领域</p>
<p>而elasticsearch是elastic stack的核心，负责存储、搜索、分析数据。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230329134229.png" alt="" loading="lazy"></p>
<h4> 1.1.3、elasticsearch的发展</h4>
<p>elasticsearch底层是基于<strong>lucene</strong>来实现的。</p>
<p>**<a href="https://lucene.apache.org/" target="_blank" rel="noopener noreferrer">Lucene</a>**是一个Java语言的搜索引擎类库，是Apache公司的顶级项目，由DougCutting于1999年研发。</p>
<p>Lucene的优势：易扩展，高性能（基于倒排索引）<br>
Lucene的缺点：只限于Java语言开发，学习曲线陡峭，不支持水平扩展</p>
<p>**<a href="https://www.elastic.co/cn/" target="_blank" rel="noopener noreferrer">elasticsearch</a>**的发展历史：<br>
2004年Shay Banon基于Lucene开发了Compass<br>
2010年Shay Banon 重写了Compass，取名为Elasticsearch。</p>
<h3> 1.2、倒排索引</h3>
<p>倒排索引的概念是基于MySQL这样的正向索引而言的。</p>
<h4> 1.2.1、正向索引</h4>
<p>如果是根据<strong>id查询</strong>，那么直接走索引，查询<strong>速度非常快</strong></p>
<p>但如果是基于title做<strong>模糊查询</strong>，只能是逐行扫描数据，流程如下：<br>
1）用户搜索数据，条件是title符合<code>"%手机%"</code><br>
2）逐行获取数据，比如id为1的数据<br>
3）判断数据中的title是否符合用户搜索条件<br>
4）如果符合则放入结果集，不符合则丢弃。回到步骤1</p>
<p><strong>逐行扫描</strong>，也就是全表扫描，随着数据量增加，其查询效率也会越来越低。当数据量达到数百万时，就是一场灾难。</p>
<h4> 1.2.2、倒排索引</h4>
<p>倒排索引中两个非常重要的概念：</p>
<ul>
<li><strong>文档（<code>Document</code>）</strong>：用来搜索的数据，其中的每一条数据就是一个文档。例如一个网页、一个商品信息</li>
<li><strong>词条（<code>Term</code>）</strong>：对文档数据或用户搜索数据，利用某种算法分词，得到的具备含义的词语就是词条。例如：我是中国人，就可以分为：我、是、中国人、中国、国人这样的几个词条</li>
</ul>
<p><strong>创建倒排索引</strong>是对正向索引的一种特殊处理，流程如下：</p>
<ul>
<li>将每一个文档的数据利用算法分词，得到一个个词条</li>
<li>创建表，每行数据包括词条、词条所在文档id、位置等信息</li>
<li>因为词条唯一性，可以给词条创建索引，例如hash表结构索引</li>
</ul>
<p>如图：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230329140151.png" alt="" loading="lazy"></p>
<p>举例：倒排索引的<strong>搜索流程</strong>如下（以搜索"华为手机"为例）：</p>
<p>1）用户输入条件<code>"华为手机"</code>进行搜索。<br>
2）对用户输入内容<strong>分词</strong>，得到词条：<code>华为</code>、<code>手机</code>。<br>
3）拿着词条在倒排索引中查找，可以得到包含词条的文档id：1、2、3。<br>
4）拿着文档id到正向索引中查找具体文档。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230329140231.png" alt="" loading="lazy"></p>
<h4> 1.2.3、正向和倒排</h4>
<ul>
<li>
<p><strong>正向索引</strong>是最传统的，根据<strong>id索引</strong>的方式。但根据词条查询时，必须<strong>先逐条获取每个文档</strong>，然后判断文档中是否包含所需要的词条，是<strong>根据文档找词条</strong>的过程。</p>
</li>
<li>
<p><strong>倒排索引</strong>则相反，是先找到用户要搜索的词条，根据词条得到保护词条的文档的id，然后根据id获取文档。是<strong>根据词条找文档</strong>的过程。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>正向索引</th>
<th><strong>倒排索引</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>优点</strong></td>
<td>可以给多个字段创建索引<br>根据索引字段搜索、排序速度非常快</td>
<td>根据词条搜索、模糊搜索时，速度非常快</td>
</tr>
<tr>
<td><strong>缺点</strong></td>
<td>根据非索引字段，或者索引字段中的部分词条查找时，只能全表扫描。</td>
<td>只能给词条创建索引，而不是字段 <br>无法根据字段做排序</td>
</tr>
</tbody>
</table>
<h3> 1.3、es中的概念</h3>
<h4> 1.3.1、文档和字段</h4>
<p>elasticserch是<strong>面向文档</strong>存储的，可以是数据库的一条商品数据，一个订单信息。<br>
文档数据会被序列化为<strong>json格式</strong>后存储在elasticsearch中</p>
<p>而Json文档中往往包含很多的<strong>字段（Field）</strong>，类似于数据库中的列。</p>
<h4> 1.3.2、索引和映射</h4>
<p><strong>索引（Index）</strong>，就是相同类型的文档的集合。</p>
<p>例如：<br>
所有用户文档，就可以组织在一起，称为用户的索引；<br>
所有商品的文档，可以组织在一起，称为商品的索引；<br>
所有订单的文档，可以组织在一起，称为订单的索引；</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230329141204.png" alt="" loading="lazy"></p>
<p>因此，我们可以把<strong>索引</strong>当做是数据库中的<strong>表</strong>。</p>
<p>数据库的表会有约束信息，用来定义表的结构、字段的名称、类型等信息。因此，索引库中就有<strong>映射（mapping）</strong>，是索引中文档的字段约束信息，<strong>类似表的结构约束</strong>。</p>
<h4> 1.3.3、mysql与elasticsearch</h4>
<table>
<thead>
<tr>
<th><strong>MySQL</strong></th>
<th><strong>Elasticsearch</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Table</td>
<td>Index</td>
<td>索引(index)，就是文档的集合，类似数据库的表(table)</td>
</tr>
<tr>
<td>Row</td>
<td>Document</td>
<td>文档（Document），就是一条条的数据，类似数据库中的行（Row），文档都是JSON格式</td>
</tr>
<tr>
<td>Column</td>
<td>Field</td>
<td>字段（Field），就是JSON文档中的字段，类似数据库中的列（Column）</td>
</tr>
<tr>
<td>Schema</td>
<td>Mapping</td>
<td>Mapping（映射）是索引中文档的约束，例如字段类型约束。类似数据库的表结构（Schema）</td>
</tr>
<tr>
<td>SQL</td>
<td>DSL</td>
<td>DSL是elasticsearch提供的JSON风格的请求语句，用来操作elasticsearch，实现CRUD</td>
</tr>
</tbody>
</table>
<p>Mysql：擅长事务类型操作，可以确保数据的安全和一致性<br>
Elasticsearch：擅长海量数据的搜索、分析、计算</p>
<p>因此在企业中，往往是两者结合使用：<br>
对安全性要求较高的写操作，使用mysql实现<br>
对查询性能要求较高的搜索需求，使用elasticsearch实现<br>
两者再基于某种方式，实现数据的同步，保证一致性</p>
<h2> 2、安装、部署es、kibana</h2>
<h3> 2.1.创建网络</h3>
<p>因为我们还需要部署<strong>kibana容器</strong>，因此需要让es和kibana容器互联。这里先<strong>创建一个网络</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2.2、加载镜像</h3>
<p>采用elasticsearch的7.12.1版本的镜像，这个镜像体积非常大，接近1G。不建议大家自己pull</p>
<p>将课前资料中的es.tar，kibana.tar上传到虚拟机中，然后运行命令加载即可</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.3、部署ES</h3>
<p>运行docker命令，部署单点es：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>命令解释：</p>
<ul>
<li><code>-e "cluster.name=es-docker-cluster"</code>：设置集群名称</li>
<li><code>-e "http.host=0.0.0.0"</code>：监听的地址，可以外网访问</li>
<li><code>-e "ES_JAVA_OPTS=-Xms512m -Xmx512m"</code>：内存大小</li>
<li><code>-e "discovery.type=single-node"</code>：非集群模式</li>
<li><code>-v es-data:/usr/share/elasticsearch/data</code>：挂载逻辑卷，绑定es的数据目录</li>
<li><code>-v es-logs:/usr/share/elasticsearch/logs</code>：挂载逻辑卷，绑定es的日志目录</li>
<li><code>-v es-plugins:/usr/share/elasticsearch/plugins</code>：挂载逻辑卷，绑定es的插件目录</li>
<li><code>--privileged</code>：授予逻辑卷访问权</li>
<li><code>--network es-net</code> ：加入一个名为es-net的网络中</li>
<li><code>-p 9200:9200</code>：端口映射配置</li>
</ul>
<p>在浏览器中输入：<a href="http://192.168.80.130:9200" target="_blank" rel="noopener noreferrer">http://192.168.80.130:9200</a> 即可看到elasticsearch的响应结果：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230329151453.png" alt="" loading="lazy"></p>
<h3> 2.4、部署kibana</h3>
<p>kibana可以给我们提供一个elasticsearch的可视化界面，便于我们学习。</p>
<h4> 2.4.1、部署</h4>
<p>运行docker命令，部署kibana</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><code>--network es-net</code> ：加入一个名为es-net的网络中，与elasticsearch在同一个网络中</li>
<li><code>-e ELASTICSEARCH_HOSTS=http://es:9200"</code>：设置elasticsearch的地址，因为kibana已经与elasticsearch在一个网络，因此可以用容器名直接访问elasticsearch</li>
<li><code>-p 5601:5601</code>：端口映射配置</li>
</ul>
<p>kibana启动一般比较慢，需要多等待一会，可以通过命令：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>查看运行日志，当查看到下面的日志，说明成功：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230329151658886.png" alt="image-20230329151658886" loading="lazy"></p>
<p>此时，在浏览器输入地址访问：<a href="http://192.168.80.130:5601" target="_blank" rel="noopener noreferrer">http://192.168.80.130:5601</a>，即可看到结果</p>
<h4> 2.4.2、DevTools</h4>
<p>kibana中提供了一个DevTools界面，这个界面中可以编写DSL来操作elasticsearch。并且对DSL语句有自动补全功能。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230330194248676.png" alt="image-20230330194248676" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230329151743.png" alt="" loading="lazy"></p>
<div class="language-dsl line-numbers-mode" data-ext="dsl"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3、安装IK分词器</h2>
<p>es在创建倒排索引时需要对文档分词，在搜索时，需要对用户输入内容分词。但默认的分词规则对中文处理并不友好。</p>
<p>因此，一般会使用IK分词器</p>
<h3> 3.1、在线安装ik插件（较慢）</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.2、离线安装ik插件（推荐）</h3>
<h4> 1）查看数据卷目录</h4>
<p>安装插件需要知道elasticsearch的plugins目录位置，而我们用了数据卷挂载，因此需要查看elasticsearch的数据卷目录，通过下面命令查看:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>显示结果：</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明plugins目录被挂载到了：<code>/var/lib/docker/volumes/es-plugins/_data </code>这个目录中。</p>
<h4> 2）解压缩分词器安装包</h4>
<p>把课前资料中的ik分词器解压缩，重命名为ik</p>
<h4> 3）上传到es容器的插件数据卷中</h4>
<p>也就是<code>/var/lib/docker/volumes/es-plugins/_data </code>：</p>
<h4> 4）重启容器</h4>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 5）测试</h4>
<p>IK分词器包含两种模式：<br>
<strong><code>ik_smart</code>：智能切分，组粒度<br>
<code>ik_max_word</code>：最细切分，细粒度</strong></p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.3、扩展、停用词词典</h3>
<p>随着互联网的发展，“造词运动”也越发的频繁。出现了很多新的词语，在原有的词汇列表中并不存在。<br>
所以我们的<strong>词汇</strong>字典也需要<strong>不断的更新</strong>，IK分词器提供了<strong>扩展词汇</strong>的功能。</p>
<p>1）打开IK分词器config目录：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230329153523.png" alt="" loading="lazy"></p>
<p>2）在IKAnalyzer.cfg.xml配置文件内容添加：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3）<strong>新建ext.dic，stopword.dic</strong>可以参考config目录下复制一个配置文件进行修改</p>
<div class="language-properties line-numbers-mode" data-ext="properties"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>4）重启elasticsearch</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>日志中已经成功加载ext.dic配置文件</p>
<p>5）测试效果：</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>注意当前文件的编码必须是 <strong>UTF-8</strong> 格式，严禁使用Windows记事本编辑</p>
</blockquote>
<h2> 4、索引库操作</h2>
<p><strong>索引库</strong>就类似<strong>数据库表</strong>，<strong>mapping映射</strong>就类似<strong>表的结构</strong>。<br>
我们要向es中存储数据，必须先创建“库”和“表”。</p>
<h3> 4.1、mapping属性</h3>
<p>mapping是对索引库中文档的约束，常见的mapping属性包括：</p>
<ul>
<li><strong>type</strong>：字段<strong>数据类型</strong>，常见的简单类型有：
<ul>
<li><strong>字符串</strong>：<br>
<strong>text</strong>（可分词的文本）<br>
<strong>keyword</strong>（不分词，是精确值，例如：品牌、国家、ip地址）</li>
<li><strong>数值</strong>：<br>
<strong>long、integer、short、byte、double、float</strong></li>
<li>布尔：<br>
boolean</li>
<li>日期：<br>
date</li>
<li>对象：<br>
object</li>
</ul>
</li>
<li><strong>index</strong>：是否创建<strong>倒排索引</strong>，默认为true，false：将来不会参与搜索</li>
<li><strong>analyzer</strong>：使用哪种<strong>分词器</strong></li>
<li><strong>properties</strong>：该字段的<strong>子字段</strong></li>
</ul>
<p>例如：</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4.2、创建索引库</h3>
<p>ES中通过<strong>Restful请求操作索引库、文档</strong>。请求内容用DSL语句来表示。创建索引库和mapping的DSL语法如下：</p>
<p>请求方式：PUT<br>
请求路径：/索引库名，可以自定义<br>
请求参数：mapping映射</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4.2、修改索引库</h3>
<p>倒排索引结构虽然不复杂，但是一旦数据结构改变（比如改变了分词器），就需要重新创建倒排索引，这简直是灾难。因此索引库<strong>一旦创建，无法修改mapping</strong>。</p>
<p>虽然无法修改mapping中已有的字段，但是却<strong>允许添加新的字段</strong>到mapping中，因为不会对倒排索引产生影响。</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4.3、查询索引库</h3>
<p><strong>基本语法</strong>：</p>
<ul>
<li>
<p>请求方式：GET</p>
</li>
<li>
<p>请求路径：/索引库名</p>
</li>
<li>
<p>请求参数：无</p>
</li>
</ul>
<p><strong>格式</strong>：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 4.4、总结</h3>
<p>索引库的操作：<br>
创建索引库：PUT /索引库名<br>
查询索引库：GET /索引库名<br>
删除索引库：DELETE /索引库名<br>
添加字段：PUT /索引库名/_mapping</p>
<h2> 5、文档操作</h2>
<h3> 5.1、新增文档</h3>
<p><strong>POST</strong></p>
<p><strong>语法：</strong></p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例：</strong></p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20210720212933362.png" alt="" loading="lazy"></p>
<h3> 5.2、查询文档</h3>
<p>根据rest风格，查询是<strong>GET</strong>，不过查询一般都需要条件，这里我们把文档id带上。</p>
<p><strong>语法：</strong></p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>通过kibana查看数据：</strong></p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 5.3、删除文档</h3>
<p>删除使用<strong>DELETE</strong>请求，同样，需要根据id进行删除：</p>
<p><strong>语法：</strong></p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>示例：</strong></p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5.4、修改文档</h3>
<p>修改有两种方式：</p>
<ul>
<li>全量修改：直接覆盖原来的文档</li>
<li>增量修改：修改文档中的部分字段</li>
</ul>
<h4> 5.4.1、全量修改</h4>
<p>全量修改是覆盖原来的文档，其本质是：</p>
<ul>
<li>根据指定的id删除文档</li>
<li>新增一个相同id的文档</li>
</ul>
<blockquote>
<p><strong>注意</strong>：如果根据id删除时，id不存在，第二步的新增也会<strong>执行</strong>，也就<strong>从修改变成了新增</strong>操作了。</p>
</blockquote>
<p><strong>语法：</strong></p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例：</strong></p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 5.4.2、增量修改</h4>
<p>增量修改是只修改指定id匹配的文档中的部分字段。</p>
<p><strong>语法：</strong></p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例：</strong></p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5.5、总结</h3>
<p>文档操作有哪些？</p>
<ul>
<li json文档="">创建文档：POST /{索引库名}/_doc/文档id  </li>
<li>查询文档：GET /{索引库名}/_doc/文档id</li>
<li>删除文档：DELETE /{索引库名}/_doc/文档id</li>
<li>修改文档：
<ul>
<li json文档="">全量修改：PUT /{索引库名}/_doc/文档id</li>
<li>增量修改：POST /{索引库名}/_update/文档id { "doc": {字段}}</li>
</ul>
</li>
</ul>
<h2> 6、RestAPI</h2>
<p>ES官方提供了各种不同语言的客户端，用来操作ES。这些客户端的本质就是组装DSL语句，通过http请求发送给ES。官方文档地址：<a href="https://www.elastic.co/guide/en/elasticsearch/client/index.html" target="_blank" rel="noopener noreferrer">https://www.elastic.co/guide/en/elasticsearch/client/index.html</a></p>
<p>其中的Java Rest Client又包括两种：</p>
<ul>
<li>Java Low Level Rest Client</li>
<li>Java High Level Rest Client</li>
</ul>
<p>我们学习的是Java HighLevel Rest Client客户端API</p>
<p>利用JavaRestClient实现创建、删除索引库，判断索引是否存在<br>
根据课前资料提供的数据创建索引库，名称为hotel，mapping属性根据数据库结构定义。<br>
基本步骤入下：<br>
1、导入课前资料Demo<br>
2、分析数据结构，定义mapping属性<br>
3、初始化JavaRestClient<br>
4、利用JavaRestClient创建索引库<br>
5、利用JavaRestClient删除索引库<br>
6、利用JavaRestClient判断索引库是否存在</p>
<h3> 6.0、导入、配置Demo工程</h3>
<h4> 6.0.1、导入工程</h4>
<p>首先导入课前资料提供的数据库数据（tb_hotel.sql）</p>
<p>然后导入课前资料提供的项目（hotel-demo）</p>
<h4> 6.0.2、mapping映射分析</h4>
<p>创建索引库，最关键的是mapping映射，而mapping映射要考虑的信息包括：</p>
<ul>
<li>字段名</li>
<li>字段数据类型</li>
<li>是否参与搜索</li>
<li>是否需要分词</li>
<li>如果分词，分词器是什么？</li>
</ul>
<p>其中：</p>
<ul>
<li>字段名、字段数据类型，可以参考数据表结构的名称和类型</li>
<li>是否参与搜索要分析业务来判断，例如图片地址，就无需参与搜索</li>
<li>是否分词呢要看内容，内容如果是一个整体就无需分词，反之则要分词</li>
<li>分词器，我们可以统一使用ik_max_word</li>
</ul>
<p>酒店数据的<strong>索引库结构</strong>:</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>特殊字段说明：<br>
location：地理坐标，里面包含精度、纬度<br>
<strong>all</strong>：一个<strong>组合字段</strong>，其目的是将多字段的值 <strong>利用copy_to合并</strong>，提供给用户搜索（多字段搜索）</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20210720222110126.png" alt="" loading="lazy"></p>
<p>字段拷贝可以使用<strong>copy_to</strong>属性<strong>将当前字段拷贝到指定字段</strong></p>
<h4> 6.0.3、初始化JavaRestClient</h4>
<p>1、导入es的依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2、因为SpringBoot默认的ES版本是7.6.2，所以我们需要覆盖默认的ES版本：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3、初始化RestHighLevelClient：</p>
<p>初始化核心代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注：为了单元测试方便，我们创建一个测试类HotelIndexTest，然后将初始化的代码编写在@BeforeEach方法中：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6.1、创建索引库</h3>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20210720223049408.png" alt="" loading="lazy"></p>
<p>代码分为三步：<br>
1、创建Request对象。Request是<strong>CreateIndexRequest</strong><br>
2、添加请求参数，其实就是<strong>DSL的JSON参数</strong>部分。因为json字符串很长，这里是定义了<strong>静态字符串常量</strong>MAPPING_TEMPLATE，让代码看起来更加优雅。<br>
3、发送请求，**client.indices()**方法的返回值是IndicesClient类型，封装了所有与索引库操作有关的方法。</p>
<h3> 6.2、删除索引库</h3>
<p>与删除的Java代码流程是类似的。依然是三步走：<br>
1、创建Request对象。这次是<strong>GetIndexRequest</strong>对象<br>
2、准备参数。这里是<strong>无参</strong><br>
3、<strong>发送请求。改用exists方法</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6.3、判断索引库是否存在</h3>
<p>判断索引库是否存在，本质就是查询，对应的DSL：GET /hotel</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 7、RestClient操作文档</h2>
<p>利用JavaRestClient事项文档的CRUD</p>
<p>数据库查询酒店数据，导入到hotel索引库，实现酒店数据的CRUD</p>
<p>基本步骤：<br>
1、初始化JavaRestClient<br>
2、利用JavaRestClient新增酒店数据<br>
3、利用哦JavaRestClient根据id查询酒店数据<br>
4、利用JavaRestClient删除酒店数据<br>
5、利用JavaRestClient修改酒店数据</p>
<h3> 7.1、新增文档</h3>
<p>将数据库的酒店数据查询出来，写入elasticsearch中</p>
<p>注意准备<strong>两个实体类</strong>，Hotel，HotelDoc<br>
Hotel类型与<strong>索引库结构存在差异</strong>：<br>
longitude和latitude需要合并为location<br>
因此，我们需要定义一个新的类型，与索引库结构吻合</p>
<p>新增文档的DSL语句如下：</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的java代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>三步走：<br>
1）创建Request对象<br>
2）准备请求参数，也就是DSL中的JSON文档<br>
3）发送请求<br>
变化的地方在于，<a href="http://xn--client-vt9in98k266am0d6y0gd5e.xxx" target="_blank" rel="noopener noreferrer">这里直接使用client.xxx</a>()的API</p>
<h3> 7.2、查询文档</h3>
<p>根据id查询到文档数据时json，需要反序列化为java对象</p>
<p>查询的DSL语句如下：</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>与之前类似，也是三步走：<br>
1）准备Request对象。这次是查询，所以是GetRequest<br>
2）发送请求，得到结果。因为是查询，这里调用client.get()方法<br>
3）解析结果，就是对JSON做反序列化</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7.3、修改文档</h3>
<p>根据id修改数据的方式有两种：<br>
方式一：全量修改：本质是先根据id删除，再新增<br>
方式二：增量修改：修改文档中的指定字段值</p>
<p>在RestClient的API中，全量修改与新增的API完全一致，判断依据是ID：<br>
如果新增时，ID已经存在，则修改<br>
如果新增时，ID不存在，则新增</p>
<p>增量修改：<br>
与之前类似，也是三步走：<br>
1）准备Request对象。这次是修改，所以是UpdateRequest<br>
2）准备参数。也就是JSON文档，里面包含要修改的字段<br>
3）更新文档。这里调用client.update()方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7.4、删除文档</h3>
<p>删除的DSL为是这样的：</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>依然是三步走：<br>
1）准备Request对象，因为是删除，这次是DeleteRequest对象。要指定索引库名和id<br>
2）准备参数，无参<br>
3）发送请求。因为是删除，所以是client.delete()方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7.5、批量导入文档</h3>
<p>批量查询数据，然后批量导入索引库中：<br>
思路：<br>
1、利用mybatis-plus查询酒店数据<br>
2、将查询到的数据（Bean）装换为文档数据类型（BeanDOC）<br>
3、利用JavaRequestClient的Bulk批处理，实现批量新增文档</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230329134229.png" type="image/png"/>
    </item>
    <item>
      <title>MongoDB</title>
      <link>https://T4mako.github.io/code/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB.html</link>
      <guid>https://T4mako.github.io/code/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB.html</guid>
      <source url="https://T4mako.github.io/rss.xml">MongoDB</source>
      <description>MongoDB 是一个基于分布式文件存储的数据库 1、介绍 1.1、概念 Mongodb 中有三个重要概念： 数据库 -&amp;gt; 集合(表) -&amp;gt; 文档(行) 数据库（database）数据库服务可以创建很多数据库，数据库中存放很多集合 集合（collection） 集合类似于 JS 中的数组，在集合中可以存放很多文档 文档（document） 文档是数据库中的最小单位，类似于 JS 中的对象</description>
      <content:encoded><![CDATA[<p><a href="https://www.mongodb.com/" target="_blank" rel="noopener noreferrer">MongoDB</a> 是一个基于<strong>分布式文件存储</strong>的数据库</p>
<h2> 1、介绍</h2>
<h3> 1.1、概念</h3>
<p>Mongodb 中有三个重要概念：</p>
<p>数据库 -&gt; 集合(表) -&gt; 文档(行)</p>
<p>数据库（database）数据库服务可以创建很多数据库，<strong>数据库</strong>中存放很多<strong>集合</strong><br>
集合（collection） 集合类似于 <strong>JS 中的数组</strong>，在集合中可以<strong>存放</strong>很多<strong>文档</strong><br>
文档（document） <strong>文档</strong>是数据库中的<strong>最小单位</strong>，类似于 JS 中的<strong>对象</strong></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230429213859.png" alt="" loading="lazy"></p>
<h3> 1.2、下载</h3>
<p>下载地址： <a href="https://www.mongodb.com/try/download/community" target="_blank" rel="noopener noreferrer">https://www.mongodb.com/try/download/community</a></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230429214304.png" alt="" loading="lazy"></p>
<p>将压缩包移动到 C:\Program Files 下，解压<br>
创建 C:\data\db 目录，mongodb 会将数据<strong>默认保存</strong>在这个文件夹</p>
<h3> 1.3、启动服务</h3>
<p>以 mongodb 中 bin 目录作为工作目录，启动命令行<br>
运行命令 <strong>mongod</strong></p>
<p>看到最后的 waiting for connections 则表明服务 已经启动成功</p>
<p>可以使用 <strong>mongo</strong> 命令连接本机的 mongodb 服务</p>
<blockquote>
<p>注：<br>
为了方便后续方便使用 mongod 命令，可以将 bin 目录配置到环境变量 Path 中<br>
千万不要选中服务端窗口的内容 ，选中会停止服务，可以 敲回车 取消选中</p>
</blockquote>
<h2> 2、基础命令</h2>
<h3> 2.1、数据库</h3>
<p>显示所有数据库：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>切换到指定的数据库（不存在自动创建）</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>显示当前所在数据库</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>删除当前数据库</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.2、集合</h3>
<p>创建集合</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>显示当前数据库的所有集合</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>删除某个集合</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>重命名集合</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.3、文档</h3>
<p>插入文档</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>查询文档</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>_id</strong> 是 mongodb 自动生成的唯一编号，用来唯一标识文档</p>
<p>更新文档</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>删除文档</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3、Mongoose</h2>
<p><a href="http://www.mongoosejs.net/" target="_blank" rel="noopener noreferrer">Mongoose</a> 是一个对象文档模型库<br>
可以使用 <strong>代码操作 mongodb</strong> 数据库</p>
<p>安装：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 3.1、使用流程</h3>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.2、字段类型</h3>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>字符串</td>
</tr>
<tr>
<td>Number</td>
<td>数字</td>
</tr>
<tr>
<td>Boolean</td>
<td>布尔值</td>
</tr>
<tr>
<td>Array</td>
<td>数组，也可以使用 [] 来标识</td>
</tr>
<tr>
<td>Date</td>
<td>日期</td>
</tr>
<tr>
<td>Buffer</td>
<td>Buffer 对象</td>
</tr>
<tr>
<td>Mixed</td>
<td>任意类型，需要使用 mongoose.Schema.Types.Mixed 指定</td>
</tr>
<tr>
<td>ObjectId</td>
<td>对象 ID，需要使用 mongoose.Schema.Types.ObjectId 指定</td>
</tr>
<tr>
<td>Decimal128</td>
<td>高精度数字，需要使用 mongoose.Schema.Types.Decimal128 指定</td>
</tr>
</tbody>
</table>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.3、字段值验证</h3>
<p>Mongoose 内置了一些验证器，可以对字段值进行验证</p>
<p>① 必填</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>② 默认值</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>③ 枚举值</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>④ 唯一值</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>举例：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>注：<br>
unique 需要 重建集合 才能有效果  ，即不能在旧的集合中使用</p>
</blockquote>
<h3> 3.4、crud</h3>
<p>增加（create），删除（delete），修改（update），查（read）</p>
<h4> 3.4.1、插入</h4>
<p>插入一条：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>批量插入：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3.4.2、删除</h4>
<p>删除一条数据</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>批量删除</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3.4.3、更新</h4>
<p>更新一条数据</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>批量更新数据</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3.4.4、查询</h4>
<p>查询一条数据</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>批量查询数据</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.5、运算符</h3>
<h4> 3.5.1、条件运算</h4>
<p>在 mongodb 不能 &gt; &lt; &gt;= &lt;= !== 等运算符，需要使用替代符号</p>
<p>&gt; 使用 $gt<br>
&lt; 使用 $lt<br>
&gt;= 使用 $gte<br>
&lt;= 使用 $lte<br>
!== 使用 $ne</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3.5.2、逻辑运算</h4>
<p><code>$or</code> 逻辑或的情况<br>
<code>$and</code> 逻辑与的情况</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>条件中可以直接使用 JS 的正则语法，通过正则可以进行模糊查询</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 3.6、个性化读取</h3>
<h4> 3.6.1、字段筛选</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3.6.2、排序</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3.6.3、截取</h4>
<p>跨过几条，截取几条</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 4、图形化工具</h2>
<p>可以使用图形化的管理工具来对 Mongodb 进行交互</p>
<p>Robo 3T 免费 <a href="https://github.com/Studio3T/robomongo/releases" target="_blank" rel="noopener noreferrer">https://github.com/Studio3T/robomongo/releases</a><br>
Navicat 收费 <a href="https://www.navicat.com.cn/" target="_blank" rel="noopener noreferrer">https://www.navicat.com.cn/</a></p>
]]></content:encoded>
      <enclosure url="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230429213859.png" type="image/png"/>
    </item>
    <item>
      <title>MySQL</title>
      <link>https://T4mako.github.io/code/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%9F%BA%E7%A1%80.html</link>
      <guid>https://T4mako.github.io/code/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%9F%BA%E7%A1%80.html</guid>
      <source url="https://T4mako.github.io/rss.xml">MySQL</source>
      <description>1、数据库概述 1、概述 E-R（entity-relationship，实体-联系）模型中有三个主要概念是： **实体集 、 属性 、 联系集 **。 一个实体集（class）对应于数据库中的一个表（table），一个实体（instance）则对应于数据库表中的一行（row），也称为一条记录（record）。一个属性（attribute）对应于数据库表中的一列（column），也称为一个字段（field）。 实体--行--记录 属性--列--字段</description>
      <content:encoded><![CDATA[<h2> 1、数据库概述</h2>
<h3> 1、概述</h3>
<p>E-R（entity-relationship，实体-联系）模型中有三个主要概念是： **实体集 、 属性 、 联系集 **。<br>
一个实体集（class）对应于数据库中的一个表（table），一个实体（instance）则对应于数据库表中的一行（row），也称为一条记录（record）。一个属性（attribute）对应于数据库表中的一列（column），也称为一个字段（field）。</p>
<p><strong>实体--行--记录</strong><br>
<strong>属性--列--字段</strong></p>
<p>数据库中的一个<strong>表 <strong>&lt;---&gt; Java或Python中的一个</strong>类</strong><br>
表中的<strong>一条数据 <strong>&lt;---&gt; 类中的一个</strong>对象</strong>（或实体）<br>
表中的一个<strong>列</strong> &lt;----&gt; 类中的一个<strong>字段、属性</strong>(field)</p>
<p>表的关联关系：<br>
表与表之间的数据记录有关系(relationship)。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。<br>
**四种：一对一关联、一对多关联、多对多关联、自我引用  **</p>
<p>MySQL的版本：</p>
<p><strong>MySQL Community Server 社区版本</strong>，开源免费，自由下载，但不提供官方技术支持，适用于大多数普通用户。<br>
<strong>MySQL Enterprise Edition 企业版本</strong>，需付费，不能在线下载，可以试用30天。提供了更多的功能和更完备的技术支持，更适合于对数据库的功能和可靠性要求较高的企业客户。<br>
<strong>MySQL Cluster 集群版</strong>，开源免费。用于架设集群服务器，可将几个MySQL Server封装成一个Server。需要在社区版或企业版的基础上使用。<br>
<strong>MySQL Cluster CGE 高级集群版</strong>，需付费。</p>
<p>MySQL8.0以后<strong>修改密码加密方式</strong>：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2、SQL 的分类：</h3>
<p>SQL（Structured Query Language，结构化查询语言）</p>
<p><strong>DDL</strong>（Data Definition Languages、数据定义语言），这些语句定义了不同的数据库、表、视图、索引等数据库对象，还可以用来创建、删除、修改数据库和数据表的结构。主要的语句关键字包括 <strong>CREATE 、 DROP 、 ALTER、RENAME、TURNCATE</strong> 等。<br>
<strong>DML</strong>（Data Manipulation Language、数据操作语言），用于添加、删除、更新和查询数据库记录，并检查数据完整性。主要的语句关键字包括 **INSERT 、 DELETE 、 UPDATE 、 SELECT **等。SELECT是SQL语言的基础，最为重要。<br>
<strong>DCL</strong>（Data Control Language、数据控制语言），用于定义数据库、表、字段、用户的访问权限和安全级别。主要的语句关键字包括 <strong>GRANT 、 REVOKE 、 COMMIT 、 ROLLBACK 、 SAVEPOINT</strong> 等。</p>
<p>SQL 可以写在一行或者多行。为了提高可读性，各子句分行写，必要时使用缩进<br>
每条命令以 ; 或 \g 或 \G 结束<br>
<strong>MySQL 在 Windows</strong> 环境下是<strong>大小写不敏感</strong>的<br>
<strong>MySQL 在 Linux</strong> 环境下是<strong>大小写敏感</strong>的</p>
<p>推荐采用统一的<strong>书写规范：</strong><br>
<strong>数据库名、表名、表别名、字段名、字段别名等都小写</strong><br>
**SQL 关键字、函数名、绑定变量等都大写  **</p>
<h3> 3、注释</h3>
<p>单行注释：#注释文字(MySQL特有的方式)<br>
单行注释：-- 注释文字(--后面必须包含一个空格。)<br>
多行注释：/* 注释文字 */</p>
<h3> 4、数据的导入</h3>
<p>导入现有的数据表、表的数据<br>
方式一：source文件的全路径名</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>方式二：基于具体的图形化界面的工具可以导入数据</p>
<h2> 2、基本的SELECT语句</h2>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> AS列的别名</h3>
<p><strong>as</strong>：（全称alias，别名）可以省略<br>
列的别名可以使用一对“”引起来</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> DISTINCT去除重复行</h3>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> NULL空值</h3>
<p>空值：null 不同于“null”，0<br>
空值参与运算，结果一定为空</p>
<h3> ``着重号</h3>
<p>避免与关键字、保留字重名</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> DESC显示表结构</h3>
<p><strong>describe</strong><br>
<strong>DESC</strong></p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> WHERE过滤数据</h3>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3、运算符</h2>
<h3> 1、算数运算符</h3>
<p>算术运算符：+ - * / div(除) % mod(取模)</p>
<h3> 2、比较运算符</h3>
<p>比较运算符用来对表达式左边的操作数和右边的操作数进行比较，比较的结果为真则返回1，比较的结果<br>
为假则返回0，其他情况则返回NULL。<br>
比较运算符经常被用来作为SELECT查询语句的条件来使用，返回符合条件的结果记录</p>
<h4> =	&lt;=&gt;	&lt;&gt;	!=	&lt;	&lt;=	&gt;	&gt;=</h4>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>与null参与的运算基本都是null(+,*,==)，除了&lt;=&gt;</strong></p>
<h4> IS NULL	IS NOT NULL	ISNULL</h4>
<h4> LEAST()	GREATEST() 	最小，最大</h4>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> BETWEEN AND	IN(SET)	NOT IN(SET)</h4>
<p>区别它们之间的区别</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> LIKE模糊查询</h4>
<p>通配符：<br>
<strong>_	  1个</strong><br>
<strong>% 	0个，1个或多个</strong><br>
转义字符：\ 或者 escape</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3、逻辑运算符</h3>
<p><strong>OR 	||	逻辑或</strong><br>
<strong>AND	&amp;&amp;	逻辑与</strong><br>
<strong>NOT	！	逻辑非</strong><br>
<strong>XOR		逻辑异或</strong><br>
AND的优先级高于OR</p>
<h3> 4、位运算符</h3>
<p><strong>&amp;	按位与<br>
|	  按位或<br>
^	按位异或<br>
~	按位取反<br>
&gt;&gt;  右移<br>
&lt;&lt;  左移</strong></p>
<h2> 4、排序和分页</h2>
<h3> 1、排序 ORDER BY</h3>
<p>如果没有使用排序操作，默认情况下数据按照添加顺序排列</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>列的别名不能在WHERE后使用，可以在ORDER BY后使用</strong></p>
<h3> 2、分页 LIMIT</h3>
<p>Limit 偏移量,显示条数<br>
LIMIT 显示条数<br>
LIMIT 显示条数 OFFSET 偏移量 (MySQL新特性)</p>
<p>每页显示pageSize条记录，显示第pageNo页：(LIMIT pageNo-1)*pageSize,pageSize</p>
<h2> 5、多表查询</h2>
<p>多表查询的分类：<br>
等值连接，非等值连接<br>
自连接，非自连接<br>
内连接，外连接</p>
<p>1、笛卡尔积（m*n条数据）</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>2、等值连接，非等值连接</p>
<p>如果查询语句中出现了<strong>多个表都存在的字段</strong>，必须<strong>指明此字段所在的表</strong><br>
建议多表查询时，每个字段都声明其所在的表</p>
<p>可以起别名，在SELECT和WHERE中使用表的别名<br>
<strong>如果给表起了别名，一旦在SELECT或WHERE中使用表名，必须使用表的别名，而不能使用表的原名</strong></p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>结论：如果有n个表实现多表连接，<mark>至少</mark>需要n-1个连接条件</strong></p>
<p>非等值连接</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3、自连接，非自连接</p>
<p>自连接<br>
举例：查询员工表的员工id，姓名及其管理者的id和姓名</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>4、内连接，外连接</p>
<p><strong>内连接：合并具有同一列的两个以上的表的行，结果集中不包含一个表与另一个表不匹配的行<br>
外连接：合并具有同一列的两个以上的表的行，结果集中除了包含一个表与另一个表匹配的行，还包含左表或右表中不匹配的行</strong></p>
<p>外连接：左外连接，右外连接，满外连接</p>
<p>SQL92语法实现外连接：使用 + (MySQL不支持SQL92语法)<br>
SQL99语法中使用JOIN...ON的方式实现多表查询</p>
<p>SQL99实现内连接：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>SQL99实现外连接：</p>
<p>左外连接</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>右外连接</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>满外连接：mysql不支持FULL OUTER JOIN</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>UNION关键字的使用</strong></p>
<p>UNION：会执行去重操作<br>
UNION ALL：不会执行去重操作<br>
执行UNION ALL语句时所需要的资源比UNION语句少。如果明确知道合并数据后的<strong>结果数据不存在重复数据</strong>，或者不需要去除重复的数据，则<strong>尽量使用UNION ALL</strong>语句，以提高数据查询的效率。</p>
<h3> 七种SQL JOINS的实现</h3>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220806215624195.png" alt="image-20220806215624195" loading="lazy"></p>
<p>中图：内连接</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>左上图：左外连接</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>右上图：右外连接</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>左中图：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>右中图：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>左下图：<br>
左上图 UNION ALL 有中图 或者<br>
左中图 UNION ALL 右上图</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>右下图：<br>
左中图 UNION 右中图</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>SQL99语法新特性</p>
<p>1、自然连接NATURAL JOIN：<strong>自动</strong>连接表中<strong>相同的字段</strong>，然后进行<strong>等值连接</strong></p>
<p>2、USING连接</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 6、函数</h2>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221105194821206.png" alt="image-20221105194821206" loading="lazy"></p>
<h3> 1、基本函数</h3>
<table>
<thead>
<tr>
<th>ABS(x)</th>
<th>返回x的绝对值</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>SIGN(X)</strong></td>
<td><strong>返回X的符号。正数返回1，负数返回-1，0返回0</strong></td>
</tr>
<tr>
<td><strong>PI()</strong></td>
<td><strong>返回圆周率的值</strong></td>
</tr>
<tr>
<td><strong>CEIL(x)，CEILING(x)</strong></td>
<td><strong>返回大于或等于某个值的最小整数</strong></td>
</tr>
<tr>
<td><strong>FLOOR(x)</strong></td>
<td><strong>返回小于或等于某个值的最大整数</strong></td>
</tr>
<tr>
<td><strong>LEAST(e1,e2,e3…)</strong></td>
<td><strong>返回列表中的最小值</strong></td>
</tr>
<tr>
<td><strong>GREATEST(e1,e2,e3…)</strong></td>
<td><strong>返回列表中的最大值</strong></td>
</tr>
<tr>
<td><strong>MOD(x,y)</strong></td>
<td><strong>返回X除以Y后的余数</strong></td>
</tr>
<tr>
<td><strong>RAND()</strong></td>
<td><strong>返回0~1的随机值</strong></td>
</tr>
<tr>
<td><strong>RAND(x)</strong></td>
<td><strong>返回0~1的随机值，其中x的值用作种子值，相同的X值会产生相同的随机 数</strong></td>
</tr>
<tr>
<td><strong>ROUND(x)</strong></td>
<td><strong>返回一个对x的值进行四舍五入后，最接近于X的整数</strong></td>
</tr>
<tr>
<td><strong>ROUND(x,y)</strong></td>
<td><strong>返回一个对x的值进行四舍五入后最接近X的值，并保留到小数点后面Y位</strong></td>
</tr>
<tr>
<td><strong>TRUNCATE(x,y)</strong></td>
<td><strong>返回数字x截断为y位小数的结果</strong></td>
</tr>
<tr>
<td><strong>SQRT(x)</strong></td>
<td><strong>返回x的平方根。当X的值为负数时，返回NULL</strong></td>
</tr>
</tbody>
</table>
<h3> 2、角度制与弧度制</h3>
<table>
<thead>
<tr>
<th>RADIANS(x)</th>
<th>将角度转化为弧度，其中，参数x为角度值</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>DEGREES(x)</strong></td>
<td><strong>将弧度转化为角度，其中，参数x为弧度值</strong></td>
</tr>
</tbody>
</table>
<h3> 3、三角函数</h3>
<table>
<thead>
<tr>
<th>SIN(x)</th>
<th>返回x的正弦值，其中，参数x为弧度值</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ASIN(x)</strong></td>
<td><strong>返回x的反正弦值，即获取正弦为x的值。如果x的值不在-1到1之间，则返回NULL</strong></td>
</tr>
<tr>
<td><strong>COS(x)</strong></td>
<td><strong>返回x的余弦值，其中，参数x为弧度值</strong></td>
</tr>
<tr>
<td><strong>ACOS(x)</strong></td>
<td><strong>返回x的反余弦值，即获取余弦为x的值。如果x的值不在-1到1之间，则返回NULL</strong></td>
</tr>
<tr>
<td><strong>TAN(x)</strong></td>
<td><strong>返回x的正切值，其中，参数x为弧度值</strong></td>
</tr>
<tr>
<td><strong>ATAN(x)</strong></td>
<td><strong>返回x的反正切值，即返回正切值为x的值</strong></td>
</tr>
<tr>
<td><strong>ATAN2(m,n)</strong></td>
<td><strong>返回两个参数的反正切值</strong></td>
</tr>
<tr>
<td><strong>COT(x)</strong></td>
<td><strong>返回x的余切值，其中，X为弧度值</strong></td>
</tr>
</tbody>
</table>
<h3> 4、指数与对数</h3>
<table>
<thead>
<tr>
<th><strong>POW(x,y)，POWER(X,Y)</strong></th>
<th><strong>返回x的y次方</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>EXP(X)</strong></td>
<td><strong>返回e的X次方，其中e是一个常数，2.718281828459045</strong></td>
</tr>
<tr>
<td><strong>LN(X)，LOG(X)</strong></td>
<td><strong>返回以e为底的X的对数，当X &lt;= 0 时，返回的结果为NULL</strong></td>
</tr>
<tr>
<td><strong>LOG10(X)</strong></td>
<td><strong>返回以10为底的X的对数，当X &lt;= 0 时，返回的结果为NULL</strong></td>
</tr>
<tr>
<td><strong>LOG2(X)</strong></td>
<td><strong>返回以2为底的X的对数，当X &lt;= 0 时，返回NULL</strong></td>
</tr>
</tbody>
</table>
<h3> 5、进制间的转换</h3>
<table>
<thead>
<tr>
<th><strong>BIN(x)</strong></th>
<th><strong>返回x的二进制编码</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>HEX(x)</strong></td>
<td><strong>返回x的十六进制编码</strong></td>
</tr>
<tr>
<td><strong>OCT(x)</strong></td>
<td><strong>返回x的八进制编码</strong></td>
</tr>
<tr>
<td><strong>CONV(x,f1,f2)</strong></td>
<td><strong>返回f1进制数变成f2进制数</strong></td>
</tr>
</tbody>
</table>
<h3> 6、字符串函数</h3>
<p><strong>字符串的索引从1开始</strong></p>
<table>
<thead>
<tr>
<th>ASCII(S)</th>
<th>返回字符串S中的第一个字符的ASCII码值</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CHAR_LENGTH(s)</strong></td>
<td><strong>返回字符串s的字符数。作用与CHARACTER_LENGTH(s)相同</strong></td>
</tr>
<tr>
<td><strong>LENGTH(s)</strong></td>
<td><strong>返回字符串s的字节数，和字符集有关</strong></td>
</tr>
<tr>
<td><strong>CONCAT(s1,s2,......,sn)</strong></td>
<td><strong>连接s1,s2,......,sn为一个字符串</strong></td>
</tr>
<tr>
<td><strong>CONCAT_WS(x, s1,s2,......,sn)</strong></td>
<td><strong>同CONCAT(s1,s2,...)函数，但是每个字符串之间要加上x</strong></td>
</tr>
<tr>
<td><strong>INSERT(str, idx, len, replacestr)</strong></td>
<td><strong>将字符串str从第idx位置开始，len个字符长的子串替换为字符串replacestr</strong></td>
</tr>
<tr>
<td><strong>REPLACE(str, a, b)</strong></td>
<td><strong>用字符串b替换字符串str中所有出现的字符串a</strong></td>
</tr>
<tr>
<td><strong>UPPER(s) 或 UCASE(s)</strong></td>
<td><strong>将字符串s的所有字母转成大写字母</strong></td>
</tr>
<tr>
<td><strong>LOWER(s) 或LCASE(s)</strong></td>
<td><strong>将字符串s的所有字母转成小写字母</strong></td>
</tr>
<tr>
<td><strong>LEFT(str,n)</strong></td>
<td><strong>返回字符串str最左边的n个字符</strong></td>
</tr>
<tr>
<td><strong>RIGHT(str,n)</strong></td>
<td><strong>返回字符串str最右边的n个字符</strong></td>
</tr>
<tr>
<td><strong>LPAD(str, len, pad)</strong></td>
<td><strong>用字符串pad对str最左边进行填充，直到str的长度为len个字符</strong></td>
</tr>
<tr>
<td><strong>RPAD(str ,len, pad)</strong></td>
<td><strong>用字符串pad对str最右边进行填充，直到str的长度为len个字符</strong></td>
</tr>
<tr>
<td><strong>LTRIM(s)</strong></td>
<td><strong>去掉字符串s左侧的空格</strong></td>
</tr>
<tr>
<td><strong>RTRIM(s)</strong></td>
<td><strong>去掉字符串s右侧的空格</strong></td>
</tr>
<tr>
<td><strong>TRIM(s)</strong></td>
<td><strong>去掉字符串s开始与结尾的空格</strong></td>
</tr>
<tr>
<td><strong>TRIM(s1 FROM s)</strong></td>
<td><strong>去掉字符串s开始与结尾的s1</strong></td>
</tr>
<tr>
<td><strong>TRIM(LEADING s1 FROM s)</strong></td>
<td><strong>去掉字符串s开始处的s1</strong></td>
</tr>
<tr>
<td><strong>TRIM(TRAILING s1 FROM s)</strong></td>
<td><strong>去掉字符串s结尾处的s1</strong></td>
</tr>
<tr>
<td><strong>REPEAT(str, n)</strong></td>
<td><strong>返回str重复n次的结果</strong></td>
</tr>
<tr>
<td><strong>SPACE(n)</strong></td>
<td><strong>返回n个空格</strong></td>
</tr>
<tr>
<td><strong>STRCMP(s1,s2)</strong></td>
<td><strong>比较字符串s1,s2的ASCII码值的大小</strong></td>
</tr>
<tr>
<td><strong>SUBSTR(s,index,len)</strong></td>
<td><strong>返回从字符串s的index位置其len个字符，作用与SUBSTRING(s,n,len)、 MID(s,n,len)相同</strong></td>
</tr>
<tr>
<td><strong>LOCATE(substr,str)</strong></td>
<td><strong>返回字符串substr在字符串str中首次出现的位置，作用于POSITION(substr IN str)、INSTR(str,substr)相同。未找到，返回0</strong></td>
</tr>
<tr>
<td><strong>ELT(m,s1,s2,…,sn)</strong></td>
<td><strong>返回指定位置的字符串，如果m=1，则返回s1，如果m=2，则返回s2，如 果m=n，则返回sn</strong></td>
</tr>
<tr>
<td><strong>FIELD(s,s1,s2,…,sn)</strong></td>
<td><strong>返回字符串s在字符串列表中第一次出现的位置</strong></td>
</tr>
<tr>
<td><strong>FIND_IN_SET(s1,s2)</strong></td>
<td><strong>返回字符串s1在字符串s2中出现的位置。其中，字符串s2是一个以逗号分 隔的字符串</strong></td>
</tr>
<tr>
<td><strong>REVERSE(s)</strong></td>
<td><strong>返回s反转后的字符串</strong></td>
</tr>
<tr>
<td><strong>NULLIF(value1,value2)</strong></td>
<td><strong>比较两个字符串，如果value1与value2相等，则返回NULL，否则返回 value1</strong></td>
</tr>
</tbody>
</table>
<h3> 7、日期与时间</h3>
<table>
<thead>
<tr>
<th><mark>**CURDATE()</mark>，CURRENT_DATE()**</th>
<th><strong>返回当前日期，只包含年、 月、日</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><mark><strong>CURTIME()</strong></mark> ， CURRENT_TIME()**</td>
<td><strong>返回当前时间，只包含时、 分、秒</strong></td>
</tr>
<tr>
<td><strong><mark>NOW()</mark> / SYSDATE() / CURRENT_TIMESTAMP() / LOCALTIME() / LOCALTIMESTAMP()</strong></td>
<td><strong>返回当前系统日期和时间</strong></td>
</tr>
<tr>
<td><strong>UTC_DATE()</strong></td>
<td><strong>返回UTC（世界标准时间） 日期</strong></td>
</tr>
<tr>
<td><strong>UTC_TIME()</strong></td>
<td><strong>返回UTC（世界标准时间） 时间</strong></td>
</tr>
<tr>
<td><strong>UNIX_TIMESTAMP()</strong></td>
<td><strong>以UNIX时间戳的形式返回当前时间。SELECT UNIX_TIMESTAMP() - &gt;1634348884</strong></td>
</tr>
<tr>
<td><strong>UNIX_TIMESTAMP(date)</strong></td>
<td><strong>将时间date以UNIX时间戳的形式返回。</strong></td>
</tr>
<tr>
<td><strong>FROM_UNIXTIME(timestamp)</strong></td>
<td><strong>将UNIX时间戳的时间转换为普通格式的时间</strong></td>
</tr>
<tr>
<td><strong>YEAR(date) / MONTH(date) / DAY(date)</strong></td>
<td><strong>返回具体的日期值</strong></td>
</tr>
<tr>
<td><strong>HOUR(time) / MINUTE(time) / SECOND(time)</strong></td>
<td><strong>返回具体的时间值</strong></td>
</tr>
<tr>
<td><strong>MONTHNAME(date)</strong></td>
<td><strong>返回月份：January，...</strong></td>
</tr>
<tr>
<td><strong>DAYNAME(date)</strong></td>
<td><strong>返回星期几：MONDAY，TUESDAY.....SUNDAY</strong></td>
</tr>
<tr>
<td><strong>WEEKDAY(date)</strong></td>
<td><strong>返回周几，注意，周1是0，周2是1，。。。周日是6</strong></td>
</tr>
<tr>
<td><strong>QUARTER(date)</strong></td>
<td><strong>返回日期对应的季度，范围为1～4</strong></td>
</tr>
<tr>
<td><strong>WEEK(date) ， WEEKOFYEAR(date)</strong></td>
<td><strong>返回一年中的第几周</strong></td>
</tr>
<tr>
<td><strong>DAYOFYEAR(date)</strong></td>
<td><strong>返回日期是一年中的第几天</strong></td>
</tr>
<tr>
<td><strong>DAYOFMONTH(date)</strong></td>
<td><strong>返回日期位于所在月份的第几天</strong></td>
</tr>
<tr>
<td><strong>DAYOFWEEK(date)</strong></td>
<td><strong>返回周几，注意：周日是1，周一是2，。。。周六是 7</strong></td>
</tr>
<tr>
<td><strong>EXTRACT(type FROM date)</strong></td>
<td><strong>返回指定日期中特定的部分，type指定返回的值</strong></td>
</tr>
<tr>
<td><strong>TIME_TO_SEC(time)</strong></td>
<td>*<em>将 time 转化为秒并返回结果值。转化的公式为： 小时*3600+分钟 <em>60+秒</em></em></td>
</tr>
<tr>
<td><strong>SEC_TO_TIME(seconds)</strong></td>
<td><strong>将 seconds 描述转化为包含小时、分钟和秒的时间</strong></td>
</tr>
<tr>
<td><strong>DATE_ADD(datetime, INTERVAL expr type)， ADDDATE(date,INTERVAL expr type)</strong></td>
<td><strong>返回与给定日期时间相差INTERVAL时 间段的日期时间</strong></td>
</tr>
<tr>
<td><strong>DATE_SUB(date,INTERVAL expr type)， SUBDATE(date,INTERVAL expr type)</strong></td>
<td><strong>返回与date相差INTERVAL时间间隔的 日期</strong></td>
</tr>
<tr>
<td><strong>ADDTIME(time1,time2)</strong></td>
<td><strong>返回time1加上time2的时间。当time2为一个数字时，代表的是 秒 ，可以为负数</strong></td>
</tr>
<tr>
<td><strong>SUBTIME(time1,time2)</strong></td>
<td><strong>返回time1减去time2后的时间。当time2为一个数字时，代表的 是 秒 ，可以为负数</strong></td>
</tr>
<tr>
<td><strong>DATEDIFF(date1,date2)</strong></td>
<td><strong>返回date1 - date2的日期间隔天数</strong></td>
</tr>
<tr>
<td><strong>TIMEDIFF(time1, time2)</strong></td>
<td><strong>返回time1 - time2的时间间隔</strong></td>
</tr>
<tr>
<td><strong>FROM_DAYS(N)</strong></td>
<td><strong>返回从0000年1月1日起，N天以后的日期</strong></td>
</tr>
<tr>
<td><strong>TO_DAYS(date)</strong></td>
<td><strong>返回日期date距离0000年1月1日的天数</strong></td>
</tr>
<tr>
<td><strong>LAST_DAY(date)</strong></td>
<td><strong>返回date所在月份的最后一天的日期</strong></td>
</tr>
<tr>
<td><strong>MAKEDATE(year,n)</strong></td>
<td><strong>针对给定年份与所在年份中的天数返回一个日期</strong></td>
</tr>
<tr>
<td><strong>MAKETIME(hour,minute,second)</strong></td>
<td><strong>将给定的小时、分钟和秒组合成时间并返回</strong></td>
</tr>
<tr>
<td><strong>PERIOD_ADD(time,n)</strong></td>
<td><strong>返回time加上n后的时间</strong></td>
</tr>
<tr>
<td><strong>DATE_FORMAT(date,fmt)</strong></td>
<td><strong>按照字符串fmt格式化日期date值</strong></td>
</tr>
<tr>
<td><strong>TIME_FORMAT(time,fmt)</strong></td>
<td><strong>按照字符串fmt格式化时间time值</strong></td>
</tr>
<tr>
<td><strong>GET_FORMAT(date_type,format_type)</strong></td>
<td><strong>返回日期字符串的显示格式</strong></td>
</tr>
<tr>
<td><strong>STR_TO_DATE(str, fmt)</strong></td>
<td><strong>按照字符串fmt对str进行解析，解析为一个日期</strong></td>
</tr>
</tbody>
</table>
<h3> 8、流程控制函数</h3>
<table>
<thead>
<tr>
<th>IF(value,value1,value2)</th>
<th>如果value的值为TRUE，返回value1， 否则返回value2</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>IFNULL(value1, value2)</strong></td>
<td><strong>如果value1不为NULL，返回value1，否 则返回value2</strong></td>
</tr>
<tr>
<td><strong>CASE WHEN 条件1 THEN 结果1 WHEN 条件2 THEN 结果2 .... [ELSE resultn] END</strong></td>
<td><strong>相当于Java的if...else if...else...</strong></td>
</tr>
<tr>
<td><strong>CASE expr WHEN 常量值1 THEN 值1 WHEN 常量值1 THEN 值1 .... [ELSE 值n] END</strong></td>
<td><strong>相当于Java的switch...case...</strong></td>
</tr>
</tbody>
</table>
<h3> 9、加密与解密函数</h3>
<table>
<thead>
<tr>
<th>PASSWORD(str)</th>
<th>返回字符串str的加密版本，41位长的字符串。加密结果 不可 逆 ，常用于用户的密码加密</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>MD5(str)</strong></td>
<td><strong>返回字符串str的md5加密后的值，也是一种加密方式。若参数为 NULL，则会返回NULL</strong></td>
</tr>
<tr>
<td><strong>SHA(str)</strong></td>
<td><strong>从原明文密码str计算并返回加密后的密码字符串，当参数为 NULL时，返回NULL。 SHA加密算法比MD5更加安全 。</strong></td>
</tr>
<tr>
<td><strong>ENCODE(value,password_seed)</strong></td>
<td><strong>返回使用password_seed作为加密密码加密value</strong></td>
</tr>
<tr>
<td><strong>DECODE(value,password_seed)</strong></td>
<td><strong>返回使用password_seed作为加密密码解密value</strong></td>
</tr>
</tbody>
</table>
<h3> 10、 MySQL信息函数</h3>
<table>
<thead>
<tr>
<th><strong>VERSION()</strong></th>
<th><strong>返回当前MySQL的版本号</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CONNECTION_ID()</strong></td>
<td><strong>返回当前MySQL服务器的连接数</strong></td>
</tr>
<tr>
<td><strong>DATABASE()，SCHEMA()</strong></td>
<td><strong>返回MySQL命令行当前所在的数据库</strong></td>
</tr>
<tr>
<td><strong>USER()，CURRENT_USER()、SYSTEM_USER()， SESSION_USER()</strong></td>
<td><strong>返回当前连接MySQL的用户名，返回结果格式为 “主机名@用户名”</strong></td>
</tr>
<tr>
<td><strong>CHARSET(value)</strong></td>
<td><strong>返回字符串value自变量的字符集</strong></td>
</tr>
<tr>
<td><strong>COLLATION(value)</strong></td>
<td><strong>返回字符串value的比较规则</strong></td>
</tr>
<tr>
<td><strong>FORMAT(value,n)</strong></td>
<td><strong>返回对数字value进行格式化后的结果数据。n表示 四舍五入 后保留 到小数点后n位</strong></td>
</tr>
<tr>
<td><strong>CONV(value,from,to)</strong></td>
<td><strong>将value的值进行不同进制之间的转换</strong></td>
</tr>
<tr>
<td><strong>INET_ATON(ipvalue)</strong></td>
<td><strong>将以点分隔的IP地址转化为一个数字</strong></td>
</tr>
<tr>
<td><strong>INET_NTOA(value)</strong></td>
<td><strong>将数字形式的IP地址转化为以点分隔的IP地址</strong></td>
</tr>
<tr>
<td><strong>BENCHMARK(n,expr)</strong></td>
<td><strong>将表达式expr重复执行n次。用于测试MySQL处理expr表达式所耗费 的时间</strong></td>
</tr>
<tr>
<td><strong>CONVERT(value USING char_code)</strong></td>
<td><strong>将value所使用的字符编码修改为char_code</strong></td>
</tr>
</tbody>
</table>
<h3> 11、聚合函数（多行函数）</h3>
<h4> 1、常见的聚合函数</h4>
<p>可以对<strong>数值型数据</strong>使用<strong>AVG() 和 SUM()</strong> 函数。<br>
可以对<strong>任意数据类型</strong>的数据使用 <strong>MIN() 和 MAX()</strong> 函数。<br>
<em>对于null值不进行计算(跳过)</em></p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>COUNT函数</strong><br>
<strong>COUNT(*)<strong>返回表中记录总数，适用于</strong>任意数据类型</strong>。<br>
<strong>COUNT(expr)</strong> 返回<strong>expr不为空</strong>的记录总数。</p>
<p>问题：用count(*)，count(1)，count(列名)谁好呢/效率高?<br>
其实，对于MyISAM引擎的表是没有区别的。这种引擎内部有一计数器在维护着行数。<br>
Innodb引擎的表用count(*),count(1)直接读行数，复杂度是O(n)，因为innodb真的要去数一遍。但好于具体的count(列名)。<br>
问题：能不能使用count(列名)替换count(*)?<br>
**不要使用 count(列名)来替代 count(*) **， <strong>count(*)</strong> 是 SQL92 定义的标准统计行数的语法，跟数据库无关，<strong>跟 NULL 和非 NULL 无关。</strong><br>
<mark>说明：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。</mark></p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2、GROUP BY 的使用</h4>
<p>可以使用GROUP BY子句将表中的数据分成若干组</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>明确：WHERE一定放在FROM后面</p>
<p>**使用多个列分组  **</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221105203240868.png" alt="image-20221105203240868" loading="lazy"></p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><mark>在SELECT列表中所有未包含在组函数(多行函数)中的列都应该包含在 GROUP BY子句中</mark></p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 <strong>WITH ROLLUP</strong> 关键字之后，在所有查询出的分组记录之后增加一条记录，该记录计算查询出的所有记录的总和，即统计记录数量，（<em>所有数据为一组</em>）。</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：<br>
当使用ROLLUP时，不能同时使用ORDER BY子句进行结果排序，即<strong>ROLLUP和ORDER BY是互相排斥的</strong>。</p>
<h4> 3、HAVING 的使用</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221105204546857.png" alt="image-20221105204546857" loading="lazy"></p>
<p><strong>where后不能使用聚合函数</strong></p>
<p>过滤分组：HAVING子句<br>
1、行已经被分组。<br>
2、使用了聚合函数。<br>
3、满足HAVING 子句中条件的分组将被显示。<br>
4、HAVING 不能单独使用，必须要跟 GROUP BY 一起使用</p>
<h5> **WHERE和HAVING的对比  **</h5>
<p>区别1：<strong>Having的使用范围更广</strong>，WHERE 可以直接使用表中的字段作为筛选条件，但不能使用分组中的计算函数作为筛选条件；HAVING 必须要与 GROUP BY 配合使用，可以把分组计算的函数和分组字段作为筛选条件。<br>
区别2：<strong>如果过滤条件中没有聚合函数，WHERE的执行效率高于HAVING</strong>，如果需要通过连接从关联表中获取需要的数据，WHERE 是先筛选后连接，而 HAVING 是先连接后筛选。</p>
<table>
<thead>
<tr>
<th style="text-align:center">WHERE</th>
<th style="text-align:center">先筛选数据再关联，执行效率高</th>
<th style="text-align:center">不能使用分组中的计算函数进行筛选</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>HAVING</strong></td>
<td style="text-align:center">**可以使用分组中的计算函数 **</td>
<td style="text-align:center"><strong>在最后的结果集中进行筛选，执行效率较低</strong></td>
</tr>
</tbody>
</table>
<h4> 4、SQL底层执行原理</h4>
<p>SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ... LIMIT...<br>
在 SELECT 语句执行这些步骤的时候，每个步骤都会产生一个 虚拟表 ，然后将这个虚拟表传入下一个步<br>
骤中作为输入。需要注意的是，这些步骤隐含在 SQL 的执行过程中，对于我们来说是不可见的</p>
<p>SQL99语法：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><em><strong>先执行FROM到HAVING语句块，在执行SELECT语句，再执行ORDER BY，LIMIT语句</strong></em></p>
<h2> 7、子查询</h2>
<p>子查询（内查询）在主查询之前一次执行完成。<br>
子查询的结果被主查询（外查询）使用 。<br>
注意事项<br>
子查询要包含在括号内<br>
将子查询放在比较条件的右侧<br>
单行操作符对应单行子查询，多行操作符对应多行子查询</p>
<h3> 1、子查询的分类</h3>
<p>按内<strong>查询的结果的条目数</strong>，将子查询分为 <strong>单行子查询 、 多行子查询</strong>。<br>
按内查询<strong>是否被执行多次</strong>，将子查询划分为 <strong>相关(或关联)子查询 和 不相关(或非关联)子查询</strong> 。</p>
<p>子查询从数据表中查询了数据结果，如果这个数据结果只执行一次，然后这个数据结果作为主查询的条件进行执行，那么这样的子查询叫做<strong>不相关子查询</strong>。<br>
同样，如果子查询需要执行多次，即采用循环的方式，先从外部查询开始，每次都传入子查询进行查询，然后再将结果反馈给外部，这种嵌套的执行方式就称为<strong>相关子查询</strong>。</p>
<h3> 2、单行子查询</h3>
<p>单行操作符：=,&lt;,&gt;,&gt;=,&lt;=,&lt;&gt;</p>
<p><strong>子查询的编写技巧(或步骤)：<br>
1、从里往外写<br>
2、从外往里写</strong><br>
如果子查询相对较简单，建立从外往里写，一旦子查询结构较复杂，建议从里往外写<br>
如果是相关子查询的话，通常是从外往里写</p>
<p>题目：查询与141号或174号员工的manager_id和department_id相同的其他员工的employee_id，manager_id，department_id</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>HAVING中的子查询：<br>
查询最低工资大于50号部门最低工资的部门id和其最低工资</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在CASE表达式中使用单列子查询：<br>
题目：显示员工的employee_id,last_name和location。其中，若员工department_id与location_id为1800的department_id相同，则location为’Canada’，其余则为’USA’。</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>非法使用子查询：</strong></p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>=为单行操作符，而自查询结果为多条记录</strong></p>
<h3> 3、多行子查询</h3>
<p>也称为集合比较子查询<br>
内查询返回多行<br>
使用多行比较操作符</p>
<p>多行比较操作符 ：IN，ANY，ALL，SOME</p>
<p>题目：查询平均工资最低的部门id</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>空值问题</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4、相关子查询</h3>
<p>如果子查询的执行依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件关联，<strong>因此每执行一次外部查询，子查询都要重新计算一次</strong>，这样的子查询就称之为 关联子查询 。<br>
相关子查询按照一行接一行的顺序执行，主查询的每一行都执行一次子查询 。</p>
<p>题目：查询员工中工资大于本部门平均工资的员工的last_name,salary和其department_id</p>
<p>方式一：相关子查询</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221106202021524.png" alt="image-20221106202021524" loading="lazy"></p>
<p>方式二：在 FROM 中使用子查询</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在ORDER BY 中使用子查询：<br>
题目：查询员工的id,salary,按照department_name 排序</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> EXISTS 与 NOT EXISTS关键字</h4>
<p>关联子查询通常也会和 EXISTS操作符一起来使用，用来检查在子查询中是否存在满足条件的行</p>
<p>如果在子查询中不存在满足条件的行：<br>
条件返回 FALSE<br>
继续在子查询中查找<br>
如果在子查询中存在满足条件的行：<br>
不在子查询中继续查找<br>
条件返回 TRUE</p>
<p>题目：查询公司管理者的employee_id，last_name，job_id，department_id信息</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>相关更新与相关删除</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 8、创建与管理表</h2>
<h3> 1、标识符命名规则</h3>
<p><strong>数据库名、表名不得超过30个字符，变量名限制为29个</strong><br>
必须只能包含 <strong>A–Z, a–z, 0–9, _<strong>共63个字符<br>
数据库名、表名、字段名等对象名中间不要包含空格<br>
同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名<br>
必须保证你的</strong>字段没有和保留字、数据库系统或常用方法冲突</strong>。如果坚持使用，请在SQL语句中使用**`（着重号）引起来**<br>
保持<strong>字段名和类型的一致性</strong>：在命名字段并为其指定数据类型的时候一定要保证一致性，假如数据类型在一个表里是整数，那在另一个表里可就别变成字符型了</p>
<h3> 2、mysql数据类型</h3>
<table>
<thead>
<tr>
<th>类型</th>
<th>种类</th>
</tr>
</thead>
<tbody>
<tr>
<td>整数类型</td>
<td>TINYINT、SMALLINT、MEDIUMINT、INT(或INTEGER)、BIGINT</td>
</tr>
<tr>
<td>浮点类型</td>
<td>FLOAT、DOUBLE</td>
</tr>
<tr>
<td>定点数类型</td>
<td>DECIMAL</td>
</tr>
<tr>
<td>位类型</td>
<td>BIT</td>
</tr>
<tr>
<td>日期时间类型</td>
<td>YEAR、TIME、DATE、DATETIME、TIMESTAMP</td>
</tr>
<tr>
<td>文本字符串类型</td>
<td>CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT</td>
</tr>
<tr>
<td>枚举类型</td>
<td>ENUM</td>
</tr>
<tr>
<td>集合类型</td>
<td>SET</td>
</tr>
<tr>
<td>二进制字符串类 型</td>
<td>BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB</td>
</tr>
<tr>
<td>JSON类型</td>
<td>JSON对象、JSON数组</td>
</tr>
<tr>
<td>空间数据类型</td>
<td>单值：GEOMETRY、POINT、LINESTRING、POLYGON； 集合：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、 GEOMETRYCOLLECTION</td>
</tr>
</tbody>
</table>
<p>其中，常用的几类类型介绍如下：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>INT</td>
<td>从-2<sup>31到2</sup>31-1的整型数据。存储大小为 4个字节</td>
</tr>
<tr>
<td>CHAR(size)</td>
<td>定长字符数据。若未指定，默认为1个字符，最大长度255</td>
</tr>
<tr>
<td>VARCHAR(size)</td>
<td>可变长字符数据，根据字符串实际长度保存，必须指定长度</td>
</tr>
<tr>
<td>FLOAT(M,D)</td>
<td>单精度，占用4个字节，M=整数位+小数位，D=小数位。 D&lt;=M&lt;=255,0&lt;=D&lt;=30， 默认M+D&lt;=6</td>
</tr>
<tr>
<td>DOUBLE(M,D)</td>
<td>双精度，占用8个字节，D&lt;=M&lt;=255,0&lt;=D&lt;=30，默认M+D&lt;=15</td>
</tr>
<tr>
<td>DECIMAL(M,D)</td>
<td>高精度小数，占用M+2个字节，D&lt;=M&lt;=65，0&lt;=D&lt;=30，最大取值范围与DOUBLE 相同。</td>
</tr>
<tr>
<td>DATE</td>
<td>日期型数据，格式'YYYY-MM-DD'</td>
</tr>
<tr>
<td>BLOB</td>
<td>二进制形式的长文本数据，最大可达4G</td>
</tr>
<tr>
<td>TEXT</td>
<td>长文本数据，最大可达4G</td>
</tr>
</tbody>
</table>
<h3> 3、创建和管理数据库</h3>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4、创建表</h3>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在MySQL中创建好数据表之后，可以查看数据表的结构。MySQL支持使用 DESCRIBE/DESC 语句查看数据表结构，也支持使用 SHOW CREATE TABLE 语句查看数据表结构</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 5、修改表</h3>
<p>1、添加一个字段</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2、修改一个列</p>
<p>可以修改列的数据类型，长度、默认值和位置<br>
修改字段数据类型、长度、默认值、位置的语法格式如下：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对默认值的修改只影响今后对表的修改<br>
此外，还可以通过此种方式修改列的约束。这里暂先不讲。</p>
<p>3、重命名列</p>
<p>使用 CHANGE old_column new_column dataType子句重命名列。语法格式如下：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>4、删除列</p>
<p>删除表中某个字段的语法格式如下：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 6、重命名表</h3>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7、删除表</h3>
<p>在MySQL中，当一张数据表<strong>没有与其他任何数据表形成关联关系</strong>时，可以将当前数据表直接删除。<br>
<strong>数据和结构都被删除</strong><br>
所有<strong>正在运行的相关事务被提交</strong><br>
所有**相关索引被删除  **</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>**DROP TABLE 语句不能回滚  **</p>
<h3> 8、清空表</h3>
<p>TRUNCATE TABLE语句：<br>
<strong>删除表中所有的数据，但是表结构保留</strong><br>
释放表的存储空间</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>TRUNCATE语句不能回滚，而使用 DELETE 语句删除数据，可以回滚</strong></p>
<p>注意turncate与delete的区别</p>
<p><strong>阿里开发规范：</strong><br>
【参考】TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE 无事务且不触发 TRIGGER，有可能造成事故，故不建议在开发代码中使用此语句。<br>
说明：TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。</p>
<h3> 9、COMMIT与ROLLBACK</h3>
<p>COMMIT：提交数据。一旦执行COMMIT，数据就被永久保存在了数据库中，意味着数据不可以回滚。<br>
DDL的操作一旦执行，就不可回滚（在执行完DDl操作之后，一定会执行一次COMMIT，而此COMMIT操作不收SET autocommit = FALSE影响的。）<br>
DML的操作默认情况下，一旦执行， 也是不可回滚的，但是如果在执行DML之前，执行了set autocommit = False，则执行的DML操作就可以实现回滚。</p>
<h3> 10、mysql字段命名</h3>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221108144920536.png" alt="image-20221108144920536" loading="lazy"></p>
<p>如何理解清空表、删除表等操作需谨慎：<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221108145130193.png" alt="image-20221108145130193" loading="lazy"></p>
<p>MySQL8新特性—DDL的原子化；<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221108145627124.png" alt="image-20221108145627124" loading="lazy"></p>
<h2> 9、数据的增删改</h2>
<h3> 1、插入数据</h3>
<h4> 1.、方式一：VALUES的方式添加</h4>
<p>①没有指明添加字段</p>
<p>INSERT INTO 表名 VALUES (value1,value2,....);</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>②指明要添加字段（推荐）</p>
<p>INSERT INTO 表名(column1 [, column2, …, columnn]) VALUES (value1 [,value2, …, valuen]);</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 INSERT 子句中随意列出列名，但是一旦列出，VALUES中要插入的value1,....valuen需要与 column1,...columnn列一一对应。如果类型不同，将无法插入，并且MySQL会产生错误。</p>
<p>③同时添加多条几记录（推荐）</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2、方式二：将查询的结果插入到表中</h4>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 INSERT 语句中加入子查询。<br>
<strong>不必书写 VALUES 子句。</strong><br>
子查询中的值列表应与 INSERT 子句中的列名对应。<br>
（插入表中要添加的字段的长度不能低于查询表种查询的字段的长度，不然有添加不成功的风险）</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2、更新数据（修改数据）</h3>
<p>UPDATE...SET...WHERE...<br>
可以实现批量修改数据的</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3、删除数据</h3>
<p>DELETE FROM...WHERE...<br>
在删除数据时，也有可能因为约束的影响，导致删除失败</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4、MySQL8新特性：计算列</h3>
<p>什么叫计算列呢？简单来说就是某一列的值是通过别的列计算得来的。例如，a列值为1、b列值为2，c列不需要手动插入，定义a+b的结果为c的值，那么c就是计算列，是通过别的列计算得来的。<br>
在MySQL 8.0中，CREATE TABLE 和 ALTER TABLE 中都支持增加计算列。下面以CREATE TABLE为例进行讲解。<br>
举例：定义数据表tb1，然后定义字段id、字段a、字段b和字段c，其中字段c为计算列，用于计算a+b的值。 首先创建测试表tb1，语句如下：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 10、mysql数据类型精讲</h2>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221109155810761.png" alt="image-20221109155810761" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221109155828811.png" alt="image-20221109155828811" loading="lazy"></p>
<h3> 1、字符集设置</h3>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2、整数类型</h3>
<p>整数类型一共有 5 种，包括 TINYINT、SMALLINT、MEDIUMINT、INT（INTEGER）和 BIGINT。<br>
它们的区别如下表所示：</p>
<table>
<thead>
<tr>
<th>整数类型</th>
<th>字节</th>
<th>有符号数取值范围</th>
<th>无符号数取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>TINYINT</td>
<td>1</td>
<td>-128~127</td>
<td>0~255</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>2</td>
<td>-32768~32767</td>
<td>0~65535</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>3</td>
<td>-8388608~8388607</td>
<td>0~16777215</td>
</tr>
<tr>
<td>INT、INTEGER</td>
<td>4</td>
<td>-2147483648~2147483647</td>
<td>0~4294967295</td>
</tr>
<tr>
<td>BIGINT</td>
<td>8</td>
<td>-9223372036854775808~9223372036854775807</td>
<td>0~18446744073709551615</td>
</tr>
</tbody>
</table>
<h4> 可选属性</h4>
<p>整数类型的可选属性有三个：</p>
<p>1、<br>
M : 表示<strong>显示宽度</strong>，M的取值范围是(0, 255)。例如，int(5)：当数据宽度小于5位的时候在数字前面需要用字符填满宽度。该项功能需要配合“ ZEROFILL ”使用，表示用“0”填满宽度，否则指定显示宽度无效。<br>
如果设置了显示宽度，那么插入的数据宽度超过显示宽度限制，会不会截断或插入失败？<br>
答案：不会对插入的数据有任何影响，还是按照类型的实际宽度进行保存，即 显示宽度与类型可以存储的值范围无关 。从MySQL 8.0.17开始，<strong>整数数据类型不推荐使用显示宽度属性</strong>。<br>
整型数据类型可以在定义表结构时指定所需要的显示宽度，如果不指定，则系统为每一种类型指定默认的宽度值。</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2、<br>
UNSIGNED : 无符号类型（非负），所有的整数类型都有一个可选的属性UNSIGNED（无符号属性），无符号整数类型的最小取值为0。所以，如果需要在MySQL数据库中保存非负整数值时，可以将整数类型设置为无符号类型。<br>
int类型默认显示宽度为int(11)，无符号int类型默认显示宽度为int(10)。</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3、<br>
ZEROFILL : 0填充,（如果某列是ZEROFILL，那么MySQL会自动为当前列添加UNSIGNED属性），如果指定了ZEROFILL只是表示不够M位时，用0在左边填充，如果超过M位，只要不超过数据存储范围即可。<br>
原来，在 int(M) 中，M 的值跟 int(M) 所占多少存储空间并无任何关系。 int(3)、int(4)、int(8) 在磁盘上都是占用 4 bytes 的存储空间。也就是说，<strong>int(M)，必须和UNSIGNED ZEROFILL一起使用才有意义</strong>。如果整数值超过M位，就按照实际位数存储。只是无须再用字符 0 进行填充。</p>
<h4> 适用场景</h4>
<p>TINYINT ：一般用于枚举数据，比如系统设定取值范围很小且固定的场景。<br>
SMALLINT ：可以用于较小范围的统计数据，比如统计工厂的固定资产库存数量等。<br>
MEDIUMINT ：用于较大整数的计算，比如车站每日的客流量等。<br>
INT、INTEGER ：取值范围足够大，一般情况下不用考虑超限问题，用得最多。比如商品编号。<br>
BIGINT ：只有当你处理特别巨大的整数时才会用到。比如双十一的交易量、大型门户网站点击量、证<br>
券公司衍生产品持仓等。</p>
<p>你要注意的是，在实际工作中，<strong>系统故障产生的成本远远超过增加几个字段存储空间所产生的成本</strong>。因此，我建议你首先确保数据不会超过取值范围，在这个前提之下，再去考虑如何节省存储空间</p>
<h3> 3、浮点类型</h3>
<p>MySQL支持的浮点数类型，分别是 FLOAT、DOUBLE、REAL。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221109164349992.png" alt="image-20221109164349992" loading="lazy"></p>
<p>REAL默认就是 DOUBLE。如果你把 SQL 模式设定为启用“ REAL_AS_FLOAT ”，那 么，MySQL 就认为REAL 是 FLOAT。如果要启用“REAL_AS_FLOAT”，可以通过以下 SQL 语句实现：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>浮点数无符号数取值范围为有符号数的正数部分：<br>
MySQL 存储浮点数的格式为： 符号(S) 、 尾数(M) 和 阶码(E) 。因此，无论有没有符号，MySQL 的浮点数都会存储表示符号的部分。因此， 所谓的无符号数取值范围，其实就是有符号数取值范围大于等于零的部分。</p>
<h4> 数据精度说明</h4>
<p>对于浮点类型，在MySQL中单精度值使用 4 个字节，双精度值使用 8 个字节。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221109164929025.png" alt="image-20221109164929025" loading="lazy"></p>
<h4> 精度误差说明</h4>
<p>浮点数类型有个缺陷，就是不精准。比如，我们设计一个表，有f1这个字段，插入值分别为0.47,0.44,0.19，我们期待的运行结果是：0.47 + 0.44 + 0.19 =1.1。而使用sum之后查询 结果是 1.0999999999999999。虽然误差很小，但确实有误差。 你也可以尝试把数据类型改成 FLOAT，然后运行求和查询，得到的是， 1.0999999940395355。显然，误差更大了。<br>
MySQL 用 4 个字节存储 FLOAT 类型数据，用 8 个字节来存储 DOUBLE 类型数据。无论哪个，都是<strong>采用二进制的方式</strong>来进行存储的。比如 9.625，用二进制来表达，就是 1001.101，或者表达成 1.001101×2^3。<strong>如果尾数不是 0 或 5（比如 9.624），你就无法用一个二进制数来精确表达</strong>。进而，就只好在取值允许的范围内进行四舍五入。<br>
在编程中，如果用到浮点数，要特别注意误差问题，因为浮点数是不准确的，所以我们<strong>要避免使用“=”来判断两个数是否相等</strong>。同时，在一些<strong>对精确度要求较高的项目中，千万不要使用浮点数</strong>，不然会导致结果错误，甚至是造成不可挽回的损失。那么，MySQL 有没有精准的数据类型呢？当然有，这就是定点数类型：<strong>DECIMAL</strong> 。</p>
<h3> 4、定点类型</h3>
<p>MySQL中的定点数类型只有 DECIMAL 一种类型。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>字节数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>DECIMAL(M,D),DEC,NUMERIC</td>
<td>M+2字节</td>
<td>有效范围由M和D决定</td>
</tr>
</tbody>
</table>
<p><strong>DECIMAL(M,D)的最大取值范围与DOUBLE类型一样</strong>，但是有效的数据范围是由M和D决定的。<br>
DECIMAL 的存储空间并不是固定的，由精度值M决定，<strong>总共占用的存储空间为M+2个字节</strong>。也就是说，在一些对精度要求不高的场景下，比起占用同样字节长度的定点数，浮点数表达的数值范围可以更大一些。<br>
<strong>定点数在MySQL内部是以<mark>字符串</mark>的形式进行存储</strong>，这就决定了它一定是精准的。<br>
当DECIMAL类型不指定精度和标度时，其<strong>默认为DECIMAL(10,0)</strong>。当数据的精度超出了定点数类型的精度范围时，则MySQL同样**会进行四舍五入处理  **</p>
<p>举例：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>开发中经验<br>
由于 DECIMAL 数据类型的精准性，在我们的项目中，<strong>除了极少数（比如商品编号）用到整数类型外，其他的数值都用的是 DECIMAL</strong>，原因就是这个项目所处的零售行业，要求精准，一分钱也不能差。</p>
<h3> 5、位类型</h3>
<p>BIT类型中存储的是二进制值，类似010110</p>
<table>
<thead>
<tr>
<th>二进制字符串类型</th>
<th>长度</th>
<th>长度范围</th>
<th>占用空间</th>
</tr>
</thead>
<tbody>
<tr>
<td>BIT(M)</td>
<td>M</td>
<td>1 &lt;= M &lt;= 64</td>
<td>约为(M + 7)/8个字节</td>
</tr>
</tbody>
</table>
<p>BIT类型，如果没有指定(M)，默认是1位。这个1位，表示只能存1位的二进制值。这里(M)是表示二进制的位数，位数最小值为1，最大值为64。</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用SELECT命令查询位字段时，可以用**BIN()**或 <strong>HEX()</strong> 函数进行读取</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6、日期与时间类型</h3>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>字 节</th>
<th>日期格式</th>
<th>最小值</th>
<th>最大值</th>
</tr>
</thead>
<tbody>
<tr>
<td>YEAR</td>
<td>年</td>
<td>1</td>
<td>YYYY或YY</td>
<td>1901</td>
<td>2155</td>
</tr>
<tr>
<td>TIME</td>
<td>时间</td>
<td>3</td>
<td>HH:MM:SS</td>
<td>-838:59:59</td>
<td>838:59:59</td>
</tr>
<tr>
<td>DATE</td>
<td>日期</td>
<td>3</td>
<td>YYYY-MM-DD</td>
<td>1000-01-01</td>
<td>9999-12-03</td>
</tr>
<tr>
<td>DATETIME</td>
<td>日期 时间</td>
<td>8</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>1000-01-01 00:00:00</td>
<td>9999-12-31 23:59:59</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>日期 时间</td>
<td>4</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>1970-01-01 00:00:00 UTC</td>
<td>2038-01-19 03:14:07UTC</td>
</tr>
</tbody>
</table>
<h4> 1、year类型</h4>
<p>YEAR类型用来表示年份，在所有的日期时间类型中所占用的存储空间最小，只需要 1个字节 的存储空间</p>
<p>在MySQL中，YEAR有以下几种存储格式：<br>
以4位字符串或数字格式表示YEAR类型，其格式为YYYY，最小值为1901，最大值为2155。<br>
以2位字符串格式表示YEAR类型，最小值为00，最大值为99。<br>
当取值为01到69时，表示2001到2069；<br>
当取值为70到99时，表示1970到1999；<br>
当取值整数的0或00添加的话，那么是0000年；<br>
当取值是日期/字符串的'0'添加的话，是2000年。<br>
从MySQL5.5.27开始，2位格式的YEAR已经不推荐使用。YEAR默认格式就是“YYYY”，没必要写成YEAR(4)，<br>
从MySQL 8.0.19开始，不推荐使用指定显示宽度的YEAR(4)数据类型。</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2、DATE类型</h4>
<p>DATE类型表示日期，没有时间部分，格式为 YYYY-MM-DD ，其中，YYYY表示年份，MM表示月份，DD表示日期。需要 <strong>3个字节</strong> 的存储空间。在向DATE类型的字段插入数据时，同样需要满足一定的格式条件。<br>
以 YYYY-MM-DD 格式或者 YYYYMMDD 格式表示的字符串日期，其最小取值为1000-01-01，最大取值为9999-12-03。YYYYMMDD格式会被转化为YYYY-MM-DD格式。<br>
以 YY-MM-DD 格式或者 YYMMDD 格式表示的字符串日期，此格式中，年份为两位数值或字符串满足YEAR类型的格式条件为：当年份取值为00到69时，会被转化为2000到2069；当年份取值为70到99时，会被转化为1970到1999。<br>
使用 CURRENT_DATE() 或者 NOW() 函数，会插入当前系统的日期。</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3、Time类型</h4>
<p>TIME类型用来表示时间，不包含日期部分。在MySQL中，需要 <strong>3个字节</strong> 的存储空间来存储TIME类型的数据，可以使用“HH:MM:SS”格式来表示TIME类型，其中，HH表示小时，MM表示分钟，SS表示秒。<br>
在MySQL中，向TIME类型的字段插入数据时，也可以使用几种不同的格式。<br>
（1）可以使用带有冒号的字符串，比如' D HH:MM:SS' 、' HH:MM:SS '、' HH:MM '、' D HH:MM '、' D HH '或' SS '格式，都能被正确地插入TIME类型的字段中。其中D表示天，其最小值为0，最大值为34。如果使用带有D格式的字符串插入TIME类型的字段时，D会被转化为小时，计算格式为D*24+HH。当使用带有冒号并且不带D的字符串表示时间时，表示当天的时间，比如12:10表示12:10:00，而不是00:12:10。<br>
（2）可以使用不带有冒号的<br>
字符串或者数字，格式为' HHMMSS '或者 HHMMSS 。如果插入一个不合法的字符串或者数字，MySQL在存储数据时，会将其自动转化为00:00:00进行存储。比如1210，MySQL会将最右边的两位解析成秒，表示00:12:10，而不是12:10:00。<br>
（3）使用 CURRENT_TIME() 或者 NOW() ，会插入当前系统的时间。</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4、DATETIME类型</h4>
<p>DATETIME类型在所有的日期时间类型中占用的存储空间最大，总共需要 <strong>8 个字节</strong>的存储空间。在格式上为DATE类型和TIME类型的组合，可以表示为 <strong>YYYY-MM-DD HH:MM:SS</strong> ，其中YYYY表示年份，MM表示月份，DD表示日期，HH表示小时，MM表示分钟，SS表示秒。</p>
<p>在向DTETIME类型的字段插入数据时，同样需要满足一定的格式条件<br>
以 YYYY-MM-DD HH:MM:SS 格式或者 YYYYMMDDHHMMSS 格式的字符串插入DATETIME类型的字段时，最小值为1000-01-01 00:00:00，最大值为9999-12-03 23:59:59。<br>
以YYYYMMDDHHMMSS格式的数字插入DATETIME类型的字段时，会被转化为YYYY-MM-DDHH:MM:SS格式。<br>
以 YY-MM-DD HH:MM:SS 格式或者 YYMMDDHHMMSS 格式的字符串插入DATETIME类型的字段时，两位数的年份规则符合YEAR类型的规则，00到69表示2000到2069；70到99表示1970到1999。</p>
<p>使用函数 <strong>CURRENT_TIMESTAMP() 和 NOW()</strong> ，可以向DATETIME类型的字段插入系统的当前日期和时间。</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 5、TIMESTAMP类型</h4>
<p>TIMESTAMP类型也可以表示日期时间，其显示格式与DATETIME类型相同，都是 YYYY-MM-DD HH:MM:SS ，需要4个字节的存储空间。但是TIMESTAMP存储的时间范围比DATETIME要小很多，<strong>只能存储“1970-01-01 00:00:01 UTC”到“2038-01-19 03:14:07 UTC”之间</strong>的时间。其中，UTC表示世界统一时间，也叫作世界标准时间。</p>
<p>**存储数据的时候需要对当前时间所在的时区进行转换，查询数据的时候再将时间转换回当前的时区。因此，使用TIMESTAMP存储的同一个时间值，在不同的时区查询时会显示不同的时间。  **</p>
<p>向TIMESTAMP类型的字段插入数据时，当插入的数据格式满足YY-MM-DD HH:MM:SS和YYMMDDHHMMSS时，两位数值的年份同样符合YEAR类型的规则条件，只不过表示的时间范围要小很多。如果向TIMESTAMP类型的字段插入的时间超出了TIMESTAMP类型的范围，则MySQL会抛出错误信息。</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> TIMESTAMP和DATETIME的区别：</h4>
<p>TIMESTAMP存储空间比较小，表示的日期时间范围也比较小<br>
底层存储方式不同，TIMESTAMP底层存储的是毫秒值，距离1970-1-1 0:0:0 0毫秒的毫秒值。<br>
两个日期比较大小或日期计算时，TIMESTAMP更方便、更快。<br>
TIMESTAMP和时区有关。TIMESTAMP会根据用户的时区不同，显示不同的结果。而DATETIME则只能反映出插入时当地的时区，其他时区的人查看数据必然会有误差的。</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>**用得最多的日期时间类型，就是 DATETIME 。<br>
此外，一般存注册时间、商品发布时间等，不建议使用DATETIME存储，而是使用 时间戳 ，因为DATETIME虽然直观，但不便于计算。  **</p>
<h3> 7、文本字符串类型</h3>
<p>MySQL中，文本字符串总体上分为 CHAR 、 VARCHAR 、 TINYTEXT 、 TEXT 、 MEDIUMTEXT 、LONGTEXT 、 ENUM 、 SET 等类型。</p>
<h4> 1、CHAR与VARCHAR类型</h4>
<p>CHAR和VARCHAR类型都可以存储比较短的字符串。</p>
<table>
<thead>
<tr>
<th>字符串(文本)类型</th>
<th>特点</th>
<th>长度</th>
<th>长度范围</th>
<th>占用的存储空间</th>
</tr>
</thead>
<tbody>
<tr>
<td>CHAR(M)</td>
<td>固定长度</td>
<td>M</td>
<td>0 &lt;= M &lt;= 255</td>
<td>M个字节</td>
</tr>
<tr>
<td>VARCHAR(M)</td>
<td>可变长度</td>
<td>M</td>
<td>0 &lt;= M &lt;= 65535</td>
<td>(实际长度 + 1) 个字节</td>
</tr>
</tbody>
</table>
<p>CHAR类型：<br>
CHAR(M) 类型一般需要预先定义字符串长度。如果不指定(M)，则表示长度默认是1个字符。<br>
如果保存时，数据的实际长度比CHAR类型声明的长度小，则会在 右侧填充 空格以达到指定的长度。当MySQL检索CHAR类型的数据时，CHAR类型的字段会去除尾部的空格。<br>
定义CHAR类型字段时，声明的字段长度即为CHAR类型字段所占的存储空间的字节数。</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>VARCHAR类型：<br>
VARCHAR(M) 定义时， 必须指定 长度M，否则报错。<br>
MySQL4.0版本以下，varchar(20)：指的是20字节，如果存放UTF8汉字时，只能存6个（每个汉字3字<br>
节） ；MySQL5.0版本以上，varchar(20)：指的是20字符。<br>
检索VARCHAR类型的字段数据时，会保留数据尾部的空格。VARCHAR类型的字段所占用的存储空间为字符串实际长度加1个字节。</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>哪些情况使用 CHAR 或 VARCHAR 更好</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>特点</th>
<th>空间上</th>
<th>时间上</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>CHAR(M)</td>
<td>固定长度</td>
<td>浪费存储空间</td>
<td>效率高</td>
<td>存储不大，速度要求高</td>
</tr>
<tr>
<td>VARCHAR(M)</td>
<td>可变长度</td>
<td>节省存储空间</td>
<td>效率低</td>
<td>非CHAR的情况</td>
</tr>
</tbody>
</table>
<p>存储很短的信息。比如门牌号码101，201……这样很短的信息应该用char<br>
固定长度的。比如使用uuid作为主键，那用char应该更合适。<br>
十分频繁改变的column。因为varchar每次存储都要有额外的计算，得到长度等工作，如果一个非常频繁改变的，那就要有很多的精力用于计算，而这些对于char来说是不需要的。<br>
具体存储引擎中的情况：<br>
MyISAM 数据存储引擎和数据列：MyISAM数据表，最好使用固定长度(CHAR)的数据列代替可变长度(VARCHAR)的数据列。这样使得整个表静态化，从而使 数据检索更快 ，用空间换时间。<br>
MEMORY 存储引擎和数据列：MEMORY数据表目前都使用固定长度的数据行存储，因此无论使用CHAR或VARCHAR列都没有关系，两者都是作为CHAR类型处理的。<br>
<strong>InnoDB 存储引擎</strong>，建议使用VARCHAR类型。因为对于InnoDB数据表，内部的行存储格式并没有区分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），<strong>而且主要影响性能的因素是数据行使用的存储总量</strong>，由于char平均占用的空间多于varchar，所以除了简短并且固定长度的，其他考虑varchar。这样节省空间，对磁盘I/O和数据存储总量比较好</p>
<h4> 2、Text类型</h4>
<p>在MySQL中，TEXT用来保存文本类型的字符串，总共包含4种类型，分别为TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT 类型。<br>
在向TEXT类型的字段保存和查询数据时，系统自动按照实际长度存储，不需要预先定义长度。这一点和VARCHAR类型相同。</p>
<table>
<thead>
<tr>
<th>文本字符串类 型</th>
<th>特点</th>
<th>长 度</th>
<th>长度范围</th>
<th>占用的存储空 间</th>
</tr>
</thead>
<tbody>
<tr>
<td>TINYTEXT</td>
<td>小文本、可变长 度</td>
<td>L</td>
<td>0 &lt;= L &lt;= 255</td>
<td>L + 2 个字节</td>
</tr>
<tr>
<td>TEXT</td>
<td>文本、可变长度</td>
<td>L</td>
<td>0 &lt;= L &lt;= 65535</td>
<td>L + 2 个字节</td>
</tr>
<tr>
<td>MEDIUMTEXT</td>
<td>中等文本、可变 长度</td>
<td>L</td>
<td>0 &lt;= L &lt;= 16777215</td>
<td>L + 3 个字节</td>
</tr>
<tr>
<td>LONGTEXT</td>
<td>大文本、可变长 度</td>
<td>L</td>
<td>0 &lt;= L&lt;= 4294967295（相当于 4GB）</td>
<td>L + 4 个字节</td>
</tr>
</tbody>
</table>
<p>由于实际存储的长度不确定，*<strong>MySQL 不允许 TEXT 类型的字段做主键</strong>。遇到这种情况，你只能采用CHAR(M)，或者 VARCHAR(M)。</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明在保存和查询数据时，并没有删除TEXT类型的数据尾部的空格<br>
TEXT文本类型，可以存比较大的文本段，搜索速度稍慢，因此<strong>如果不是特别大的内容，建议使用CHAR，VARCHAR来代替</strong>。还有TEXT类型不用加默认值，加了也没用。而且text和blob类型的数据删除后容易导致“空洞”，使得文件碎片比较多，所以频繁使用的表不建议包含TEXT类型字段，建议单独分出去，单独用一个表。</p>
<h3> 8、ENUM类型</h3>
<p>ENUM类型也叫作枚举类型，ENUM类型的取值范围需要在定义字段时进行指定。设置字段值时，ENUM类型只允许从成员中选取单个值，不能一次选取多个值。<br>
其所需要的存储空间由定义ENUM类型时指定的成员个数决定。</p>
<table>
<thead>
<tr>
<th>文本字符串类型</th>
<th>长度</th>
<th>长度范围</th>
<th>占用的存储空间</th>
</tr>
</thead>
<tbody>
<tr>
<td>ENUM</td>
<td>L</td>
<td>1 &lt;= L &lt;= 65535</td>
<td>1或2个字节</td>
</tr>
</tbody>
</table>
<p>当ENUM类型包含1～255个成员时，需要1个字节的存储空间；<br>
当ENUM类型包含256～65535个成员时，需要2个字节的存储空间。<br>
ENUM类型的成员个数的上限为65535个。</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 9、SET类型</h3>
<p>SET表示一个字符串对象，可以包含0个或多个成员，但成员个数的上限为 64 。设置字段值时，可以取取值范围内的 0 个或多个值。</p>
<table>
<thead>
<tr>
<th>成员个数范围（L表示实际成员个数）</th>
<th>占用的存储空间</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 &lt;= L &lt;= 8</td>
<td>1个字节</td>
</tr>
<tr>
<td>9 &lt;= L &lt;= 16</td>
<td>2个字节</td>
</tr>
<tr>
<td>17 &lt;= L &lt;= 24</td>
<td>3个字节</td>
</tr>
<tr>
<td>25 &lt;= L &lt;= 32</td>
<td>4个字节</td>
</tr>
<tr>
<td>33 &lt;= L &lt;= 64</td>
<td>8个字节</td>
</tr>
</tbody>
</table>
<p>SET类型在存储数据时成员个数越多，其占用的存储空间越大。注意：SET类型在选取成员时，可以一次选择多个成员，这一点与ENUM类型不同。</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 10、二进制字符串类型</h3>
<p>MySQL中的二进制字符串类型主要存储一些二进制数据，比如可以存储图片、音频和视频等二进制数据。<br>
MySQL中支持的二进制字符串类型主要包括BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和LONGBLOB类型。</p>
<h4> 1、BINARY与VARBINARY类型</h4>
<p>BINARY和VARBINARY类似于CHAR和VARCHAR，只是它们存储的是二进制字符串。</p>
<p>BINARY (M)为固定长度的二进制字符串，M表示最多能存储的字节数，取值范围是0~255个字符。如果未指定(M)，表示只能存储 1个字节 。例如BINARY (8)，表示最多能存储8个字节，如果字段值不足(M)个字节，将在右边填充'\0'以补齐指定长度。<br>
VARBINARY (M)为可变长度的二进制字符串，M表示最多能存储的字节数，总字节数不能超过行的字节长度限制65535，另外还要考虑额外字节开销，VARBINARY类型的数据除了存储数据本身外，还需要1或2个字节来存储数据的字节数。VARBINARY类型 必须指定(M) ，否则报错。</p>
<table>
<thead>
<tr>
<th>二进制字符串类型</th>
<th>特点</th>
<th>值的长度</th>
<th>占用空间</th>
</tr>
</thead>
<tbody>
<tr>
<td>BINARY(M)</td>
<td>固定长度</td>
<td>M （0 &lt;= M &lt;= 255）</td>
<td>M个字节</td>
</tr>
<tr>
<td>VARBINARY(M)</td>
<td>可变长度</td>
<td>M（0 &lt;= M &lt;= 65535）</td>
<td>M+1个字节</td>
</tr>
</tbody>
</table>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 2、BLOB类型</h5>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>BLOB是一个二进制大对象，可以容纳可变数量的数据。<br>
MySQL中的BLOB类型包括TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB 4种类型，它们可容纳值的最大长度不同。可以存储一个二进制的大对象，比如 图片 、 音频 和 视频 等。<br>
需要注意的是，在实际工作中，往往不会在MySQL数据库中使用BLOB类型存储大对象数据，通常会将图片、音频和视频文件存储到 服务器的磁盘上 ，并将图片、音频和视频的访问路径存储到MySQL中。</p>
<table>
<thead>
<tr>
<th>二进制字符串类型</th>
<th>值的长度</th>
<th>长度范围</th>
<th>占用空间</th>
</tr>
</thead>
<tbody>
<tr>
<td>TINYBLOB</td>
<td>L</td>
<td>0 &lt;= L &lt;= 255</td>
<td>L + 1 个字节</td>
</tr>
<tr>
<td>BLOB</td>
<td>L</td>
<td>0 &lt;= L &lt;= 65535（相当于64KB）</td>
<td>L + 2 个字节</td>
</tr>
<tr>
<td>MEDIUMBLOB</td>
<td>L</td>
<td>0 &lt;= L &lt;= 16777215 （相当于16MB）</td>
<td>L + 3 个字节</td>
</tr>
<tr>
<td>LONGBLOB</td>
<td>L</td>
<td>0 &lt;= L &lt;= 4294967295（相当于4GB）</td>
<td>L + 4 个字节</td>
</tr>
</tbody>
</table>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>TEXT和BLOB的使用注意事项：</p>
<p>① BLOB和TEXT值也会引起自己的一些问题，特别是执行了大量的删除或更新操作的时候。删除这种值会在数据表中留下很大的" 空洞 "，以后填入这些"空洞"的记录可能长度不同。为了提高性能，建议定期使用 OPTIMIZE TABLE 功能对这类表进行 碎片整理<br>
② 如果需要对大文本字段进行模糊查询，MySQL 提供了 前缀索引 。但是仍然要在不必要的时候避免检索大型的BLOB或TEXT值。例如，SELECT * 查询就不是很好的想法，除非你能够确定作为约束条件的WHERE子句只会找到所需要的数据行。否则，你可能毫无目的地在网络上传输大量的值。<br>
③ 把BLOB或TEXT列 分离到单独的表 中。在某些环境中，如果把这些数据列移动到第二张数据表中，可以让你把原数据表中的数据列转换为固定长度的数据行格式，那么它就是有意义的。这会 减少主表中的碎片 ，使你得到固定长度数据行的性能优势。它还使你在主数据表上运行 SELECT * 查询的时候不会通过网络传输大量的BLOB或TEXT值。</p>
<h3> 11、JSON类型</h3>
<p>JSON（JavaScript Object Notation）是一种轻量级的 数据交换格式 。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。它易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。<strong>JSON 可以将 JavaScript 对象中表示的一组数据转换为字符串，然后就可以在网络或者程序之间轻松地传递这个字符串，并在需要的时候将它还原为各编程语言所支持的数据格式。</strong></p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过“-&gt;”和“-&gt;&gt;”符号，从JSON字段中正确查询出了指定的JSON数据的值。</p>
<h3> 12、小结及选择建议</h3>
<p>在定义数据类型时，如果确定是<strong>整数</strong>，就用 <strong>INT</strong> ； 如果是<strong>小数</strong> ，一定用定点数类型<strong>DECIMAL(M,D)</strong> ； 如果是<strong>日期与时间</strong>，就用 **DATETIME  **</p>
<p>阿里巴巴《Java开发手册》之MySQL数据库：<br>
任何字段如果为非负数，必须是 UNSIGNED<br>
【 强制 】小数类型为<strong>DECIMAL</strong>，禁止使用 FLOAT 和 DOUBLE。<br>
说明：在存储的时候，FLOAT 和 DOUBLE 都存在精度损失的问题，很可能在比较值的时候，得到不正确的结果。如果存储的数据范围超过 DECIMAL 的范围，建议将数据拆成整数和小数并分开存储。<br>
【 强制 】如果存储的字符串长度几乎相等，使用 CHAR 定长字符串类型。<br>
【 强制 】VARCHAR 是可变长字符串，不预先分配存储空间，长度不要超过 5000。如果存储长度大<br>
于此值，定义字段类型为 TEXT，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</p>
<h2> 11、约束</h2>
<p>为什么需要约束：为了保证数据的完整性<br>
什么叫约束：对表中字段的限制<br>
约束的分类：<br>
约束的字段的个数（单列约束，多列约束）<br>
约束的作用范围（列级约束，表级约束）<br>
约束的作用（或功能）</p>
<p>查看表中的约束：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1、非空约束</h3>
<p>作用：限定某个字段/某列的值不允许为空<br>
<strong>关键字：not null</strong></p>
<h4> 1、添加非空约束</h4>
<p>1、建表前：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2、建表后</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2、删除非空约束</h4>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2、唯一性约束</h3>
<p>用来限制某个字段/某列的值不能重复<br>
<strong>关键字：UNIQUE</strong></p>
<p>同一个表可以有多个唯一约束。<br>
唯一约束可以是某一个列的值唯一，也可以多个列组合的值唯一。<br>
唯一性约束允许列值为空。<br>
在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同。<br>
**MySQL会给唯一约束的列上默认创建一个唯一索引。  **</p>
<p><strong>可以向声明null为unique的字段上添加null值，而且可以多次添加null值</strong></p>
<h4> 1、添加唯一性约束</h4>
<p>1、建表时</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2、建表后指定唯一键约束</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2、关于复合唯一约束</h4>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3、删除唯一约束</h4>
<p>添加唯一性约束的列上也会自动创建唯一索引。<br>
删除唯一约束只能通过删除唯一索引的方式删除。<br>
删除时需要指定唯一索引名，唯一索引名就和唯一约束名一样。<br>
如果创建唯一约束时未指定名称，如果是单列，就默认和列名相同；如果是组合列，那么默认和()中排在第一个的列名相同。也可以自定义唯一性约束名。</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：可以通过 show index from 表名称; 查看表的索引</p>
<h3> 3、PRIMARY KEY 约束</h3>
<p>用来唯一标识表中的一行记录。<br>
<strong>关键字：primary key  **<br>
主键约束相当于</strong>唯一约束+非空约束的组合**，主键约束列不允许重复，也不允许出现空值</p>
<p>一个表最多只能有一个主键约束，建立主键约束可以在列级别创建，也可以在表级别上创建。<br>
如果是多列组合的复合主键约束，那么这些列都不允许为空值，并且组合的值不允许重复 。<br>
<strong>MySQL的主键名总是PRIMARY</strong>，就算自己命名了主键约束名也没用<br>
当创建主键约束时，系统默认会在所在的列或列组合上<strong>建立对应的主键索引</strong>（能够根据主键查询的，就根据主键查询，效率更高）。如果删除主键约束了，主键约束对应的索引就自动删除了。<br>
需要注意的一点是，不要修改主键字段的值。因为主键是数据记录的唯一标识，如果修改了主键的值，就有可能会破坏数据的完整性。</p>
<h4> 1、添加主键约束</h4>
<p>1、建表时指定主键约束  ：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2、建表后增加主键约束</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2、删除主键约束</h4>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4、自增列：AUTO_INCREMENT</h3>
<p>作用：某个字段的值自增<br>
**关键字：auto_increment  **</p>
<p><strong>一个表最多只能有一个自增长列</strong><br>
当需要产生唯一标识符或顺序值时，可设置自增长<br>
自增长列约束的列<strong>必须是键列</strong>（主键列，唯一键列）<br>
自增约束的列的数据类型必须是<strong>整数类型</strong><br>
**如果自增列指定了 0 和 null，会在当前最大值的基础上自增；如果自增列手动指定了具体值，直接赋值为具体值。  **</p>
<p>开发中，一旦逐渐作用的字段上声明有Auto_INCREMENT，则我们在添加数据时，就不要给逐主键对应的字段赋值了</p>
<h4> 1、指定自增约束</h4>
<p>1、建表时：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2、建表后：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2、删除自增约束</h4>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3、MySQL 8.0新特性—自增变量的持久化</h4>
<p>在MySQL 8.0之前，自增主键AUTO_INCREMENT的值如果大于max(primary key)+1，在MySQL重启后，会重置AUTO_INCREMENT=max(primary key)+1，这种现象在某些情况下会导致业务主键冲突或者其他难以发现的问题。</p>
<p>在MySQL 5.7系统中，对于自增主键的分配规则，是由InnoDB数据字典内部一个 计数器 来决定的，而<strong>该计数器只在内存中维护</strong> ，并不会持久化到磁盘中。**当数据库重启时，该计数器会被初始化 **</p>
<p><strong>MySQL 8.0将自增主键的计数器持久化到重做日志中</strong>。每次计数器发生改变，都会将其写入重做日志中。如果数据库重启，InnoDB会根据重做日志中的信息来初始化计数器的内存值。</p>
<h3> 5、FOREIGN KEY 约束</h3>
<p>作用：限定某个表的某个字段的引用完整性。<br>
比如：员工表的员工所在部门的选择，必须在部门表能找到对应的部分。<br>
**关键字：FOREIGN KEY **</p>
<h4> 1、主表和从表/父表和子表</h4>
<p>主表（父表）：<strong>被引用</strong>的表，<strong>被参考</strong>的表<br>
从表（子表）：**引用别人的表，参考别人的表  **</p>
<h4> 2、特点</h4>
<p>1、从表的外键列，必须<strong>引用/参考主表的主键或唯一约束的列</strong>，因为被依赖/被参考的值必须是唯一的<br>
2、在创建外键约束时，如果<strong>不给外键约束命名</strong>，默认名不是列名，而是<strong>自动产生一个外键名</strong>（例如student_ibfk_1;），也可以指定外键约束名<br>
3、创建(CREATE)表时就指定外键约束的话，<strong>先创建主表，再创建从表</strong><br>
4、删表时，<strong>先删从表（或先删除外键约束），再删除主表 **<br>
5、当主表的记录被从表参照时，主表的记录将不允许删除，<strong>如果要删除数据，需要先删除从表中依赖该记录的数据</strong>，然后才可以删除主表的数据<br>
6、在“从表”中指定外键约束，并且</strong>一个表可以建立多个外键约束 ****<br>
7、<strong>从表的外键列与主表被参照的列名字可以不相同</strong>，但是<strong>数据类型必须一样</strong>，逻辑意义一致。如果类型不一样，创建子表时，就会出现错误“ERROR 1005 (HY000): Can't createtable'database.tablename'(errno: 150)”。<br>
8、<strong>当创建外键约束时，系统默认会在所在的列上建立对应的普通索引</strong>。但是索引名是外键的约束名。（根据外键查询效率很高）<br>
9、删除外键约束后，必须 <strong>手动</strong>删除对应的索引</p>
<h4> 3、添加外键约束</h4>
<p>1、建表时：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2、建表后</p>
<p>一般情况下，表与表的关联都是提前设计好了的，因此，会在创建表的时候就把外键约束定义好。不过，如果需要修改表的设计（比如添加新的字段，增加新的关联关系），但没有预先定义外键约束，那么，就要用修改表的方式来补充定义</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>总结：约束关系是针对双方的<br>
添加了外键约束后，主表的修改和删除数据受约束<br>
添加了外键约束后，从表的添加和修改数据受约束<br>
在从表上建立外键，要求主表必须存在<br>
删除主表时，要求从表从表先删除，或将从表中外键引用该主表的关系先删除</p>
<h4> 4、约束等级</h4>
<p>Cascade方式 ：在父表上update/delete记录时，同步update/delete掉子表的匹配记录<br>
Set null方式 ：在父表上update/delete记录时，将子表上匹配记录的列设为null，但是要注意子表的外键列不能为not null<br>
No action方式 ：如果子表中有匹配的记录，则不允许对父表对应候选键进行update/delete操作<br>
Restrict方式 ：同no action， 都是立即检查外键约束<br>
Set default方式 （在可视化工具SQLyog中可能显示空白）：父表有变更时，子表将外键列设置成一个默认的值，但Innodb不能识别</p>
<p>如果没有指定等级，就相当于Restrict方式。<br>
对于外键约束，最好是采用: <strong>ON UPDATE CASCADE ON DELETE RESTRICT</strong> 的方式。</p>
<h4> 5、删除外键约束</h4>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 6、开发场景</h4>
<p>1、如果两个表之间有关系（一对一、一对多），比如：员工表和部门表（一对多），它们之间<strong>不一定要建外键约束</strong><br>
2、<strong>建外键约束</strong>，你的操作（创建表、删除表、添加、修改、删除）<strong>会受到限制</strong>，从语法层面受到限制。<br>
<strong>不建外键约束</strong>，你的操作（创建表、删除表、添加、修改、删除）<strong>不受限制</strong>，要保证数据的 引用完整<br>
性 ，只能<strong>依靠程序员的自觉</strong> ，或者是 在<strong>Java程序中进行限定</strong> 。例如：在员工表中，可以添加一个员工的<br>
信息，它的部门指定为一个完全不存在的部门。<br>
3、<strong>建和不建外键约束和查询没有关系</strong></p>
<p>在 MySQL 里，外键约束是有成本的，需要消耗系统资源。对于大并发的 SQL 操作，有可能会不适合。比如大型网站的中央数据库，可能会 因为外键约束的系统开销而变得非常慢 。所以， MySQL 允许你不使用系统自带的外键约束，<strong>在 应用层面 完成检查数据一致性的逻辑</strong>。也就是说，即使你不用外键约束，也要想办法通过应用层面的附加逻辑，来实现外键约束的功能，确保数据的一致性。</p>
<p><strong>阿里开发规范</strong><br>
【 强制 】不得使用外键与级联，一切外键概念必须在应用层解决。<br>
说明：（概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于 单机低并发 ，不适合 分布式 、 高并发集群 ；级联更新是强阻塞，存在数据库 更新风暴 的风险；外键影响数据库的 插入速度 。</p>
<h3> 6、check约束</h3>
<p>作用：检查某个字段的值是否符号xx要求，一般指的是值的范围<br>
关键字：CHECK<br>
MySQL5.7 可以使用check约束，但check约束对数据验证没有任何作用。添加数据时，没有任何错误或警告。但是MySQL 8.0中可以使用check约束了。</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7、DEFAULT约束</h3>
<p>作用：给某个字段/某列指定默认值，一旦设置默认值，在插入数据时，如果此字段没有显式赋值，则赋值为默认值<br>
关键字：DEFAULT</p>
<h4> 1、给字段加默认值</h4>
<p>1、建表时：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2、建表后</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2、删除默认值约束</h4>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 12、视图</h2>
<h3> 1、视图概述</h3>
<p>视图是一种<strong>虚拟表</strong>，本身是<strong>不具有数据</strong>的，占用很少的内存空间<br>
视图<strong>建立在已有表的基础上</strong>, 视图赖以建立的这些表称为<strong>基表</strong><br>
视图本质是<strong>存储起来的select语句</strong><br>
<mark>针对视图做DML操作，会影响到对应的基表中的数据。反之亦然</mark><br>
视图本身的删除，不会导致基表中数据的删除<br>
视图的应用场景：针对小型项目，不推荐使用视图，针对大型项目可以考虑<br>
视图的优点：<strong>简化查询；控制数据的访问</strong></p>
<h3> 2、创建视图</h3>
<p>在 CREATE VIEW 语句中嵌入子查询</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1、创建单表视图</h4>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明1：实际上就是我们在 SQL 查询语句的基础上封装了视图 VIEW，这样就会基于 SQL 语句的结果集形成一张虚拟表。<br>
说明2：在创建视图时，没有在视图名后面指定字段列表，则视图中字段列表默认和SELECT语句中的字段列表一致。如果SELECT语句中给字段取了别名，那么视图中的字段名和别名相同。</p>
<h4> 2、创建多表联合视图</h4>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>利用视图对数据进行格式化<br>
我们经常需要输出某个格式的内容，比如我们想输出员工姓名和对应的部门名，对应格式为emp_name(department_name)，就可以使用视图来完成数据格式化的操作：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3、基于视图创建视图</h4>
<p>当我们创建好一张视图之后，还可以在它的基础上继续创建视图。</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3、查看视图</h3>
<p>语法1：查看数据库的表对象、视图对象</p>
<div class="language-msyql line-numbers-mode" data-ext="msyql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>语法2：查看视图的结构</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>语法3：查看视图的属性信息</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>语法4：查看视图的详细定义信息</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 4、更新视图的数据</h3>
<h4> 1、一般情况</h4>
<p>MySQL支持使用INSERT、UPDATE和DELETE语句对视图中的数据进行插入、更新和删除操作。当视图中的数据发生变化时，数据表中的数据也会发生变化，反之亦然。</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2、不可更新的视图</h4>
<p>要使视图可更新，视图中的行和底层基本表中的行之间必须存在<strong>一对一</strong>的关系。另外当视图定义出现如下情况时，视图不支持更新操作：<br>
在定义视图的时候指定了“ALGORITHM = TEMPTABLE”，视图将不支持INSERT和DELETE操作；<br>
视图中不包含基表中所有被定义为非空又未指定默认值的列，视图将不支持INSERT操作；<br>
在定义视图的SELECT语句中使用了 <strong>JOIN联合查询</strong> ，视图将不支持INSERT和DELETE操作；<br>
在定义视图的SELECT语句后的字段列表中使用了 <strong>数学表达式</strong> 或<strong>子查询 <strong>，视图将不支持INSERT，也<br>
不支持UPDATE使用了数学表达式、子查询的字段值；<br>
在定义视图的SELECT语句后的字段列表中使用</strong>DISTINCT 、 聚合函数 、 GROUP BY 、 HAVING 、UNION 等，视图将不支持INSERT、UPDATE、DELETE</strong>；<br>
在定义视图的SELECT语句中包含了子查询，而子查询中引用了FROM后面的表，视图将不支持INSERT、UPDATE、DELETE；<br>
视图定义基于一个 <strong>不可更新视图</strong> ；<br>
常量视图。</p>
<p>总结：虽然可以更新视图数据，但总的来说，<strong>视图作为 虚拟表 ，主要用于方便查询</strong> ，<strong>不建议更新视图的数据。对视图数据的更改</strong>，都是通过对实际数据表里数据的操作来完成的。</p>
<h3> 5、修改、删除视图</h3>
<p>方式1：使用CREATE OR REPLACE VIEW 子句修改视图</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>方式2：ALTER VIEW</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6、删除视图</h3>
<p>删除视图只是删除视图的定义，并不会删除基表的数据。<br>
删除视图的语法是：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：基于视图a、b创建了新的视图c，<strong>如果将视图a或者视图b删除，会导致视图c的查询失败</strong>。这样的<strong>视图c需要手动删除或修改</strong>，否则影响使用。</p>
<h3> 7、总结</h3>
<h4> 1、视图优点</h4>
<p>1、操作简单<br>
2、减少数据冗余<br>
3、数据安全<br>
MySQL将用户对数据的 访问限制 在某些数据的结果集上，而这些数据的结果集可以使用视图来实现。用户不必直接查询或操作数据表。这也可以理解为视图	具有 隔离性 。视图相当于在用户和实际的数据表之间加了一层虚拟表。  同时，MySQL可以根据权限将用户对数据的访问限制在某些视图上，用户<strong>不需要查询	数据表，可以直接通过视图获取数据表中的信息</strong>。这在一定程度上保障了数据表中数据的安全性。<br>
4、适应灵活多变的需求<br>
5、能够分解复杂的查询逻辑</p>
<h4> 2、视图不足</h4>
<p>如果我们在实际数据表的基础上创建了视图，那么，<strong>如果实际数据表的结构变更了，我们就需要及时对相关的视图进行相应的维护</strong>。特别是嵌套的视图（就是在视图的基础上创建视图），维护会变得比较复杂， 可读性不好 ，容易变成系统的潜在隐患。因为创建视图的 SQL 查询可能会对字段重命名，也可能包含复杂的逻辑，这些都会增加维护的成本。实际项目中，如果视图过多，会导致数据库维护成本的问题。<br>
所以，在创建视图的时候，你要结合实际项目需求，综合考虑视图的优点和不足，这样才能正确使用视图，使系统整体达到最优。<br>
一旦存储过程被创建出来，使用它就像使用函数一样简单，我们直接通过调用存储过程名即可。相较于函数，存储过程是<strong>没有返回值</strong>的。</p>
<h2> 13、存储过程与函数</h2>
<h3> 1、存储过程概述</h3>
<p>含义：存储过程的英文是 Stored Procedure 。它的思想很简单，就是一组经过<strong>预先编译的 SQL 语句的封装</strong>。<br>
执行过程：存储过程<strong>预先存储在 MySQL 服务器上</strong>，需要执行的时候，客户端只需要<strong>向服务器端发出调用存储过程的命令</strong>，服务器端就可以把预先存储好的这一系列 SQL 语句全部执行。</p>
<p>分类：<br>
存储过程的参数类型可以是IN、OUT和INOUT。根据这点分类如下：<br>
1、没有参数（无参数无返回）<br>
2、仅仅带 IN 类型（有参数无返回）<br>
3、仅仅带 OUT 类型（无参数有返回）<br>
4、既带 IN 又带 OUT（有参数有返回） 5、带 INOUT（有参数有返回）<br>
注意：IN、OUT、INOUT 都可以在一个存储过程中带多个。</p>
<h3> 2、创建存储过程</h3>
<p>语法：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>IN ：当前参数为输入参数，也就是表示入参； 如果没有定义参数种类， <strong>默认就是 IN</strong> ，表示输入参数<br>
OUT ：当前参数为输出参数，也就是表示出参；<br>
INOUT ：当前参数既可以为输入参数，也可以为输出参数<br>
characteristics 表示创建存储过程时指定的对存储过程的约束条件<br>
存储过程体中可以有多条 SQL 语句，如果仅仅一条SQL 语句，则可以省略 BEGIN 和 END</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3、调用存储过程</h3>
<p>存储过程有多种调用方法。存储过程必须使用CALL语句调用，并且存储过程和数据库相关，如果要执行其他数据库中的存储过程，需要指定数据库名称，例如CALL dbname.procname。</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>1、调用in模式的参数：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>2、调用out模式的参数：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3、调用inout模式的参数：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4、如何调试</h3>
<p>在 MySQL 中，存储过程不像普通的编程语言（比如 VC++、Java 等）那样有专门的集成开发环境。因此，你可以通过 SELECT 语句，把程序执行的中间结果查询出来，来调试一个 SQL 语句的正确性。调试成功之后，把 SELECT 语句后移到下一个 SQL 语句之后，再调试下一个 SQL 语句。这样 逐步推进 ，就可以完成对存储过程中所有操作的调试了。当然，你也可以把存储过程中的 SQL 语句复制出来，逐段单独调试</p>
<h3> 5、 存储函数的使用</h3>
<p>前面学习了很多函数，使用这些函数可以对数据进行的各种处理操作，极大地提高用户对数据库的管理效率。MySQL支持<strong>自定义函数</strong>，定义好之后，调用方式与调用MySQL预定义的系统函数一样。</p>
<p>语法格式：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：<br>
1、参数列表：指定参数为IN、OUT或INOUT只对PROCEDURE是合法的，FUNCTION中总是默认为IN参数。<br>
2、RETURNS type 语句表示函数返回数据的类型；RETURNS子句只能对FUNCTION做指定，对函数而言这是 强制 的。它用来指定函数的返回类型，而且函数体必须包含一个 RETURN value 语句。<br>
3、characteristic 创建函数时指定的对函数的约束。取值与创建存储过程时相同，这里不再赘述。<br>
4、函数体也可以用BEGIN…END来表示SQL代码的开始和结束。如果函数体只有一条语句，也可以省略BEGIN…END。</p>
<h3> 6、调用存储函数</h3>
<p>在MySQL中，存储函数的使用方法与MySQL内部函数的使用方法是一样的。换言之，用户自己定义的存储函数与MySQL内部函数是一个性质的。区别在于，存储函数是 用户自己定义 的，而内部函数是MySQL的 开发者定义 的。</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>举例1：创建存储函数，名称为email_by_name()，参数定义为空，该函数查询Abel的email，并返回，数据类型为字符串型。</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>举例2：创建存储函数，名称为email_by_id()，参数传入emp_id，该函数查询emp_id的email，并返回，数据类型为字符串型。</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>若在创建存储函数中报错“ you might want to use the less safelog_bin_trust_function_creators variable ”，有两种处理方法：<br>
方式1：加上必要的函数特性“[NOT] DETERMINISTIC”和“{CONTAINS SQL | NO SQL | READS SQL DATA |MODIFIES SQL DATA}<br>
方式2：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>对比存储函数和存储过程</strong></p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>调用语法</th>
<th>返回值</th>
<th>应用场景</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>存储过程</td>
<td>PROCEDURE</td>
<td>CALL 存储过 程()</td>
<td>理解为有0个或 多个</td>
<td>一般用于更新</td>
</tr>
<tr>
<td>存储函数</td>
<td>FUNCTION</td>
<td>SELECT 函数 ()</td>
<td>只能是一个</td>
<td>一般用于查询结果为一个值并 返回时</td>
</tr>
</tbody>
</table>
<p>此外，<strong>存储函数可以放在查询语句中使用，存储过程不行</strong>。反之，存储过程的功能更加强大，包括能够执行对表的操作（比如创建表，删除表等）和事务操作，这些功能是存储函数不具备的。</p>
<h3> 7、存储过程和函数的查看、修改、删除</h3>
<h4> 1、查看</h4>
<p>MySQL存储了存储过程和函数的状态信息，用户可以使用SHOW STATUS语句或SHOW CREATE语句来查看，也可直接从系统的information_schema数据库中查询。这里介绍3种方法。</p>
<p>1、使用SHOW CREATE语句查看存储过程和函数的创建信息</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2、使用SHOW STATUS语句查看存储过程和函数的状态信息</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3、从information_schema.Routines表中查看存储过程和函数的信息</p>
<p>MySQL中存储过程和函数的信息存储在information_schema数据库下的Routines表中。可以通过查询该表的记录来查询存储过程和函数的信息。</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：如果在MySQL数据库中存在存储过程和函数名称相同的情况，最好指定ROUTINE_TYPE查询条件来指明查询的是存储过程还是函数。</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2、修改  ：</h4>
<p>修改存储过程或函数，不影响存储过程或函数功能，只是修改相关特性。使用ALTER语句实现。</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其中，characteristic指定存储过程或函数的特性，其取值信息与创建存储过程、函数时的取值信息略有不同</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>CONTAINS SQL ，表示子程序包含SQL语句，但不包含读或写数据的语句。<br>
NO SQL ，表示子程序中不包含SQL语句。<br>
READS SQL DATA ，表示子程序中包含读数据的语句。<br>
MODIFIES SQL DATA ，表示子程序中包含写数据的语句。<br>
SQL SECURITY { DEFINER | INVOKER } ，指明谁有权限来执行。<br>
DEFINER ，表示只有定义者自己才能够执行。<br>
INVOKER ，表示调用者可以执行。<br>
COMMENT 'string' ，表示注释信息。</p>
<p>修改存储过程使用ALTER PROCEDURE语句，修改存储函数使用ALTER FUNCTION语句。但是，这两个语句的结构是一样的，语句中的所有参数也是一样的</p>
<p>举例1：<br>
修改存储过程CountProc的定义。将读写权限改为MODIFIES SQL DATA，并指明调用者可以执行，代码如下：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查询修改后的信息：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3、删除</h4>
<p>删除存储过程和函数，可以使用DROP语句，其语法结构如下：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>IF EXISTS：如果程序或函数不存储，它可以防止发生错误，产生一个用SHOW WARNINGS查看的警告。</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8、存储过程的优缺点</h3>
<p>优点：<br>
1、存储过程可以一次编译多次使用。<br>
2、可以减少开发工作量<br>
3、存储过程的安全性强。<br>
4、可以减少网络传输量。<br>
5、良好的封装性。</p>
<p>缺点：<br>
1、良好的封装性<br>
2、调试困难<br>
3、调试困难<br>
4、它不适合高并发的场景。</p>
<p>小结：<br>
存储过程既方便，又有局限性。尽管不同的公司对存储过程的态度不一，但是对于我们开发人员来说，不论怎样，掌握存储过程都是必备的技能之一。</p>
<h2> 14、变量、流程控制与游标</h2>
<h3> 1、变量</h3>
<p>在MySQL数据库的存储过程和函数中，可以使用变量来存储查询或计算的中间结果数据，或者输出最终的结果数据<br>
在 MySQL 数据库中，变量分为<strong>系统变量</strong>以及<strong>用户自定义变量</strong>。</p>
<h4> 1、系统变量</h4>
<p>由系统定义，不是用户定义，属于<strong>服务器</strong>层面。  启动MySQL服务，生成MySQL服务实例期间，MySQL将为MySQL服务器内存中的系统变量赋值，这些系统变量定义了当前MySQL服务实例的属性、特征。这些系统变量的值要么是 编译MySQL时参数 的默认值，要么是 配置文件 （例如my.ini等）中的参数值。<br>
系统变量分为<strong>全局系统变量</strong>（需要添加 global 关键字）以及<strong>会话系统变量</strong>（需要添加 session 关键字），有时也把全局系统变量简称为全局变量，有时也把会话系统变量称为local变量  ，<strong>如果不写，默认会话级别</strong>。</p>
<p>每一个MySQL客户机成功连接MySQL服务器后，都会产生与之对应的会话。<br>
全局系统变量针对于所有会话（连接）有效，但 不能跨重启<br>
会话系统变量仅针对于当前会话（连接）有效。会话期间，当前会话对某个会话系统变量值的修改，不会影响其他会话同一个会话系统变量的值。<br>
会话1对某个全局系统变量值的修改会导致会话2中同一个全局系统变量值的修改</p>
<p>在MySQL中有些系统变量只能是全局的，例如 max_connections 用于限制服务器的最大连接数；有些系统变量作用域既可以是全局又可以是会话，例如 character_set_client 用于设置客户端的字符集；有些系统变量的作用域只能是当前会话，例如 pseudo_thread_id 用于标记当前会话的 MySQL 连接 ID。</p>
<h5> 查看系统变量</h5>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 查看指定系统变量</h5>
<p>MySQL 中的系统变量以 <strong>两个“@” 开头</strong>，其中“@@global”仅用于标记全局系统变量，“@@session”仅用于标记会话系统变量。“@@”首先标记会话系统变量，如果会话系统变量不存在，则标记全局系统变量</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 修改系统变量的值</h5>
<p>有些时候，数据库管理员需要修改系统变量的默认值，以便修改当前会话或者MySQL服务实例的属性、特征。具体方法：<br>
方式1：修改MySQL 配置文件 ，继而修改MySQL系统变量的值（该方法需要重启MySQL服务）<br>
方式2：在MySQL服务运行期间，使用“set”命令重新设置系统变量的值</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2、用户变量</h4>
<p>用户变量的分类：会话用户变量，局部变量</p>
<p>会话用户变量：使用‘@’开通，作用域为当前会话有效<br>
局部变量：只能使用在存储过程和存储函数中</p>
<h5> 1、会话用户变量</h5>
<h6> 变量的声明和赋值：</h6>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h6> 变量的使用</h6>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 2、局部变量</h5>
<p>局部变量：<br>
①必须使用DECLARE声明<br>
②声明并使用在BEGIN...END中（使用在存储过程，存储函数中）<br>
③DECLARE的方式声明的局部变量必须声明在BEGIN中的首行的位置</p>
<h6> 定义变量</h6>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h6> 变量赋值</h6>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h6> 使用变量（查看、比较、运算等）</h6>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2、定义条件与处理程序</h3>
<p>定义条件 是<strong>事先定义程序执行过程中可能遇到的问题</strong>，处理程序定义了在遇到问题时应当采取的处理方式，并且保证存储过程或函数在遇到警告或错误时能继续执行。这样可以增强存储程序处理问题的能力，避免程序异常停止运行。<br>
说明：定义条件和处理程序在存储过程、存储函数中都是支持的。</p>
<h4> 定义条件</h4>
<p>定义条件就是给MySQL中的错误码命名，这有助于存储的程序代码更清晰。它将一个 错误名字 和 指定的错误条件 关联起来。这个名字可以随后被用在定义处理程序的 DECLARE HANDLER 语句中。</p>
<p>定义条件使用DECLARE语句，语法格式如下：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>错误码的说明：<br>
MySQL_error_code 和 sqlstate_value 都可以表示MySQL的错误。<br>
MySQL_error_code是数值类型错误代码。<br>
sqlstate_value是长度为5的字符串类型错误代码。<br>
例如，在ERROR 1418 (HY000)中，1418是MySQL_error_code，'HY000'是sqlstate_value。<br>
例如，在ERROR 1142（42000）中，1142是MySQL_error_code，'42000'是sqlstate_value。</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 定义处理程序</h4>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20221114210010921.png" alt="image-20221114210010921" loading="lazy"></p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>举例：创建一个名称为“InsertDataWithCondition”的存储过程，代码如下。<br>
在存储过程中，定义处理程序，捕获sqlstate_value值，当遇到sqlstate_value值为23000时，执行EXIT操作，并且将@proc_value的值设置为-1。</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3、流程控制</h3>
<p>针对于MySQL 的流程控制语句主要有 3 类。注意：只能用于存储程序。<br>
条件判断语句 ：IF 语句和 CASE 语句<br>
循环语句 ：LOOP、WHILE 和 REPEAT 语句<br>
跳转语句 ：ITERATE 和 LEAVE 语句</p>
<h4> 1、分支结构IF</h4>
<p>IF 语句的语法结构是：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>特点：① 不同的表达式对应不同的操作 ② 使用在begin end中</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2、分支结构之 CASE</h4>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3、循环结构之LOOP</h4>
<p>LOOP循环语句用来重复执行某些语句。LOOP内的语句一直重复执行直到循环被退出（使用LEAVE子句），跳出循环过程。</p>
<p>LOOP语句的基本格式如下：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中，loop_label表示LOOP语句的标注名称，该参数可以省略。</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4、循环结构之WHILE</h4>
<p>WHILE语句创建一个带条件判断的循环过程。WHILE在执行语句执行时，先对指定的表达式进行判断，如果为真，就执行循环内的语句，否则退出循环。WHILE语句的基本格式如下：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 5、循环结构之REPEAT</h4>
<p>REPEAT语句创建一个带条件判断的循环过程。与WHILE循环不同的是，<strong>REPEAT 循环首先会执行一次循环</strong>，然后在 UNTIL 中进行表达式的判断，如果满足条件就退出，即 END REPEAT；如果条件不满足，则会就继续执行循环，直到满足退出条件为止。</p>
<p>REPEAT语句的基本格式如下：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>repeat_label为REPEAT语句的标注名称，该参数可以省略；REPEAT语句内的语句或语句群被重复，直至expr_condition为真。</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 6、跳转语句之LEAVE语句</h4>
<p>LEAVE语句：可以用在循环语句内，或者以 BEGIN 和 END 包裹起来的程序体内，表示跳出循环或者跳出程序体的操作。如果你有面向过程的编程语言的使用经验，你可以把 LEAVE 理解为 break。</p>
<p>基本格式如下：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其中，label参数表示循环的标志。LEAVE和BEGIN ... END或循环一起被使用。</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 7、跳转语句之ITERATE语句</h4>
<p>ITERATE语句：只能用在循环语句（LOOP、REPEAT和WHILE语句）内，表示重新开始循环，将执行顺序转到语句段开头处。如果你有面向过程的编程语言的使用经验，你可以把 ITERATE 理解为 continue，意思为“再次循环”。</p>
<p>语句基本格式如下：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>label参数表示循环的标志。ITERATE语句必须跟在循环标志前面。</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4、游标</h3>
<p>游标，提供了一种灵活的操作方式，让我们能够对结果集中的<strong>每一条记录进行定位</strong>，并对指向的记录中的数据进行操作的数据结构。游标让 SQL 这种面向集合的语言有了<strong>面向过程开发的能力</strong>。 **充当了指针的作用   **<br>
MySQL中游标可以在存储过程和函数中使用。</p>
<h4> 1、使用游标步骤</h4>
<p>游标必须在声明处理程序之前被声明，并且变量和条件还必须在声明游标或处理程序之前被声明。<br>
如果我们想要使用游标，一般需要经历四个步骤。不同的 DBMS 中，使用游标的语法可能略有不同。</p>
<p>第一步，声明游标<br>
在MySQL中，使用DECLARE关键字来声明游标，其语法的基本形式如下：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>要使用 SELECT 语句来获取数据结果集，而此时还没有开始遍历数据，这里 select_statement 代表的是SELECT 语句，返回一个用于创建游标的结果集<br>
比如：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2、打开游标</h4>
<p>打开游标的语法如下：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当我们定义好游标之后，如果想要使用游标，必须先打开游标。打开游标的时候 SELECT 语句的查询结果集就会送到游标工作区，为后面游标的 逐条读取 结果集中的记录做准备</p>
<h4> 3、使用游标（从游标中取得数据）</h4>
<p>语法如下：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这句的作用是<strong>使用 cursor_name 这个游标来读取当前行</strong>，并且将数据保存到 var_name 这个变量中，游标指针指到下一行。如果游标<strong>读取的数据行有多个列名</strong>，则在 INTO <strong>关键字后面赋值给多个变量名</strong>即可<br>
注意：var_name必须在声明游标之前就定义好。</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>注意：游标的<strong>查询结果集中的字段数</strong>，<strong>必须跟 INTO 后面的变量数一致</strong>，否则，在存储过程执行的时候，MySQL 会提示错误。</p>
<h4> 4、关闭游标</h4>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>关闭游标之后，我们就不能再检索查询结果中的数据行，如果需要检索只能再次打开游标。</p>
<h4> 5、举例</h4>
<p>创建存储过程“get_count_by_limit_total_salary()”，声明IN参数 limit_total_salary，DOUBLE类型；声明OUT参数total_count，INT类型。函数的功能可以实现累加薪资最高的几个员工的薪资值，直到薪资总和达到limit_total_salary参数的值，返回累加的人数给total_count。</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 15、触发器</h2>
<h3> 1、触发器概述</h3>
<p>触发器是由 事件来触发 某个操作，这些事件包括 INSERT 、 UPDATE 、 DELETE 事件。所谓事件就是指用户的动作或者触发某项行为。如果定义了触发程序，当数据库执行这些语句时候，就相当于事件发生了，就会 自动 激发触发器执行相应的操作  （商品信息与库存信息一同变更）</p>
<p>当对数据表中的数据执行插入、更新和删除操作，需要自动执行一些数据库逻辑时，可以使用触发器来实现。</p>
<h3> 2、触发器的创建</h3>
<p>创建触发器语法  ：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>表名 ：表示触发器监控的对象<br>
BEFORE|AFTER ：表示触发的时间。BEFORE 表示在事件之前触发；AFTER 表示在事件之后触发。<br>
INSERT|UPDATE|DELETE ：表示触发的事件。<br>
INSERT 表示插入记录时触发；<br>
UPDATE 表示更新记录时触发；<br>
DELETE 表示删除记录时触发。<br>
触发器执行的语句块 ：可以是单条SQL语句，也可以是由BEGIN…END结构组成的复合语句块</p>
<p>举例：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3、查看、删除触发器</h3>
<p>查看触发器是查看数据库中已经存在的触发器的定义、状态和语法信息等。</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>触发器也是数据库对象，删除触发器也用DROP语句，语法格式如下：</p>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 4、触发器的优缺点</h3>
<p>优点：<br>
1、触发器可以确保数据的完整性<br>
2、触发器可以帮助我们记录操作日志<br>
3、触发器还可以用在操作数据前，对数据进行合法性检查</p>
<p>缺点：<br>
1、触发器最大的一个问题就是可读性差。<br>
2、相关数据的变更，可能会导致触发器出错</p>
]]></content:encoded>
      <enclosure url="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20220806215624195.png" type="image/png"/>
    </item>
    <item>
      <title>Redis 基础</title>
      <link>https://T4mako.github.io/code/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis.html</link>
      <guid>https://T4mako.github.io/code/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis.html</guid>
      <source url="https://T4mako.github.io/rss.xml">Redis 基础</source>
      <description>Redis的安装位置： /usr/local/bin 启动redis： cd /usr/local/bin redis-server /etc/redis.conf 连接redis： /usr/local/bin/redis-cli 1、NoSQL数据库简介 1.1、技术发展 技术的分类： 1、解决功能性的问题：Java、Jsp、RDBMS、Tomcat、HTML、Linux、JDBC、SVN 2、解决扩展性的问题：Struts、Spring、SpringMVC、Hibernate、Mybatis 3、解决性能的问题：NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch</description>
      <content:encoded><![CDATA[<p>Redis的安装位置：<br>
<strong>/usr/local/bin</strong></p>
<p><strong>启动redis：</strong><br>
cd /usr/local/bin<br>
redis-server /etc/redis.conf<br>
<strong>连接redis</strong>：<br>
/usr/local/bin/redis-cli</p>
<h2> 1、NoSQL数据库简介</h2>
<h3> 1.1、技术发展</h3>
<p>技术的分类：<br>
1、解决<strong>功能性</strong>的问题：Java、Jsp、RDBMS、Tomcat、HTML、Linux、JDBC、SVN<br>
2、解决<strong>扩展性</strong>的问题：Struts、Spring、SpringMVC、Hibernate、Mybatis<br>
3、解决<strong>性能</strong>的问题：NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch</p>
<h4> 1.1.1、Web1.0时代</h4>
<p>Web1.0的时代，数据访问量很有限，用一夫当关的高性能的单点服务器可以解决大部分问题。</p>
<h4> 1.1.2.、Web2.0时代</h4>
<p>随着Web2.0的时代的到来，用户访问量大幅度提升，同时产生了大量的用户数据。加上后来的智能移动设备的普及，所有的互联网平台都面临了巨大的性能挑战。</p>
<h4> 1.1.3、 解决CPU及内存压力</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230212180730.png" alt="" loading="lazy"></p>
<h4> 1.1.4、解决IO压力</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230212180815.png" alt="" loading="lazy"></p>
<h3> 1.2、NoSQL数据库</h3>
<h4> 1.2.1、NoSQL数据库概述</h4>
<p>NoSQL(<strong>Not Only SQL</strong>)，意即“不仅仅是SQL”，泛指<strong>非关系型的数据库</strong>。<br>
NoSQL 不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大的增加了数据库的扩展能力。</p>
<p>不遵循SQL标准。<br>
不支持ACID。<br>
远超于SQL的性能。</p>
<h4> 1.2.2、NoSQL适用场景</h4>
<p>对数据高并发的读写<br>
海量数据的读写<br>
对数据高可扩展性的</p>
<h4> 1.2.3、NoSQL不适用场景</h4>
<p>需要<strong>事务</strong>支持<br>
基于sql的<strong>结构化查询存储</strong>，处理复杂的关系,需要即席查询。<br>
<em><strong>（用不着sql的和用了sql也不行的情况，请考虑用NoSql）</strong></em></p>
<h4> 1.2.4、常见的NoSQL数据库</h4>
<p>Memcache：|<br>
很早出现的NoSql数据库<br>
数据都在内存中，一般不持久化<br>
支持简单的key-value模式，支持类型单一<br>
一般是作为缓存数据库辅助持久化的数据库</p>
<p><strong>Redis：</strong><br>
几乎覆盖了Memcached的绝大部分功能<br>
数据都在内存中，支持持久化，主要用作备份恢复<br>
除了支持简单的key-value模式，还支持多种数据结构的存储，比如 list、set、hash、zset等。<br>
一般是作为缓存数据库辅助持久化的数据库</p>
<p>MongoDB：<br>
高性能、开源、模式自由(schema free)的<strong>文档型数据库</strong><br>
数据都在内存中， 如果内存不足，把不常用的数据保存到硬盘<br>
虽然是key-value模式，但是对value（尤其是<strong>json</strong>）提供了丰富的查询功能<br>
支持二进制数据及大型对象<br>
可以根据数据的特点<strong>替代RDBMS</strong> ，成为独立的数据库。或者配合RDBMS，存储特定的数据。</p>
<h3> 1.3、行式存储数据库（大数据时代）</h3>
<h4> 1.3.1、行式数据库</h4>
<p>各有利弊</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230212204234.png" alt="" loading="lazy"></p>
<h4> 1.3.2、列式数据库</h4>
<p>各有利弊</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230212204335.png" alt="" loading="lazy"></p>
<h5> 1.3.2.1、Hbase</h5>
<p>HBase是<strong>Hadoop</strong>项目中的数据库。它用于需要对大量的数据进行随机、实时的读写操作的场景中。<br>
HBase的目标就是处理数据量<strong>非常庞大</strong>的表，可以用<strong>普通的计算机</strong>处理超过<strong>10</strong>亿行数据**，还可处理有数百万**列元素的数据表。</p>
<h5> 1.3.2.2、Cassandra</h5>
<p>Apache Cassandra是一款免费的开源NoSQL数据库，其设计目的在于管理由大量商用服务器构建起来的庞大集群上的海量数据集(数据量通常达到<strong>PB级别</strong>)。在众多显著特性当中，Cassandra最为卓越的长处是对写入及读取操作进行规模调整，而且其不强调主集群的设计思路能够以相对直观的方式简化各集群的创建与扩展流程。</p>
<h3> 1.4、图关系型数据库</h3>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230212204638.png" alt="" loading="lazy"></p>
<h2> 2、Redis概述安装</h2>
<h3> 2.1、概述</h3>
<p>Redis是一个开源的key-value存储系统<br>
和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set --有序集合)和hash（哈希类型）<br>
这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些<strong>操作</strong>都是<strong>原子性</strong>的<br>
在此基础上，Redis支持各种不同方式的<strong>排序</strong><br>
与memcached一样，为了保证效率，数据都是<strong>缓存在内存</strong>中<br>
<strong>区别</strong>的是Redis会<strong>周期性</strong>的把更新的数据<strong>写入磁盘</strong>或者把修改操作写入追加的记录文件<br>
并且在此基础上实现了<strong>master-slave(主从)同步</strong></p>
<h3> 2.2、安装步骤</h3>
<p>不用考虑在windows环境下对Redis的支持</p>
<p>下载redis 6</p>
<p><strong>①使用Xftp上传文件：</strong><br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230213153223.png" alt="" loading="lazy"></p>
<p>（使用老师的Redis）</p>
<p><strong>②使用Xshell进入终端</strong></p>
<p>准备工作：<strong>下载安装最新版的gcc编译器</strong><br>
<strong>yum install gcc</strong></p>
<p>测试 gcc版本：<br>
<strong>gcc --version</strong><br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230213153850.png" alt="" loading="lazy"></p>
<p>下载redis-6.2.1.tar.gz放/opt目录<br>
解压命令：<strong>tar -zxvf redis-6.2.1.tar.gz</strong><br>
解压完成后进入目录：<strong>cd redis-6.2.1</strong><br>
在redis-6.2.1目录下再次执行<strong>make</strong>命令（只是编译好）<br>
跳过make test 继续执行: <strong>make install</strong></p>
<h3> 2.3、安装目录：/usr/local/bin</h3>
<p>查看默认安装目录：<br>
redis-benchmark:性能测试工具，可以在自己本地运行，看看自己本子性能如何<br>
redis-check-aof：修复有问题的AOF文件，rdb和aof后面讲<br>
redis-check-dump：修复有问题的dump.rdb文件<br>
redis-sentinel：Redis集群使用<br>
<strong>redis-server</strong>：Redis服务器启动命令<br>
<strong>redis-cli</strong>：客户端，操作入口</p>
<h3> 2.4、前台使用（不推荐）</h3>
<p>前台启动，命令行窗口不能关闭，否则服务器停止<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230213155313486.png" alt="image-20230213155313486" loading="lazy"></p>
<p>使用ctrl+c停止服务</p>
<h3> 2.5、后台启动</h3>
<h4> 2.5.1、备份redis.conf</h4>
<p>拷贝一份redis.conf到其他目录<br>
cp /opt/redis-3.2.5/redis.conf /etc/redis.conf</p>
<h4> 2.5.2、后台启动设置daemonize no改成yes</h4>
<p>修改redis.conf(128行)文件将里面的daemonize no 改成 yes，让服务在后台启动</p>
<p>cd /etc<br>
vim redis.conf</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230213160945.png" alt="" loading="lazy"></p>
<h4> 2.5.3、Redis启动</h4>
<p>cd /usr/local/bin<br>
redis-server /etc/redis.conf</p>
<p>查看进程：<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230213161309.png" alt="" loading="lazy"></p>
<h4> 2.5.4、用客户端访问redis-cli</h4>
<h4> 2.5.5、多个端口可以：redis-cli -p6379</h4>
<h4> 2.5.6、测试验证：ping</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230213161433861.png" alt="image-20230213161433861" loading="lazy"></p>
<h4> 2.5.7、Reds关闭</h4>
<p>单实例关闭：redis-cli shutdown</p>
<p>也可以进入终端后通过进程kill再关闭</p>
<p>多实例关闭，指定端口关闭：redis-cli -p 6379 shutdown</p>
<h3> 2.6、Redis介绍相关知识</h3>
<p>端口<em><strong>6379</strong></em>从何而来：Alessia  Merz（6379）</p>
<p>默认16个数据库，类似数组下标从0开始，初始默认使用0号库<br>
使用命令 select 来切换数据库。如: select 8<br>
统一密码管理，所有库同样密码<br>
dbsize查看当前数据库的key的数量<br>
<strong>flushdb</strong>清空当前库<br>
<strong>flushall</strong>通杀全部库</p>
<p>edis是单线程+多路IO复用技术</p>
<p>多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）</p>
<p><strong>串行  vs  多线程+锁（memcached） vs  单线程+多路IO复用(Redis)</strong></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230213162353213.png" alt="image-20230213162353213" loading="lazy"></p>
<h2> 3、常用5大数据类型</h2>
<p>redis常见数据类型操作命令<a href="http://www.redis.cn/commands.html" target="_blank" rel="noopener noreferrer">http://www.redis.cn/commands.html</a></p>
<p><strong>启动redis：</strong><br>
cd /usr/local/bin<br>
redis-server /etc/redis.conf<br>
<strong>连接redis</strong>：<br>
/usr/local/bin/redis-cli</p>
<h3> 3.1、键(key)</h3>
<p>keys *：			查看当前库所有key  (匹配：keys *1)<br>
exists key：	  判断某个key是否存在<br>
type key：	    查看你的key是什么类型<br>
del key：    	  删除指定的key数据<br>
unlink key：     根据value选择<strong>非阻塞删除</strong>（仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。）<br>
expire key 10：10秒钟：为给定的key设置过期时间<br>
ttl key：			查看还有多少秒过期，-1表示永不过期，-2表示已过期<br>
select：			命令切换数据库（默认有15可库）<br>
dbsize：		   查看当前数据库的key的数量<br>
<strong>flushdb</strong>：		  清空当前库<br>
flushall：		  通杀全部库</p>
<h3> 3.2、字符串（String）</h3>
<h4> 3.2.1、简介</h4>
<p>String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。</p>
<p>String类型是<strong>二进制安全</strong>的。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。</p>
<p>String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是<strong>512M</strong></p>
<h4> 3.2.2、常用命令</h4>
<p>set &lt;key&gt; &lt;value&gt;：	  添加键值对<br>
get &lt;key&gt;：					查询对应键值<br>
append &lt;key&gt;&lt;value&gt;：将给定的&lt;value&gt;：追加到原值的末尾<br>
strlen &lt;key&gt;：				获得值的长度<br>
setnx &lt;key&gt; &lt;value&gt;：  只有在 key 不存在时  设置 key 的值<br>
incr &lt;key&gt;：				   将 key 中储存的数字值减1，只能对数字值操作，如果为空，新增值为-1decr &lt;key&gt;：将 key 中储存的数字值减1，只能对数字值操作，如果为空，新增值为-1<br>
incrby / decrby &lt;key&gt; &lt;步长&gt;：						将 key 中储存的数字值增减，自定义步长<br>
mset &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;...：	 同时设置一个或多个 key-value对<br>
mget &lt;key1&gt;&lt;key2&gt;&lt;key3&gt;...：				 	  同时获取一个或多个 value<br>
msetnx &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;...： 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。<br>
getrange &lt;key&gt;&lt;起始位置&gt;&lt;结束位置&gt;：	    获得值的范围，类似java中的substring，<strong>左闭右闭</strong><br>
setrange &lt;key&gt;&lt;起始位置&gt;&lt;value&gt;：			  用 &lt;value&gt; <strong>覆写</strong>&lt;key&gt;所储存的字符串值，从&lt;起始位置&gt;开始(索引从0开始)。<br>
setex &lt;key&gt;&lt;过期时间&gt;&lt;value&gt;：				    设置键值的同时，设置过期时间，单位秒<br>
getset &lt;key&gt;&lt;value&gt;：									 以新换旧，设置了新值同时获得旧值</p>
<p><strong>redis操作时原子性的（单线程，多路IO复用）</strong></p>
<h4> 3.2.3、底层数据结构</h4>
<p>tring的数据结构为简单动态字符串(Simple Dynamic String,缩写SDS)。是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配</p>
<p>内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。</p>
<h3> 3.3、列表（List）</h3>
<h4> 3.3.1、简介</h4>
<p><strong>单键多值</strong><br>
Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。<br>
它的底层实际是个<strong>双向链表</strong>，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</p>
<h4> 3.3.2、常用命令</h4>
<p>lpush/rpush &lt;key&gt;&lt;value1&gt;&lt;value2&gt;&lt;value3&gt; ....：从左边/右边插入一个或多个值<br>
lpop/rpop &lt;key&gt;：从左边/右边吐出一个值。<strong>值在键在，值光键亡</strong><br>
rpoplpush &lt;key1&gt;&lt;key2&gt;：从&lt;key1&gt;列表右边吐出一个值，插到&lt;key2&gt;列表左边<br>
lrange &lt;key&gt;&lt;start&gt;&lt;stop&gt;：按照索引下标获得元素(从左到右)<br>
lrange &lt;key&gt; 0 -1：0左边第一个，-1右边第一个，（<strong>0-1表示获取所有</strong>）<br>
lindex &lt;key&gt;&lt;index&gt;：按照索引下标获得元素(从左到右)<br>
llen &lt;key&gt;：获得列表长度<br>
linsert &lt;key&gt; before/after &lt;value&gt; &lt;newvalue&gt;：在&lt;value&gt;的前、后面插入&lt;newvalue&gt;插入值<br>
lrem &lt;key&gt;&lt;n&gt;&lt;value&gt;：从左边删除n个value(从左到右)<br>
lset&lt;key&gt;&lt;index&gt;&lt;value&gt;：将列表key下标为index的值替换成value</p>
<h4> 3.3.3、底层数据结构</h4>
<p>List的数据结构为快速链表quickList<br>
首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。<br>
它将所有的元素紧挨着一起存储，分配的是一块连续的内存。<br>
当数据量比较多的时候才会改成quicklist。<br>
因为普通的链表需要的附加指针空间太大，会比较浪费空间。<br>
Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p>
<h3> 3.4、集合（Set）</h3>
<h4> 3.4.1、简介</h4>
<p>Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以<strong>自动去重</strong>的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。</p>
<p>Redis的Set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的复杂度都是<strong>O(1)</strong>。</p>
<h4> 3.4.2、常用命令</h4>
<p>sadd &lt;key&gt;&lt;value1&gt;&lt;value2&gt; ...：将一个或多个 member 元素加入到集合 key 中，已经存在的 member元素将被忽略<br>
smembers &lt;key&gt;：取出该集合的所有值。<br>
sismember &lt;key&gt;&lt;value&gt;：判断集合&lt;key&gt;是否为含有该&lt;value&gt;值，有1，没有0<br>
scard&lt;key&gt;：返回该集合的元素个数。<br>
srem &lt;key&gt;&lt;value1&gt;&lt;value2&gt; ...： 删除集合中的某个元素。<br>
spop &lt;key&gt;：<strong>随机</strong>从该集合中吐出一个值<br>
srandmember &lt;key&gt;&lt;n&gt;：随机从该集合中取出n个值。不会从集合中删除 。<br>
smove &lt;key1&gt;&lt;key2&gt;&lt;value&gt;：把集合中一个值从一个集合移动到另一个集合<br>
sinter &lt;key1&gt;&lt;key2&gt;：返回两个集合的交集元素。<br>
sunion &lt;key1&gt;&lt;key2&gt;：返回两个集合的并集元素。<br>
sdiff &lt;key1&gt;&lt;key2&gt;：返回两个集合的<strong>差集</strong>元素(key1中的，不包含key2中的)</p>
<h4> 3.4.3、底层数据结构</h4>
<p>Set数据结构是dict字典，字典是用哈希表实现的<br>
Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。</p>
<h3> 3.5、哈希（Hash）</h3>
<p>Redis hash 是一个键值对集合。<br>
Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。<br>
类似Java里面的Map&lt;String,Object&gt;</p>
<h4> 3.5.1、简介</h4>
<p>Redis hash 是一个键值对集合。<br>
Redis hash的value是一个string类型的<strong>field和value的映射表</strong>，hash特别适合用于存储对象。<br>
类似Java里面的<strong>Map&lt;String,Object&gt;</strong><br>
用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储</p>
<p>不同的存储方式：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230215162617.png" alt="" loading="lazy"></p>
<h4> 3.5.2、常用命令</h4>
<p>hset &lt;key&gt;&lt;field&gt;&lt;value&gt;：给&lt;key&gt;集合中的 &lt;field&gt;键赋值&lt;value&gt;<br>
hget &lt;key1&gt;&lt;field&gt;：从&lt;key1&gt;集合&lt;field&gt;取出 value<br>
hmset &lt;key1&gt;&lt;field1&gt;&lt;value1&gt;&lt;field2&gt;&lt;value2&gt;... ：批量设置hash的值<br>
hexists&lt;key1&gt;&lt;field&gt;：查看哈希表 key 中，给定域 field 是否存在。<br>
hkeys &lt;key&gt;：列出该hash集合的所有field<br>
hvals &lt;key&gt;：列出该hash集合的所有value<br>
hincrby &lt;key&gt;&lt;field&gt;&lt;increment&gt;：为哈希表 key 中的域 field 的值加上增量 1  -1<br>
hsetnx &lt;key&gt;&lt;field&gt;&lt;value&gt;：将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在</p>
<h4> 3.5.3、底层数据结构</h4>
<p>Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。</p>
<h3> 3.6、有序集合Zset（sorted set）</h3>
<h4> 3.6.1、简介</h4>
<p>Redis有序集合zset与普通集合set非常相似，是一个<strong>没有重复元素</strong>的字符串集合。<br>
不同之处是有序集合的每个成员都关联了一个<strong>评分（score）</strong>,这个评分（score）被用来按照从最低分到最高分的方式<strong>排序</strong>集合中的成员。集合的成员是唯一的，但是<strong>评分可以是重复</strong>了 。</p>
<p>因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。</p>
<p>访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。</p>
<h4> 3.6.2、常用命令</h4>
<p>zadd &lt;key&gt;&lt;score1&gt;&lt;value1&gt;&lt;score2&gt;&lt;value2&gt;…：将一个或多个 member 元素及其 score 值加入到有序集 key 当中。<br>
zrange &lt;key&gt;&lt;start&gt;&lt;stop&gt; [WITHSCORES]：返回有序集 key 中，下标在&lt;start&gt;&lt;stop&gt;之间的元素。带WITHSCORES，可以让分数一起和值返回到结果集。<br>
zrangebyscore key &lt;min&gt; &lt;max&gt; [withscores] [limit offset count]：返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。<br>
zrevrangebyscore key &lt;max&gt; &lt;min&gt; [withscores] [limit offset count]  ：同上，改为从大到小排列。<br>
zincrby &lt;key&gt;&lt;increment&gt;&lt;value&gt;：为元素的score加上增量<br>
zrem &lt;key&gt;&lt;value&gt;：删除该集合下，指定值的元素<br>
zcount &lt;key&gt;&lt;min&gt;&lt;max&gt;：统计该集合，分数区间内的元素个数<br>
zrank &lt;key&gt;&lt;value&gt;：返回该值在集合中的排名，从0开始。</p>
<h4> 3.6.3、底层数据结构</h4>
<p>SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map&lt;String, Double&gt;，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。</p>
<p>zset底层使用了两个数据结构：<br>
（1）hash，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。<br>
（2）跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。</p>
<h4> 3.6.4、跳跃表（调表）</h4>
<p>Redis采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230215171716.png" alt="" loading="lazy"></p>
<p>例如查找元素51：<br>
从第2层开始，1节点比51节点小，向后比较。<br>
21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层<br>
在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下<br>
在第0层，51节点为要查找的节点，节点被找到，共查找4次。</p>
<h2> 4、Redis配置文件</h2>
<p>自己设置的redis配置文件的位置：/etc/redis.conf</p>
<h3> 4.1、Units单位</h3>
<p>配置大小单位,开头定义了一些基本的度量单位，只支持bytes，不支持bit<br>
大小写不敏感</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230216150107283.png" alt="image-20230216150107283" loading="lazy"></p>
<h3> 4.2、INCLUDES包含</h3>
<p>类似jsp中的include，多实例的情况可以把公用的配置文件提取出来</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230216150215092.png" alt="image-20230216150215092" loading="lazy"></p>
<h3> 4.3、网络相关配置</h3>
<h4> 4.3.1、bind</h4>
<p>默认情况<strong>bind=127.0.0.1</strong>只能接受本机的访问请求<br>
不写的情况下，无限制接受任何ip地址的访问<br>
生产环境肯定要写你应用服务器的地址；服务器是需要远程访问的，所以需要将其<strong>注释掉</strong><br>
如果开启了protected-mode，那么在没有设定bind ip且没有设密码的情况下，Redis只允许接受本机的响应</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230216150324687.png" alt="image-20230216150324687" loading="lazy"></p>
<p>保存配置，停止服务，重启启动查看进程，不再是本机访问了</p>
<h4> 4.3.2、protected-mode</h4>
<p>将本机访问护模式设置no</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230216150406973.png" alt="image-20230216150406973" loading="lazy"></p>
<h4> 4.3.3、port</h4>
<p>端口号，默认 6379</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230216150437268.png" alt="image-20230216150437268" loading="lazy"></p>
<h4> 4.3.4、tcp-backlog</h4>
<p>设置tcp的backlog，backlog其实是一个连接队列，backlog队列总和=未完成三次握手队列 + 已经完成三次握手队列。</p>
<p>在高并发环境下你需要一个高backlog值来避免慢客户端连接问题。</p>
<p>注意Linux内核会将这个值减小到/proc/sys/net/core/somaxconn的值（128），所以需要确认增大/proc/sys/net/core/somaxconn和/proc/sys/net/ipv4/tcp_max_syn_backlog（128）两个值来达到想要的效果</p>
<h4> 4.3.5、timeout</h4>
<p>一个空闲的客户端维持多少秒会关闭，0表示关闭该功能。即永不关闭。</p>
<h4> 4.3.6、tcp-keepalive</h4>
<p>对访问客户端的一种心跳检测，每个n秒检测一次。<br>
单位为秒，如果设置为0，则不会进行Keepalive检测，建议设置成60</p>
<h3> 4.4、GENERAL通用</h3>
<h4> 4.4.1、daemonize</h4>
<p>是否为后台进程，设置为yes<br>
守护进程，后台启动</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230216150656768.png" alt="image-20230216150656768" loading="lazy"></p>
<h4> 4.4.2、pidfile</h4>
<p>存放pid文件的位置，每个实例会产生一个不同的pid文件</p>
<h4> 4.4.3、loglevel</h4>
<p>指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为<strong>notice</strong></p>
<p>四个级别根据使用阶段来选择，生产环境选择notice 或者warning</p>
<h4> 4.4.4、logfile</h4>
<p>日志文件名称</p>
<h4> 4.4.5、database 16</h4>
<p>设定库的数量 默认16，默认数据库为0，可以使用SELECT &lt;dbid&gt;命令在连接上指定数据库id</p>
<h3> 4.5、SECURITY 安全</h3>
<h4> 4.5.1、设置密码</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230216151109341.png" alt="image-20230216151109341" loading="lazy"></p>
<p>访问密码的查看、设置和取消<br>
在命令中设置密码，只是临时的。重启redis服务器，密码就还原了。<br>
永久设置，需要再配置文件中进行设置。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230216151302849.png" alt="image-20230216151302849" loading="lazy"></p>
<h3> 4.6、LIMITS限制</h3>
<h4> 4.6.1、maxclients</h4>
<p>设置redis同时可以与多少个客户端进行连接。</p>
<p>默认情况下为10000个客户端。</p>
<p>如果达到了此限制，redis则会拒绝新的连接请求，并且向这些连接请求方发出“max number of clients reached”以作回应。</p>
<h4> 4.6.2、maxmeory</h4>
<p>建议<strong>必须设置</strong>，否则，将内存占满，造成服务器宕机</p>
<p>设置redis可以使用的内存量。一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过<strong>maxmemory-policy</strong>来指定。</p>
<p>如果redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，那么redis则会针对那些需要申请内存的指令返回错误信息，比如SET、LPUSH等。</p>
<p>但是对于无内存申请的指令，仍然会正常响应，比如GET等。如果你的redis是主redis（说明你的redis有从redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素。</p>
<h4> 4.6.3、maxmemory-policy</h4>
<p>volatile-lru：使用LRU算法移除key，只对设置了过期时间的键；（最近最少使用）<br>
allkeys-lru：在所有集合key中，使用LRU算法移除key<br>
volatile-random：在过期集合中移除随机的key，只对设置了过期时间的键<br>
allkeys-random：在所有集合key中，移除随机的key<br>
volatile-ttl：移除那些TTL值最小的key，即那些最近要过期的key<br>
noeviction：不进行移除。针对写操作，只是返回错误信息</p>
<h4> 4.6.4、maxmemory-samples</h4>
<p>设置样本数量，LRU算法和最小TTL算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，redis默认会检查这么多个key并选择其中LRU的那个。</p>
<p>一般设置3到7的数字，数值越小样本越不准确，但性能消耗越小。</p>
<h2> 5、Redis发布和订阅</h2>
<h3> 5.1、什么是发布和订阅</h3>
<p>Redis 发布订阅 (pub/sub) 是一种<strong>消息通信模式</strong>：<br>
发送者 (pub) 发送消息<br>
订阅者 (sub) 接收消息。</p>
<p>Redis 客户端可以订阅任意数量的频道。</p>
<h3> 5.2、Redis的发布和订阅</h3>
<p>客户端可以订阅频道：<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230216152128.png" alt="" loading="lazy"></p>
<p>当给这个频道发布消息后，消息就会发送给订阅的客户端：<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230216152211.png" alt="" loading="lazy"></p>
<h3> 5.3、发布订阅命令的实现</h3>
<p>1、打开一个客户端订阅channel1：</p>
<p>subscribe channel1</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230216152925974.png" alt="image-20230216152925974" loading="lazy"></p>
<p>2、打开另一个客户端，给channel1发布消息hello</p>
<p>publish channel1 hello<br>
返回的1是订阅者数量</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230216152950911.png" alt="image-20230216152950911" loading="lazy"></p>
<h2> 6、Redis6新数据类型</h2>
<h3> 6.1、Bitmaps</h3>
<h4> 6.1.1、简介</h4>
<p>Redis提供了Bitmaps这个“数据类型”可以实现对位的操作：<br>
（1）  Bitmaps本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以<strong>对字符串的位进行操作</strong>。<br>
（2）Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把Bitmaps想象成一个7<strong>以位为单位的数组</strong>， 数组的<strong>每个单元只能存储0和1</strong>， 数组的<strong>下标</strong>在Bitmaps中叫做<strong>偏移量</strong></p>
<h4> 6.1.2、命令</h4>
<p>1、setbit</p>
<p>格式：setbit&lt;key&gt;&lt;offset&gt;&lt;value&gt; 设置bitmaps中某个偏移量的值（0或1）<br>
offset:偏移量从0开始</p>
<p>举例：将key为users:20210101的1、6、11、15、19位设置为1</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230216161852940.png" alt="image-20230216161852940" loading="lazy"></p>
<p>2、getbit</p>
<p>格式：getbit&lt;key&gt;&lt;offset&gt;获取Bitmaps中某个偏移量的值</p>
<p>获取键的第offset位的值（从0开始算）：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230216161935200.png" alt="image-20230216161935200" loading="lazy"></p>
<p>3、bitcount</p>
<p>统计<strong>字符串</strong>被设置为1的bit数<br>
通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行<br>
-1 表示最后一个位，-2 表示倒数第二个位</p>
<p>格式：bitcount&lt;key&gt;[start end] 统计字符串从<strong>start字节</strong>到<strong>end字节</strong>比特值为1的数量</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230216162108342.png" alt="image-20230216162108342" loading="lazy"></p>
<p>4、bitop</p>
<p>格式：bitop and(or/not/xor) &lt;destkey&gt; [key…]<br>
bitop是一个复合操作， 它可以做多个Bitmaps的and（交集） 、 or（并集） 、 not（非） 、 xor（异或） 操作并将结果保存在destkey中。</p>
<p>举例：<br>
2020-11-04 日访问网站的userid=1,2,5,9<br>
setbit unique:users:20201104 1 1<br>
setbit unique:users:20201104 2 1<br>
setbit unique:users:20201104 5 1<br>
setbit unique:users:20201104 9 1</p>
<p>2020-11-03 日访问网站的userid=0,1,4,9<br>
setbit unique:users:20201103 0 1<br>
setbit unique:users:20201103 1 1<br>
setbit unique:users:20201103 4 1<br>
setbit unique:users:20201103 9 1</p>
<p>计算出两天都访问过网站的用户数量：<br>
bitop and unique:users:and:20201104_03 unique:users:20201103 unique:users:20201104</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230216165709921.png" alt="image-20230216165709921" loading="lazy"></p>
<h4> 6.1.3、bitmaps与set对比</h4>
<p>用户多时或存储独立用户使用Bitmap节省很多空间<br>
若活跃用户较少，那大部分都是0，用集合节省空间</p>
<h3> 6.2、HyperLogLog</h3>
<h4> 6.2.1、简介</h4>
<p>在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站PV（PageView页面访问量）,可以使用Redis的incr、incrby轻松实现。</p>
<p>但像UV（UniqueVisitor，独立访客）、独立IP数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为<strong>基数问题</strong></p>
<p>基数：所有非重复数字</p>
<p>解决基数问题有很多种方案：<br>
（1）数据存储在MySQL表中，使用distinct count计算不重复个数<br>
（2）使用Redis提供的hash、set、bitmaps等数据结构来处理</p>
<p>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。</p>
<p>能否能够降低一定的精度来平衡存储空间？Redis推出了<strong>HyperLogLog</strong></p>
<p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p>
<p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p>
<p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p>
<h4> 6.2.2、命令</h4>
<p>1、pfadd</p>
<p>格式：pfadd &lt;key&gt;&lt;element&gt; [element ...]  添加指定元素到 HyperLogLog 中</p>
<p>举例：<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230216171619915.png" alt="image-20230216171619915" loading="lazy"></p>
<p>如果执行命令后HLL估计的近似基数发生变化，则返回1，否则返回0。</p>
<p>2、pfcount</p>
<p>格式：pfcount&lt;key&gt; [key ...] 计算HLL的近似基数</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230216171824571.png" alt="image-20230216171824571" loading="lazy"></p>
<p>3、pfmerge</p>
<p>格式：pfmerge&lt;destkey&gt;&lt;sourcekey&gt; [sourcekey ...] 将一个或多个HLL合并后的结果存储在另一个HLL中，比如每月活跃用户可以使用每天的活跃用户来合并计算可得</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230216172107315.png" alt="image-20230216172107315" loading="lazy"></p>
<h3> 6.3、Geospatial</h3>
<h4> 6.3.1、简介</h4>
<p>Redis 3.2 中增加了对GEO类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。</p>
<h4> 6.3.2、命令</h4>
<p>1、geoadd</p>
<p>格式：geoadd&lt;key&gt;&lt; longitude&gt;&lt;latitude&gt;&lt;member&gt; [longitude latitude member...]  添加地理位置（经度，纬度，名称）</p>
<p>举例：<br>
geoadd china:city 121.47 31.23 shanghai<br>
geoadd china:city 106.50 29.53 chongqing 114.05 22.52 shenzhen 116.38 39.90 beijing</p>
<p>两极无法直接添加，一般会下载城市数据，直接通过 Java 程序一次性导入。<br>
有效的经度从 -180 度到 180 度。有效的纬度从 -85.05112878 度到 85.05112878 度。</p>
<p>当坐标位置超出指定范围时，该命令将会返回一个错误。<br>
已经添加的数据，是无法再次往里面添加的。</p>
<p>2、geopos</p>
<p>格式：geopos &lt;key&gt;&lt;member&gt; [member...] 获得指定地区的坐标值</p>
<p>举例：<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230216173526297.png" alt="image-20230216173526297" loading="lazy"></p>
<p>3、geodist</p>
<p>格式：geodist&lt;key&gt;&lt;member1&gt;&lt;member2&gt; [m|km|ft|mi ] 获取两个位置之间的直线距离</p>
<p>举例：<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230216173915212.png" alt="image-20230216173915212" loading="lazy"></p>
<p>单位：<br>
m 表示单位为米[默认值]。<br>
km 表示单位为千米。<br>
mi 表示单位为英里。<br>
ft 表示单位为英尺。<br>
如果用户没有显式地指定单位参数， 那么 GEODIST 默认使用米作为单位</p>
<p>4、georadius</p>
<p>格式：georadius&lt;key&gt;&lt; longitude&gt;&lt;latitude&gt;radius m|km|ft|mi  以给定的经纬度为中心，找出某一半径内的元素（经度 纬度 距离 单位）</p>
<p>举例：<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230216174034734.png" alt="image-20230216174034734" loading="lazy"></p>
<h2> 7、Jedis入门</h2>
<h3> 7.1、Jedis所需jar包</h3>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7.2、连接Redis注意事项</h3>
<p><strong>禁用Linux的防火墙</strong>：Linux(CentOS7)里执行命令</p>
<p><em><strong>systemctl stop/disable firewalld.service</strong></em></p>
<p>redis.conf中注释掉bind 127.0.0.1 ,然后 protected-mode no</p>
<h3> 7.3、Jedis常用操作</h3>
<h4> 7.3.1、创建maven工程</h4>
<h4> 7.3.2、创建测试程序</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7.4、测试相关数据类型</h3>
<h4> 7.4.1、Key、String</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 7.4.2、List</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 7.4.3、set</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 7.4.4、hash</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 7.4.5、zset</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 8、Jedis实例</h2>
<p>完成一个手机验证码功能</p>
<p>要求：<br>
1、输入手机号，点击发送后随机生成6位数字码，2分钟有效<br>
2、输入验证码，点击验证，返回成功或失败<br>
3、每个手机号每天只能输入3次</p>
<p>分析：<br>
1、生成随机数：random<br>
2、验证码二分钟有效：把验证码放入redis，设置过期时间120s<br>
3、判断验证码是否一致：从redis获取验证码和输入的验证码进行比较<br>
4、每个手机只能发送三次验证码：incr每次发送后+1，大于2的时候，提交不能发送</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 9、SpringBoot整合Redis</h2>
<h3> 9.1、 添加依赖</h3>
<p>在spring boot中，可以使用Spring Data Redis来简化Redis操作</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230315210937.png" alt="" loading="lazy"></p>
<p>在pom.xml文件中引入redis相关依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 9.2、application中的配置</h3>
<div class="language-properties line-numbers-mode" data-ext="properties"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 9.3、添加redis配置类</h3>
<p>更改Redis的序列化器：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 9.4、测试</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 10、Redis事务</h2>
<h3> 10.1、Redis的事务定义</h3>
<p>Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。<br>
Redis事务的主要作用就是<strong>串联多个命令，防止别的命令插队</strong>。</p>
<h3> 10.2、Multi、Exec、discard</h3>
<p>从输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec后，Redis会将之前的命令队列中的命令依次执行。<br>
组队的过程中可以通过discard来放弃组队。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230219140612333.png" alt="image-20230219140612333" loading="lazy"></p>
<p>举例：<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230219141038.png" alt="" loading="lazy"></p>
<h3> 10.3、事务错误处理</h3>
<p>（1）组队阶段报错，提交失败<br>
组队中某个命令出现了报告错误，执行时整个的<strong>所有</strong>队列都会被取消。</p>
<p>举例：<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230219141437027.png" alt="image-20230219141437027" loading="lazy"></p>
<p>（2）组队成功，提交有成功有失败情况<br>
如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。</p>
<p>举例：<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230219141445831.png" alt="image-20230219141445831" loading="lazy"></p>
<h3> 10.4、事务冲突的问题</h3>
<h4> 10.4.1、悲观锁</h4>
<p><strong>悲观锁(Pessimistic Lock)</strong>, 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以<strong>每次在拿数据的时候都会上锁</strong>，这样别人想拿这个数据就会block直到它拿到锁。<strong>传统的关系型数据库里边就用到了很多这种锁机制</strong>，比如<strong>行锁</strong>，<strong>表锁</strong>等，<strong>读锁</strong>，<strong>写锁</strong>等，都是在做操作之前先上锁。</p>
<p><strong>Redis默认不能直接使用悲观锁</strong></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230219150245282.png" alt="image-20230219150245282" loading="lazy"></p>
<h4> 10.4.2、乐观锁</h4>
<p><strong>乐观锁(Optimistic Lock)</strong>, 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用<strong>版本号</strong>等机制。<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>。Redis就是利用这种check-and-set机制实现事务的。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230219150305527.png" alt="image-20230219150305527" loading="lazy"></p>
<h4> 10.4.3、WATCH key [key...]</h4>
<p>在执行multi之前，先执行watch key1 [key2],可以监视一个(或多个) key ，如果在<strong>事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断</strong></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230219151206.png" alt="" loading="lazy"></p>
<h3> 10.5、Redis事务三特性</h3>
<p>①单独的隔离操作：<br>
<strong>事务</strong>中的<strong>所有命令</strong>都会<strong>序列化</strong>、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
<p>②没有隔离级别的概念：<br>
队列中的命令<strong>没有提交之前都不会实际被执行</strong>，因为事务提交前任何指令都不会被实际执行</p>
<p>③不保证原子性<br>
事务中如果有一<strong>条命令执行失败</strong>，<strong>其后的命令仍然会被执行</strong>，**没有回滚 **</p>
<h2> 11、Redis事务案例</h2>
<p>秒杀案例</p>
<h3> 11.1、解决计数器和人员记录的事务操作</h3>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230219152515148.png" alt="image-20230219152515148" loading="lazy"></p>
<h3> 11.2、并发模拟工具</h3>
<p>压力测试：<br>
使用工具ab模拟测试：<br>
CentOS6 默认安装<br>
CentOS7需要手动安装</p>
<h4> 11.2.1、有网络：yum install httpd-tools</h4>
<h4> 11.2.3、无网络：</h4>
<p>（1） 进入cd /run/media/root/CentOS 7 x86_64/Packages（路径跟centos6不同）<br>
（2） 顺序安装<br>
apr-1.4.8-3.el7.x86_64.rpm<br>
apr-util-1.5.2-6.el7.x86_64.rpm<br>
httpd-tools-2.4.6-67.el7.centos.x86_64.rpm</p>
<h4> 11.2.4、测试</h4>
<h5> 11.2.4.1、通过ab测试</h5>
<p>使用<strong>ab --help</strong>查看ab的使用方式</p>
<p>通过<strong>vim postfile</strong> 在~文件夹下创建文件：模拟表单提交参数,以&amp;符号结尾;存放当前目录<br>
内容：prodid=1010&amp;</p>
<p>ab -n 1000 -c 100 -p ~/postfile -T application/x-www-form-urlencoded <a href="http://192.168.137.221:8080/seckill" target="_blank" rel="noopener noreferrer">http://192.168.137.221:8080/seckill</a><br>
表示一共有一千个请求，有100个请求是并发的</p>
<h3> 11.3、超时问题</h3>
<p>连接超时，通过连接池解决：</p>
<p>节省每次连接redis服务带来的消耗，把连接好的实例反复利用。<br>
通过参数管理连接的行为</p>
<p>JedisPoolUtil工具类：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>链接池参数<br>
MaxTotal：控制一个pool可分配多少个jedis实例，通过pool.getResource()来获取；如果赋值为-1，则表示不限制；如果pool已经分配了MaxTotal个jedis实例，则此时pool的状态为exhausted。</p>
<p>maxIdle：控制一个pool最多有多少个状态为idle(空闲)的jedis实例；</p>
<p>MaxWaitMillis：表示当borrow一个jedis实例时，最大的等待毫秒数，如果超过等待时间，则直接抛JedisConnectionException</p>
<p>testOnBorrow：获得一个jedis实例的时候是否检查连接可用性（ping()）；如果为true，则得到的jedis实例均是可用的</p>
<h3> 11.4、超卖问题</h3>
<p>利用乐观锁淘汰用户，解决超卖问题</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230219161241564.png" alt="image-20230219161241564" loading="lazy"></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 11.5、库存遗留问题</h3>
<p>乐观锁会造成库存遗留问题，乐观锁导致很多请求都失败。先点的没秒到，后点的可能秒到了。</p>
<h4> 11.5.1、LUA脚本</h4>
<p><strong>Lua</strong>是一个小巧的<strong>脚本语言</strong>，Lua脚本可以很容易的<strong>被C/C++ 代码调用</strong>，也可以反过来<strong>调用C/C++的函数</strong>，Lua并没有提供强大的库，一个完整的Lua解释器不过200k，所以Lua不适合作为开发独立应用程序的语言，而是作为<strong>嵌入式脚本语言</strong>。</p>
<p>很多应用程序、游戏使用LUA作为自己的嵌入式脚本语言，以此来实现可配置性、可扩展性。这其中包括魔兽争霸地图、魔兽世界、博德之门、愤怒的小鸟等众多游戏插件或外挂。</p>
<h4> 11.5.2、LUA脚本在Redis中的优势</h4>
<p>将复杂的或者多步的redis操作，写为一个脚本，一次提交给redis执行，<strong>减少反复连接redis的次数</strong>。提升性能</p>
<p>LUA脚本是类似redis事务，有一定的原子性，不会被其他命令插队，可以完成一些redis事务性的操作</p>
<p>但是注意redis的lua脚本功能，只有在Redis 2.6以上的版本才可以使用</p>
<p>利用lua脚本淘汰用户，解决超卖问题</p>
<p>redis 2.6版本以后，通过lua脚本解决<strong>争抢问题</strong>，实际上是<strong>redis</strong> <strong>利用其单线程的特性，用任务队列的方式解决多任务并发问题</strong>。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230219162833961.png" alt="image-20230219162833961" loading="lazy"></p>
<p>LUA脚本：</p>
<div class="language-lua line-numbers-mode" data-ext="lua"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 12、Redis持久化之RDB</h2>
<p>Redis 提供了2个不同形式的持久化方式：<br>
RDB（Redis DataBase）<br>
AOF（Append Of File）</p>
<h3> 12.1、RDB介绍</h3>
<p>RDB（Redis DataBase）</p>
<p>在指定的<strong>时间间隔</strong>内将内存中的数据集<strong>快照写入磁盘</strong>， 也就是行话讲的Snapshot快照，它恢复时是将<strong>快照文件直接读到内存</strong>里</p>
<h3> 12.2、备份是如何执行的</h3>
<p>Redis会单独创建（<strong>fork</strong>）一个<strong>子进程</strong>来进行持久化，会先将数据<strong>写入到一个临时文件中</strong>，待持久化过程都结束了，再用这个<em>临时文件替换上次持久化好的文件</em>。 整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。<strong>RDB的缺点是最后一次持久化后的数据可能丢失</strong></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230220162243.png" alt="" loading="lazy"></p>
<h3> 12.3、Fork</h3>
<p>Fork的作用是<strong>复制</strong>一个与当前<strong>进程</strong>一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并<strong>作为原进程的子进程</strong></p>
<p>在Linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，Linux中引入了“<strong>写时复制技术</strong>（先写入一个临时文件，替换文件的过程）”</p>
<p><strong>一般情况父进程和子进程会共用同一段物理内存</strong>，只有进程空间的各段的内容要<strong>发生变化</strong>时，才会将<strong>父进程的内容复制一份给子进程</strong>。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230220162351.png" alt="" loading="lazy"></p>
<h3> 12.4、dump.rdb文件</h3>
<p>在redis.conf中：vim /etc/redis.conf</p>
<p>查找到snapshotting：</p>
<p>rdb的默认文件名：dump.rdb<br>
rdb文件位置：redis的启动目录中（/usr//local/bin/）<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230220163011.png" alt="" loading="lazy"></p>
<h3> 12.5、如何触发RDB快照；保持策略</h3>
<p>配置文件中默认的快照配置：<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230220163918.png" alt="" loading="lazy"></p>
<h4> 12.5.1、命令save VS bgsave</h4>
<p><strong>save</strong> ：save时只管保存，其它不管，全部阻塞，手动保存，不建议。</p>
<p><strong>bgsave</strong>：Redis会在后台异步进行<strong>快照操作</strong>，快照同时还可以响应客户端请求。可以通过lastsave 命令获取最后一次成功执行快照的时间</p>
<p>save格式：save 秒钟 写操作次数</p>
<p>RDB是整个内存的压缩过的Snapshot，RDB的数据结构，可以配置复合的快照触发条件，<strong>默认是1分钟内改了1万次，或5分钟内改了10次，或15分钟内改了1次</strong>。<br>
禁用<br>
不设置save指令，或者给save传入空字符串</p>
<h4> 12.5.2、flushall命令</h4>
<p>执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义</p>
<h4> 12.5.3、stop-writes-on-bgsave-error</h4>
<p>当Redis无法写入磁盘的话，直接关掉Redis的写操作。推荐yes.</p>
<h4> 12.5.4、rdbcompression 压缩文件</h4>
<p>对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。</p>
<p>如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能。推荐yes.</p>
<h4> 12.5.5、 rdbchecksum 检查完整性</h4>
<p>在存储快照后，还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。推荐yes.</p>
<h5> 12.5.6、dump.rdb的备份、恢复</h5>
<p>将rdb文件目录下（/usr/loacl/bin）的*.rdb的文件拷贝到别的地方<br>
rdb的恢复：①关闭redis②先把备份的文件拷贝到工作目录下（ cp dump2.rdb dump.rdb）③启动Redis, 备份数据会直接加载</p>
<h3> 12.6、RDB的优势</h3>
<p>①适合大规模的数据恢复<br>
②对数据完整性和一致性要求不高更适合使用<br>
③节省磁盘空间<br>
④恢复速度快</p>
<h3> 12.7、RDB的劣势</h3>
<p>①Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑<br>
②虽然Redis在fork时使用了<strong>写时拷贝技术</strong>,但是如果数据庞大时还是比较消耗性能<br>
③在备份周期在一定间隔时间做一次备份，所以<strong>如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改</strong></p>
<h3> 12.8、停止RDB</h3>
<p>动态停止RDB：redis-cli config set save ""#save后给空值，表示禁用保存策略</p>
<h3> 12.9、总结</h3>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230220170054543.png" alt="image-20230220170054543" loading="lazy"></p>
<h2> 13、Redis持久化之AOF</h2>
<h3> 13.1、AOF简介</h3>
<p>AOF（Append Only File）</p>
<p>以<strong>日志</strong>的形式来记录每个<strong>写操作</strong>（增量保存），将Redis执行过的<strong>所有写指令</strong>记录下来(<strong>读操作不记录</strong>)， <strong>只许追加文件但不可以改写文件</strong>，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p>
<h3> 13.2、AOF持久化流程</h3>
<h3> 13.3、AOF的开启</h3>
<p>AOF默认不开启，可以在redis.conf中配置文件名称，默认为<strong>appendonly.aof</strong><br>
AOF文件的保存路径，同RDB的路径一致。</p>
<h3> 13.4、AOF和RDB同时开启，系统默认取AOF的数据（数据不会存在丢失）</h3>
<h3> 13.5、AOF启动/修复/恢复</h3>
<p>启动：AOF的备份机制和性能虽然和RDB不同, 但是备份和恢复的操作同RDB一样，都是拷贝备份文件，需要恢复时再拷贝到Redis工作目录下，启动系统即加载</p>
<p>恢复：<br>
正常恢复：<br>
修改默认的appendonly no，改为yes<br>
将有数据aof文件名复制一份保存到对应目录（查看目录：config get dir）<br>
重启redis然后重新加载<br>
异常恢复：<br>
修改默认的n appendonly no，改为yes<br>
如遇到<strong>AOF文件损坏</strong>，通过/usr/local/bin/<strong>redis-check-aof--fix appendonly.aof</strong>进行恢复<br>
备份写坏的AOF文件<br>
恢复：重启redis，然后重新加载</p>
<h3> 13.6、AOF同步频率设置</h3>
<p>在配置文件中：<br>
appendfsync always：始终同步，每次Redis的写入都会立刻记入日志；性能较差但数据完整性比较好<br>
appendfsync everysec：每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。<br>
appendfsync no：redis不主动进行同步，把同步时机交给操作系统。</p>
<h3> 13.7、Rewrite重写压缩</h3>
<p>1、Rewrite：<br>
当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩， 只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof</p>
<p>2、重写原理：<br>
AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，redis4.0版本后的重写，是指上就是把rdb 的快照，以二级制的形式附在新的aof头部，作为已有的历史数据，替换掉原来的流水账操作</p>
<p>no-appendfsync-on-rewrite：<br>
如果 no-appendfsync-on-rewrite=yes ,不写入aof文件只写入缓存，用户请求不会阻塞，但是在这段时间如果宕机会丢失这段时间的缓存数据。（降低数据安全性，提高性能）<br>
如果 no-appendfsync-on-rewrite=no, 还是会把数据往磁盘里刷，但是遇到重写操作，可能会发生阻塞。（数据安全，但是性能降低）</p>
<p>触发机制，何时重写：<br>
Redis会记录上次重写时的AOF大小，默认配置是当*<strong>AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发</strong></p>
<p>重写虽然可以节约大量磁盘空间，减少恢复时间。但是每次重写还是有一定的负担的，因此设定Redis要满足一定条件才会进行重写：<br>
auto-aof-rewrite-percentage：设置重写的基准值，文件达到100%时开始重写（文件是原来重写后文件的2倍时触发）<br>
auto-aof-rewrite-min-size：设置重写的基准值，最小文件64MB。达到这个值开始重写。</p>
<p>3、重写流程：<br>
（1）bgrewriteaof触发重写，判断是否当前有bgsave或bgrewriteaof在运行，如果有，则等待该命令结束后再继续执行。<br>
（2）主进程fork出子进程执行重写操作，保证主进程不会阻塞。<br>
（3）子进程遍历redis内存中数据到临时文件，客户端的写请求同时写入aof_buf缓冲区和aof_rewrite_buf重写缓冲区保证原AOF文件完整以及新AOF文件生成期间的新的数据修改动作不会丢失。<br>
（4）1).子进程写完新的AOF文件后，向主进程发信号，父进程更新统计信息。2).主进程把aof_rewrite_buf中的数据写入到新的AOF文件。（5）使用新的AOF文件覆盖旧的AOF文件，完成AOF重写。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230220175403234.png" alt="image-20230220175403234" loading="lazy"></p>
<h3> 13.8、AOF优势</h3>
<p>备份机制更稳健，丢失数据概率更低。<br>
可读的日志文本，通过操作AOF稳健，可以处理误操作。</p>
<h3> 13.9、AOF劣势</h3>
<p>比起RDB占用更多的磁盘空间。<br>
恢复备份速度要慢。<br>
每次读写都同步的话，有一定的性能压力。<br>
存在个别Bug，造成恢复不能。</p>
<h3> 13.10、总结</h3>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230220175717896.png" alt="image-20230220175717896" loading="lazy"></p>
<p><strong>RDB，AOF使用建议</strong><br>
官方推荐两个都启用<br>
如果对数据不敏感，可以选单独用RDB<br>
不建议单独用 AOF，因为可能会出现Bug<br>
如果只是做纯内存缓存，可以都不用</p>
<h2> 14、Redis主从复制</h2>
<h3> 14.1、主从复制的概念</h3>
<p>主机数据更新后根据配置和策略， 自动同步到备机的master/slaver机制（主从机制），<strong>Master(主)以写为主，Slave(从)以读为主</strong></p>
<p>一主多从：主服务器只能有一台，从服务器可以有多台<br>
集群：多个一主多从</p>
<h3> 14.2、主从复制的作用</h3>
<p>1、读写分离（在不同服务器进行读操作，写操作），性能扩展<br>
2、容灾快速恢复</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230221173858332.png" alt="image-20230221173858332" loading="lazy"></p>
<h3> 14.3、主从复制的实现</h3>
<p>搭建一主两从的服务器：</p>
<p>①开启redis<br>
②创建/myredis文件夹<br>
③复制redis.conf配置文件到/myredis文件夹中<br>
开启daemonize yes<br>
关闭AOF，设置：appendpnly no<br>
④配置一主多从（一主两从），创建三个配置文件：<br>
redis6379.conf<br>
redis6380.conf<br>
redis6381.conf</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230221190907287.png" alt="image-20230221190907287" loading="lazy"></p>
<p>⑤在三个配置文件中写入内容（不同文件修改不同数字)</p>
<p>Pid文件名，指定端口port，dump.rdb名字</p>
<div class="language-vim line-numbers-mode" data-ext="vim"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>⑥启动三台redis</p>
<p>redis-server redis6379.conf</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230221191343334.png" alt="image-20230221191343334" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230221191548.png" alt="" loading="lazy"></p>
<p>⑦查看三台主机运行情况</p>
<p>连接不同的redis服务器：<strong>redis-cli -p 6379</strong><br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230221191905.png" alt="" loading="lazy"></p>
<p><strong>info replication</strong>：打印主从复制的相关信息<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230221192038152.png" alt="image-20230221192038152" loading="lazy"></p>
<p>在从机上执行命令，开启主从关系：slaveof 主机ip 端口号</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230221192429.png" alt="" loading="lazy"></p>
<p><strong>在主机上可以做读写（set，get）操作，在从机上只能做读（get）操作</strong></p>
<h3> 14.4、主从复制常用操作</h3>
<h4> 14.4.1、一主二从</h4>
<p>①当从服务器挂掉后（shutdown），主服务器写入数据。重启从服务器，默认为主服务器，需要创建主从关系：slaveof 主机ip 端口号，成为从服务器后，可以看到主服务器新加的数据。</p>
<p>②当主服务器挂掉后（shutdown），从服务器不会成为主服务器</p>
<h4> 14.4.2、薪火相传</h4>
<p>一台从服务器作为另一台从服务器的从服务器，使用slaveof 主机ip 端口号</p>
<p>与一主二从相同，主服务器挂掉，从服务器不会上位，主服务器开启，仍为主服务器。一旦某个slave宕机，后面的slave都没法备份</p>
<h4> 14.4.3、反客为主</h4>
<p>当一个主服务器宕机后，后面的从服务器可以立刻升为主服务器：<strong>slaveof no one</strong>，其后面的从服务器不用做任何修改。</p>
<h3> 14.5、主从复制原理</h3>
<p>1、当从连接上主服务器后，从服务器向主服务器发送进行数据同步消息<br>
2、主服务器接到从服务器发送过来同步消息，把从服务器数据进行持久化，把rdb文件发送给从服务器，从服务器进行读取<br>
3、每次主服务器进行写操作后，向从服务器进行数据同步（主服务器发起的）</p>
<p>两个名词：<br>
全量复制：slave服务器在接收到数据库文件数据后，将其存盘并加载到内存中。<br>
增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步</p>
<h3> 14.6、哨兵模式（自动反客为主）</h3>
<p>哨兵模式为<strong>反客为主的自动版</strong>，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230221201438282.png" alt="image-20230221201438282" loading="lazy"></p>
<h4> 14.6.1、哨兵模式的启用</h4>
<p>①调整为一主二仆模式，6379带着6380、6381</p>
<p>②自定义的/myredis目录下新建<strong>sentinel.conf</strong>文件，名字固定不能错<br>
配置哨兵，填写内容：<strong>sentinel monitor mymaster 127.0.0.1 6379 1</strong></p>
<p>sentinel（哨兵）monitor（监控）<br>
其中mymaster为监控对象起的服务器名称， 1为至少有多少个哨兵同意迁移的数量（投票）。</p>
<p>③启动哨兵</p>
<p><strong>redis-sentinel sentinel.conf</strong></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230221202821446.png" alt="image-20230221202821446" loading="lazy"></p>
<p>当主机挂掉，从机选举中产生新的主机<br>
(大概10秒左右可以看到哨兵窗口日志，切换了新的主机)<br>
哪个从机会被选举为主机呢？根据优先级别：slave-priority<br>
原主机重启后会变为从机。</p>
<h4> 14.6.2、复制延时</h4>
<p>由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</p>
<h4> 14.6.3、故障恢复</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230221203932529.png" alt="image-20230221203932529" loading="lazy"></p>
<p><strong>优先级</strong>在redis.conf中默认：<strong>replica-priority 100</strong>，值越小优先级越高<br>
<strong>偏移量</strong>是指获得原主机数据最全的<br>
每个redis实例启动后都会随机生成一个40位的<strong>runid</strong></p>
<h4> 14.6.4、在java中进行主从复制</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 15、Redis集群</h2>
<h3> 15.1、问题引出</h3>
<p>Redis容量不够，redis如何进行扩容<br>
并发写操作难，redis如何分摊<br>
主从模式，薪火相传模式，主机宕机，导致ip地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息</p>
<p>之前通过<strong>代理主机</strong>来解决，但是redis3.0中提供了解决方案。就是<strong>无中心化集群</strong>配置。</p>
<p><strong>Redis集群的好处：实现扩容、分摊压力、无中心配置相对简单</strong></p>
<p>代理主机：8台服务器<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230222125830.png" alt="" loading="lazy"></p>
<p><strong>无中心化集群：6台服务器</strong><br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230222130125.png" alt="" loading="lazy"></p>
<h3> 15.2、Redis集群的概念</h3>
<p>Redis 集群实现了对Redis的水平扩容，即启动N个redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1/N。<br>
Redis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</p>
<h3> 15.3、redis集群的实践</h3>
<h4> 15.3.1、删除所有rdb，aof文件</h4>
<p>cd /myredis<br>
rm -rf dump63*</p>
<h4> 15.3.2、制作六个实例，修改配置</h4>
<p>创建6个实例：6379,6380,6381,6389,6390,6391</p>
<p><strong>配置基本信息：</strong><br>
开启daemonize yes、pidfile 文件名、指定端口、Dump.rdb 名字、Dump.rdb名字、Appendonly 关掉或者换名字<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230222131536.png" alt="" loading="lazy"></p>
<p><strong>配置修改：</strong><br>
cluster-enabled yes  打开集群模式<br>
cluster-config-file nodes-6379.conf 设定节点配置文件名<br>
cluster-node-timeout 15000  设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换。<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230222131818.png" alt="" loading="lazy"></p>
<p>修改这六个配置文件<br>
vi编辑器的替换操作：<em>:%s/6379/6380</em></p>
<h4> 15.3.3、启动6个redis服务</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230222132601.png" alt="" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230222132631.png" alt="" loading="lazy"></p>
<h4> 15.3.4、将六个节点合成一个集群</h4>
<p>组合之前，请确保所有redis实例启动后，nodes-xxxx.conf文件都生成正常</p>
<p>进入redis一开始安装的src（cd /opt/redis-6.2.1）<br>
cd src</p>
<p>集成只能在src目录下进行</p>
<div class="language-linux line-numbers-mode" data-ext="linux"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>此处不要用127.0.0.1， 请用真实IP地址<br>
--replicas 1 采用最简单的方式配置集群，一台主机，一台从机，正好三组。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230222133458.png" alt="" loading="lazy"></p>
<h4> 15.3.5、集群登录</h4>
<p>普通登录方式：<br>
redis-cli -p 端口号：可能直接进入读主机，存储数据时，会出现MOVED重定向操作。所以，应该以集群方式登录。</p>
<p><strong>集群方式登录：redis-cli -c -p 集群中任意一台端口号</strong><br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230222133832.png" alt="" loading="lazy"></p>
<h4> 15.3.6、查看集群信息</h4>
<p>通过 <strong>cluster nodes</strong> 命令查看集群信息<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230222134148.png" alt="" loading="lazy"></p>
<h3> 15.4、redis cluster如何分配这六个节点</h3>
<p>一个集群至少要有三个主节点。</p>
<p>选项 --cluster-replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。</p>
<p><strong>分配原则</strong>尽量保证每个<strong>主数据库运行在不同的IP</strong>地址，每个<strong>从库和主库不在一个IP地址上</strong>。</p>
<h3> 15.5、slots</h3>
<p>一个 <strong>Redis 集群</strong>包含 <strong>16384 个插槽</strong>（hash slot），插槽平均分配， 数据库中的每个键都属于这 16384 个插槽的其中一个</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230222135222.png" alt="" loading="lazy"></p>
<p>集群使用公式 CRC16(key) % 16384 来<strong>计算键 key 属于哪个槽</strong>， 其中CRC16(key) 语句用于计算键 key 的 CRC16 校验和</p>
<p><strong>集群中的每个节点负责处理一部分插槽</strong>。<br>
举个例子， 如果一个集群可以有主节点， 其中：<br>
节点 A 负责处理 0 号至 5460 号插槽。<br>
节点 B 负责处理 5461 号至 10922 号插槽。<br>
节点 C 负责处理 10923 号至 16383 号插槽。</p>
<h3> 15.6、在集群中录入值</h3>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230222135735.png" alt="" loading="lazy"></p>
<p>不在一个slot下的键值，是<strong>不能使用mget,mset等多键操作</strong>。</p>
<p>可以通过{}来定义组的概念，从而使key中**{}内相同内容的键值对<strong>放到</strong>一个slot**中去<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230222140513.png" alt="" loading="lazy"></p>
<h3> 15.7、查询集群中的值</h3>
<p>cluster keyslot k1：根据k1查询slot值<br>
cluster countkeysinslot 4847：查询插槽内key的个数（不同端口只能看<strong>自己插槽中的值</strong>）<br>
luster getkeysinslot 4847 5：返回对应插槽（4847）中对应数目（5）的key</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230222141328.png" alt="" loading="lazy"></p>
<h3> 15.8、故障恢复</h3>
<p>如果主节点下线，从节点自动升为主节点，(15秒超时,15秒内重启好还是主机，否则为从机）<br>
主节点挂掉后重新上线，会变成从机<br>
如果某一段插槽的主从都挂掉：<br>
<em>redis.conf中的参数 cluster-require-full-coverage</em><br>
如果cluster-require-full-coverage 为yes ，那么 ，整个集群都挂掉<br>
如果cluster-require-full-coverage 为no ，那么，<strong>该插槽</strong>数据全都不能使用，也无法存储，<strong>其他插槽能够提供服务</strong></p>
<h3> 15.9、集群的Jedis开发</h3>
<p>关闭Linux防火墙<br>
<strong>systemctl stop firewalld.service</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 15.10、Redis 集群的优劣</h3>
<p>redis集群的好处：<br>
<strong>实现扩容、分摊压力、无中心配置相对简单</strong></p>
<p>redis集群的不足：<br>
多键操作是不被支持的<br>
多键的Redis事务是不被支持的。lua脚本不被支持<br>
由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至redis cluster，需要整体迁移而不是逐步过渡，复杂度较大。</p>
<h2> 16、应用问题解决</h2>
<h3> 16.1、缓存穿透</h3>
<h4> 问题描述</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230222145050453.png" alt="image-20230222145050453" loading="lazy"></p>
<p>现象：<br>
1、应用服务器压力变大<br>
2、redis命中率降低<br>
3、一直查询数据库</p>
<p>原因：<br>
1、redis查询不到数据库<br>
2、出现很非正常url访问（如rest风格频繁访问不存在资源，而在缓存中找不到，所以一直访问数据库，失去了缓存的意义）</p>
<h4> 解决方案</h4>
<p>一个一定不存在缓存及查询不到的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据<strong>每次请求都要到存储层去查询</strong>，失去了缓存的意义</p>
<p><em>解决方案：</em></p>
<p><strong>（1）</strong>  <strong>对空值缓存：</strong><br>
如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟（应急方案）</p>
<p><strong>（2）</strong>  <strong>设置可访问的名单（白名单）：</strong><br>
使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问。（效率不高）</p>
<p><strong>（3）</strong>  <strong>采用布隆过滤器</strong>：<br>
与方案二类似<br>
(布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量(位图)和一系列随机映射函数（哈希函数）。<br>
布隆过滤器可以用于检索一个元素是否在一个集合中。它的<strong>优点是空间效率和查询时间都远远超过一般的算法</strong>，<strong>缺点是有一定的误识别率和删除困难</strong>。)</p>
<p>将所有可能存在的数据哈希到一个足够大的bitmaps中，一个一定不存在的数据会被这个bitmaps拦截掉，从而避免了对底层存储系统的查询压力。</p>
<p><strong>（4）</strong>  <strong>进行实时监控：</strong><br>
当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务</p>
<h3> 16.2、缓存击穿</h3>
<h4> 问题描述</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230222150301413.png" alt="image-20230222150301413" loading="lazy"></p>
<p>现象：<br>
1、数据库访问压力瞬时增大<br>
2、redis里面没有出现大量ket过期<br>
3、redis正常运行</p>
<p>原因：<br>
1、redis某个key过期了，大量访问都要使用这个key</p>
<h4> 解决方案</h4>
<p>key可能会在某些时间点被超高并发地访问，是一种<strong>非常“热点”的数据</strong>。这个时候，需要考虑一个问题：缓存被“击穿”的问题。</p>
<p>解决方案：</p>
<p><strong>（1）预先设置热门数据</strong>：<br>
在redis高峰访问之前，把一些热门数据提前存入到redis里面，<strong>加大这些热门数据key的时长</strong></p>
<p><strong>（2）实时调整</strong>：<br>
现场<strong>监控哪些数据热门</strong>，实时<strong>调整key的过期时长</strong></p>
<p><strong>（3）使用锁：</strong><br>
①  就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db。<br>
②  先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）去set一个mutex key<br>
③  当操作返回成功时，再进行load db的操作，并回设缓存,最后删除mutex key；<br>
④  当操作返回失败，证明有线程在load db，当前线程睡眠一段时间再重试整个get缓存的方法。</p>
<p><strong>缺点：效率低</strong></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230222151053788.png" alt="image-20230222151053788" loading="lazy"></p>
<h3> 16.3、缓存雪崩</h3>
<h4> 问题描述</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230222151421251.png" alt="image-20230222151421251" loading="lazy"></p>
<p>现象：<br>
1、数据库压力变大，导致服务器崩溃</p>
<p>原因：<br>
1、在极少时间段内，查询大量key的集中过期</p>
<h4> 解决方案</h4>
<p>缓存失效时的雪崩效应对底层系统的冲击非常可怕！</p>
<p>解决方案：</p>
<p><strong>（1）</strong>  <strong>构建多级缓存架构：</strong><br>
nginx缓存 + redis缓存 +其他缓存（ehcache等）（构建复杂）</p>
<p><strong>（2）</strong>  <strong>使用锁或队列：</strong><br>
用<strong>加锁</strong>或者队列的方式保证来保证不会有<strong>大量的线程对数据库一次性进行读写</strong>，从而避免失效时大量的并发请求落到底层存储系统上。<strong>效率极低，不适用高并发情况</strong></p>
<p><strong>（3）</strong>  <strong>设置过期标志更新缓存：</strong><br>
记录缓存数据是否过期（设置提前量），<strong>如果过期</strong>会触发通知另外的线程在后台去<strong>更新实际key的缓存</strong>。</p>
<p><strong>（4）</strong>  <strong>将缓存失效时间分散开：</strong><br>
比如我们可以<strong>在原有的失效时间基础上增加一个随机值</strong>，比如1-5分钟随机，这样每一个缓存的<strong>过期时间的重复率就会降低</strong>，就很难引发集体失效的事件。</p>
<h3> 16.4、分布式锁</h3>
<h4> 16.4.1、问题描述</h4>
<p>随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分<strong>布式系统多线程、多进程</strong>并且分布在不同机器上，这将使原<strong>单机</strong>部署情况下的<strong>并发控制锁策略失效</strong>，单纯的<strong>Java API并不能提供分布式锁的能力</strong>。为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！</p>
<p><strong>分布式锁：加一把锁，对整个集群都有效</strong></p>
<p>分布式锁主流的实现方案：<br>
1、基于数据库实现分布式锁<br>
2、基于缓存（Redis等）<br>
3、基于Zookeeper</p>
<p>每一种分布式锁解决方案都有各自的优缺点：<br>
性能：redis最高<br>
可靠性：zookeeper最高</p>
<p>这里，我们就<strong>基于redis实现分布式锁</strong></p>
<h4> 16.4.2、使用redis实现分布式锁</h4>
<p>使用<strong>setnx上锁</strong>，使用<strong>del释放锁</strong><br>
不设置过期时间，锁会一直没有释放，因此要<strong>设置key的过期时间</strong>，自动释放<br>
在上锁之后，突然出现异常，无法设置过期时间。该<strong>原子操作没有完成</strong>。因此，要上锁的同时设置过期时间</p>
<p>redis命令：<br>
setnx key value：上锁（只有当key不存在时才设置value）<br>
del key： 释放锁， 删除指定的key数据<br>
pire key 10：为给定的key设置过期时间10秒</p>
<p><em><strong>set key value nx ex time：上锁的同时设置过期时间</strong></em></p>
<p>多个客户端（index）获取锁的情况：<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230223085248497.png" alt="image-20230223085248497" loading="lazy"></p>
<h4> 16.4.3、Jedis演示</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重启，服务集群，通过网关压力测试，查看num值<br>
ab -n 1000 -c 100 <a href="http://192.168.137.1:8080/test/testLock" target="_blank" rel="noopener noreferrer">http://192.168.137.1:8080/test/testLock</a></p>
<p>问题：setnx刚好获取到锁，业务逻辑出现异常，导致锁无法释放<br>
解决：<strong>设置过期时间，自动释放锁</strong>。</p>
<h4> 16.4.4、优化之UUID防误删</h4>
<p>问题引入：<br>
有三个操作，a操作拿到锁后未进行操作，导致锁10s过期，被操作b上锁，a的操作未进行</p>
<p>解决方案：引入uuid</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230223134600.png" alt="" loading="lazy"></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 16.4.5、优化之LUA脚本保证删除的原子性</h4>
<p>问题引入：<br>
a，b两个操作，当a操作完后，判断uuid相同，而锁正好过期，b上锁，导致删除了b的锁</p>
<p>解决方案：lua脚本保证原子性</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 16.4.6、总结</h4>
<p>1、加锁</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2、使用lua释放锁</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3、重试</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>为了确保分布式锁可用，我们至少要确保锁的实现同时<strong>满足以下四个条件</strong>：</p>
<p>①互斥性。在任意时刻，<strong>只有一个客户端能持有锁</strong><br>
②不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。（设置<strong>过期时间</strong>）<br>
③解铃还须系铃人。<strong>加锁和解锁必须是同一个客户端</strong>，客户端自己不能把别人加的锁给解了<br>
④加锁和解锁必须具有<strong>原子性</strong></p>
]]></content:encoded>
      <enclosure url="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230212180730.png" type="image/png"/>
    </item>
    <item>
      <title>Docker 基础</title>
      <link>https://T4mako.github.io/code/%E8%BF%90%E7%BB%B4%E4%B8%8E%E9%83%A8%E7%BD%B2/Docker.html</link>
      <guid>https://T4mako.github.io/code/%E8%BF%90%E7%BB%B4%E4%B8%8E%E9%83%A8%E7%BD%B2/Docker.html</guid>
      <source url="https://T4mako.github.io/rss.xml">Docker 基础</source>
      <description>Docker systemctl start docker # 启动docker服务 systemctl stop docker # 停止docker服务 systemctl restart docker # 重启docker服务</description>
      <category>Docker</category>
      <content:encoded><![CDATA[<h2> Docker</h2>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 1、Docker介绍与安装</h2>
<h3> 1.1、Docker概念</h3>
<h4> 1.1.1、应用部署的环境问题</h4>
<p>微服务虽然具备各种各样的优势，但服务的拆分通用给部署带来了很大的麻烦：</p>
<ul>
<li>分布式系统中，依赖的组件非常多，不同组件之间部署时往往会产生一些冲突。</li>
<li>在数百上千台服务中重复部署，环境不一定一致，会遇到各种问题</li>
</ul>
<p>大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题：</p>
<ul>
<li>依赖关系复杂，容易出现兼容性问题</li>
<li>开发、测试、生产环境有差异</li>
</ul>
<h4> 1.1.2、Docker解决依赖兼容问题</h4>
<p>Docker为了解决依赖的兼容问题的，采用了两个手段：</p>
<ul>
<li>
<p>将应用的Libs（函数库）、Deps（依赖）、配置与应用<strong>一起打包</strong></p>
</li>
<li>
<p>将每个应用放到一个隔离<strong>容器</strong>去运行，避免互相干扰</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230324200128.png" alt="" loading="lazy"></p>
<p>这样打包好的应用包中，既包含应用本身，也保护应用所需要的Libs、Deps，<strong>无需再操作系统上安装这些</strong>，自然就不存在不同应用之间的兼容问题了。</p>
<p>虽然解决了不同应用的兼容问题，但是开发、测试等环境会存在差异，操作系统版本也会有差异，怎么解决这些问题呢？</p>
<h4> 1.1.3、Docker解决操作系统环境差异</h4>
<p>要解决不同操作系统环境差异问题，必须先了解操作系统结构。以一个Ubuntu操作系统为例</p>
<p>结构包括：<br>
计算机硬件：例如CPU、内存、磁盘等<br>
系统内核：所有Linux发行版的内核都是Linux，例如CentOS、Ubuntu、Fedora等。内核可以与计算机硬件交互，对外提供<strong>内核指令</strong>，用于操作计算机硬件。<br>
<strong>系统应用</strong>：操作系统本身提供的应用、函数库。这些函数库是对内核指令的封装，使用更加方便。</p>
<p>应用于计算机交互的流程如下：<br>
应用调用操作系统应用（函数库），实现各种功能<br>
<strong>系统函数库</strong>是对内核指令集的封装，会调用内核指令<br>
内核指令操作计算机硬件</p>
<p>Ubuntu和CentOs都是基于Linux内核，无非是系统应用不同，<strong>提供的函数库有差异</strong><br>
此时，如果将一个Ubuntu版本的MySQL应用安装到CentOS系统，MySQL在调用Ubuntu函数库时，会发现找不到或者不匹配，就会报错了</p>
<p><em><strong>Docker如何解决不同系统环境的问题？</strong></em></p>
<ul>
<li>Docker将用户程序与所需要调用的系统(比如Ubuntu)函数库一起打包</li>
<li>Docker运行到不同操作系统时，直接基于打包的函数库，借助于操作系统的Linux内核来运行</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230324200848.png" alt="" loading="lazy"></p>
<h4> 1.1.4、小结</h4>
<p>Docker如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？</p>
<ul>
<li>Docker允许开发中将应用、依赖、函数库、配置一起<strong>打包</strong>，形成可移植镜像</li>
<li>Docker应用运行在容器中，使用沙箱机制，相互<strong>隔离</strong></li>
</ul>
<p>Docker如何解决开发、测试、生产环境有差异的问题？</p>
<ul>
<li><strong>Docker镜像中包含完整运行环境</strong>，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行</li>
</ul>
<p>Docker是一个<strong>快速交付应用、运行应用的技术</strong>，具备下列优势：</p>
<ul>
<li>可以将程序及其依赖、运行环境一起打包为一个镜像，<strong>可以迁移到任意Linux操作系统</strong></li>
<li>运行时利用沙箱机制形成隔离容器，各个应用互不干扰</li>
<li>启动、移除都可以通过一行命令完成，方便快捷</li>
</ul>
<h3> 1.2、Docker和虚拟机的区别</h3>
<p>Docker可以让一个应用在任何操作系统中非常方便的运行。而以前我们接触的虚拟机，也能在一个操作系统中，运行另外一个操作系统，保护系统中的任何应用。</p>
<p>两者的差异：</p>
<p><strong>虚拟机</strong>（virtual machine）是在操作系统中<strong>模拟硬件设备</strong>，然后运行另一个操作系统，比如在 Windows 系统里面运行 Ubuntu 系统，这样就可以运行任意的Ubuntu应用了。<br>
<strong>Docker</strong>仅仅是<strong>封装函数库</strong>，并没有模拟完整的操作系统，如图：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230324202321.png" alt="" loading="lazy"></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>Docker</th>
<th>虚拟机</th>
</tr>
</thead>
<tbody>
<tr>
<td>性能</td>
<td>接近原生</td>
<td>性能较差</td>
</tr>
<tr>
<td>硬盘占用</td>
<td>一般为MB</td>
<td>一般为GB</td>
</tr>
<tr>
<td>启动</td>
<td>秒级</td>
<td>分钟级</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>docker是一个系统进程；虚拟机是在操作系统中的操作系统</p>
</li>
<li>
<p>docker体积小、启动速度快、性能好；虚拟机体积大、启动速度慢、性能一般</p>
</li>
</ul>
<h3> 1.3、Docker架构</h3>
<h4> 1.3.1、镜像和容器</h4>
<p><strong>镜像（Image）</strong>：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件<strong>打包在一起</strong>，称为<strong>镜像</strong></p>
<p><strong>容器（Container）</strong>：镜像中的<strong>应用程序运行后形成的进程</strong>就是<strong>容器</strong>，只是Docker会给容器进程做隔离，对外不可见</p>
<p>镜像，就是把一个应用在硬盘上的文件、及其运行环境、部分系统函数库文件一起打包形成的文件包。这个文件包是<strong>只读</strong>的<br>
容器，就是将这些文件中编写的程序、函数加载到内存中允许，形成进程，只不过要隔离起来。因此<strong>一个镜像可以启动多次，形成多个容器进程</strong></p>
<h4> 1.3.2、DockerHub</h4>
<p><strong><a href="https://hub.docker.com/" target="_blank" rel="noopener noreferrer">DockerHub</a></strong>：一个Docker镜像的托管平台，这样的平台称为Docker Registry</p>
<p>国内也有类似于DockerHub 的公开服务，比如 <a href="https://c.163yun.com/hub" target="_blank" rel="noopener noreferrer">网易云镜像服务</a>、<a href="https://cr.console.aliyun.com/" target="_blank" rel="noopener noreferrer">阿里云镜像库</a>等。</p>
<p>一方面可以将自己的镜像共享到DockerHub，另一方面也可以从DockerHub拉取镜像</p>
<h4> 1.3.3、Docker架构</h4>
<p>我们要使用Docker来操作镜像、容器，就必须要安装Docker。</p>
<p>Docker是一个CS架构的程序，由两部分组成：</p>
<ul>
<li>
<p>服务端(server)：Docker守护进程，负责处理Docker指令，管理镜像、容器等</p>
</li>
<li>
<p>客户端(client)：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230324203906.png" alt="" loading="lazy"></p>
<h3> 1.4、安装Docker</h3>
<p>在CentOS下安装Docker：<br>
Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10， CentOS 7 满足最低内核的要求</p>
<h4> 1.4.1、卸载（可选）</h4>
<p>如果之前安装过旧版本的Docker，可以使用下面命令卸载：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>\ 表示命令的拼贴，表示一行写不下</p>
</blockquote>
<h4> 1.4.2、安装Docker</h4>
<p>安装yum工具</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后更新本地镜像源：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输入命令：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>docker-ce为<strong>社区免费版本</strong>。稍等片刻，docker即可安装成功。</p>
<h3> 1.5、启动docker</h3>
<p>Docker应用需要用到各种端口，逐一去修改防火墙设置。非常麻烦，因此建议大家直接<strong>关闭防火墙</strong>！<br>
启动docker前，一定要关闭防火墙</p>
<p>关闭防火墙：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过命令启动docker：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后输入命令，可以查看docker版本：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230324205228531.png" alt="image-20230324205228531" loading="lazy"></p>
<h3> 1.6、配置介绍</h3>
<p>docker官方镜像仓库网速较差，我们需要设置国内镜像服务：</p>
<p>参考阿里云的镜像加速文档：<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors" target="_blank" rel="noopener noreferrer">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</a></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230324205410.png" alt="" loading="lazy"></p>
<h2> 2、Docker基本操作</h2>
<h3> 2.1、镜像操作</h3>
<h4> 2.1.1、镜像名称</h4>
<p>镜像的名称组成：</p>
<ul>
<li>镜名称一般分两部分组成：[repository]:[tag]。</li>
<li>在没有指定tag时，默认是latest，代表最新版本的镜像</li>
</ul>
<p>比如Mysql : 5.7<br>
这里的mysql就是repository，5.7就是tag，合一起就是镜像名称，代表5.7版本的MySQL镜像。</p>
<h4> 2.1.2、镜像命令</h4>
<p>常见的镜像操作命令如图：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230325201245.png" alt="" loading="lazy"></p>
<h4> 2.1.3、拉取、查看镜像</h4>
<p>从DockerHub中拉取一个nginx镜像并查看：</p>
<p>1）首先去镜像仓库搜索nginx镜像，比如<a href="https://hub.docker.com/" target="_blank" rel="noopener noreferrer">DockerHub</a>:</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230325201540.png" alt="" loading="lazy"></p>
<p>2）根据查看到的镜像名称，拉取自己需要的镜像，通过命令：<strong>docker pull nginx</strong></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230325201611.png" alt="" loading="lazy"></p>
<p>3）通过命令：<strong>docker images</strong> 查看拉取到的镜像</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230325201958.png" alt="" loading="lazy"></p>
<h4> 2.1.4、保存、导入镜像</h4>
<p>利用docker save将nginx镜像导出磁盘，然后再通过load加载回来</p>
<p>1）<strong>docker xx --help</strong> 命令查看docker命令的语法</p>
<p>例如：docker save --help</p>
<p>2）<strong>docker save</strong> 保存镜像</p>
<p>docker save 的命令格式</p>
<p>o：output</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用docker save导出镜像到磁盘</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230325202433.png" alt="" loading="lazy"></p>
<p>3）**docker rmi **删除镜像</p>
<div class="language-0sh line-numbers-mode" data-ext="0sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230325203133.png" alt="" loading="lazy"></p>
<p>4）使用<strong>docker load</strong> 加载镜像</p>
<p>先删除本地的nginx镜像，然后运行命令，加载本地文件：</p>
<p>i：inpute</p>
<div class="language-SH line-numbers-mode" data-ext="SH"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2.2、容器操作</h3>
<h4> 2.2.1.容器相关命令</h4>
<p>容器操作的命令如图：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230325204158.png" alt="" loading="lazy"></p>
<p>容器保护三个状态：<br>
运行：进程正常运行<br>
暂停：进程暂停，CPU不再运行，并不释放内存<br>
停止：进程终止，回收进程占用的内存、CPU等资源</p>
<p><strong>docker ps -a</strong>：查看全部容器命令<br>
<strong>docker run</strong>：创建并运行一个容器，处于运行状态<br>
<strong>docker pause</strong>：让一个运行的容器暂停<br>
<strong>docker unpause</strong>：让一个容器从暂停状态恢复运行<br>
<strong>docker stop</strong>：停止一个运行的容器<br>
<strong>docker start</strong>：让一个停止的容器再次运行<br>
<strong>docker rm</strong>：删除一个容器</p>
<h4> 2.2.2、创建并运行一个容器</h4>
<p>首先去docker hub查看Nginx的容器运行命令</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230325204823.png" alt="" loading="lazy"></p>
<p>创建并运行nginx容器的命令：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>docker run</strong> ：创建并运行一个容器<br>
--name : 给容器起一个名字，比如叫做mn<br>
-p ：将宿主机端口与容器端口映射，冒号<strong>左侧是宿主机端口，右侧是容器端口</strong>（容器是隔离环境，访问不到容器中的nginx）<br>
-d：后台运行容器<br>
nginx：镜像名称，例如nginx</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230325205509.png" alt="" loading="lazy"></p>
<p>使用 **docker ps **查看容器状态：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230325205636.png" alt="" loading="lazy"></p>
<p>使用 <strong>docker log 容器名</strong> ：查看容器日志信息</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230325210207.png" alt="" loading="lazy"></p>
<h4> 2.2.3、进入容器，修改文件</h4>
<p>1）进入容器</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>docker exec</strong> ：进入容器内部，执行一个命令<br>
-it: 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互<br>
mynginx：要进入的容器的名称<br>
bash：进入容器后执行的命令，bash是一个linux终端交互命令</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230325211126.png" alt="" loading="lazy"></p>
<p>2）进入nginx的HTML所在目录 /usr/share/nginx/html</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230325212440.png" alt="" loading="lazy"></p>
<p>容器内部会模拟一个独立的Linux文件系统，看起来如同一个linux服务器一样</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>3）修改index.html的内容</p>
<p>容器内没有vi命令，无法直接修改，我们用下面的命令来修改：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>**exit：**退出容器</p>
<p><strong>docker stop</strong> mynginx：停止容器</p>
<p><strong>docker ps -a</strong> （查看所有容器，不带-a是正在运行的）</p>
<p><strong>docker start mynginx</strong>：开启容器</p>
<p><strong>docker rm</strong> mynginx：删除容器（要先stop才能删除）</p>
<p><strong>docker rm -f</strong> mynginx：强制删除容器</p>
<h3> 2.3、数据卷（容器数据管理）</h3>
<p>在之前的nginx案例中，修改nginx的html页面时，需要进入nginx内部。并且因为没有编辑器，修改文件也很麻烦。<br>
这就是因为<strong>容器与数据（容器内文件）耦合</strong>带来的后果。</p>
<p>要解决这个问题，必须将数据与容器解耦，这就要用到<strong>数据卷</strong>了。</p>
<h4> 2.3.1、数据卷的概念</h4>
<p>**数据卷（volume）**是一个虚拟目录，指向宿主机文件系统中的某个目录。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230325214249.png" alt="" loading="lazy"></p>
<p>一旦完成数据卷挂载，<strong>对容器的一切操作</strong>都会作用<strong>在数据卷对应的宿主机目录</strong>了。<br>
这样，我们操作宿主机的/var/lib/docker/volumes/html目录，就等于操作容器内的/usr/share/nginx/html目录了</p>
<h4> 2.3.2、数据卷操作命令</h4>
<p>基本语法：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>docker volume命令是数据卷操作，根据命令后<strong>跟随的command</strong>来确定<strong>下一步</strong>的操作：</p>
<p><strong>create</strong> 			创建一个volume<br>
<strong>inspect</strong> 		  显示一个或多个volume的信息<br>
<strong>ls</strong> 					列出所有的volume<br>
<strong>prune</strong> 			 删除未使用的volume<br>
<strong>rm</strong> 				  删除一个或多个指定的volume</p>
<h4> 2.3.3、创建和查看数据卷</h4>
<p>创建一个数据卷，并查看数据卷在宿主机的目录位置</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，我们创建的html这个数据卷关联的宿主机目录为<code>/var/lib/docker/volumes/html/_data</code>目录。</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230325215020.png" alt="" loading="lazy"></p>
<h4> 2.3.4、挂载数据卷</h4>
<p>在创建容器时，可以通过 -v 参数来挂载一个数据卷到某个容器内目录，命令格式如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p><strong>注意：如果容器运行时volume不存在，会被自动创建出来</strong>（即无需创建卷，在容器创建时直接挂在卷即可）</p>
</blockquote>
<h4> 2.3.6、挂载本地目录</h4>
<p>容器不仅仅可以挂载数据卷，也可以直接挂载到宿主机目录上。关联关系如下：</p>
<ul>
<li>带数据卷模式：宿主机目录 --&gt; 数据卷 ---&gt; 容器内目录</li>
<li><strong>直接挂载</strong>模式：宿主机目录 ---&gt; 容器内目录</li>
</ul>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230325221338.png" alt="" loading="lazy"></p>
<p>目录挂载与数据卷挂载的语法是类似的：</p>
<ul>
<li>-v [宿主机目录]:[容器内目录]</li>
<li>-v [宿主机文件]:[容器内文件]</li>
</ul>
<p>举例：<br>
创建并运行一个MySQL容器，将宿主机目录直接挂载到容器<br>
1）在将课前资料中的mysql.tar文件上传到虚拟机，通过load命令加载为镜像<br>
2）创建目录/tmp/mysql/data<br>
3）创建目录/tmp/mysql/conf，将课前资料提供的hmy.cnf文件上传到/tmp/mysql/conf<br>
4）去DockerHub查阅资料，创建并运行MySQL容器，要求：<br>
① 挂载/tmp/mysql/data到mysql容器内数据存储目录<br>
② 挂载/tmp/mysql/conf/hmy.cnf到mysql容器的配置文件<br>
③ 设置MySQL密码</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3、Dockerfile自定义镜像</h2>
<p>常见的镜像在DockerHub就能找到，但是我们自己写的项目就必须自己构建镜像了。</p>
<h3> 3.1、镜像结构</h3>
<p><strong>镜像</strong>是将<strong>应用程序及其需要的系统函数库、环境、配置、依赖打包</strong>而成。</p>
<p>镜像是一个分层结构，每一层称为一个Layer<br>
<strong>BaseImage</strong>层：包含基本的系统函数库，环境变量，文件系统<br>
<strong>Entrypoint</strong>：入口，是镜像中应用启动的命令<br>
其他：在BaseImage基础上添加依赖，安装程序、完成整个应用的安装和配置</p>
<p>简单来说，镜像就是在<strong>系统函数库</strong>、运行环境基础上，<strong>添加应用程序文件、配置文件、依赖文件</strong>等组合，然后编写好<strong>启动脚本</strong>打包在一起形成的<strong>文件</strong>。</p>
<p>构建镜像，其实就是实现上述打包的过程。</p>
<h3> 3.2、Dockerfile语法</h3>
<p>构建自定义的镜像时，并不需要一个个文件去拷贝，打包<br>
只需要告诉Docker，我们的镜像的组成，需要哪些<strong>BaseImage</strong>、需要<strong>拷贝什么文件</strong>、需要安装什么<strong>依赖</strong>、<strong>启动脚本</strong>是什么，将来Docker会帮助我们构建镜像。</p>
<p>而描述上述信息的文件就是<strong>Dockerfile文件</strong></p>
<p><strong>Dockerfile</strong>就是一个<strong>文本文件</strong>，其中包含一个个的<strong>指令(Instruction)</strong>，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层Layer。<br>
<a href="https://docs.docker.com/engine/reference/builder" target="_blank" rel="noopener noreferrer">官网文档</a></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230326100643.png" alt="" loading="lazy"></p>
<h3> 3.3、构建Java项目案例</h3>
<h4> 3.3.1、基于Ubuntu构建Java项目（麻烦）</h4>
<p>基于Ubuntu镜像构建一个新镜像，运行一个java项目</p>
<p>步骤1：新建一个空文件夹docker-demo<br>
步骤2：拷贝课前资料中的docker-demo.jar文件到docker-demo这个目录<br>
步骤3：拷贝课前资料中的jdk8.tar.gz文件到docker-demo这个目录<br>
步骤4：拷贝课前资料提供的Dockerfile到docker-demo这个目录<br>
其中的内容如下：</p>
<div class="language-docker line-numbers-mode" data-ext="docker"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>步骤5：进入docker-demo<br>
将准备好的docker-demo上传到虚拟机任意目录，然后进入docker-demo目录下</p>
<p>步骤6：运行命令：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>最后访问 <a href="http://192.168.80.135:8090/hello/count" target="_blank" rel="noopener noreferrer">http://192.168.80.135:8090/hello/count</a></p>
<h4> 3.3.2、基于java8构建Java项目（简便）</h4>
<p>虽然我们可以基于Ubuntu基础镜像，添加任意自己需要的安装包，构建镜像，但是却比较麻烦。所以大多数情况下，我们都可以<strong>在一些安装了部分软件的基础镜像上做改造</strong>。<br>
构建java项目的镜像，可以在已经准备了JDK的基础镜像基础上构建。</p>
<p>基于java:8-alpine镜像，将一个Java项目构建为镜像：</p>
<p>① 新建一个空的目录，然后在目录中新建一个文件，命名为Dockerfile<br>
② 拷贝课前资料提供的docker-demo.jar到这个目录中<br>
③ 修改Dockerfile文件：<br>
a ）基于java:8-alpine作为基础镜像<br>
b ）将app.jar拷贝到镜像中<br>
c ）暴露端口<br>
d ）编写入口ENTRYPOINT</p>
<p>内容如下：</p>
<div class="language-docker line-numbers-mode" data-ext="docker"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>④ 使用docker build命令构建镜像</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>⑤ 使用docker run创建容器并运行</p>
<h2> 4、Docker-Compose</h2>
<p>Docker Compose可以<strong>基于Compose文件</strong>帮我们<strong>快速的部署分布式应用，而无需手动一个个创建和运行容器</strong>！</p>
<h3> 4.1、认识DockerCompose</h3>
<p>Compose文件是一个文本文件，通过指令定义集群中的每个容器如何运行。格式如下：</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><a href="https://docs.docker.com/compose/compose-file/" target="_blank" rel="noopener noreferrer">DockerCompose的详细语法参考官网</a></p>
<p>DockerCompose文件可以看做是将多个docker run命令写到一个文件，只是语法稍有差异。</p>
<h3> 4.2、CentOS7安装DockerCompose</h3>
<h4> 4.2.1、下载</h4>
<p>Linux下需要通过命令下载：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果下载速度较慢，或者下载失败，可以使用课前资料提供的docker-compose文件，上传到<code>/usr/local/bin/</code>目录也可以。</p>
<h4> 4.2.2、修改文件权限</h4>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4.3.3、Base自动补全命令：</h4>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果这里出现错误，需要修改自己的hosts文件：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 4.3、部署微服务集群案例</h3>
<p>案例：将cloud-demo微服务集群利用DockerCompose部署</p>
<p><strong>实现思路</strong>：</p>
<p>① 查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件<br>
② 修改自己的cloud-demo项目，将数据库、nacos地址都命名为docker-compose中的服务名<br>
③ 使用maven打包工具，将项目中的每个微服务都打包为app.jar<br>
④ 将打包好的app.jar拷贝到cloud-demo中的每一个对应的子目录中<br>
⑤ 将cloud-demo上传至虚拟机，利用 docker-compose up -d 来部署</p>
<h4> 4.3.1、compose文件</h4>
<p>课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件，而且每个微服务都准备了一个独立的目录：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中包含5个service服务：<br>
<code>nacos</code>：作为注册中心和配置中心<br>
<code>image: nacos/nacos-server</code>： 基于nacos/nacos-server镜像构建<br>
<code>environment</code>：环境变量<br>
<code>MODE: standalone</code>：单点模式启动<br>
<code>ports</code>：端口映射，这里暴露了8848端口</p>
<p><code>mysql</code>：数据库<br>
<code>image: mysql:5.7.25</code>：镜像版本是mysql:5.7.25<br>
<code>environment</code>：环境变量<br>
<code>MYSQL_ROOT_PASSWORD: 123</code>：设置数据库root账户的密码为123<br>
<code>volumes</code>：数据卷挂载，这里挂载了mysql的data、conf目录，其中有提前准备好的数据</p>
<p>​	<code>userservice</code>、<code>orderservice</code>、<code>gateway</code>：都是基于Dockerfile临时构建的</p>
<p>查看mysql目录，可以看到其中已经准备好了cloud_order、cloud_user表<br>
查看微服务目录，可以看到都包含Dockerfile文件</p>
<p>内容如下：</p>
<div class="language-docker line-numbers-mode" data-ext="docker"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4.3.2、修改微服务配置</h4>
<p><strong>微服务</strong>将来要<strong>部署为docker容器</strong>，而<strong>容器之间</strong>互联不是通过IP地址，而是<strong>通过容器名</strong>。这里我们<strong>将order-service、user-service、gateway服务的mysql、nacos地址都修改为基于容器名的访问</strong></p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4.3.3、打包</h4>
<p>接下来需要将我们的每个微服务都打包。因为之前查看到<strong>Dockerfile中的jar包名称都是app.jar</strong>，因此我们的每个微服务都需要用这个名称。</p>
<p>可以通过<strong>修改pom.xml</strong>中的<strong>打包名称</strong>来实现，每个微服务都需要修改：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>打包后</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230326113508.png" alt="" loading="lazy"></p>
<h4> 4.3.4、拷贝jar包到部署目录</h4>
<p>编译打包好的app.jar文件，需要<strong>放到Dockerfile的同级目录中</strong><br>
注意：每个微服务的app.jar放到与服务名称对应的目录</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230326113628.png" alt="" loading="lazy"></p>
<h4> 4.3.5、部署</h4>
<p>最后，需要将文件整个cloud-demo文件夹上传到虚拟机中，由DockerCompose部署。</p>
<p>进入cloud-demo目录，然后运行下面的命令：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 5.Docker镜像仓库</h2>
<h3> 5.1、搭建私有镜像仓库</h3>
<p>搭建镜像仓库可以基于Docker官方提供的<a href="https://hub.docker.com/_/registry" target="_blank" rel="noopener noreferrer">DockerRegistry</a>来实现。</p>
<h4> 5.1.1、简化版镜像仓库</h4>
<p>Docker官方的Docker Registry是一个基础版本的Docker镜像仓库，具备仓库管理的完整功能，但是没有图形化界面。</p>
<p>搭建方式比较简单，命令如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>命令中挂载了一个数据卷registry-data到容器内的/var/lib/registry 目录，这是私有镜像库存放数据的目录。</p>
<p>访问<a href="http://YourIp:5000/v2/_catalog" target="_blank" rel="noopener noreferrer">http://YourIp:5000/v2/_catalog</a> 可以查看当前私有镜像服务中包含的镜像</p>
<h4> 5.1.2、带有图形化界面版本</h4>
<p>使用DockerCompose部署带有图象界面的DockerRegistry，命令如下：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 5.1.3、配置Docker信任地址</h4>
<p>我们的私服采用的是http协议，默认不被Docker信任，所以需要做一个配置：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5.2、推送、拉取镜像</h3>
<p>推送镜像到私有镜像服务必须先tag，步骤如下：</p>
<p>① 重新tag本地镜像，名称前缀为私有仓库的地址：<br>
192.168.80.135:8080/</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>② 推送镜像</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>③ 拉取镜像</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230324200128.png" type="image/png"/>
    </item>
    <item>
      <title>CentOS 部署 Java 项目</title>
      <link>https://T4mako.github.io/code/%E8%BF%90%E7%BB%B4%E4%B8%8E%E9%83%A8%E7%BD%B2/%E5%9F%BA%E4%BA%8Ecentos%E9%83%A8%E7%BD%B2java%E9%A1%B9%E7%9B%AE.html</link>
      <guid>https://T4mako.github.io/code/%E8%BF%90%E7%BB%B4%E4%B8%8E%E9%83%A8%E7%BD%B2/%E5%9F%BA%E4%BA%8Ecentos%E9%83%A8%E7%BD%B2java%E9%A1%B9%E7%9B%AE.html</guid>
      <source url="https://T4mako.github.io/rss.xml">CentOS 部署 Java 项目</source>
      <description>基于CentOs的Java项目部署 1、软件安装 1、软件安装方式 二进制发布包安装	软件已经针对具体平台编译打包发布，只要解压，修改配置即可 rmp安装			(Red-Hat Package Manage)，软件已经按照redhat的包管理规范进行打包，使用rpm命令安装，不能自行解决库依赖问题 yum安装			(Yellow dog Updater)一种在线软件安装方式，本质上还是rpm安装，自动下载安装包并安装，安装过程中自动解决库依赖问题 源码编译安装	软件以源码工程形式发布，需要自己编译打包</description>
      <category>Linux</category>
      <content:encoded><![CDATA[<p><strong>基于CentOs的Java项目部署</strong></p>
<h2> 1、软件安装</h2>
<h3> 1、软件安装方式</h3>
<p>二进制发布包安装	软件已经针对具体平台编译打包发布，只要解压，修改配置即可<br>
rmp安装			(Red-Hat Package Manage)，软件已经按照redhat的包管理规范进行打包，使用rpm命令安装，不能自行解决库依赖问题<br>
yum安装			(Yellow dog Updater)一种在线软件安装方式，本质上还是rpm安装，自动下载安装包并安装，安装过程中自动解决库依赖问题<br>
源码编译安装	软件以源码工程形式发布，需要自己编译打包</p>
<h3> 2、搭建环境</h3>
<p><strong>安装JDK、Tomcat、MySQL、lrzsz，Redis</strong></p>
<p>jdk的重新安装位置：/usr/lcoal</p>
<h4> 1、Tomcat的开启，使用、关闭</h4>
<p>在Tomecat官网下砸Tomcat8.tar.gz，通过xftp上传至CentOS<br>
上传地址为**/usr/lcoal/tomcat**<br>
使用tar -zxvf apache-tomcat-8.5.87.tar.gz解压<br>
进入Tomcat的bin目录启动服务，命令为<strong>sh <a href="http://startup.sh" target="_blank" rel="noopener noreferrer">startup.sh</a></strong> 或 <strong>./startup.sh</strong></p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230315131921000.png" alt="image-20230315131921000" loading="lazy"></p>
<p>要访问Tomcat，需要开放8080端口<br>
firewall-cmd --zone=public --add-port=8080/tcp --permanent<br>
firewall-cmd --reload</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230315132243.png" alt="" loading="lazy"></p>
<p>停止Tomcat服务的方式：<br>
<a href="http://xn--Tomcatbinshutdown-0g60al89up52et2bl07olesb.sh" target="_blank" rel="noopener noreferrer">运行Tomcat中bin目录的shutdown.sh</a><br>
<strong>sh <a href="http://shutdown.sh" target="_blank" rel="noopener noreferrer">shutdown.sh</a></strong> 或者 <strong>./shutdowndown.sh</strong></p>
<p>结束Tomcat进程：<br>
使用ps -ef | grep tomcat查看tomcat进程，获得进程id<br>
执行kill -9 id命令</p>
<h4> 2、安装lrzsz</h4>
<p>1、搜索lrzsz安装包，命令为yum list lrzsz<br>
2、使用yum命令在线安装，命令为yum install lrzsz.x86_64</p>
<p><code>Yum是一个在Fedora和RedHat以及CEntOS中的shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理一拉关系，并且一次安装所有依赖的软件包，无需繁琐地一次次下载，安装</code></p>
<h3> 3、安装GIt</h3>
<p>yum list git	列出git安装包<br>
yum install git	在线安装git</p>
<h3> 4、安装maven</h3>
<p>将maven.tar.gz复制到/usr目录下<br>
tar -zxvf apache-maven-3.8.8-bin.tar.gz</p>
<p>修改配置文件：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230315144922.png" alt="" loading="lazy"></p>
<p>配置环境变量</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>修改settings文件，配置maven的本地仓库为/usr/local/repo<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230315154928.png" alt="" loading="lazy"></p>
<h2> 2、项目部署</h2>
<h3> 1、手工部署项目（不推荐）</h3>
<h5> 1、先将idea中的项目打成jar包</h5>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230315140251283.png" alt="image-20230315140251283" loading="lazy"></p>
<h4> 2、将jar包传到linux上，目录/usr/app</h4>
<h4> 3、通过java -jar XXX.jar 运行jar包</h4>
<h4> 4、检查防火墙，确保8080端口对外开放，访问springboot项目</h4>
<p>fire-cmd --zone=public --list-ports</p>
<h4> 5、改为后台运行项目，并将日志输出到日志文件</h4>
<p>目前程序运行的问题：<br>
线上程序霸屏控制台，应该后台运行<br>
日志不应输出到控制台，应该输入到文件，方便运维查阅信息</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230315141525.png" alt="" loading="lazy"></p>
<p>命令：<br>
<strong>nohup java -jar XXX.jar &amp;&gt; XXX,log &amp;</strong></p>
<p>关闭项目：<br>
ps -ef | grep java -jar   查找id<br>
kill -9 id						结束进程</p>
<h3> 2、通过Shell脚本自动部署项目</h3>
<p>操作步骤：<br>
①在Linux中安装Git<br>
②在Linux中安装maven<br>
③编写Shell脚本（拉取代码，编译，打包，启动）<br>
④为用户授予执行shell脚本的权限<br>
⑤执行shell脚本</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/20230315142408.png" alt="" loading="lazy"></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>将shell脚本复制到项目中，chmod修改权限777，通过./bootStart.sh运行shell脚本</p>
]]></content:encoded>
      <enclosure url="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230315131921000.png" type="image/png"/>
    </item>
    <item>
      <title>一些效果/插件</title>
      <link>https://T4mako.github.io/interests/AE/%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6.html</link>
      <guid>https://T4mako.github.io/interests/AE/%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6.html</guid>
      <source url="https://T4mako.github.io/rss.xml">一些效果/插件</source>
      <description>２、位移 1、偏移 图形层、alpha遮罩遮、偏移 2、变形 ３、表达式 1、晃动表达式 freq = 3; decay = 5; n = 0; if (numKeys &amp;gt; 0){ n = nearestKey(time).index; if (key(n).time &amp;gt; time) n--; } if (n &amp;gt; 0){ t = time - key(n).time; amp = velocityAtTime(key(n).time - .001); w = freq*Math.PI*2; value + amp*(Math.sin(t*w)/Math.exp(decay*t)/w); }else Value</description>
      <content:encoded><![CDATA[<h2> ２、位移</h2>
<p>1、偏移</p>
<p><code>图形层、alpha遮罩遮、偏移</code></p>
<p>2、变形</p>
<h2> ３、表达式</h2>
<h3> 1、晃动表达式</h3>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 4、GLITCH</h2>
<p>1、universe stylize - GLITCH</p>
<h2> 5、RGB分离</h2>
<p>1、s_TimeWarpRGB<br>
2、Simple RGB Separation<br>
3、s_DistrotRGB（RGB边缘）<br>
<code>s_TVdamage，CC Toner，模糊，twitch，差值</code><br>
4、uni.Chromatic Aberration<br>
<code>光学补偿、blur</code><br>
5、S_WarpChroma</p>
<h2> 6、Shake</h2>
<p>1、s_shake<br>
参数、预设<br>
wiggle，垂直，旋转</p>
<h2> 7、发光</h2>
<p>1、deep glow<br>
2、Shine<br>
3、of光<br>
4、StarGlow</p>
<h2> 8、模糊</h2>
<p>1、动态模糊<br>
2、RSMB<br>
3、Bcc lens blur obs<br>
4、S_BlurDirectional<br>
5、定向模糊<br>
6、镜像模糊<br>
7、CC  Wide  Time</p>
<h2> 9、闪烁</h2>
<p>1、闪烁s_Flicker<br>
2、纯色层（全/局）</p>
<h2> 10、HalfTone</h2>
<p>1、BCC_HalfTone （以明暗度画点）</p>
]]></content:encoded>
    </item>
    <item>
      <title>快捷键</title>
      <link>https://T4mako.github.io/interests/AE/%E5%BF%AB%E6%8D%B7%E9%94%AE.html</link>
      <guid>https://T4mako.github.io/interests/AE/%E5%BF%AB%E6%8D%B7%E9%94%AE.html</guid>
      <source url="https://T4mako.github.io/rss.xml">快捷键</source>
      <description>快捷键</description>
      <category>AE</category>
      <content:encoded><![CDATA[<h1> 快捷键</h1>
<!-- more -->
<table>
<thead>
<tr>
<th>快捷键</th>
<th style="text-align:left">效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl+D</td>
<td style="text-align:left">复制</td>
</tr>
<tr>
<td>Ctrl+K</td>
<td style="text-align:left">调出工程设置</td>
</tr>
<tr>
<td>*</td>
<td style="text-align:left">打点</td>
</tr>
<tr>
<td>Alt+[</td>
<td style="text-align:left">裁切码表前时间条</td>
</tr>
<tr>
<td>Alt+]</td>
<td style="text-align:left">裁切码表后时间条</td>
</tr>
<tr>
<td>[</td>
<td style="text-align:left">快速对齐码表</td>
</tr>
<tr>
<td>B</td>
<td style="text-align:left">前工作区节点</td>
</tr>
<tr>
<td>N</td>
<td style="text-align:left">后工作区节点</td>
</tr>
<tr>
<td>Y</td>
<td style="text-align:left">移动中心点</td>
</tr>
<tr>
<td>P</td>
<td style="text-align:left">位移</td>
</tr>
<tr>
<td>S</td>
<td style="text-align:left">缩放</td>
</tr>
<tr>
<td>R</td>
<td style="text-align:left">旋转</td>
</tr>
<tr>
<td>T</td>
<td style="text-align:left">透明度</td>
</tr>
<tr>
<td>U</td>
<td style="text-align:left">调出关键帧属性</td>
</tr>
<tr>
<td>C</td>
<td style="text-align:left">进入摄像机</td>
</tr>
<tr>
<td>Ctrl+alt+t</td>
<td style="text-align:left">时间重映射</td>
</tr>
<tr>
<td>Shift</td>
<td style="text-align:left">吸附</td>
</tr>
<tr>
<td>Ctrl+R</td>
<td style="text-align:left">调出标尺</td>
</tr>
<tr>
<td>PgDn（PageDown）</td>
<td style="text-align:left">单帧</td>
</tr>
<tr>
<td>Ctrl+Shift+C</td>
<td style="text-align:left">预合成打组（三维层打组，要加摄像机）</td>
</tr>
<tr>
<td>Ctrl+Shift+B</td>
<td style="text-align:left">切一刀</td>
</tr>
<tr>
<td>蒙版 Ctrl+t</td>
<td style="text-align:left">移动蒙版</td>
</tr>
<tr>
<td>关键帧的 C V</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>选中图层双击图形工具</td>
<td style="text-align:left">快速建立蒙版</td>
</tr>
<tr>
<td>选中图层调整蒙版单独触点</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>Ctrl+Y</td>
<td style="text-align:left">新建纯色层</td>
</tr>
<tr>
<td>Ctrl+Shift+Y</td>
<td style="text-align:left">修改纯色层颜色</td>
</tr>
</tbody>
</table>
]]></content:encoded>
    </item>
    <item>
      <title>CSGO weapons 导入 blender</title>
      <link>https://T4mako.github.io/interests/Blender/CSGO%E9%A5%B0%E5%93%81%E5%9B%BE.html</link>
      <guid>https://T4mako.github.io/interests/Blender/CSGO%E9%A5%B0%E5%93%81%E5%9B%BE.html</guid>
      <source url="https://T4mako.github.io/rss.xml">CSGO weapons 导入 blender</source>
      <description>1、提取CSGO文件 下载Crowbar、解包文件 image-20230202233524241 2、导出smd文件 image-20230202233539754 登录buff 进入3d检视 下载纹理贴图和法向贴图（注意要PNG） 在着色编辑器下编辑 添加法向贴图 调整金属度与糙度 image-20230203184558140</description>
      <enclosure url="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230202233524241.png" type="image/png"/>
    </item>
    <item>
      <title>基础</title>
      <link>https://T4mako.github.io/interests/Blender/%E5%9F%BA%E7%A1%80.html</link>
      <guid>https://T4mako.github.io/interests/Blender/%E5%9F%BA%E7%A1%80.html</guid>
      <source url="https://T4mako.github.io/rss.xml">基础</source>
      <description>1、基础操作/概念 1、移动 沿坐标轴移动（图中轴） 沿平面移动（图中面） 沿着自由方向移动（图中白色圆圈） 微调面板 2、旋转 3、缩放 4、显示物体边界范围</description>
      <content:encoded><![CDATA[<h3> 1、基础操作/概念</h3>
<h4> 1、移动</h4>
<p>沿坐标轴移动（图中轴）<br>
沿平面移动（图中面）<br>
沿着自由方向移动（图中白色圆圈）</p>
<p>微调面板</p>
<h4> 2、旋转</h4>
<h4> 3、缩放</h4>
<h4> 4、显示物体边界范围</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230120210101271.png" alt="image-20230120210101271" loading="lazy"></p>
<h4> 5、游标</h4>
<p>游标是物体的出生点<br>
移动游标时不要点击虚空</p>
<p>移动方式：目视定位、吸附定位<br>
目视定位：shift+rmb<br>
吸附定位：切换到编辑模式→点模式→选中点→网格、吸附、游标-&gt;选中项<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230120214222913.png" alt="image-20230120214222913" loading="lazy"><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230120214258016.png" alt="image-20230120214258016" loading="lazy"></p>
<h4> 6、原点</h4>
<p>修改物体坐标时是修改的原点坐标</p>
<p>修改物体的原点：先修改游标，再进入物体模式，右键物体，设置原点-&gt;3d游标</p>
<h4> 7、显示</h4>
<p>选择场景中想显示或不想显示的东西</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230120231619203.png" alt="image-20230120231619203" loading="lazy"></p>
<h3> 2、模型</h3>
<h4> 1、编辑模型</h4>
<p><strong>选中一个物体</strong><br>
按<strong>TAB</strong>键进入编辑模式<br>
对<strong>点线面</strong>进行操作</p>
<h4> 2、模型构成</h4>
<p>模型基本都由三角形，四边形构成，多边形较少<br>
三维模型是中空的</p>
<p>三种基本元素：<br>
顶点 Vertex<br>
边线 Edge<br>
面 Face</p>
<p>编辑模式的二级菜单：长按左键</p>
<p><strong>按shift加选/ctrl减选/A全选</strong></p>
<h3> 3、面操作</h3>
<h4> 1、细分</h4>
<p>选择一个面<br>
<strong>右键，细分</strong><br>
微调，设置切割次数</p>
<p><strong>面的细分本质是对边的细分，一般针对四边形</strong></p>
<h4> 2、删除</h4>
<p>选择一个面、按x键，确认<br>
选择<strong>仅面</strong>或<strong>面加边</strong></p>
<h4> 3、挤出面</h4>
<p><strong>1、挤出 Extrude</strong><br>
选择一个面<br>
使用Extrude工具<br>
拖拽手柄，向外挤出<br>
微调面板，调整挤出的长度</p>
<p><strong>2、挤出流形，即向内挤压</strong><br>
选择一个面<br>
Extrude | 二级菜单选择挤出流形<br>
向内挤压<br>
微雕面板<br>
相当于勾选了‘融并正交边’</p>
<h4> 4、内/外插面</h4>
<p>内插面Inset，向内缩小一圈<br>
快捷键：i</p>
<p>选择一个面<br>
选择insert工具<br>
鼠标放在圆圈出、鼠标按下，往里拖拽<br>
微调</p>
<p>外插面，向外扩展一圈<br>
Inset，同时选择外侧<br>
更多操作：<br>
选择多个面，同时Inset<br>
<strong>微调中的选择外侧、各面、外插等等</strong></p>
<h4> 5、尖分面/面三角化/融并面</h4>
<p>尖分面：Poke Faces，从面的中心点连接到每一条边</p>
<p>面三角化：选中一个多边形，分割为多个三角形</p>
<p>融并面：选中多个面合并为一个面</p>
<p>以上操作选中面，右键</p>
<h4> 6、面的切割</h4>
<p><strong>切割面：</strong><br>
切割工具Knife：快捷键k</p>
<p>k：进入切割工具<br>
shift：选中中间点<br>
enter/space：确认切割<br>
ESC/RMB：取消切割</p>
<p><strong>整体切割：</strong><br>
点击工具<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230124230134291.png" alt="image-20230124230134291" loading="lazy"></p>
<p>选中多个面<br>
点切分工具<br>
划出一个平面，执行切分<br>
微调中：清空内侧、清空外侧、填充</p>
<h4> 7、面的法相</h4>
<p>与面垂直，方向朝外</p>
<p>在<strong>视图叠层中勾选面朝向</strong>，<br>
正面为蓝、背面为红</p>
<p>在视图着色方式中，勾选把<strong>背面剔除</strong> Backface Culling则背面显示透明</p>
<h4> 8、面填充</h4>
<p>选择一圈边线，填充为面<br>
填充面：按F键<br>
选择面-填充，用三角填充<br>
栅格填充（要求偶数边），用四边形填充</p>
<h4> 9、X-Ray透视</h4>
<p>打开方式：<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230125210958009.png" alt="image-20230125210958009" loading="lazy"></p>
<p>操作完成后建议关闭x-ray</p>
<h3> 4、边操作</h3>
<h4> 1、边的细分，滑移</h4>
<p>选中一条边<br>
菜单，边 滑移边线</p>
<h4> 2、边的删除，溶解</h4>
<p>选中一条边，按x键删除边<br>
当删除边时，所在的面也会被删除</p>
<p>边的溶解（x键选择<strong>融并边</strong>）<br>
删除边但不影响面的结构</p>
<h4> 3、边线倒角</h4>
<p>边线倒角 Bevel<br>
选中一条边<br>
倒角工具，向反向拉<br>
<strong>微调（各种参数）</strong></p>
<p>面的倒角：就是对所有边进行倒角</p>
<h4> 4、环切</h4>
<p>环切 Loop Cut，一个常用操作</p>
<p>选择环切工具<br>
预览切线<br>
LMB，按下确认（别松开）<br>
继续按住LMB，滑移，调整位置<br>
参数微调：<br>
切割次数<br>
钳制：受左右边线的制约</p>
<h4> 5、循环边/并排边</h4>
<p>选择循环边：<br>
<strong>ctrl+shift+LMB</strong><br>
<strong>菜单选择-选择循环-循环边</strong></p>
<p>选择并排边：<br>
<strong>ctrl+alt+LMB</strong> 或<br>
<strong>菜单选择-选择循环-并排边</strong></p>
<p>选择则循环面：<br>
ctrl+alt+LMB</p>
<p>循环边：<br>
选中一组循环边，可以执行以下操作：<br>
1、移动，移动循环边<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230125222830892.png" alt="image-20230125222830892" loading="lazy"><br>
2、切变，倾斜循环边<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230125223131173.png" alt="image-20230125223131173" loading="lazy"></p>
<p>3、法向收缩，变细或变粗<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230125223422069.png" alt="image-20230125223422069" loading="lazy"></p>
<p>4、菜单-边-偏移边线并滑动</p>
<p>5、删除循环边：选择循环边，按x，融并边</p>
<h4> 6、桥接循环边</h4>
<p>选中两组循环边，边数要相同<br>
菜单，边-桥接循环边</p>
<p>应用：墙面打洞<br>
（还可以选择两个面，选择边-桥接循环边）</p>
<h3> 5、点操作</h3>
<h4> 1、顶点移动</h4>
<p>顶点的移动，即 布线</p>
<p>对齐平面<br>
选中一个顶点，进入移动工具<br>
在平面内移动</p>
<p>几种不同的表面：<br>
1、正规平面<br>
2、斜面，进入法相坐标系</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230126222737928.png" alt="image-20230126222737928" loading="lazy"></p>
<p>3、曲面，点白圈自动移动，或按G抓取移动</p>
<h4> 2、顶点滑移</h4>
<p>选中一个点<br>
顶点滑移工具<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230126223139690.png" alt="image-20230126223139690" loading="lazy">，或shift+v</p>
<p>开始滑移，按RMB确定<br>
滑移时会以相邻边为滑轨</p>
<p>自动吸附：打开磁铁选项，选顶点吸附<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230126224118777.png" alt="image-20230126224118777" loading="lazy"></p>
<h4> 3、顶点合并</h4>
<p>顶点合并，即 焊接 ，合并邻近或重叠的顶点</p>
<p>合并邻近的顶点：<br>
选中几个非常靠近的顶点<br>
右键（或按键M），合并顶点→到中心</p>
<p>合并重叠顶点：<br>
打开x-ray模式<br>
选中重叠点，在统计信息里观察顶点个数<br>
右键，顶点合并→到中心<br>
或者a选择全部顶点，顶点合并→按距离</p>
<p>自动合并：<br>
打开自动合并，当两个顶点重叠时，自动焊接<br>
一般与顶点吸附联用</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230126225305248.png" alt="image-20230126225305248" loading="lazy"></p>
<h4> 4、顶点倒角</h4>
<p>选中一个顶点，选择倒角工具，微调中选择点模式，修改段数</p>
<p>其中，平面内倒角时，一般结合LoopTools插件使用</p>
<h4> 5、连接顶点</h4>
<p>选中两个点：<br>
按f键，连成一条边<br>
按j键，连接顶点并切割平面</p>
<p>一般都使用j键操作</p>
<h4> 6、顶点删除</h4>
<p>选择点，按x键：<br>
删除顶点：相邻的边、面一并删除<br>
融并顶点：移走顶点、融合邻边</p>
<h4> 7、衰减编辑</h4>
<p>拉扯顶点，形变（拉力）沿边线传导、并衰减</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230126232434364.png" alt="image-20230126232434364" loading="lazy"></p>
<p>衰减半径，即衰减影响的范围，方式：<br>
1、微调<br>
2、滚轮调整<br>
其中，鼠标左键不要松开，同时转动滚轮</p>
<h3> 6、ExtraObjects插件</h3>
<h4> 1、添加插件</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230127230642657.png" alt="image-20230127230642657" loading="lazy"></p>
<h4> 2、各种形状</h4>
<p>圆角立方体、环形、数学函数曲面z=f(x,y)、正多面体、齿轮、管道接头、钻石......</p>
<h4> 3、创建一个五角星</h4>
<p>创建10个点的圆环，将五个点往里缩，f创建面，e挤出，x-塌陷。继续e挤出，x-塌陷</p>
<p>其中，选中面-x、塌陷：即一个面坍缩为一个点</p>
<h3> 7、物体操作</h3>
<h4> 1、添加形状</h4>
<p>两种操作：<br>
在编辑模式下，添加物体为原物体的一部分<br>
在物体模式下，添加物体为新的物体</p>
<p>在极端情况下，一个物体的网格内，可以什么都没有</p>
<h4> 2、模型的合并</h4>
<p>在物体模式下，选中两个物体，右键合并或者ctrl+j合并</p>
<p>其中，最后一个选中的物体为活动物体（橙黄色），其他物体为选中体（橙红色）</p>
<h4> 3、拆分与分离</h4>
<p>拆分：在编辑模式下，选中一些元素（点，面，边）右键、拆分<br>
（从模型中拆分，以便独立操作）</p>
<p>分离：在编辑模式下，选中一些元素（点，面，边）右键、分离，选中项<br>
（从模型中分离，为一个独立的物体）</p>
<h4> 4、BoolTool插件</h4>
<p>Bool Tool插件，布尔工具<br>
用于两个模型做并、交、差运算</p>
<p>在偏好设置中启用Bool Tool插件<br>
创建一个圆柱体、一个正方体<br>
<strong>先选圆柱体，再选正方体</strong><br>
则active=正方体，Selected=圆柱体<br>
<strong>按n键打开侧边栏→编辑→Bool Tool</strong><br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230128001503282.png" alt="image-20230128001503282" loading="lazy"></p>
<p>Difference：差集<br>
Union：并集<br>
Intersect：交集<br>
Slice：切片</p>
<h3> 8、曲线</h3>
<p>曲线：用于描绘平滑的曲线和形状<br>
一般分两种：贝塞尔曲线、NURBS曲线</p>
<h4> 1、控制点</h4>
<p>选中调整工具，移动曲线<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230128202345087.png" alt="image-20230128202345087" loading="lazy"></p>
<h4> 2、编辑曲线</h4>
<p>1、添加控制点</p>
<p>细分：选中两个控制点，右键，细分<br>
挤出：选中端点，按e键</p>
<p>2、删除控制点</p>
<p>融并顶点：选中控制点，按x键</p>
<p>选中一个控制柄，按v键，控制柄类型：<br>
自由：自由调节<br>
对齐：左右同步<br>
矢量：直接连接<br>
自动：自动平滑</p>
<h4> 3、钢笔工具</h4>
<p>曲线笔，即钢笔工具</p>
<p>挤出LMB：添加一个控制点<br>
删除CTRL+LMB：点击并删除现有的控制点<br>
插入Ctrl+LMB：点击线段插入一个控制点<br>
调整控制点/控制柄：LMB<br>
调整曲线：LMB<br>
切换控制点类型：鼠标双击<br>
闭合曲线：LMB</p>
<p>定制化操作、修改键位：<br>
LMB：空白位置取消全选，或ALT+A<br>
添加ctrl+LMB：挤出</p>
<h4> 4、更多操纵</h4>
<p>选一点，按e：挤出<br>
选两点，按f：闭合<br>
选两点，按Y(或右键)：拆分，G：移动，X：删除</p>
<p>法向：曲线的方向，自起始点到结束点</p>
<p>（1）显示：视图</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230128210940719.png" alt="image-20230128210940719" loading="lazy"></p>
<p>（2）翻转：段数 → 切换方向</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230128211009492.png" alt="image-20230128211009492" loading="lazy"></p>
<h4> 5、参考图</h4>
<p>添加物体可选择<strong>添加参考图或背景</strong></p>
<p>更多操作：<br>
先切到正交视图，再拖一张图进来<br>
边：仅显示正面，背面等<br>
深度：显示在后面，不遮挡别的物体<br>
在透视图下不显示</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230128212135505.png" alt="image-20230128212135505" loading="lazy"></p>
<h4> 6、更多曲线形状</h4>
<p>添加插件：extra objects</p>
<h4> 7、曲线与网格</h4>
<p>曲线：由贝塞尔方程描述<br>
网格：Mesh，由点、边、面组成</p>
<p>曲线可以转成网格：<br>
选中曲线，右键，转换到<br>
微调中：保留原有，会有两个物体</p>
<p>U分辨率：决定了曲线的平滑程度<br>
例如，U分辨率=12，表示每两个控制点之间细分12段</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230128220748922.png" alt="image-20230128220748922" loading="lazy"></p>
<h3> 9、曲线与倒角</h3>
<h4> 1、曲线倒角</h4>
<p>新建曲线，调整倒角</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230128221115764.png" alt="image-20230128221115764" loading="lazy"></p>
<p>在物体模式下观察：<br>
打开x-ray，切换着色方式： 线框<br>
在编辑模式下观察：<br>
打开x-ray<br>
切换着色方式：实体</p>
<h4> 2、倒角参数</h4>
<p>选中曲线对象，在编辑模式下编辑<br>
按n键：打开侧边栏<br>
半径：管子的粗细<br>
倾斜：管子的扭曲</p>
<h4> 3、横截面</h4>
<p>曲线倒角横截面设置：<br>
另建一条封闭曲线b<br>
选择曲线a，按右图设置<br>
以曲线b作为横截面<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230128222615772.png" alt="image-20230128222615772" loading="lazy"></p>
<p>其中一般要求在XY平面</p>
<h4> 4、圆环倒角</h4>
<p>添加一个圆环，对其进行倒角</p>
<h4> 5、曲线路径</h4>
<p>添加曲线-路径曲线<br>
曲线路径：一种NURBS曲线<br>
操作方式类似：<br>
移动控制点<br>
曲线倒角<br>
控制点半径</p>
<h3> 10、修改器</h3>
<p>修改器Modifier，对模型进行修改<br>
相当于一个函数，类似于y=f(x)</p>
<h4> 1、使用</h4>
<p>选中一个网格物体<br>
修改器属性，添加修改器→倒角修改器<br>
点 实时，打开/关闭修改器<br>
点 叉号，移除修改器<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230129184742945.png" alt="image-20230129184742945" loading="lazy"></p>
<h5> 1、修改器属性：</h5>
<p>图标，表示修改器的类型<br>
名字，表示修改器实例的名字<br>
选项，启动/关闭<br>
参数，修改器的具体参数设定</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230129202251488.png" alt="image-20230129202251488" loading="lazy"><br>
编辑模式：是否在编辑模式下实时预览<br>
实时：启用/关闭预览效果</p>
<p>修改器一般是<strong>物体模式</strong>下运作的</p>
<h5> 3、应用修改</h5>
<p>应用修改/ctrl+a让修改永久生效：</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230129202808986.png" alt="image-20230129202808986" loading="lazy"></p>
<h4> 2、阵列修改器</h4>
<p>阵列修改器，也称数组修改器<br>
用于生成阵列结构</p>
<p>相关参数：数量、偏移</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230129203914630.png" alt="image-20230129203914630" loading="lazy"></p>
<p>其中当偏移系数为1时，刚好精密排列</p>
<h5> 偏移量：</h5>
<p>阵列修改器中，每个克隆体之间的间距相等<br>
例如：1,4,7,13<br>
偏移量Offset = 3</p>
<p>物体偏移：可以指定一个物体B，来标记偏移量</p>
<p>例如：<br>
1、创建一个空物体B→纯轴<br>
2、给物体A，指定物体偏移B<br>
Offset = B - A</p>
<p>偏移量包括位置，缩放，旋转三个要素<br>
例如：<br>
A.scale = 1<br>
B.scale = 1.5<br>
则offect = 0.5，阵列的物体会逐个增大</p>
<h4> 3、镜像修改器</h4>
<p>镜像修改器：适用于制作轴对称物体</p>
<p>添加镜像修改器<br>
指定对称中心<br>
添加空物体→纯轴<br>
指定镜像物体，即对称中心<br>
移动对称中心，到合适位置</p>
<p>相关参数：<br>
轴向，指沿哪个轴向对称<br>
切分，越过对称轴的部分是否被切除<br>
翻转，当切除时，选择切换的是哪一半</p>
<h4> 4、BOOL修改器</h4>
<p>选中物体A，添加布局修改器<br>
运算：交，并，差<br>
物体：目标B</p>
<p>记得隐藏物体B，观察bool运算结果</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230130185048014.png" alt="image-20230130185048014" loading="lazy"></p>
<p>更多操作：<br>
把物体B以线框显示，以方便观察结果<br>
物体属性→视图显示→显示为线框<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230130190437588.png" alt="image-20230130190437588" loading="lazy"></p>
<p>物体B也可以添加修改器<br>
例如：添加阵列修改器</p>
<h4> 5、线框修改器</h4>
<p>线框修改器用于制作<strong>网状结构</strong></p>
<p>演示：<br>
厚度：指线框的粗细<br>
偏移：1向外扩张，-1向内收缩<br>
边界范围：一般勾选<br>
替换原物体：原来的物体是否保留</p>
<p>菱形网面的制作：<br>
创建平面→细分→(边)反细分（<strong>迭代值设置为1</strong>）</p>
<h4> 6、细分修改器</h4>
<h5> 1、使用</h5>
<p>表面细分修改器，让物体的表面更加圆滑</p>
<p>演示：<br>
1、添加一个猴头<br>
2、添加表面细分修改器<br>
3、观察效果，视图叠加层→显示线框</p>
<h5> 2、细分过程</h5>
<p>1、细分：将一个面切分为4<sup>2</sup>个小面<br>
2、过渡：调整面的法相、使之平滑过渡</p>
<p>其中，优化显示，指不显示细分产生的线框</p>
<p>卡线操作：调整过渡更小，添加修改器后可以移动卡线</p>
<h5> 3、边线折痕</h5>
<p>选择边，选择边→边线折痕（或shift+e）</p>
<p>折痕是边的一个属性，用于提示细分修改器要不要平滑处理</p>
<h5> 4、三角面、多边面</h5>
<p>三角面与多边面在细分时不好计算</p>
<h4> 7、几何节点修改器</h4>
<p>几何节点修改器<br>
本质上是一种自定义修改器</p>
<h5> 1、修改器添加</h5>
<p>​	<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230130222334397.png" alt="image-20230130222334397" loading="lazy"></p>
<h5> 2、添加节点</h5>
<p>几何节点修改器，是自定义的一组功能（函数）</p>
<p>可以给节点组起个命名</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230130223218347.png" alt="image-20230130223218347" loading="lazy"></p>
<h5> 3、节点的操作</h5>
<p>节点Node，代表一个函数/功<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230130223506139.png" alt="image-20230130223506139" loading="lazy"></p>
<p>节点名称：<br>
左侧，输入端口，即参数<br>
右侧，输出端口，即输出的数据</p>
<p>更多操作：<br>
1、添加节点：从菜单添加，或者shift+a<br>
2、删除节点：先选中节点，右键删除或x键<br>
3、复制节点：shift+d</p>
<h5> 4、点上的实例</h5>
<p>点上的实例 类似于阵列修改器，比阵列修改器更强大</p>
<p>演示：<br>
1、添加一个平面A，添加几何节点修改器<br>
2、添加节点 <strong>实例→实例化</strong>与点上<br>
3、添加另一个物体B，作为模板<br>
4、回到物体A，添加节点 <strong>输入→物体信息</strong>，指定该物体<br>
其中在物体A的顶点位置，克隆几个B物体的实例</p>
<p>要点与细节：<br>
为了便于理解，物体A，B都应该应用缩放和旋转<br>
编辑节点树时，注意节点树的名字要对应<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230130225622677.png" alt="image-20230130225622677" loading="lazy"></p>
<h5> 5、网格基本体</h5>
<p>默认以网格自身的数据作为输入<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230130230135595.png" alt="image-20230130230135595" loading="lazy"></p>
<p>其中几何数据即点、边、面、法向等数据</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230130230819199.png" alt="image-20230130230819199" loading="lazy"></p>
<h5> 6、实例的旋转</h5>
<p>旋转实例即旋转每一个实例<br>
对齐欧拉至矢量，控制每一个实例的指向<br>
比如：辐射状阵列实例</p>
<p>演示：<br>
先添加环形阵列<br>
添加节点 实例→旋转实例<br>
添加节点 实例工具→对齐欧拉至矢量<br>
添加节点 输入→位置<br>
其中，要调整物体的对齐轴</p>
<p>为了避免歧义，物体应与阵列处于同一平面</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230130232702958.png" alt="image-20230130232702958" loading="lazy"></p>
<h5> 7、实例的缩放</h5>
<p>添加实例→缩放实例<br>
或添加一个实用工具→随机值</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230130234014307.png" alt="image-20230130234014307" loading="lazy"></p>
<h5> 8、表面上的分布</h5>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230202211215731.png" alt="image-20230202211215731" loading="lazy"></p>
<p>可以设置泊松盘分布</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230202211458623.png" alt="image-20230202211458623" loading="lazy"></p>
<p>让平面也显示：<br>
添加一个物体，修改物体数据属性为平面</p>
<h4> 8、曲线修改器</h4>
<p>曲线函数修改器，使物体沿一条曲线变形<br>
如：火车（网格对象）停在铁轨（曲线）</p>
<p>演示：添加一列火车，环切为多节<br>
添加一条铁轨<br>
调节长度<br>
原点调节，将两者的原点调到各自起点<br>
将火车移到铁轨的起点</p>
<p>注：形变类修改器，修改了顶点的位置，产生形变（不会增加或删除顶点）<br>
钢笔绘制的曲线默认方向是反的，要反转一下法线（选中曲线，编辑模式→段数→反转）</p>
<h4> </h4>
<p><strong>物体的原点一定要与曲线原点重合，否则会出现问题</strong></p>
<p>半径与倾斜：<br>
编辑曲线，选择控制点，按n键<br>
半径、旋转</p>
<p>锁链的制作：添加一个圆环、添加阵列修改器，修改阵列修改器的物体偏移，添加曲线，添加曲线修改器</p>
<h4> 9、晶格修改器</h4>
<h5> 1、晶格</h5>
<p>晶格Lattice，用于定义一块扭曲的空间</p>
<p>添加一个晶格对象，默认1米<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230131213621588.png" alt="image-20230131213621588" loading="lazy"><br>
可以移动、缩放、指定分辨：数据属性：U,V,W<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230131213645987.png" alt="image-20230131213645987" loading="lazy"></p>
<p>可以启用衰减编辑</p>
<h5> 2、晶格修改器</h5>
<p>晶格修改器，使用晶格来使物体发生形变</p>
<p>添加足够大的一块晶格空间<br>
添加一个待变形的物体<br>
表面细分<br>
添加晶格修改器，指定晶格<br>
将物体置于晶体中</p>
<p>注意：物体需要表面细分才有效果<br>
物体要置于晶格之中，才有效果<br>
晶格可以包裹住整体物体，或者物体的一部分</p>
<h3> 11、材质</h3>
<p>材质Material，用于描述物体表面性质<br>
基础色<br>
金属/非金属<br>
粗糙度<br>
透光度<br>
凹凸细节</p>
<h4> 1.添加材质</h4>
<p>操作：<br>
切换到曹植预览模式(白模)<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230131234540920.png" alt="image-20230131234540920" loading="lazy"><br>
添加一个材质：<br>
点 + 号，添加一个槽位Slot<br>
点 新建，创建一个新材质<br>
修改基础色<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230131234904689.png" alt="image-20230131234904689" loading="lazy"></p>
<h4> 2、关联材质</h4>
<p>定义一个<strong>金属</strong>材质，修改：<br>
基础色、金属度（0：非金属，1：金属），粗糙度，光泽度</p>
<p><strong>关联材质：一个材质可以被多个物体使用</strong><br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230131235508467.png" alt="image-20230131235508467" loading="lazy"></p>
<p><strong>CTRL+L ：批量关联</strong><br>
选中多个物体，再选中目标物体<br>
按下CTRL+L，关联材质</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230131235846435.png" alt="image-20230131235846435" loading="lazy"></p>
<h4> 3、复制材质</h4>
<p>关联材质的两个物体通过新材质彼此分离<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230201201123857.png" alt="image-20230201201123857" loading="lazy"></p>
<h4> 4、多个材质</h4>
<p>一个物体可以有多个材质<br>
新建材质后，进入编辑模式，指定<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230201201739378.png" alt="image-20230201201739378" loading="lazy"></p>
<h3> 12、着色器/BSDF</h3>
<h4> 1、着色器</h4>
<p>着色器Shader，负责给表面物体着色<br>
它本质上是一段程序（算法）</p>
<p>基础色、金属度、高光度、粗糙度、入射光颜色、强度、角度   ---&gt; 最终表面着色、</p>
<h4> 2、 BSDF：</h4>
<p>BSDF：双向散射分步函数（一类着色器的算法）</p>
<h4> 3、原理化BSDF</h4>
<p>一个通用的着色器</p>
<p>带有丰富的参数，适用于表现各样的材质</p>
<h4> 4、着色器编辑器</h4>
<p>一般的，在着色器编辑器中定义材质</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230201204029644.png" alt="image-20230201204029644" loading="lazy"></p>
<p>其中<br>
打开着色器编辑器<br>
按Home键居中<br>
以节点的方式来定义着色流程</p>
<h3> 13、纹理/贴图/UV</h3>
<h4> 1、纹理</h4>
<p>一般来说，物体表面不是纯色的。由贴图来定义颜色</p>
<p>添加着色器，在着色编辑器中添加图片纹理，打开图片（或直接拖图片到编辑器中）<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230201205325376.png" alt="image-20230201205325376" loading="lazy"></p>
<h4> 2、UV编辑器</h4>
<p>点击UV编辑布局<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230201210146710.png" alt="image-20230201210146710" loading="lazy"></p>
<p>在右侧选择一个面，观察UV编辑器<br>
右侧，按A，选择所有面，观察UV编辑器<br>
右侧，不选中任何人面，贯彻UV编辑器</p>
<h4> 3、UV坐标</h4>
<p>UV，指一个表面映射到贴图后、每个顶点坐标<br>
UV坐标范围在0.0-1.0之间<br>
原点为左下角</p>
<p>选择点模式<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230201210807786.png" alt="image-20230201210807786" loading="lazy"></p>
<h4> 4、UV映射</h4>
<p>UV映射是可以自由指定的<br>
选中一个表面，修改它的UV映射</p>
<p>UV映射可以自由指定</p>
<h4> 5、UV展开</h4>
<p>UV展开，把模型的所有表面展开平铺<br>
UV把布局图：在一张图上，包含所有的表面UV坐标数据</p>
<p>默认的基本体自带UV展开图<br>
对于自己创建的模型，需要手动展开</p>
<h4> 6、纹理绘制</h4>
<p>根据UV布局图，绘制纹理<br>
1、右侧，A键选中所有面<br>
2、UV→导出UV图<br>
3、在PS中编辑，赋值一份，编辑各个面，保存为psd<br>
4、返回blender，给物体添加材质，贴图<br>
5、修改贴图后，重载，刷新显示<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230201213716451.png" alt="image-20230201213716451" loading="lazy"></p>
<h4> 7、UV展开</h4>
<p>对于自定义的模型，默认局部图一般不在适用</p>
<p>展开两种方式：<br>
<strong>自动展开，由Blender自行结算，A键全选，UV→只能UV投射→确定</strong><br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230201220520875.png" alt="image-20230201220520875" loading="lazy"></p>
<p>​	手动展开：<br>
​		进入编辑模式<br>
​		选中要剪开的边，<strong>标记为缝合边</strong><br>
​		选中所有的面，<strong>UV→展开</strong><br>
​		观察新的UV布局图</p>
<p>其中，缝合边Seam，即细缝，下刀之处</p>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230201221121880.png" alt="image-20230201221121880" loading="lazy"></p>
<h4> 8、UV布局调整</h4>
<p>调整UV布局，方便后续的纹理绘制</p>
<p>孤岛：即独立的一片选区<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230201223037501.png" alt="image-20230201223037501" loading="lazy"><br>
L键：选择相邻面<br>
移动，旋转，缩放</p>
<h4> 9、UV对齐</h4>
<p><strong>X/Y对齐</strong><br>
选中点，右键（或选UV→对齐）<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230201223257803.png" alt="image-20230201223257803" loading="lazy"></p>
<p><strong>选中孤岛</strong><br>
按n键，手工输入，精确对齐<br>
或使用 顶点吸附对<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230201223451014.png" alt="image-20230201223451014" loading="lazy"></p>
<p><strong>沿活动四边面展开</strong><br>
先对齐一个面，做成矩形<br>
选中一个面，右键，沿活动四边面展开<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230201223701293.png" alt="image-20230201223701293" loading="lazy"></p>
<p><strong>拆分与缝合</strong></p>
<p>拆分面，移动，将一个孤岛拆分成多个孤岛<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230201223829484.png" alt="image-20230201223829484" loading="lazy"></p>
<h3> 14、饼状菜单</h3>
<p>饼状菜单，用于快速切换、选择</p>
<p>例如：<br>
~：切换视图<br>
z：切换着色方式<br>
，：切换坐标系<br>
. ：切换基准点<br>
shift+s：吸附</p>
<h3> 15、Machin3tools插件</h3>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230202185027418.png" alt="image-20230202185027418" loading="lazy"></p>
<p>shift+s：选中点/面，快速移动原点到点/中心</p>
<p>饼状菜单AlinePie<br>
选中两个物体，进入编辑模式<br>
各选一个顶点<br>
ALT+A<br>
Align Object to Vert对齐到点<br>
Align Object to Edge 对齐到边</p>
<h3> 16、子父级</h3>
<h4> 1、关联数据</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230202200422323.png" alt="image-20230202200422323" loading="lazy"></p>
<h4> 2、父子级关系</h4>
<p>先选中子物体A，在选择父物体B<br>
ctrl+p或物体→父级→物体<br>
B为父节点，A为子节点</p>
<p>选中子物体<br>
alt+p：脱离子父级</p>
<p>在大纲视图中按住shift创建子父级</p>
<h4> 3、子级约束</h4>
<p>子级约束：可选择的父子关系</p>
<p>创建约束：物体为子集</p>
<h4> 4、资产</h4>
<p>可重复使用的东西</p>
<p>目前支持4种类型：<br>
物体，材质，动作，世界环境</p>
<p>切换到资产浏览器：<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230202203508772.png" alt="image-20230202203508772" loading="lazy"></p>
<p>标记为资产：<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230202203647485.png" alt="image-20230202203647485" loading="lazy"></p>
<h4> 5、文本</h4>
<p>添加→文本</p>
<p>修改字体：<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230202204759315.png" alt="image-20230202204759315" loading="lazy"></p>
<p>添加中文：外面复制过来</p>
<h3> 17、灯光</h3>
<p>可以添加一个新的摄像机<br>
点击图标<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230203194919967.png" alt="image-20230203194919967" loading="lazy"><br>
或小键盘数字0进入/退出摄像机视角<br>
按home：最大化当前摄像机视角</p>
<p>灯光类型：三种</p>
<p>勾选锁定摄像机到当前位图：方便移动摄像机<br>
调整摄像机参数（注意要在场景中选中摄像机）：<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230203195541788.png" alt="image-20230203195541788" loading="lazy"></p>
<h3> 18、渲染</h3>
<h4> 1、渲染引擎</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230203205616847.png" alt="image-20230203205616847" loading="lazy"></p>
<h4> 2、添加/修改世界灯光</h4>
<p><img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230203205708752.png" alt="image-20230203205708752" loading="lazy"></p>
<p>进入摄像机模式ctrl+b裁剪，减少渲染</p>
<h4> 3、渲染</h4>
<p>修改渲染<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230203220925442.png" alt="image-20230203220925442" loading="lazy"></p>
<p>修改输出<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230203221139268.png" alt="image-20230203221139268" loading="lazy"></p>
<p>渲染<br>
<img src="https://raw.githubusercontent.com/T4mako/ImageBed/main/image-20230203221232921.png" alt="image-20230203221232921" loading="lazy"></p>
]]></content:encoded>
    </item>
    <item>
      <title>快捷键</title>
      <link>https://T4mako.github.io/interests/Blender/%E5%BF%AB%E6%8D%B7%E9%94%AE.html</link>
      <guid>https://T4mako.github.io/interests/Blender/%E5%BF%AB%E6%8D%B7%E9%94%AE.html</guid>
      <source url="https://T4mako.github.io/rss.xml">快捷键</source>
      <description>快捷键 旋转：鼠标中键 缩放：alt+左键 平移：鼠标中键 g：移动 s：缩放	s+x/y/z：沿轴缩放 r：旋转	r+r：3d旋转	r+x/y/z	r+x+90：绕x轴旋转90度 g：抓取模式 g+x、y、z：抓取模式按xyz轴移动 四视图： 透视图：正常情况下 顶视图：7 正视图：1 右视图：3 四格视图：CTRL+ALT+Q	 底视图：9 alt+鼠标中键：移动切换视图 alt+z：透视模式 变换：n键</description>
      <content:encoded><![CDATA[<h1> 快捷键</h1>
<p>旋转：鼠标中键<br>
缩放：alt+左键<br>
平移：鼠标中键</p>
<p>g：移动<br>
s：缩放	s+x/y/z：沿轴缩放<br>
r：旋转	r+r：3d旋转	r+x/y/z	r+x+90：绕x轴旋转90度<br>
g：抓取模式<br>
g+x、y、z：抓取模式按xyz轴移动</p>
<p>四视图：<br>
透视图：正常情况下<br>
顶视图：7<br>
正视图：1<br>
右视图：3<br>
四格视图：CTRL+ALT+Q	<br>
底视图：9</p>
<p>alt+鼠标中键：移动切换视图</p>
<p>alt+z：透视模式</p>
<p>变换：n键</p>
<p><strong>.</strong>：物体缩放居中显示</p>
<p>q：收藏夹</p>
<p>ctrl+1/2/3...：快速添加修改器</p>
<p>坐标归0：ALT + G<br>
旋转归0：ALT + R<br>
缩放重置：ALT + S</p>
<p>选中两个物体 ctrl+p：创建子父级<br>
选中子物体alt+p：清空物体<br>
在大纲视图中按住shift创建子父级</p>
<p>x：确认后删除</p>
<p>shift+d：复制一份并进入抓取模式</p>
<p>shift+右键：移动游标</p>
<p>ctrl+j：合并</p>
<p>选中物体m：新建集合</p>
<p>选中物体按/：局部视图</p>
<p>饼状菜单<br>
~：切换视图<br>
z：切换着色方式<br>
，：切换坐标系<br>
. ：切换基准点<br>
shift+s：吸附菜单</p>
<p>选中多个物体再在选中目标物体，CTRL+L：关联材质</p>
<p><strong>编辑模式：</strong><br>
按shift加选<br>
ctrl减选<br>
a：全选<br>
Ctrl + i：反选<br>
ctrl+l：选中相邻项（编辑模式下有多个物体，选一个）<br>
e：挤出面(法向)	e+x/y/z	<strong>e+s：内/外插</strong><br>
<strong>ctrl + RMB 挤出到鼠标位置</strong><br>
i：内插面<br>
k：进入切割工具<br>
shift：选中中间点<br>
enter/space：确认切割<br>
ESC/RMB：取消切割<br>
选中边线f：填充面<br>
ctrl + b：倒角<br>
环切后 g+g：滑移</p>
<p>​	ctrl+shift+LMB：最短路径（最短的连接方式）<br>
​	ctrl+alt+LMB：选择并排边/循环面<br>
​	alt+shift+LMB：多选 循环边<br>
​	ctrl+alt+shift+LMB：多选 并排边/面</p>
<p>​	shift+v：顶点滑移<br>
​	选中点+ m：合并顶点<br>
​	选中两个点+ J：连接顶点并切割平面</p>
<p>​	H：隐藏选中项<br>
​	Alt+H：恢复隐藏选中项</p>
<p>ctrl+l：选择关联项</p>
<p>选择边，shift+e：边线折痕</p>
<p>编辑曲线/钢笔工具：<br>
v/双击：修改控制点模式<br>
ctrl+a：取消选择<br>
选择两个点，f：闭合曲线<br>
x：删除/融并点<br>
选择一个点，e：挤出一个点</p>
<p>shift+s：选中点/面，快速移动原点到点/中心</p>
<p>进入编辑模式，选两个点/边<br>
ALT+A：<br>
Align Object to Vert对齐到点<br>
Align Object to Edge 对齐到边</p>
<p>其他操作：<br>
交互时添加正方体<br>
复制，分离，实体化</p>
<p>数字0：进入/退出摄像机视角</p>
<p>T：展示左边栏</p>
<p>进入摄像机，ctrl+b：裁剪</p>
]]></content:encoded>
    </item>
    <item>
      <title>hlae instructs</title>
      <link>https://T4mako.github.io/interests/HLAE/hlae.html</link>
      <guid>https://T4mako.github.io/interests/HLAE/hlae.html</guid>
      <source url="https://T4mako.github.io/rss.xml">hlae instructs</source>
      <description>hlae instructs</description>
      <content:encoded><![CDATA[<h1> hlae instructs</h1>
<!-- more -->
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>═══════════════════════════════════════════<br>
Config Preset V1.6 by Purp1e<br>
CFG预设（Purp1e制作）<br>
#2021/8/14#<br>
<a href="https://space.bilibili.com/73115492" target="_blank" rel="noopener noreferrer">https://space.bilibili.com/73115492</a><br>
═══════════════════════════════════════════</p>
</div>
<h2> 一次性命令</h2>
<div class="language-txt line-numbers-mode" data-ext="txt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> HLAE相关设置</h2>
<div class="language-txt line-numbers-mode" data-ext="txt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> HUD 准星 持枪</h2>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 键位绑定</h2>
<div class="language-txt line-numbers-mode" data-ext="txt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 屏蔽/显示击杀信息条</h2>
<div class="language-txt line-numbers-mode" data-ext="txt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>personal config</title>
      <link>https://T4mako.github.io/interests/HLAE/settings.html</link>
      <guid>https://T4mako.github.io/interests/HLAE/settings.html</guid>
      <source url="https://T4mako.github.io/rss.xml">personal config</source>
      <description>personal config</description>
      <content:encoded><![CDATA[<h1> personal config</h1>
<!-- more -->
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title></title>
      <link>https://T4mako.github.io/interests/cook/</link>
      <guid>https://T4mako.github.io/interests/cook/</guid>
      <source url="https://T4mako.github.io/rss.xml"></source>
      <description>相关信息 Coming Soon</description>
      <content:encoded><![CDATA[<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>Coming Soon</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>817 考研</title>
      <link>https://T4mako.github.io/life/%E8%80%83%E8%AF%95/817%E8%80%83%E7%A0%94.html</link>
      <guid>https://T4mako.github.io/life/%E8%80%83%E8%AF%95/817%E8%80%83%E7%A0%94.html</guid>
      <source url="https://T4mako.github.io/rss.xml">817 考研</source>
      <description>苏州科技大学 2024 年硕士研究生入学初试考试程序设计（java）</description>
      <content:encoded><![CDATA[<p>苏州科技大学 2024 年硕士研究生入学初试考试程序设计（java）</p>
<!-- more -->
<h2> 考纲</h2>
<p><a href="/life/%E8%80%83%E8%AF%95/%E8%80%83%E7%BA%B2.html" target="blank">考纲</a></p>
<h2> 必知必会</h2>
<p><a href="/life/%E8%80%83%E8%AF%95/%E9%AB%98%E9%A2%91%E8%80%83%E7%82%B9.html" target="blank">高频考点</a></p>
<h2> 算法</h2>
<p><a href="/life/%E8%80%83%E8%AF%95/%E7%AE%97%E6%B3%95.html" target="blank">必会算法</a></p>
<h3> 基础概念</h3>
<ol>
<li><a href="/code/java/Java%20%E5%9F%BA%E7%A1%80/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/1%E3%80%81%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5.html" target="blank">基础概念</a></li>
<li><a href="/code/java/Java%20%E5%9F%BA%E7%A1%80/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/2%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html" target="blank">数据类型</a></li>
<li><a href="/code/java/Java%20%E5%9F%BA%E7%A1%80/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/19%E3%80%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA.html" target="blank">格式输入输出</a></li>
<li><a href="/code/java/Java%20%E5%9F%BA%E7%A1%80/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/5%E3%80%81%E6%95%B0%E7%BB%84.html" target="blank">数组</a></li>
<li><a href="/code/java/Java%20%E5%9F%BA%E7%A1%80/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/11%E3%80%81%E6%9E%9A%E4%B8%BE%E7%B1%BB.html" target="blank">枚举类</a></li>
<li><a href="/code/java/Java%20%E5%9F%BA%E7%A1%80/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/3%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6.html" target="blank">运算符</a></li>
<li><a href="/code/java/Java%20%E5%9F%BA%E7%A1%80/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/4%E3%80%81%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html" target="blank">程序流程控制</a></li>
<li><a href="/code/java/Java%20%E5%9F%BA%E7%A1%80/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/6%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html" target="blank">面向对象</a></li>
<li><a href="/code/java/Java%20%E5%9F%BA%E7%A1%80/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/9%E3%80%81%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html" target="blank">异常处理</a></li>
<li><a href="/code/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99.html" target="blank">面向对象设计基本原则</a></li>
<li><a href="/code/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html" target="blank">正则表达式</a></li>
<li><a href="/code/java/Java%20%E5%9F%BA%E7%A1%80/%E5%B8%B8%E7%94%A8%E7%B1%BB/" target="blank">常用类</a>（主看下面两篇即可）
<ul>
<li><a href="/code/java/Java%20%E5%9F%BA%E7%A1%80/%E5%B8%B8%E7%94%A8%E7%B1%BB/String%E3%80%81Scanner%E7%9B%B8%E5%85%B3%E7%B1%BB.html" target="blank">Stirng、Scanner 相关</a></li>
<li><a href="/code/java/Java%20%E5%9F%BA%E7%A1%80/%E5%B8%B8%E7%94%A8%E7%B1%BB/Pattern%20%E4%B8%8E%20Matcher%20%E7%B1%BB.html" target="blank">Pattern 与 Matcher 类</a></li>
</ul>
</li>
<li><a href="/code/java/Java%20%E5%9F%BA%E7%A1%80/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/15%E3%80%81IO%E6%B5%81.html" target="blank">输入输出流</a></li>
<li><a href="/code/java/Java%20%E5%9F%BA%E7%A1%80/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/14%E3%80%81%E6%B3%9B%E5%9E%8B.html" target="blank">泛型</a></li>
<li><a href="/code/java/Java%20%E5%9F%BA%E7%A1%80/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/13%E3%80%81%E9%9B%86%E5%90%88.html" target="blank">集合</a></li>
<li><a href="/code/java/Java%20%E5%9F%BA%E7%A1%80/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/17%E3%80%81%E5%8F%8D%E5%B0%84.html" target="blank">反射</a></li>
<li><a href="/code/java/Java%20%E5%9F%BA%E7%A1%80/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/10%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B.html" target="blank">Java 多线程</a></li>
<li><a href="/code/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html" target="blank">设计模式</a></li>
<li><a href="/code/java/JVM.html" target="blank">Jvm</a></li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>算法</title>
      <link>https://T4mako.github.io/life/%E8%80%83%E8%AF%95/%E7%AE%97%E6%B3%95.html</link>
      <guid>https://T4mako.github.io/life/%E8%80%83%E8%AF%95/%E7%AE%97%E6%B3%95.html</guid>
      <source url="https://T4mako.github.io/rss.xml">算法</source>
      <description>算法 算法性能度量方法 时间复杂度的判别、动态规划状态转移方程 常见问题 阶乘、素数、完数、回文数、最小公约数、最小公倍数 KMP算法、马拉车算法、Prim算法、Krusk算法、Dijkstra算法、Bellman-Ford 算法 线性表 线性表有「顺序存储结构 ArrayList」和「链式存储结构 LinkedList」 顺序表和链表的区别及其优缺点： 顺序表： 原理：顺序表存储是将数据元素放到一块连续的内存存储空间，相邻数据元素的存放地址也相邻（逻辑与物理统一）。 优点： 空间利用率高（局部性原理，连续存放，命中率高） 存取速度高效，可以随机存取，通过下标来直接存储 缺点： 插入和删除比较慢，比如：插入或者删除一个元素时，整个表需要遍历移动元素来重新排一次顺序 不可以增长长度，有空间限制，当需要存取的元素个数可能多于顺序表的元素个数时，会出现「溢出」问题，当元素个数远少于预先分配的空间时，空间浪费巨大 顺序表的存储密度为 1（存储密度 = 节点中数据占用的存储量 / 整个节点占用存储量） 时间性能 :查找 O(1)，插入和删除 O(n)</description>
      <content:encoded><![CDATA[<h1> 算法</h1>
<h2> 算法性能度量方法</h2>
<p>时间复杂度的判别、动态规划状态转移方程</p>
<h2> 常见问题</h2>
<p>阶乘、素数、完数、回文数、最小公约数、最小公倍数</p>
<p>KMP算法、马拉车算法、Prim算法、Krusk算法、Dijkstra算法、Bellman-Ford 算法</p>
<h2> 线性表</h2>
<p>线性表有「顺序存储结构 ArrayList」和「链式存储结构 LinkedList」</p>
<p>顺序表和链表的区别及其优缺点：<br>
顺序表：</p>
<ul>
<li>原理：顺序表存储是将数据元素放到一块连续的内存存储空间，相邻数据元素的存放地址也相邻（逻辑与物理统一）。</li>
<li>优点：
<ul>
<li>空间利用率高（局部性原理，连续存放，命中率高）</li>
<li>存取速度高效，可以随机存取，通过下标来直接存储</li>
</ul>
</li>
<li>缺点：
<ul>
<li>插入和删除比较慢，比如：插入或者删除一个元素时，整个表需要遍历移动元素来重新排一次顺序</li>
<li>不可以增长长度，有空间限制，当需要存取的元素个数可能多于顺序表的元素个数时，会出现「溢出」问题，当元素个数远少于预先分配的空间时，空间浪费巨大</li>
<li>顺序表的存储密度为 1（存储密度 = 节点中数据占用的存储量 / 整个节点占用存储量）</li>
</ul>
</li>
<li>时间性能 :查找 O(1)，插入和删除 O(n)</li>
</ul>
<p>链表：</p>
<ul>
<li>原理：链表存储是在程序运行过程中动态的分配空间，只要存储器还有空间，就不会发生存储溢出问题，相邻数据元素可随意存放，但所占存储空间分两部分，一部分存放结点值，另一部分存放表示结点关系间的指针</li>
<li>优点：
<ul>
<li>存取某个元素速度慢</li>
<li>插入和删除速度快，保留原有的物理顺序，比如：插入或者删除一个元素时，只需要改变指针指向即可</li>
<li>没有空间限制，存储元素的个数无上限，基本只与内存空间大小有关</li>
</ul>
</li>
<li>缺点：
<ul>
<li>占用额外的空间以存储指针</li>
<li>链表的存储密度小于 1</li>
<li>查找速度慢，因为查找时，需要从开始节点一个一个节点去查找元素访问</li>
</ul>
</li>
<li>时间性能 :查找 O(n)，插入和删除 O(1)</li>
</ul>
<h3> 链表节点定义</h3>
<ul>
<li>单链表</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>双链表</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>线性表常见算法题：</p>
<h3> 链表题</h3>
<p><a href="https://t4mako.github.io/tag/%E9%93%BE%E8%A1%A8/" target="_blank" rel="noopener noreferrer">链表合集</a></p>
<h3> 数组题</h3>
<p><a href="https://t4mako.github.io/tag/%E6%95%B0%E7%BB%84/" target="_blank" rel="noopener noreferrer">数组合集</a></p>
<h2> 查找</h2>
<h3> 顺序查找</h3>
<h3> 二分查找</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 排序</h2>
<table>
<thead>
<tr>
<th>算法</th>
<th>最好</th>
<th>最坏</th>
<th>平均</th>
<th>空间</th>
<th>稳定</th>
<th>思想</th>
</tr>
</thead>
<tbody>
<tr>
<td>冒泡</td>
<td>O(n)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(1)</td>
<td>Y</td>
<td>比较</td>
</tr>
<tr>
<td>选择</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(1)</td>
<td>N</td>
<td>比较</td>
</tr>
<tr>
<td>堆</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(1)</td>
<td>N</td>
<td>选择</td>
</tr>
<tr>
<td>插入</td>
<td>O(n)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(1)</td>
<td>Y</td>
<td>比较</td>
</tr>
<tr>
<td>希尔</td>
<td>O(nlogn)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(nlogn)</td>
<td>O(1)</td>
<td>N</td>
<td>插入</td>
</tr>
<tr>
<td>归并</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(n)</td>
<td>Y</td>
<td>归并</td>
</tr>
<tr>
<td>快速</td>
<td>O(nlogn)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>N</td>
<td>分治</td>
</tr>
</tbody>
</table>
<h3> 冒泡排序</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 选择排序</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 直接插入排序</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 快速排序</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 希尔排序</h3>
<p>将待排序数组按照步长 gap 进行分组，然后将每组的元素利用直接插入排序的方法进行排序；每次再将 gap 折半减小，循环上述操作；当 gap = 1 时，利用直接插入，完成排序。</p>
<p>gap 初始时一般为数组长度的一半，即每两个数为一组</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 归并排序</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 基数排序</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 堆排序</h3>
<ul>
<li>建立大顶堆</li>
<li>每次将堆顶元素（最大值）交换到末尾，重新调整大顶堆，使其重新符合大顶堆特性</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 递归与分支</h2>
<h2> 动态规划</h2>
<h2> 贪心算法</h2>
<h2> 回溯法</h2>
<h2> 分支限界法</h2>
]]></content:encoded>
    </item>
    <item>
      <title></title>
      <link>https://T4mako.github.io/life/%E8%80%83%E8%AF%95/%E8%80%83%E7%BA%B2.html</link>
      <guid>https://T4mako.github.io/life/%E8%80%83%E8%AF%95/%E8%80%83%E7%BA%B2.html</guid>
      <source url="https://T4mako.github.io/rss.xml"></source>
      <description>一、考试的基本要求 　　《程序设计》考试大纲适用于报考计算机科学与技术专业硕士研究生的入学考试。其主要目的是测试考生对面向算法基础知识和对象程序设计知识的理解、掌握和熟练程度及面向对象程序设计能力。要求考生掌握计算机科学与技术的基础知识，熟悉算法分析与设计的基本理论、掌握JAVA面向对象程序设计的基本方法, 具有较强的抽象思维能力、逻辑推理能力和实际应用中解决问题的能力。 二、考试内容和考试要求 1、算法语言基础知识 （1）程序设计语言发展历史、背景和特点； （2）Java面向对象编程特点、面向对象程序设计（OOP）的基本概念，Java语言编程规范； （3）结构化程序程序设计与面向对象程序设计； （4）数据类型、运算符与表达式、格式输入输出； （5）程序的控制结构：顺序结构、选择结构、循环结构及使用； （6）数组：数组的基本概念、一维数组的定义、初始化及应用；二维数组的定义、初始化及应用。</description>
      <content:encoded><![CDATA[<p>一、考试的基本要求<br>
　　《程序设计》考试大纲适用于报考计算机科学与技术专业硕士研究生的入学考试。其主要目的是测试考生对面向算法基础知识和对象程序设计知识的理解、掌握和熟练程度及面向对象程序设计能力。要求考生掌握计算机科学与技术的基础知识，熟悉算法分析与设计的基本理论、掌握JAVA面向对象程序设计的基本方法, 具有较强的抽象思维能力、逻辑推理能力和实际应用中解决问题的能力。</p>
<p>二、考试内容和考试要求<br>
1、算法语言基础知识<br>
（1）程序设计语言发展历史、背景和特点；<br>
（2）Java面向对象编程特点、面向对象程序设计（OOP）的基本概念，Java语言编程规范；<br>
（3）结构化程序程序设计与面向对象程序设计；<br>
（4）数据类型、运算符与表达式、格式输入输出；<br>
（5）程序的控制结构：顺序结构、选择结构、循环结构及使用；<br>
（6）数组：数组的基本概念、一维数组的定义、初始化及应用；二维数组的定义、初始化及应用。</p>
<p>2、面向对象程序设计基础<br>
（1）面向对象程序设计的概念；<br>
（2）类的定义；<br>
（3）对象及引用；<br>
（4）继承与多态；<br>
（5）抽象与接口；<br>
（6）内部类与匿名类；<br>
（7）自动装箱拆箱；<br>
（8）异常处理与异常类；</p>
<p>3、函数（方法）及模块化程序设计<br>
（1）模块化程序设计的思想；<br>
（2）函数的定义和调用；<br>
（3）实虚参数的传送、变量的作用域和生存时间；<br>
（4）函数（方法）递归与迭代。</p>
<p>4、面向对象编程<br>
（1）面向对象设计的基本原则；<br>
（2）类与类关系、UML类图；<br>
（3）几种常见的设计模式及应用：单例模式、工厂方法、抽象工厂、原型；</p>
<p>5、字符和字符串<br>
（1）String类、StringBuffer、StringTokenizer类；<br>
（2）正则表达式、Pattern类和Matcher类。</p>
<p>6、多线程<br>
（1）多线程的概念，Java中的线程；<br>
（2）线程的创建、调度与线程控制；<br>
（3）线程间通信，线程的互斥与同步；<br>
（4）多线程应用；</p>
<p>7、文件及IO流<br>
（1）Java的基本输入输出，IO流的类层次；<br>
（2）节点流与过滤流（InputStream/ OutputStream, BufferedInputStream/ BufferedOutputStream, DataInputStream/ DataOutputStream, FileInputStream/ FileOutputStream)；<br>
（3）Reader和Writer及其子类；<br>
（4）文件类File及文件的处理，随机文件的处理；<br>
（5）对象系列化与反系列化；</p>
<p>8、Java的常用数据结构<br>
（1）Java集合框架；<br>
（2）List、Set、Map、枚举及ArrayList、TreeSet、HashMap、Vector等常用数据结构的使用；<br>
（3）数据排序的几种实现方法；<br>
（4）泛型及应用；</p>
<p>9、反射及JAVA虚拟机基本原理<br>
（1）反射概念、作用；<br>
（2）反射机制的应用、应用场景；<br>
（3）垃圾回收器与内存分配策略；<br>
（4）虚拟机类加载机制；</p>
<p>10、应用设计与开发<br>
（1）算法性能度量方法；<br>
（2）常用数据结构（如线性表）的应用；<br>
（3）运用面向对象程序设计方法分析典型应用场景中的问题，结合当前成熟的新技术，提出解决相应问题的方案（方法），并加以实现。如电子商务、视频监控、工业控制应用等。</p>
<p>三、考试基本题型和考试方式<br>
主要题型可能有：<br>
(1)基本概念题（填空、选择填空题、程序填空或程序改错）（50~70分）<br>
(2)算法分析设计、面向对象程序设计题(80~100分)<br>
考试方式：考试时间180分钟，满分：150分。答题方式为笔试、闭卷。</p>
]]></content:encoded>
    </item>
    <item>
      <title>817 必会</title>
      <link>https://T4mako.github.io/life/%E8%80%83%E8%AF%95/%E9%AB%98%E9%A2%91%E8%80%83%E7%82%B9.html</link>
      <guid>https://T4mako.github.io/life/%E8%80%83%E8%AF%95/%E9%AB%98%E9%A2%91%E8%80%83%E7%82%B9.html</guid>
      <source url="https://T4mako.github.io/rss.xml">817 必会</source>
      <description>817 必会 uml 类图 正则表达式 随机文件读取 常见排序算法 进制转换 常见线程同步问题 面向对象相关问题 JVM 相关问题</description>
      <content:encoded><![CDATA[<h1> 817 必会</h1>
<h2> uml 类图</h2>
<h2> 正则表达式</h2>
<h2> 随机文件读取</h2>
<h2> 常见排序算法</h2>
<h2> 进制转换</h2>
<h2> 常见线程同步问题</h2>
<h2> 面向对象相关问题</h2>
<h2> JVM 相关问题</h2>
]]></content:encoded>
    </item>
  </channel>
</rss>